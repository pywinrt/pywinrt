// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_TestComponent_H
#define WINRT_TestComponent_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/TestComponent.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_TestComponent_IComposable<D>::Value() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposable>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposable, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposable>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposable>**)this;
            check_hresult(_winrt_abi_type->get_Value(&value));
        }
        return value;
    }
    template <typename D> auto consume_TestComponent_IComposable<D>::Value(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposable>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposable, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposable>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposable>**)this;
            check_hresult(_winrt_abi_type->put_Value(value));
        }
    }
    template <typename D> auto consume_TestComponent_IComposableFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::TestComponent::Composable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_IComposableFactory<D>::CreateWithValue(int32_t init, winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithValue(init, *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithValue(init, *(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::TestComponent::Composable{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_IComposableStatics<D>::ExpectComposable(winrt::TestComponent::Composable const& t) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectComposable(*(void**)(&t), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectComposable(*(void**)(&t), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IComposableStatics<D>::ExpectRequiredOne(winrt::TestComponent::IRequiredOne const& t) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectRequiredOne(*(void**)(&t), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectRequiredOne(*(void**)(&t), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IComposableStatics<D>::ExpectRequiredTwo(winrt::TestComponent::IRequiredTwo const& t) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectRequiredTwo(*(void**)(&t), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectRequiredTwo(*(void**)(&t), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IComposableStatics<D>::ExpectRequiredThree(winrt::TestComponent::IRequiredThree const& t) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectRequiredThree(*(void**)(&t), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectRequiredThree(*(void**)(&t), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IComposableStatics<D>::ExpectRequiredFour(winrt::TestComponent::IRequiredFour const& t) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IComposableStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IComposableStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectRequiredFour(*(void**)(&t), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IComposableStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectRequiredFour(*(void**)(&t), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IDerivedFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IDerivedFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IDerivedFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IDerivedFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IDerivedFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::TestComponent::Derived{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_IOverloadClass<D>::Overload() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverloadClass>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverloadClass, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClass>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Overload());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClass>**)this;
            check_hresult(_winrt_abi_type->Overload());
        }
    }
    template <typename D> auto consume_TestComponent_IOverloadClassFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverloadClassFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverloadClassFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::TestComponent::OverloadClass{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_IOverloadClassOverrides<D>::Overload(int32_t a) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverloadClassOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverloadClassOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OverloadWithOne(a));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassOverrides>**)this;
            check_hresult(_winrt_abi_type->OverloadWithOne(a));
        }
    }
    template <typename D> auto consume_TestComponent_IOverloadClassOverrides2<D>::Overload(int32_t a, int32_t b) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverloadClassOverrides2>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverloadClassOverrides2, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassOverrides2>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OverloadWithTwo(a, b));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassOverrides2>**)this;
            check_hresult(_winrt_abi_type->OverloadWithTwo(a, b));
        }
    }
    template <typename D> auto consume_TestComponent_IOverloadClassProtected<D>::Overload(int32_t a, int32_t b, int32_t c) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverloadClassProtected>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverloadClassProtected, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassProtected>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OverloadWithThree(a, b, c));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverloadClassProtected>**)this;
            check_hresult(_winrt_abi_type->OverloadWithThree(a, b, c));
        }
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::CallProtected() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CallProtected());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            check_hresult(_winrt_abi_type->CallProtected());
        }
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::ProtectedCalled(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_ProtectedCalled(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            check_hresult(_winrt_abi_type->add_ProtectedCalled(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::ProtectedCalled(auto_revoke_t, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, ProtectedCalled_revoker>(this, ProtectedCalled(handler));
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::ProtectedCalled(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            _winrt_abi_type->remove_ProtectedCalled(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            _winrt_abi_type->remove_ProtectedCalled(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::CallOverridable() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CallOverridable());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            check_hresult(_winrt_abi_type->CallOverridable());
        }
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::OverridableCalled(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_OverridableCalled(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            check_hresult(_winrt_abi_type->add_OverridableCalled(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::OverridableCalled(auto_revoke_t, winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& handler) const
    {
        return impl::make_event_revoker<D, OverridableCalled_revoker>(this, OverridableCalled(handler));
    }
    template <typename D> auto consume_TestComponent_IOverride<D>::OverridableCalled(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverride>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverride, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)&_winrt_casted_result;
            _winrt_abi_type->remove_OverridableCalled(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverride>**)this;
            _winrt_abi_type->remove_OverridableCalled(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_TestComponent_IOverrideFactory<D>::CreateInstance(winrt::Windows::Foundation::IInspectable const& baseInterface, winrt::Windows::Foundation::IInspectable& innerInterface) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverrideFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverrideFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideFactory>**)this;
            check_hresult(_winrt_abi_type->CreateInstance(*(void**)(&baseInterface), impl::bind_out(innerInterface), &value));
        }
        return winrt::TestComponent::Override{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_IOverrideOverrides<D>::OnOverridable() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverrideOverrides>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverrideOverrides, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideOverrides>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OnOverridable());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideOverrides>**)this;
            check_hresult(_winrt_abi_type->OnOverridable());
        }
    }
    template <typename D> auto consume_TestComponent_IOverrideProtected<D>::OnProtected() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IOverrideProtected>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IOverrideProtected, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideProtected>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->OnProtected());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IOverrideProtected>**)this;
            check_hresult(_winrt_abi_type->OnProtected());
        }
    }
    template <typename D> auto consume_TestComponent_IRequiredFour<D>::Four() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IRequiredFour>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IRequiredFour, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredFour>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Four(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredFour>**)this;
            check_hresult(_winrt_abi_type->Four(&result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IRequiredOne<D>::One() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IRequiredOne>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IRequiredOne, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredOne>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->One(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredOne>**)this;
            check_hresult(_winrt_abi_type->One(&result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IRequiredThree<D>::Three() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IRequiredThree>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IRequiredThree, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredThree>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Three(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredThree>**)this;
            check_hresult(_winrt_abi_type->Three(&result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_IRequiredTwo<D>::Two() const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::IRequiredTwo>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::IRequiredTwo, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredTwo>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Two(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::IRequiredTwo>**)this;
            check_hresult(_winrt_abi_type->Two(&result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestProducer(winrt::TestComponent::ITests const& callee) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TestProducer(*(void**)(&callee)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->TestProducer(*(void**)(&callee)));
        }
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestConsumer(winrt::TestComponent::TestHandler const& caller) const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TestConsumer(*(void**)(&caller), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->TestConsumer(*(void**)(&caller), &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::TestSelf() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->TestSelf());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->TestSelf());
        }
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::MakeTests() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->MakeTests(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->MakeTests(&result));
        }
        return winrt::TestComponent::ITests{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateInt32Vector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateInt32Vector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateInt32Vector(&result));
        }
        return winrt::Windows::Foundation::Collections::IVector<int32_t>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateStringVector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateStringVector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateStringVector(&result));
        }
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateStringableVector() const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateStringableVector(&result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateStringableVector(&result));
        }
        return winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateTimeSpan(uint32_t milliseconds) const
    {
        winrt::Windows::Foundation::TimeSpan result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateTimeSpan(milliseconds, put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateTimeSpan(milliseconds, put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncAction(uint32_t milliseconds) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncAction(milliseconds, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncAction(milliseconds, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncActionWithError(uint32_t milliseconds, int32_t error) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithError(milliseconds, error, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithError(milliseconds, error, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncOperation(uint32_t milliseconds, int32_t result) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncOperation(milliseconds, result, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncOperation(milliseconds, result, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncOperationWithError(uint32_t milliseconds, int32_t result, int32_t error) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithError(milliseconds, result, error, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithError(milliseconds, result, error, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncActionWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithProgress(milliseconds, *(void**)(&items), &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithProgress(milliseconds, *(void**)(&items), &operation));
        }
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncActionWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t error) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithProgressWithError(milliseconds, *(void**)(&items), error, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncActionWithProgressWithError(milliseconds, *(void**)(&items), error, &operation));
        }
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncOperationWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithProgress(milliseconds, *(void**)(&items), result, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithProgress(milliseconds, *(void**)(&items), result, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::CreateAsyncOperationWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result, int32_t error) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithProgressWithError(milliseconds, *(void**)(&items), result, error, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->CreateAsyncOperationWithProgressWithError(milliseconds, *(void**)(&items), result, error, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITestRunnerStatics<D>::ExpectObject(winrt::Windows::Foundation::IInspectable const& value) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITestRunnerStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITestRunnerStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ExpectObject(*(void**)(&value), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITestRunnerStatics>**)this;
            check_hresult(_winrt_abi_type->ExpectObject(*(void**)(&value), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Percentage() const
    {
        uint32_t value{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Percentage(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->get_Percentage(&value));
        }
        return value;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Simple() const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Simple());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Simple());
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param1(bool a, bool& b) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param1(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param1(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param2(uint8_t a, uint8_t& b) const
    {
        uint8_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param2(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param2(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param3(uint16_t a, uint16_t& b) const
    {
        uint16_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param3(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param3(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param4(uint32_t a, uint32_t& b) const
    {
        uint32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param4(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param4(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param5(uint64_t a, uint64_t& b) const
    {
        uint64_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param5(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param5(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param6(int16_t a, int16_t& b) const
    {
        int16_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param6(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param6(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param7(int32_t a, int32_t& b) const
    {
        int32_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param7(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param7(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param8(int64_t a, int64_t& b) const
    {
        int64_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param8(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param8(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param9(float a, float& b) const
    {
        float result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param9(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param9(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param10(double a, double& b) const
    {
        double result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param10(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param10(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param11(char16_t a, char16_t& b) const
    {
        char16_t result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param11(a, &b, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param11(a, &b, &result));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param12(param::hstring const& a, hstring& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param12(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param12(*(void**)(&a), impl::bind_out(b), &result));
        }
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param13(winrt::TestComponent::Blittable const& a, winrt::TestComponent::Blittable const& b, winrt::TestComponent::Blittable& c) const
    {
        winrt::TestComponent::Blittable result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param13(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param13(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param14(winrt::TestComponent::NonBlittable const& a, winrt::TestComponent::NonBlittable const& b, winrt::TestComponent::NonBlittable& c) const
    {
        winrt::TestComponent::NonBlittable result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param14(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param14(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param15(winrt::TestComponent::Nested const& a, winrt::TestComponent::Nested const& b, winrt::TestComponent::Nested& c) const
    {
        winrt::TestComponent::Nested result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param15(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param15(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        }
        return result;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param1Call(winrt::TestComponent::Param1Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param1Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param1Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param2Call(winrt::TestComponent::Param2Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param2Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param2Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param3Call(winrt::TestComponent::Param3Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param3Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param3Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param4Call(winrt::TestComponent::Param4Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param4Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param4Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param5Call(winrt::TestComponent::Param5Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param5Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param5Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param6Call(winrt::TestComponent::Param6Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param6Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param6Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param7Call(winrt::TestComponent::Param7Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param7Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param7Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param8Call(winrt::TestComponent::Param8Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param8Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param8Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param9Call(winrt::TestComponent::Param9Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param9Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param9Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param10Call(winrt::TestComponent::Param10Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param10Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param10Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param11Call(winrt::TestComponent::Param11Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param11Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param11Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param12Call(winrt::TestComponent::Param12Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param12Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param12Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param13Call(winrt::TestComponent::Param13Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param13Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param13Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param14Call(winrt::TestComponent::Param14Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param14Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param14Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Param15Call(winrt::TestComponent::Param15Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Param15Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Param15Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array1(array_view<bool const> a, array_view<bool> b, com_array<bool>& c) const
    {
        uint32_t result_impl_size{};
        bool* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array1(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array1(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<bool>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array2(array_view<uint8_t const> a, array_view<uint8_t> b, com_array<uint8_t>& c) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array2(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array2(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array3(array_view<uint16_t const> a, array_view<uint16_t> b, com_array<uint16_t>& c) const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array3(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array3(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array4(array_view<uint32_t const> a, array_view<uint32_t> b, com_array<uint32_t>& c) const
    {
        uint32_t result_impl_size{};
        uint32_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array4(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array4(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<uint32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array5(array_view<uint64_t const> a, array_view<uint64_t> b, com_array<uint64_t>& c) const
    {
        uint32_t result_impl_size{};
        uint64_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array5(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array5(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<uint64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array6(array_view<int16_t const> a, array_view<int16_t> b, com_array<int16_t>& c) const
    {
        uint32_t result_impl_size{};
        int16_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array6(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array6(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<int16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array7(array_view<int32_t const> a, array_view<int32_t> b, com_array<int32_t>& c) const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array7(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array7(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<int32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array8(array_view<int64_t const> a, array_view<int64_t> b, com_array<int64_t>& c) const
    {
        uint32_t result_impl_size{};
        int64_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array8(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array8(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<int64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array9(array_view<float const> a, array_view<float> b, com_array<float>& c) const
    {
        uint32_t result_impl_size{};
        float* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array9(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array9(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<float>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array10(array_view<double const> a, array_view<double> b, com_array<double>& c) const
    {
        uint32_t result_impl_size{};
        double* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array10(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array10(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array11(array_view<char16_t const> a, array_view<char16_t> b, com_array<char16_t>& c) const
    {
        uint32_t result_impl_size{};
        char16_t* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array11(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array11(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<char16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array12(array_view<hstring const> a, array_view<hstring> b, com_array<hstring>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array12(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array12(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array13(array_view<winrt::TestComponent::Blittable const> a, array_view<winrt::TestComponent::Blittable> b, com_array<winrt::TestComponent::Blittable>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_Blittable* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array13(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array13(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<winrt::TestComponent::Blittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array14(array_view<winrt::TestComponent::NonBlittable const> a, array_view<winrt::TestComponent::NonBlittable> b, com_array<winrt::TestComponent::NonBlittable>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_NonBlittable* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array14(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array14(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<winrt::TestComponent::NonBlittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array15(array_view<winrt::TestComponent::Nested const> a, array_view<winrt::TestComponent::Nested> b, com_array<winrt::TestComponent::Nested>& c) const
    {
        uint32_t result_impl_size{};
        struct struct_TestComponent_Nested* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array15(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array15(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<winrt::TestComponent::Nested>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array16(array_view<winrt::Windows::Foundation::IStringable const> a, array_view<winrt::Windows::Foundation::IStringable> b, com_array<winrt::Windows::Foundation::IStringable>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array16(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array16(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        }
        return com_array<winrt::Windows::Foundation::IStringable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array1Call(winrt::TestComponent::Array1Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array1Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array1Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array2Call(winrt::TestComponent::Array2Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array2Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array2Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array3Call(winrt::TestComponent::Array3Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array3Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array3Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array4Call(winrt::TestComponent::Array4Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array4Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array4Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array5Call(winrt::TestComponent::Array5Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array5Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array5Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array6Call(winrt::TestComponent::Array6Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array6Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array6Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array7Call(winrt::TestComponent::Array7Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array7Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array7Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array8Call(winrt::TestComponent::Array8Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array8Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array8Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array9Call(winrt::TestComponent::Array9Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array9Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array9Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array10Call(winrt::TestComponent::Array10Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array10Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array10Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array11Call(winrt::TestComponent::Array11Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array11Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array11Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array12Call(winrt::TestComponent::Array12Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array12Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array12Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array13Call(winrt::TestComponent::Array13Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array13Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array13Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array14Call(winrt::TestComponent::Array14Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array14Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array14Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array15Call(winrt::TestComponent::Array15Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array15Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array15Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Array16Call(winrt::TestComponent::Array16Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Array16Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Array16Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection1(param::iterable<hstring> const& a, winrt::Windows::Foundation::Collections::IIterable<hstring>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection1(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection1(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IIterable<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection2(param::iterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& a, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection2(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection2(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection3(param::map<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMap<hstring, hstring>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection3(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection3(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection4(param::map_view<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection4(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection4(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection5(param::vector<hstring> const& a, winrt::Windows::Foundation::Collections::IVector<hstring>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection5(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection5(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection6(param::vector_view<hstring> const& a, winrt::Windows::Foundation::Collections::IVectorView<hstring>& b) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection6(*(void**)(&a), impl::bind_out(b), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection6(*(void**)(&a), impl::bind_out(b), &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection1Call(winrt::TestComponent::Collection1Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection1Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection1Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection2Call(winrt::TestComponent::Collection2Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection2Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection2Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection3Call(winrt::TestComponent::Collection3Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection3Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection3Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection4Call(winrt::TestComponent::Collection4Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection4Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection4Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection5Call(winrt::TestComponent::Collection5Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection5Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection5Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Collection6Call(winrt::TestComponent::Collection6Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Collection6Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Collection6Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async1(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async1(*(void**)(&suspend), fail, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async1(*(void**)(&suspend), fail, &operation));
        }
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async2(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t progress) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async2(*(void**)(&suspend), fail, progress, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async2(*(void**)(&suspend), fail, progress, &operation));
        }
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async3(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async3(*(void**)(&suspend), fail, result, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async3(*(void**)(&suspend), fail, result, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async4(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result, int32_t progress) const
    {
        void* operation{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async4(*(void**)(&suspend), fail, result, progress, &operation));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async4(*(void**)(&suspend), fail, result, progress, &operation));
        }
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async1Call(winrt::TestComponent::Async1Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async1Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async1Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async2Call(winrt::TestComponent::Async2Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async2Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async2Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async3Call(winrt::TestComponent::Async3Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async3Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async3Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Async4Call(winrt::TestComponent::Async4Handler const& handler) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Async4Call(*(void**)(&handler)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Async4Call(*(void**)(&handler)));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(winrt::Windows::Foundation::EventHandler<int32_t> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Event1(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->add_Event1(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(auto_revoke_t, winrt::Windows::Foundation::EventHandler<int32_t> const& handler) const
    {
        return impl::make_event_revoker<D, Event1_revoker>(this, Event1(handler));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Event1(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            _winrt_abi_type->remove_Event1(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const& handler) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_Event2(*(void**)(&handler), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->add_Event2(*(void**)(&handler), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const& handler) const
    {
        return impl::make_event_revoker<D, Event2_revoker>(this, Event2(handler));
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            _winrt_abi_type->remove_Event2(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            _winrt_abi_type->remove_Event2(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event1Call(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Event1Call(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Event1Call(value));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Event2Call(int32_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Event2Call(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Event2Call(value));
        }
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetClassVectorSubset(param::vector_view<winrt::TestComponent::Class> const& classVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetClassVectorSubset(*(void**)(&classVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetClassVectorSubset(*(void**)(&classVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Class>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetComposableClassVectorSubset(param::vector_view<winrt::TestComponent::Composable> const& classVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetComposableClassVectorSubset(*(void**)(&classVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetComposableClassVectorSubset(*(void**)(&classVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Composable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetObjectVectorSubset(param::vector_view<winrt::Windows::Foundation::IInspectable> const& objectVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetObjectVectorSubset(*(void**)(&objectVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetObjectVectorSubset(*(void**)(&objectVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetInterfaceVectorSubset(param::vector_view<winrt::TestComponent::IRequiredOne> const& interfaceVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetInterfaceVectorSubset(*(void**)(&interfaceVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetInterfaceVectorSubset(*(void**)(&interfaceVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::IRequiredOne>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetBooleanVectorSubset(param::vector_view<bool> const& booleanVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetBooleanVectorSubset(*(void**)(&booleanVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetBooleanVectorSubset(*(void**)(&booleanVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<bool>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetStringVectorSubset(param::vector_view<hstring> const& stringVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetStringVectorSubset(*(void**)(&stringVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetStringVectorSubset(*(void**)(&stringVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetBlittableVectorSubset(param::vector_view<winrt::TestComponent::Blittable> const& blittableVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetBlittableVectorSubset(*(void**)(&blittableVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetBlittableVectorSubset(*(void**)(&blittableVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Blittable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::GetNonBlittableVectorSubset(param::vector_view<winrt::TestComponent::NonBlittable> const& nonBlittableVector, int32_t startIndex) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetNonBlittableVectorSubset(*(void**)(&nonBlittableVector), startIndex, &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->GetNonBlittableVectorSubset(*(void**)(&nonBlittableVector), startIndex, &result));
        }
        return winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::NonBlittable>{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box1(uint8_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box1(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box1(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box2(uint16_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box2(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box2(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box3(uint32_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box3(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box3(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box4(uint64_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box4(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box4(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box5(int16_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box5(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box5(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box6(int32_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box6(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box6(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box7(int64_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box7(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box7(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box8(bool param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box8(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box8(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box9(float param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box9(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box9(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box10(double param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box10(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box10(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box11(winrt::guid const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box11(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box11(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box12(char16_t param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box12(param, *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box12(param, *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box13(param::hstring const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box13(*(void**)(&param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box13(*(void**)(&param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box14(winrt::Windows::Foundation::TimeSpan const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box14(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box14(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box15(winrt::TestComponent::Blittable const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box15(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box15(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box16(winrt::TestComponent::NonBlittable const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box16(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box16(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box17(winrt::Windows::Foundation::DateTime const& param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box17(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box17(impl::bind_in(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box18(array_view<int64_t const> param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box18(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box18(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box19(array_view<bool const> param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box19(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box19(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box20(array_view<hstring const> param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box20(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box20(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename D> auto consume_TestComponent_ITests<D>::Box21(array_view<winrt::Windows::Foundation::TimeSpan const> param, winrt::Windows::Foundation::IInspectable const& boxedParam) const
    {
        void* result{};
        if constexpr (!std::is_same_v<D, winrt::TestComponent::ITests>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::TestComponent::ITests, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Box21(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::TestComponent::ITests>**)this;
            check_hresult(_winrt_abi_type->Box21(param.size(), get_abi(param), *(void**)(&boxedParam), &result));
        }
        return winrt::Windows::Foundation::IInspectable{ result, take_ownership_from_abi };
    }
    template <typename H> struct delegate<winrt::TestComponent::Array10Handler, H> final : implements_delegate<winrt::TestComponent::Array10Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array10Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, double* a, uint32_t __bSize, double* b, uint32_t* __cSize, double** c, uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<double const>(reinterpret_cast<double const *>(a), reinterpret_cast<double const *>(a) + __aSize), array_view<double>(reinterpret_cast<double*>(b), reinterpret_cast<double*>(b) + __bSize), detach_abi<double>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array11Handler, H> final : implements_delegate<winrt::TestComponent::Array11Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array11Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, char16_t* a, uint32_t __bSize, char16_t* b, uint32_t* __cSize, char16_t** c, uint32_t* __resultSize, char16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<char16_t const>(reinterpret_cast<char16_t const *>(a), reinterpret_cast<char16_t const *>(a) + __aSize), array_view<char16_t>(reinterpret_cast<char16_t*>(b), reinterpret_cast<char16_t*>(b) + __bSize), detach_abi<char16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array12Handler, H> final : implements_delegate<winrt::TestComponent::Array12Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array12Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<hstring>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<hstring const>(reinterpret_cast<hstring const *>(a), reinterpret_cast<hstring const *>(a) + __aSize), array_view<hstring>(reinterpret_cast<hstring*>(b), reinterpret_cast<hstring*>(b) + __bSize), detach_abi<hstring>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array13Handler, H> final : implements_delegate<winrt::TestComponent::Array13Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array13Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_Blittable* a, uint32_t __bSize, struct struct_TestComponent_Blittable* b, uint32_t* __cSize, struct struct_TestComponent_Blittable** c, uint32_t* __resultSize, struct struct_TestComponent_Blittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::Blittable const>(reinterpret_cast<winrt::TestComponent::Blittable const *>(a), reinterpret_cast<winrt::TestComponent::Blittable const *>(a) + __aSize), array_view<winrt::TestComponent::Blittable>(reinterpret_cast<winrt::TestComponent::Blittable*>(b), reinterpret_cast<winrt::TestComponent::Blittable*>(b) + __bSize), detach_abi<winrt::TestComponent::Blittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array14Handler, H> final : implements_delegate<winrt::TestComponent::Array14Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array14Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_NonBlittable* a, uint32_t __bSize, struct struct_TestComponent_NonBlittable* b, uint32_t* __cSize, struct struct_TestComponent_NonBlittable** c, uint32_t* __resultSize, struct struct_TestComponent_NonBlittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::NonBlittable const>(reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a), reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a) + __aSize), array_view<winrt::TestComponent::NonBlittable>(reinterpret_cast<winrt::TestComponent::NonBlittable*>(b), reinterpret_cast<winrt::TestComponent::NonBlittable*>(b) + __bSize), detach_abi<winrt::TestComponent::NonBlittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array15Handler, H> final : implements_delegate<winrt::TestComponent::Array15Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array15Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, struct struct_TestComponent_Nested* a, uint32_t __bSize, struct struct_TestComponent_Nested* b, uint32_t* __cSize, struct struct_TestComponent_Nested** c, uint32_t* __resultSize, struct struct_TestComponent_Nested** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::TestComponent::Nested const>(reinterpret_cast<winrt::TestComponent::Nested const *>(a), reinterpret_cast<winrt::TestComponent::Nested const *>(a) + __aSize), array_view<winrt::TestComponent::Nested>(reinterpret_cast<winrt::TestComponent::Nested*>(b), reinterpret_cast<winrt::TestComponent::Nested*>(b) + __bSize), detach_abi<winrt::TestComponent::Nested>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array16Handler, H> final : implements_delegate<winrt::TestComponent::Array16Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array16Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::IStringable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<winrt::Windows::Foundation::IStringable const>(reinterpret_cast<winrt::Windows::Foundation::IStringable const *>(a), reinterpret_cast<winrt::Windows::Foundation::IStringable const *>(a) + __aSize), array_view<winrt::Windows::Foundation::IStringable>(reinterpret_cast<winrt::Windows::Foundation::IStringable*>(b), reinterpret_cast<winrt::Windows::Foundation::IStringable*>(b) + __bSize), detach_abi<winrt::Windows::Foundation::IStringable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array1Handler, H> final : implements_delegate<winrt::TestComponent::Array1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, bool* a, uint32_t __bSize, bool* b, uint32_t* __cSize, bool** c, uint32_t* __resultSize, bool** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<bool const>(reinterpret_cast<bool const *>(a), reinterpret_cast<bool const *>(a) + __aSize), array_view<bool>(reinterpret_cast<bool*>(b), reinterpret_cast<bool*>(b) + __bSize), detach_abi<bool>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array2Handler, H> final : implements_delegate<winrt::TestComponent::Array2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint8_t* a, uint32_t __bSize, uint8_t* b, uint32_t* __cSize, uint8_t** c, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(a), reinterpret_cast<uint8_t const *>(a) + __aSize), array_view<uint8_t>(reinterpret_cast<uint8_t*>(b), reinterpret_cast<uint8_t*>(b) + __bSize), detach_abi<uint8_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array3Handler, H> final : implements_delegate<winrt::TestComponent::Array3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint16_t* a, uint32_t __bSize, uint16_t* b, uint32_t* __cSize, uint16_t** c, uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint16_t const>(reinterpret_cast<uint16_t const *>(a), reinterpret_cast<uint16_t const *>(a) + __aSize), array_view<uint16_t>(reinterpret_cast<uint16_t*>(b), reinterpret_cast<uint16_t*>(b) + __bSize), detach_abi<uint16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array4Handler, H> final : implements_delegate<winrt::TestComponent::Array4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint32_t* a, uint32_t __bSize, uint32_t* b, uint32_t* __cSize, uint32_t** c, uint32_t* __resultSize, uint32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint32_t const>(reinterpret_cast<uint32_t const *>(a), reinterpret_cast<uint32_t const *>(a) + __aSize), array_view<uint32_t>(reinterpret_cast<uint32_t*>(b), reinterpret_cast<uint32_t*>(b) + __bSize), detach_abi<uint32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array5Handler, H> final : implements_delegate<winrt::TestComponent::Array5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, uint64_t* a, uint32_t __bSize, uint64_t* b, uint32_t* __cSize, uint64_t** c, uint32_t* __resultSize, uint64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<uint64_t const>(reinterpret_cast<uint64_t const *>(a), reinterpret_cast<uint64_t const *>(a) + __aSize), array_view<uint64_t>(reinterpret_cast<uint64_t*>(b), reinterpret_cast<uint64_t*>(b) + __bSize), detach_abi<uint64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array6Handler, H> final : implements_delegate<winrt::TestComponent::Array6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int16_t* a, uint32_t __bSize, int16_t* b, uint32_t* __cSize, int16_t** c, uint32_t* __resultSize, int16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int16_t const>(reinterpret_cast<int16_t const *>(a), reinterpret_cast<int16_t const *>(a) + __aSize), array_view<int16_t>(reinterpret_cast<int16_t*>(b), reinterpret_cast<int16_t*>(b) + __bSize), detach_abi<int16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array7Handler, H> final : implements_delegate<winrt::TestComponent::Array7Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array7Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int32_t* a, uint32_t __bSize, int32_t* b, uint32_t* __cSize, int32_t** c, uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int32_t const>(reinterpret_cast<int32_t const *>(a), reinterpret_cast<int32_t const *>(a) + __aSize), array_view<int32_t>(reinterpret_cast<int32_t*>(b), reinterpret_cast<int32_t*>(b) + __bSize), detach_abi<int32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array8Handler, H> final : implements_delegate<winrt::TestComponent::Array8Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array8Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, int64_t* a, uint32_t __bSize, int64_t* b, uint32_t* __cSize, int64_t** c, uint32_t* __resultSize, int64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<int64_t const>(reinterpret_cast<int64_t const *>(a), reinterpret_cast<int64_t const *>(a) + __aSize), array_view<int64_t>(reinterpret_cast<int64_t*>(b), reinterpret_cast<int64_t*>(b) + __bSize), detach_abi<int64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Array9Handler, H> final : implements_delegate<winrt::TestComponent::Array9Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Array9Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t __aSize, float* a, uint32_t __bSize, float* b, uint32_t* __cSize, float** c, uint32_t* __resultSize, float** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            std::tie(*__resultSize, *result) = detach_abi((*this)(array_view<float const>(reinterpret_cast<float const *>(a), reinterpret_cast<float const *>(a) + __aSize), array_view<float>(reinterpret_cast<float*>(b), reinterpret_cast<float*>(b) + __bSize), detach_abi<float>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async1Handler, H> final : implements_delegate<winrt::TestComponent::Async1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async2Handler, H> final : implements_delegate<winrt::TestComponent::Async2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async3Handler, H> final : implements_delegate<winrt::TestComponent::Async3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Async4Handler, H> final : implements_delegate<winrt::TestComponent::Async4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Async4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* suspend, bool fail, int32_t result, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection1Handler, H> final : implements_delegate<winrt::TestComponent::Collection1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection2Handler, H> final : implements_delegate<winrt::TestComponent::Collection2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection3Handler, H> final : implements_delegate<winrt::TestComponent::Collection3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection4Handler, H> final : implements_delegate<winrt::TestComponent::Collection4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection5Handler, H> final : implements_delegate<winrt::TestComponent::Collection5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Collection6Handler, H> final : implements_delegate<winrt::TestComponent::Collection6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Collection6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>((*this)(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param10Handler, H> final : implements_delegate<winrt::TestComponent::Param10Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param10Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(double a, double* b, double* result) noexcept final try
        {
            *result = detach_from<double>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param11Handler, H> final : implements_delegate<winrt::TestComponent::Param11Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param11Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(char16_t a, char16_t* b, char16_t* result) noexcept final try
        {
            *result = detach_from<char16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param12Handler, H> final : implements_delegate<winrt::TestComponent::Param12Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param12Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            *result = detach_from<hstring>((*this)(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<hstring*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param13Handler, H> final : implements_delegate<winrt::TestComponent::Param13Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param13Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_Blittable a, struct struct_TestComponent_Blittable const& b, struct struct_TestComponent_Blittable* c, struct struct_TestComponent_Blittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(c);
            zero_abi<winrt::TestComponent::Blittable>(result);
            *result = detach_from<winrt::TestComponent::Blittable>((*this)(*reinterpret_cast<winrt::TestComponent::Blittable const*>(&a), *reinterpret_cast<winrt::TestComponent::Blittable const*>(&b), *reinterpret_cast<winrt::TestComponent::Blittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param14Handler, H> final : implements_delegate<winrt::TestComponent::Param14Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param14Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_NonBlittable a, struct struct_TestComponent_NonBlittable const& b, struct struct_TestComponent_NonBlittable* c, struct struct_TestComponent_NonBlittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(c);
            zero_abi<winrt::TestComponent::NonBlittable>(result);
            *result = detach_from<winrt::TestComponent::NonBlittable>((*this)(*reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&a), *reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&b), *reinterpret_cast<winrt::TestComponent::NonBlittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param15Handler, H> final : implements_delegate<winrt::TestComponent::Param15Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param15Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(struct struct_TestComponent_Nested a, struct struct_TestComponent_Nested const& b, struct struct_TestComponent_Nested* c, struct struct_TestComponent_Nested* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(c);
            zero_abi<winrt::TestComponent::Nested>(result);
            *result = detach_from<winrt::TestComponent::Nested>((*this)(*reinterpret_cast<winrt::TestComponent::Nested const*>(&a), *reinterpret_cast<winrt::TestComponent::Nested const*>(&b), *reinterpret_cast<winrt::TestComponent::Nested*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param1Handler, H> final : implements_delegate<winrt::TestComponent::Param1Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param1Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(bool a, bool* b, bool* result) noexcept final try
        {
            *result = detach_from<bool>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param2Handler, H> final : implements_delegate<winrt::TestComponent::Param2Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param2Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint8_t a, uint8_t* b, uint8_t* result) noexcept final try
        {
            *result = detach_from<uint8_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param3Handler, H> final : implements_delegate<winrt::TestComponent::Param3Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param3Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint16_t a, uint16_t* b, uint16_t* result) noexcept final try
        {
            *result = detach_from<uint16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param4Handler, H> final : implements_delegate<winrt::TestComponent::Param4Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param4Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint32_t a, uint32_t* b, uint32_t* result) noexcept final try
        {
            *result = detach_from<uint32_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param5Handler, H> final : implements_delegate<winrt::TestComponent::Param5Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param5Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(uint64_t a, uint64_t* b, uint64_t* result) noexcept final try
        {
            *result = detach_from<uint64_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param6Handler, H> final : implements_delegate<winrt::TestComponent::Param6Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param6Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int16_t a, int16_t* b, int16_t* result) noexcept final try
        {
            *result = detach_from<int16_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param7Handler, H> final : implements_delegate<winrt::TestComponent::Param7Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param7Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int32_t a, int32_t* b, int32_t* result) noexcept final try
        {
            *result = detach_from<int32_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param8Handler, H> final : implements_delegate<winrt::TestComponent::Param8Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param8Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(int64_t a, int64_t* b, int64_t* result) noexcept final try
        {
            *result = detach_from<int64_t>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::Param9Handler, H> final : implements_delegate<winrt::TestComponent::Param9Handler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::Param9Handler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(float a, float* b, float* result) noexcept final try
        {
            *result = detach_from<float>((*this)(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<winrt::TestComponent::TestHandler, H> final : implements_delegate<winrt::TestComponent::TestHandler, H>
    {
        delegate(H&& handler) : implements_delegate<winrt::TestComponent::TestHandler, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* tests) noexcept final try
        {
            (*this)(*reinterpret_cast<winrt::TestComponent::ITests const*>(&tests));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IClass> : produce_base<D, winrt::TestComponent::IClass>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IComposable> : produce_base<D, winrt::TestComponent::IComposable>
    {
        int32_t __stdcall get_Value(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Value());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Value(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Value(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IComposableFactory> : produce_base<D, winrt::TestComponent::IComposableFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::TestComponent::Composable>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithValue(int32_t init, void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::TestComponent::Composable>(this->shim().CreateWithValue(init, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IComposableStatics> : produce_base<D, winrt::TestComponent::IComposableStatics>
    {
        int32_t __stdcall ExpectComposable(void* t, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ExpectComposable(*reinterpret_cast<winrt::TestComponent::Composable const*>(&t)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExpectRequiredOne(void* t, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ExpectRequiredOne(*reinterpret_cast<winrt::TestComponent::IRequiredOne const*>(&t)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExpectRequiredTwo(void* t, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ExpectRequiredTwo(*reinterpret_cast<winrt::TestComponent::IRequiredTwo const*>(&t)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExpectRequiredThree(void* t, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ExpectRequiredThree(*reinterpret_cast<winrt::TestComponent::IRequiredThree const*>(&t)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExpectRequiredFour(void* t, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().ExpectRequiredFour(*reinterpret_cast<winrt::TestComponent::IRequiredFour const*>(&t)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IDerived> : produce_base<D, winrt::TestComponent::IDerived>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IDerivedFactory> : produce_base<D, winrt::TestComponent::IDerivedFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::TestComponent::Derived>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverloadClass> : produce_base<D, winrt::TestComponent::IOverloadClass>
    {
        int32_t __stdcall Overload() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Overload();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverloadClassFactory> : produce_base<D, winrt::TestComponent::IOverloadClassFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::TestComponent::OverloadClass>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverloadClassOverrides> : produce_base<D, winrt::TestComponent::IOverloadClassOverrides>
    {
        int32_t __stdcall OverloadWithOne(int32_t a) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Overload(a);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverloadClassOverrides2> : produce_base<D, winrt::TestComponent::IOverloadClassOverrides2>
    {
        int32_t __stdcall OverloadWithTwo(int32_t a, int32_t b) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Overload(a, b);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverloadClassProtected> : produce_base<D, winrt::TestComponent::IOverloadClassProtected>
    {
        int32_t __stdcall OverloadWithThree(int32_t a, int32_t b, int32_t c) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Overload(a, b, c);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverride> : produce_base<D, winrt::TestComponent::IOverride>
    {
        int32_t __stdcall CallProtected() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CallProtected();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ProtectedCalled(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ProtectedCalled(*reinterpret_cast<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ProtectedCalled(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ProtectedCalled(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall CallOverridable() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CallOverridable();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_OverridableCalled(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().OverridableCalled(*reinterpret_cast<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_OverridableCalled(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OverridableCalled(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverrideFactory> : produce_base<D, winrt::TestComponent::IOverrideFactory>
    {
        int32_t __stdcall CreateInstance(void* baseInterface, void** innerInterface, void** value) noexcept final try
        {
            if (innerInterface) *innerInterface = nullptr;
            winrt::Windows::Foundation::IInspectable winrt_impl_innerInterface;
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::TestComponent::Override>(this->shim().CreateInstance(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&baseInterface), winrt_impl_innerInterface));
                if (innerInterface) *innerInterface = detach_abi(winrt_impl_innerInterface);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverrideOverrides> : produce_base<D, winrt::TestComponent::IOverrideOverrides>
    {
        int32_t __stdcall OnOverridable() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OnOverridable();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::IOverrideProtected> : produce_base<D, winrt::TestComponent::IOverrideProtected>
    {
        int32_t __stdcall OnProtected() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OnProtected();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::TestComponent::IRequiredFour> : produce_base<D, winrt::TestComponent::IRequiredFour>
    {
        int32_t __stdcall Four(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().Four());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::TestComponent::IRequiredOne> : produce_base<D, winrt::TestComponent::IRequiredOne>
    {
        int32_t __stdcall One(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().One());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::TestComponent::IRequiredThree> : produce_base<D, winrt::TestComponent::IRequiredThree>
    {
        int32_t __stdcall Three(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().Three());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::TestComponent::IRequiredTwo> : produce_base<D, winrt::TestComponent::IRequiredTwo>
    {
        int32_t __stdcall Two(int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().Two());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::TestComponent::ITestRunnerStatics> : produce_base<D, winrt::TestComponent::ITestRunnerStatics>
    {
        int32_t __stdcall TestProducer(void* callee) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TestProducer(*reinterpret_cast<winrt::TestComponent::ITests const*>(&callee));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TestConsumer(void* caller, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().TestConsumer(*reinterpret_cast<winrt::TestComponent::TestHandler const*>(&caller)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TestSelf() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TestSelf();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall MakeTests(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::ITests>(this->shim().MakeTests());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInt32Vector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<int32_t>>(this->shim().CreateInt32Vector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStringVector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().CreateStringVector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateStringableVector(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>>(this->shim().CreateStringableVector());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateTimeSpan(uint32_t milliseconds, int64_t* result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::TimeSpan>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::TimeSpan>(this->shim().CreateTimeSpan(milliseconds));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncAction(uint32_t milliseconds, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsyncAction(milliseconds));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncActionWithError(uint32_t milliseconds, int32_t error, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().CreateAsyncActionWithError(milliseconds, error));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncOperation(uint32_t milliseconds, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().CreateAsyncOperation(milliseconds, result));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncOperationWithError(uint32_t milliseconds, int32_t result, int32_t error, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().CreateAsyncOperationWithError(milliseconds, result, error));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncActionWithProgress(uint32_t milliseconds, void* items, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>(this->shim().CreateAsyncActionWithProgress(milliseconds, *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<int32_t> const*>(&items)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncActionWithProgressWithError(uint32_t milliseconds, void* items, int32_t error, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>(this->shim().CreateAsyncActionWithProgressWithError(milliseconds, *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<int32_t> const*>(&items), error));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncOperationWithProgress(uint32_t milliseconds, void* items, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>(this->shim().CreateAsyncOperationWithProgress(milliseconds, *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<int32_t> const*>(&items), result));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAsyncOperationWithProgressWithError(uint32_t milliseconds, void* items, int32_t result, int32_t error, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>(this->shim().CreateAsyncOperationWithProgressWithError(milliseconds, *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<int32_t> const*>(&items), result, error));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ExpectObject(void* value, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().ExpectObject(*reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::TestComponent::ITests> : produce_base<D, winrt::TestComponent::ITests>
    {
        int32_t __stdcall get_Percentage(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().Percentage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Simple() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Simple();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param1(bool a, bool* b, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().Param1(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param2(uint8_t a, uint8_t* b, uint8_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint8_t>(this->shim().Param2(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param3(uint16_t a, uint16_t* b, uint16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint16_t>(this->shim().Param3(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param4(uint32_t a, uint32_t* b, uint32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint32_t>(this->shim().Param4(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param5(uint64_t a, uint64_t* b, uint64_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<uint64_t>(this->shim().Param5(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param6(int16_t a, int16_t* b, int16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int16_t>(this->shim().Param6(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param7(int32_t a, int32_t* b, int32_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int32_t>(this->shim().Param7(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param8(int64_t a, int64_t* b, int64_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<int64_t>(this->shim().Param8(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param9(float a, float* b, float* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<float>(this->shim().Param9(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param10(double a, double* b, double* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<double>(this->shim().Param10(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param11(char16_t a, char16_t* b, char16_t* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<char16_t>(this->shim().Param11(a, *b));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param12(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().Param12(*reinterpret_cast<hstring const*>(&a), *reinterpret_cast<hstring*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param13(struct struct_TestComponent_Blittable a, struct struct_TestComponent_Blittable const& b, struct struct_TestComponent_Blittable* c, struct struct_TestComponent_Blittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(c);
            zero_abi<winrt::TestComponent::Blittable>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::Blittable>(this->shim().Param13(*reinterpret_cast<winrt::TestComponent::Blittable const*>(&a), *reinterpret_cast<winrt::TestComponent::Blittable const*>(&b), *reinterpret_cast<winrt::TestComponent::Blittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param14(struct struct_TestComponent_NonBlittable a, struct struct_TestComponent_NonBlittable const& b, struct struct_TestComponent_NonBlittable* c, struct struct_TestComponent_NonBlittable* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(c);
            zero_abi<winrt::TestComponent::NonBlittable>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::NonBlittable>(this->shim().Param14(*reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&a), *reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&b), *reinterpret_cast<winrt::TestComponent::NonBlittable*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param15(struct struct_TestComponent_Nested a, struct struct_TestComponent_Nested const& b, struct struct_TestComponent_Nested* c, struct struct_TestComponent_Nested* result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(c);
            zero_abi<winrt::TestComponent::Nested>(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::TestComponent::Nested>(this->shim().Param15(*reinterpret_cast<winrt::TestComponent::Nested const*>(&a), *reinterpret_cast<winrt::TestComponent::Nested const*>(&b), *reinterpret_cast<winrt::TestComponent::Nested*>(c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param1Call(*reinterpret_cast<winrt::TestComponent::Param1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param2Call(*reinterpret_cast<winrt::TestComponent::Param2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param3Call(*reinterpret_cast<winrt::TestComponent::Param3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param4Call(*reinterpret_cast<winrt::TestComponent::Param4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param5Call(*reinterpret_cast<winrt::TestComponent::Param5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param6Call(*reinterpret_cast<winrt::TestComponent::Param6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param7Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param7Call(*reinterpret_cast<winrt::TestComponent::Param7Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param8Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param8Call(*reinterpret_cast<winrt::TestComponent::Param8Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param9Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param9Call(*reinterpret_cast<winrt::TestComponent::Param9Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param10Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param10Call(*reinterpret_cast<winrt::TestComponent::Param10Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param11Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param11Call(*reinterpret_cast<winrt::TestComponent::Param11Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param12Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param12Call(*reinterpret_cast<winrt::TestComponent::Param12Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param13Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param13Call(*reinterpret_cast<winrt::TestComponent::Param13Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param14Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param14Call(*reinterpret_cast<winrt::TestComponent::Param14Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Param15Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Param15Call(*reinterpret_cast<winrt::TestComponent::Param15Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array1(uint32_t __aSize, bool* a, uint32_t __bSize, bool* b, uint32_t* __cSize, bool** c, uint32_t* __resultSize, bool** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array1(array_view<bool const>(reinterpret_cast<bool const *>(a), reinterpret_cast<bool const *>(a) + __aSize), array_view<bool>(reinterpret_cast<bool*>(b), reinterpret_cast<bool*>(b) + __bSize), detach_abi<bool>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array2(uint32_t __aSize, uint8_t* a, uint32_t __bSize, uint8_t* b, uint32_t* __cSize, uint8_t** c, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array2(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(a), reinterpret_cast<uint8_t const *>(a) + __aSize), array_view<uint8_t>(reinterpret_cast<uint8_t*>(b), reinterpret_cast<uint8_t*>(b) + __bSize), detach_abi<uint8_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array3(uint32_t __aSize, uint16_t* a, uint32_t __bSize, uint16_t* b, uint32_t* __cSize, uint16_t** c, uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array3(array_view<uint16_t const>(reinterpret_cast<uint16_t const *>(a), reinterpret_cast<uint16_t const *>(a) + __aSize), array_view<uint16_t>(reinterpret_cast<uint16_t*>(b), reinterpret_cast<uint16_t*>(b) + __bSize), detach_abi<uint16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array4(uint32_t __aSize, uint32_t* a, uint32_t __bSize, uint32_t* b, uint32_t* __cSize, uint32_t** c, uint32_t* __resultSize, uint32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array4(array_view<uint32_t const>(reinterpret_cast<uint32_t const *>(a), reinterpret_cast<uint32_t const *>(a) + __aSize), array_view<uint32_t>(reinterpret_cast<uint32_t*>(b), reinterpret_cast<uint32_t*>(b) + __bSize), detach_abi<uint32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array5(uint32_t __aSize, uint64_t* a, uint32_t __bSize, uint64_t* b, uint32_t* __cSize, uint64_t** c, uint32_t* __resultSize, uint64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array5(array_view<uint64_t const>(reinterpret_cast<uint64_t const *>(a), reinterpret_cast<uint64_t const *>(a) + __aSize), array_view<uint64_t>(reinterpret_cast<uint64_t*>(b), reinterpret_cast<uint64_t*>(b) + __bSize), detach_abi<uint64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array6(uint32_t __aSize, int16_t* a, uint32_t __bSize, int16_t* b, uint32_t* __cSize, int16_t** c, uint32_t* __resultSize, int16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array6(array_view<int16_t const>(reinterpret_cast<int16_t const *>(a), reinterpret_cast<int16_t const *>(a) + __aSize), array_view<int16_t>(reinterpret_cast<int16_t*>(b), reinterpret_cast<int16_t*>(b) + __bSize), detach_abi<int16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array7(uint32_t __aSize, int32_t* a, uint32_t __bSize, int32_t* b, uint32_t* __cSize, int32_t** c, uint32_t* __resultSize, int32_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array7(array_view<int32_t const>(reinterpret_cast<int32_t const *>(a), reinterpret_cast<int32_t const *>(a) + __aSize), array_view<int32_t>(reinterpret_cast<int32_t*>(b), reinterpret_cast<int32_t*>(b) + __bSize), detach_abi<int32_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array8(uint32_t __aSize, int64_t* a, uint32_t __bSize, int64_t* b, uint32_t* __cSize, int64_t** c, uint32_t* __resultSize, int64_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array8(array_view<int64_t const>(reinterpret_cast<int64_t const *>(a), reinterpret_cast<int64_t const *>(a) + __aSize), array_view<int64_t>(reinterpret_cast<int64_t*>(b), reinterpret_cast<int64_t*>(b) + __bSize), detach_abi<int64_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array9(uint32_t __aSize, float* a, uint32_t __bSize, float* b, uint32_t* __cSize, float** c, uint32_t* __resultSize, float** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array9(array_view<float const>(reinterpret_cast<float const *>(a), reinterpret_cast<float const *>(a) + __aSize), array_view<float>(reinterpret_cast<float*>(b), reinterpret_cast<float*>(b) + __bSize), detach_abi<float>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array10(uint32_t __aSize, double* a, uint32_t __bSize, double* b, uint32_t* __cSize, double** c, uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array10(array_view<double const>(reinterpret_cast<double const *>(a), reinterpret_cast<double const *>(a) + __aSize), array_view<double>(reinterpret_cast<double*>(b), reinterpret_cast<double*>(b) + __bSize), detach_abi<double>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array11(uint32_t __aSize, char16_t* a, uint32_t __bSize, char16_t* b, uint32_t* __cSize, char16_t** c, uint32_t* __resultSize, char16_t** result) noexcept final try
        {
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array11(array_view<char16_t const>(reinterpret_cast<char16_t const *>(a), reinterpret_cast<char16_t const *>(a) + __aSize), array_view<char16_t>(reinterpret_cast<char16_t*>(b), reinterpret_cast<char16_t*>(b) + __bSize), detach_abi<char16_t>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array12(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<hstring>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array12(array_view<hstring const>(reinterpret_cast<hstring const *>(a), reinterpret_cast<hstring const *>(a) + __aSize), array_view<hstring>(reinterpret_cast<hstring*>(b), reinterpret_cast<hstring*>(b) + __bSize), detach_abi<hstring>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array13(uint32_t __aSize, struct struct_TestComponent_Blittable* a, uint32_t __bSize, struct struct_TestComponent_Blittable* b, uint32_t* __cSize, struct struct_TestComponent_Blittable** c, uint32_t* __resultSize, struct struct_TestComponent_Blittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Blittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array13(array_view<winrt::TestComponent::Blittable const>(reinterpret_cast<winrt::TestComponent::Blittable const *>(a), reinterpret_cast<winrt::TestComponent::Blittable const *>(a) + __aSize), array_view<winrt::TestComponent::Blittable>(reinterpret_cast<winrt::TestComponent::Blittable*>(b), reinterpret_cast<winrt::TestComponent::Blittable*>(b) + __bSize), detach_abi<winrt::TestComponent::Blittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array14(uint32_t __aSize, struct struct_TestComponent_NonBlittable* a, uint32_t __bSize, struct struct_TestComponent_NonBlittable* b, uint32_t* __cSize, struct struct_TestComponent_NonBlittable** c, uint32_t* __resultSize, struct struct_TestComponent_NonBlittable** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::NonBlittable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array14(array_view<winrt::TestComponent::NonBlittable const>(reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a), reinterpret_cast<winrt::TestComponent::NonBlittable const *>(a) + __aSize), array_view<winrt::TestComponent::NonBlittable>(reinterpret_cast<winrt::TestComponent::NonBlittable*>(b), reinterpret_cast<winrt::TestComponent::NonBlittable*>(b) + __bSize), detach_abi<winrt::TestComponent::NonBlittable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array15(uint32_t __aSize, struct struct_TestComponent_Nested* a, uint32_t __bSize, struct struct_TestComponent_Nested* b, uint32_t* __cSize, struct struct_TestComponent_Nested** c, uint32_t* __resultSize, struct struct_TestComponent_Nested** result) noexcept final try
        {
            zero_abi<winrt::TestComponent::Nested>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array15(array_view<winrt::TestComponent::Nested const>(reinterpret_cast<winrt::TestComponent::Nested const *>(a), reinterpret_cast<winrt::TestComponent::Nested const *>(a) + __aSize), array_view<winrt::TestComponent::Nested>(reinterpret_cast<winrt::TestComponent::Nested*>(b), reinterpret_cast<winrt::TestComponent::Nested*>(b) + __bSize), detach_abi<winrt::TestComponent::Nested>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array16(uint32_t __aSize, void** a, uint32_t __bSize, void** b, uint32_t* __cSize, void*** c, uint32_t* __resultSize, void*** result) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::IStringable>(b, __bSize);
            clear_abi(c);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().Array16(array_view<winrt::Windows::Foundation::IStringable const>(reinterpret_cast<winrt::Windows::Foundation::IStringable const *>(a), reinterpret_cast<winrt::Windows::Foundation::IStringable const *>(a) + __aSize), array_view<winrt::Windows::Foundation::IStringable>(reinterpret_cast<winrt::Windows::Foundation::IStringable*>(b), reinterpret_cast<winrt::Windows::Foundation::IStringable*>(b) + __bSize), detach_abi<winrt::Windows::Foundation::IStringable>(__cSize, c)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array1Call(*reinterpret_cast<winrt::TestComponent::Array1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array2Call(*reinterpret_cast<winrt::TestComponent::Array2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array3Call(*reinterpret_cast<winrt::TestComponent::Array3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array4Call(*reinterpret_cast<winrt::TestComponent::Array4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array5Call(*reinterpret_cast<winrt::TestComponent::Array5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array6Call(*reinterpret_cast<winrt::TestComponent::Array6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array7Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array7Call(*reinterpret_cast<winrt::TestComponent::Array7Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array8Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array8Call(*reinterpret_cast<winrt::TestComponent::Array8Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array9Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array9Call(*reinterpret_cast<winrt::TestComponent::Array9Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array10Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array10Call(*reinterpret_cast<winrt::TestComponent::Array10Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array11Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array11Call(*reinterpret_cast<winrt::TestComponent::Array11Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array12Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array12Call(*reinterpret_cast<winrt::TestComponent::Array12Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array13Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array13Call(*reinterpret_cast<winrt::TestComponent::Array13Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array14Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array14Call(*reinterpret_cast<winrt::TestComponent::Array14Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array15Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array15Call(*reinterpret_cast<winrt::TestComponent::Array15Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Array16Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Array16Call(*reinterpret_cast<winrt::TestComponent::Array16Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection1(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<hstring>>(this->shim().Collection1(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection2(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>>(this->shim().Collection2(*reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection3(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>(this->shim().Collection3(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection4(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>(this->shim().Collection4(*reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection5(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVector<hstring>>(this->shim().Collection5(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVector<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection6(void* a, void** b, void** result) noexcept final try
        {
            clear_abi(b);
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().Collection6(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&a), *reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring>*>(b)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection1Call(*reinterpret_cast<winrt::TestComponent::Collection1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection2Call(*reinterpret_cast<winrt::TestComponent::Collection2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection3Call(*reinterpret_cast<winrt::TestComponent::Collection3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection4Call(*reinterpret_cast<winrt::TestComponent::Collection4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection5Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection5Call(*reinterpret_cast<winrt::TestComponent::Collection5Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Collection6Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Collection6Call(*reinterpret_cast<winrt::TestComponent::Collection6Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async1(void* suspend, bool fail, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().Async1(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async2(void* suspend, bool fail, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>>(this->shim().Async2(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async3(void* suspend, bool fail, int32_t result, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperation<int32_t>>(this->shim().Async3(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async4(void* suspend, bool fail, int32_t result, int32_t progress, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>>(this->shim().Async4(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&suspend), fail, result, progress));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async1Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async1Call(*reinterpret_cast<winrt::TestComponent::Async1Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async2Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async2Call(*reinterpret_cast<winrt::TestComponent::Async2Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async3Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async3Call(*reinterpret_cast<winrt::TestComponent::Async3Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Async4Call(void* handler) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Async4Call(*reinterpret_cast<winrt::TestComponent::Async4Handler const*>(&handler));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_Event1(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Event1(*reinterpret_cast<winrt::Windows::Foundation::EventHandler<int32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Event1(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event1(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Event2(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Event2(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::TestComponent::ITests, int32_t> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Event2(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event2(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall Event1Call(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event1Call(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Event2Call(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Event2Call(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetClassVectorSubset(void* classVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Class>>(this->shim().GetClassVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Class> const*>(&classVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetComposableClassVectorSubset(void* classVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Composable>>(this->shim().GetComposableClassVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Composable> const*>(&classVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetObjectVectorSubset(void* objectVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable>>(this->shim().GetObjectVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Foundation::IInspectable> const*>(&objectVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetInterfaceVectorSubset(void* interfaceVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::IRequiredOne>>(this->shim().GetInterfaceVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::IRequiredOne> const*>(&interfaceVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBooleanVectorSubset(void* booleanVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<bool>>(this->shim().GetBooleanVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<bool> const*>(&booleanVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetStringVectorSubset(void* stringVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<hstring>>(this->shim().GetStringVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<hstring> const*>(&stringVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBlittableVectorSubset(void* blittableVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Blittable>>(this->shim().GetBlittableVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::Blittable> const*>(&blittableVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetNonBlittableVectorSubset(void* nonBlittableVector, int32_t startIndex, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::NonBlittable>>(this->shim().GetNonBlittableVectorSubset(*reinterpret_cast<winrt::Windows::Foundation::Collections::IVectorView<winrt::TestComponent::NonBlittable> const*>(&nonBlittableVector), startIndex));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box1(uint8_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box1(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box2(uint16_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box2(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box3(uint32_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box3(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box4(uint64_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box4(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box5(int16_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box5(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box6(int32_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box6(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box7(int64_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box7(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box8(bool param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box8(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box9(float param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box9(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box10(double param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box10(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box11(winrt::guid param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box11(*reinterpret_cast<winrt::guid const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box12(char16_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box12(param, *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box13(void* param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box13(*reinterpret_cast<hstring const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box14(int64_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box14(*reinterpret_cast<winrt::Windows::Foundation::TimeSpan const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box15(struct struct_TestComponent_Blittable param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box15(*reinterpret_cast<winrt::TestComponent::Blittable const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box16(struct struct_TestComponent_NonBlittable param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box16(*reinterpret_cast<winrt::TestComponent::NonBlittable const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box17(int64_t param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box17(*reinterpret_cast<winrt::Windows::Foundation::DateTime const*>(&param), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box18(uint32_t __paramSize, int64_t* param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box18(array_view<int64_t const>(reinterpret_cast<int64_t const *>(param), reinterpret_cast<int64_t const *>(param) + __paramSize), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box19(uint32_t __paramSize, bool* param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box19(array_view<bool const>(reinterpret_cast<bool const *>(param), reinterpret_cast<bool const *>(param) + __paramSize), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box20(uint32_t __paramSize, void** param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box20(array_view<hstring const>(reinterpret_cast<hstring const *>(param), reinterpret_cast<hstring const *>(param) + __paramSize), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Box21(uint32_t __paramSize, int64_t* param, void* boxedParam, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::IInspectable>(this->shim().Box21(array_view<winrt::Windows::Foundation::TimeSpan const>(reinterpret_cast<winrt::Windows::Foundation::TimeSpan const *>(param), reinterpret_cast<winrt::Windows::Foundation::TimeSpan const *>(param) + __paramSize), *reinterpret_cast<winrt::Windows::Foundation::IInspectable const*>(&boxedParam)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::TestComponent::IOverloadClassOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::TestComponent::IOverloadClassOverrides>
{
    auto Overload(int32_t a)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.Overload(a);
        }

        return this->shim().Overload(a);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::TestComponent::IOverloadClassOverrides2>
    : produce_dispatch_to_overridable_base<T, D, winrt::TestComponent::IOverloadClassOverrides2>
{
    auto Overload(int32_t a, int32_t b)
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.Overload(a, b);
        }

        return this->shim().Overload(a, b);
    }
};
template <typename T, typename D>
struct WINRT_IMPL_EMPTY_BASES produce_dispatch_to_overridable<T, D, winrt::TestComponent::IOverrideOverrides>
    : produce_dispatch_to_overridable_base<T, D, winrt::TestComponent::IOverrideOverrides>
{
    auto OnOverridable()
    {
        if (auto overridable = this->shim_overridable())
        {
            return overridable.OnOverridable();
        }

        return this->shim().OnOverridable();
    }
};
}
WINRT_EXPORT namespace winrt::TestComponent
{
    inline Class::Class() :
        Class(impl::call_factory_cast<Class(*)(winrt::Windows::Foundation::IActivationFactory const&), Class>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<Class>(); }))
    {
    }
    inline Composable::Composable()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<Composable, IComposableFactory>([&](IComposableFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline Composable::Composable(int32_t init)
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<Composable, IComposableFactory>([&](IComposableFactory const& f) { return f.CreateWithValue(init, baseInterface, innerInterface); });
    }
    inline auto Composable::ExpectComposable(winrt::TestComponent::Composable const& t)
    {
        return impl::call_factory<Composable, IComposableStatics>([&](IComposableStatics const& f) { return f.ExpectComposable(t); });
    }
    inline auto Composable::ExpectRequiredOne(winrt::TestComponent::IRequiredOne const& t)
    {
        return impl::call_factory<Composable, IComposableStatics>([&](IComposableStatics const& f) { return f.ExpectRequiredOne(t); });
    }
    inline auto Composable::ExpectRequiredTwo(winrt::TestComponent::IRequiredTwo const& t)
    {
        return impl::call_factory<Composable, IComposableStatics>([&](IComposableStatics const& f) { return f.ExpectRequiredTwo(t); });
    }
    inline auto Composable::ExpectRequiredThree(winrt::TestComponent::IRequiredThree const& t)
    {
        return impl::call_factory<Composable, IComposableStatics>([&](IComposableStatics const& f) { return f.ExpectRequiredThree(t); });
    }
    inline auto Composable::ExpectRequiredFour(winrt::TestComponent::IRequiredFour const& t)
    {
        return impl::call_factory<Composable, IComposableStatics>([&](IComposableStatics const& f) { return f.ExpectRequiredFour(t); });
    }
    inline Derived::Derived()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<Derived, IDerivedFactory>([&](IDerivedFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline OverloadClass::OverloadClass()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<OverloadClass, IOverloadClassFactory>([&](IOverloadClassFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline Override::Override()
    {
        winrt::Windows::Foundation::IInspectable baseInterface, innerInterface;
        *this = impl::call_factory<Override, IOverrideFactory>([&](IOverrideFactory const& f) { return f.CreateInstance(baseInterface, innerInterface); });
    }
    inline auto TestRunner::TestProducer(winrt::TestComponent::ITests const& callee)
    {
        impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.TestProducer(callee); });
    }
    inline auto TestRunner::TestConsumer(winrt::TestComponent::TestHandler const& caller)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.TestConsumer(caller); });
    }
    inline auto TestRunner::TestSelf()
    {
        impl::call_factory_cast<void(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.TestSelf(); });
    }
    inline auto TestRunner::MakeTests()
    {
        return impl::call_factory_cast<winrt::TestComponent::ITests(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.MakeTests(); });
    }
    inline auto TestRunner::CreateInt32Vector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<int32_t>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateInt32Vector(); });
    }
    inline auto TestRunner::CreateStringVector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<hstring>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateStringVector(); });
    }
    inline auto TestRunner::CreateStringableVector()
    {
        return impl::call_factory_cast<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IStringable>(*)(ITestRunnerStatics const&), TestRunner, ITestRunnerStatics>([](ITestRunnerStatics const& f) { return f.CreateStringableVector(); });
    }
    inline auto TestRunner::CreateTimeSpan(uint32_t milliseconds)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateTimeSpan(milliseconds); });
    }
    inline auto TestRunner::CreateAsyncAction(uint32_t milliseconds)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncAction(milliseconds); });
    }
    inline auto TestRunner::CreateAsyncActionWithError(uint32_t milliseconds, int32_t error)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncActionWithError(milliseconds, error); });
    }
    inline auto TestRunner::CreateAsyncOperation(uint32_t milliseconds, int32_t result)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncOperation(milliseconds, result); });
    }
    inline auto TestRunner::CreateAsyncOperationWithError(uint32_t milliseconds, int32_t result, int32_t error)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncOperationWithError(milliseconds, result, error); });
    }
    inline auto TestRunner::CreateAsyncActionWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncActionWithProgress(milliseconds, items); });
    }
    inline auto TestRunner::CreateAsyncActionWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t error)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncActionWithProgressWithError(milliseconds, items, error); });
    }
    inline auto TestRunner::CreateAsyncOperationWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncOperationWithProgress(milliseconds, items, result); });
    }
    inline auto TestRunner::CreateAsyncOperationWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result, int32_t error)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.CreateAsyncOperationWithProgressWithError(milliseconds, items, result, error); });
    }
    inline auto TestRunner::ExpectObject(winrt::Windows::Foundation::IInspectable const& value)
    {
        return impl::call_factory<TestRunner, ITestRunnerStatics>([&](ITestRunnerStatics const& f) { return f.ExpectObject(value); });
    }
    template <typename L> Array10Handler::Array10Handler(L handler) :
        Array10Handler(impl::make_delegate<Array10Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array10Handler::Array10Handler(F* handler) :
        Array10Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(O* object, M method) :
        Array10Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(com_ptr<O>&& object, M method) :
        Array10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array10Handler::Array10Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array10Handler::Array10Handler(std::shared_ptr<O>&& object, M method) :
        Array10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array10Handler::Array10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array10Handler::operator()(array_view<double const> a, array_view<double> b, com_array<double>& c) const
    {
        uint32_t result_impl_size{};
        double* result{};
        check_hresult((*(impl::abi_t<Array10Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array11Handler::Array11Handler(L handler) :
        Array11Handler(impl::make_delegate<Array11Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array11Handler::Array11Handler(F* handler) :
        Array11Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(O* object, M method) :
        Array11Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(com_ptr<O>&& object, M method) :
        Array11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array11Handler::Array11Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array11Handler::Array11Handler(std::shared_ptr<O>&& object, M method) :
        Array11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array11Handler::Array11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array11Handler::operator()(array_view<char16_t const> a, array_view<char16_t> b, com_array<char16_t>& c) const
    {
        uint32_t result_impl_size{};
        char16_t* result{};
        check_hresult((*(impl::abi_t<Array11Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<char16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array12Handler::Array12Handler(L handler) :
        Array12Handler(impl::make_delegate<Array12Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array12Handler::Array12Handler(F* handler) :
        Array12Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(O* object, M method) :
        Array12Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(com_ptr<O>&& object, M method) :
        Array12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array12Handler::Array12Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array12Handler::Array12Handler(std::shared_ptr<O>&& object, M method) :
        Array12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array12Handler::Array12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array12Handler::operator()(array_view<hstring const> a, array_view<hstring> b, com_array<hstring>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult((*(impl::abi_t<Array12Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<hstring>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array13Handler::Array13Handler(L handler) :
        Array13Handler(impl::make_delegate<Array13Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array13Handler::Array13Handler(F* handler) :
        Array13Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(O* object, M method) :
        Array13Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(com_ptr<O>&& object, M method) :
        Array13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array13Handler::Array13Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array13Handler::Array13Handler(std::shared_ptr<O>&& object, M method) :
        Array13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array13Handler::Array13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array13Handler::operator()(array_view<winrt::TestComponent::Blittable const> a, array_view<winrt::TestComponent::Blittable> b, com_array<winrt::TestComponent::Blittable>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_Blittable* result{};
        check_hresult((*(impl::abi_t<Array13Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Blittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array14Handler::Array14Handler(L handler) :
        Array14Handler(impl::make_delegate<Array14Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array14Handler::Array14Handler(F* handler) :
        Array14Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(O* object, M method) :
        Array14Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(com_ptr<O>&& object, M method) :
        Array14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array14Handler::Array14Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array14Handler::Array14Handler(std::shared_ptr<O>&& object, M method) :
        Array14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array14Handler::Array14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array14Handler::operator()(array_view<winrt::TestComponent::NonBlittable const> a, array_view<winrt::TestComponent::NonBlittable> b, com_array<winrt::TestComponent::NonBlittable>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_NonBlittable* result{};
        check_hresult((*(impl::abi_t<Array14Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::NonBlittable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array15Handler::Array15Handler(L handler) :
        Array15Handler(impl::make_delegate<Array15Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array15Handler::Array15Handler(F* handler) :
        Array15Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(O* object, M method) :
        Array15Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(com_ptr<O>&& object, M method) :
        Array15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array15Handler::Array15Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array15Handler::Array15Handler(std::shared_ptr<O>&& object, M method) :
        Array15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array15Handler::Array15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array15Handler::operator()(array_view<winrt::TestComponent::Nested const> a, array_view<winrt::TestComponent::Nested> b, com_array<winrt::TestComponent::Nested>& c) const
    {
        uint32_t result_impl_size{};
        struct impl::struct_TestComponent_Nested* result{};
        check_hresult((*(impl::abi_t<Array15Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::TestComponent::Nested>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array16Handler::Array16Handler(L handler) :
        Array16Handler(impl::make_delegate<Array16Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array16Handler::Array16Handler(F* handler) :
        Array16Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array16Handler::Array16Handler(O* object, M method) :
        Array16Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array16Handler::Array16Handler(com_ptr<O>&& object, M method) :
        Array16Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array16Handler::Array16Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array16Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array16Handler::Array16Handler(std::shared_ptr<O>&& object, M method) :
        Array16Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array16Handler::Array16Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array16Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array16Handler::operator()(array_view<winrt::Windows::Foundation::IStringable const> a, array_view<winrt::Windows::Foundation::IStringable> b, com_array<winrt::Windows::Foundation::IStringable>& c) const
    {
        uint32_t result_impl_size{};
        void** result{};
        check_hresult((*(impl::abi_t<Array16Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<winrt::Windows::Foundation::IStringable>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array1Handler::Array1Handler(L handler) :
        Array1Handler(impl::make_delegate<Array1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array1Handler::Array1Handler(F* handler) :
        Array1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(O* object, M method) :
        Array1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(com_ptr<O>&& object, M method) :
        Array1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array1Handler::Array1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array1Handler::Array1Handler(std::shared_ptr<O>&& object, M method) :
        Array1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array1Handler::Array1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array1Handler::operator()(array_view<bool const> a, array_view<bool> b, com_array<bool>& c) const
    {
        uint32_t result_impl_size{};
        bool* result{};
        check_hresult((*(impl::abi_t<Array1Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<bool>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array2Handler::Array2Handler(L handler) :
        Array2Handler(impl::make_delegate<Array2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array2Handler::Array2Handler(F* handler) :
        Array2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(O* object, M method) :
        Array2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(com_ptr<O>&& object, M method) :
        Array2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array2Handler::Array2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array2Handler::Array2Handler(std::shared_ptr<O>&& object, M method) :
        Array2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array2Handler::Array2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array2Handler::operator()(array_view<uint8_t const> a, array_view<uint8_t> b, com_array<uint8_t>& c) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult((*(impl::abi_t<Array2Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array3Handler::Array3Handler(L handler) :
        Array3Handler(impl::make_delegate<Array3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array3Handler::Array3Handler(F* handler) :
        Array3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(O* object, M method) :
        Array3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(com_ptr<O>&& object, M method) :
        Array3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array3Handler::Array3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array3Handler::Array3Handler(std::shared_ptr<O>&& object, M method) :
        Array3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array3Handler::Array3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array3Handler::operator()(array_view<uint16_t const> a, array_view<uint16_t> b, com_array<uint16_t>& c) const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        check_hresult((*(impl::abi_t<Array3Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array4Handler::Array4Handler(L handler) :
        Array4Handler(impl::make_delegate<Array4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array4Handler::Array4Handler(F* handler) :
        Array4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(O* object, M method) :
        Array4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(com_ptr<O>&& object, M method) :
        Array4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array4Handler::Array4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array4Handler::Array4Handler(std::shared_ptr<O>&& object, M method) :
        Array4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array4Handler::Array4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array4Handler::operator()(array_view<uint32_t const> a, array_view<uint32_t> b, com_array<uint32_t>& c) const
    {
        uint32_t result_impl_size{};
        uint32_t* result{};
        check_hresult((*(impl::abi_t<Array4Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array5Handler::Array5Handler(L handler) :
        Array5Handler(impl::make_delegate<Array5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array5Handler::Array5Handler(F* handler) :
        Array5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(O* object, M method) :
        Array5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(com_ptr<O>&& object, M method) :
        Array5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array5Handler::Array5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array5Handler::Array5Handler(std::shared_ptr<O>&& object, M method) :
        Array5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array5Handler::Array5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array5Handler::operator()(array_view<uint64_t const> a, array_view<uint64_t> b, com_array<uint64_t>& c) const
    {
        uint32_t result_impl_size{};
        uint64_t* result{};
        check_hresult((*(impl::abi_t<Array5Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<uint64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array6Handler::Array6Handler(L handler) :
        Array6Handler(impl::make_delegate<Array6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array6Handler::Array6Handler(F* handler) :
        Array6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(O* object, M method) :
        Array6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(com_ptr<O>&& object, M method) :
        Array6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array6Handler::Array6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array6Handler::Array6Handler(std::shared_ptr<O>&& object, M method) :
        Array6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array6Handler::Array6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array6Handler::operator()(array_view<int16_t const> a, array_view<int16_t> b, com_array<int16_t>& c) const
    {
        uint32_t result_impl_size{};
        int16_t* result{};
        check_hresult((*(impl::abi_t<Array6Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array7Handler::Array7Handler(L handler) :
        Array7Handler(impl::make_delegate<Array7Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array7Handler::Array7Handler(F* handler) :
        Array7Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(O* object, M method) :
        Array7Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(com_ptr<O>&& object, M method) :
        Array7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array7Handler::Array7Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array7Handler::Array7Handler(std::shared_ptr<O>&& object, M method) :
        Array7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array7Handler::Array7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array7Handler::operator()(array_view<int32_t const> a, array_view<int32_t> b, com_array<int32_t>& c) const
    {
        uint32_t result_impl_size{};
        int32_t* result{};
        check_hresult((*(impl::abi_t<Array7Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int32_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array8Handler::Array8Handler(L handler) :
        Array8Handler(impl::make_delegate<Array8Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array8Handler::Array8Handler(F* handler) :
        Array8Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(O* object, M method) :
        Array8Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(com_ptr<O>&& object, M method) :
        Array8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array8Handler::Array8Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array8Handler::Array8Handler(std::shared_ptr<O>&& object, M method) :
        Array8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array8Handler::Array8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array8Handler::operator()(array_view<int64_t const> a, array_view<int64_t> b, com_array<int64_t>& c) const
    {
        uint32_t result_impl_size{};
        int64_t* result{};
        check_hresult((*(impl::abi_t<Array8Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<int64_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Array9Handler::Array9Handler(L handler) :
        Array9Handler(impl::make_delegate<Array9Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Array9Handler::Array9Handler(F* handler) :
        Array9Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(O* object, M method) :
        Array9Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(com_ptr<O>&& object, M method) :
        Array9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array9Handler::Array9Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Array9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Array9Handler::Array9Handler(std::shared_ptr<O>&& object, M method) :
        Array9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Array9Handler::Array9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Array9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Array9Handler::operator()(array_view<float const> a, array_view<float> b, com_array<float>& c) const
    {
        uint32_t result_impl_size{};
        float* result{};
        check_hresult((*(impl::abi_t<Array9Handler>**)this)->Invoke(a.size(), get_abi(a), b.size(), put_abi(b), impl::put_size_abi(c), put_abi(c), &result_impl_size, &result));
        return com_array<float>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename L> Async1Handler::Async1Handler(L handler) :
        Async1Handler(impl::make_delegate<Async1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async1Handler::Async1Handler(F* handler) :
        Async1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(O* object, M method) :
        Async1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(com_ptr<O>&& object, M method) :
        Async1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async1Handler::Async1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async1Handler::Async1Handler(std::shared_ptr<O>&& object, M method) :
        Async1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async1Handler::Async1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async1Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async1Handler>**)this)->Invoke(*(void**)(&suspend), fail, &operation));
        return winrt::Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename L> Async2Handler::Async2Handler(L handler) :
        Async2Handler(impl::make_delegate<Async2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async2Handler::Async2Handler(F* handler) :
        Async2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(O* object, M method) :
        Async2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(com_ptr<O>&& object, M method) :
        Async2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async2Handler::Async2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async2Handler::Async2Handler(std::shared_ptr<O>&& object, M method) :
        Async2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async2Handler::Async2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async2Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t progress) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async2Handler>**)this)->Invoke(*(void**)(&suspend), fail, progress, &operation));
        return winrt::Windows::Foundation::IAsyncActionWithProgress<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Async3Handler::Async3Handler(L handler) :
        Async3Handler(impl::make_delegate<Async3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async3Handler::Async3Handler(F* handler) :
        Async3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(O* object, M method) :
        Async3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(com_ptr<O>&& object, M method) :
        Async3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async3Handler::Async3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async3Handler::Async3Handler(std::shared_ptr<O>&& object, M method) :
        Async3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async3Handler::Async3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async3Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async3Handler>**)this)->Invoke(*(void**)(&suspend), fail, result, &operation));
        return winrt::Windows::Foundation::IAsyncOperation<int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Async4Handler::Async4Handler(L handler) :
        Async4Handler(impl::make_delegate<Async4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Async4Handler::Async4Handler(F* handler) :
        Async4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(O* object, M method) :
        Async4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(com_ptr<O>&& object, M method) :
        Async4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async4Handler::Async4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Async4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Async4Handler::Async4Handler(std::shared_ptr<O>&& object, M method) :
        Async4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Async4Handler::Async4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Async4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Async4Handler::operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result, int32_t progress) const
    {
        void* operation{};
        check_hresult((*(impl::abi_t<Async4Handler>**)this)->Invoke(*(void**)(&suspend), fail, result, progress, &operation));
        return winrt::Windows::Foundation::IAsyncOperationWithProgress<int32_t, int32_t>{ operation, take_ownership_from_abi };
    }
    template <typename L> Collection1Handler::Collection1Handler(L handler) :
        Collection1Handler(impl::make_delegate<Collection1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection1Handler::Collection1Handler(F* handler) :
        Collection1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(O* object, M method) :
        Collection1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(com_ptr<O>&& object, M method) :
        Collection1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection1Handler::Collection1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection1Handler::Collection1Handler(std::shared_ptr<O>&& object, M method) :
        Collection1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection1Handler::Collection1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection1Handler::operator()(param::iterable<hstring> const& a, winrt::Windows::Foundation::Collections::IIterable<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection1Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection2Handler::Collection2Handler(L handler) :
        Collection2Handler(impl::make_delegate<Collection2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection2Handler::Collection2Handler(F* handler) :
        Collection2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(O* object, M method) :
        Collection2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(com_ptr<O>&& object, M method) :
        Collection2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection2Handler::Collection2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection2Handler::Collection2Handler(std::shared_ptr<O>&& object, M method) :
        Collection2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection2Handler::Collection2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection2Handler::operator()(param::iterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& a, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection2Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection3Handler::Collection3Handler(L handler) :
        Collection3Handler(impl::make_delegate<Collection3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection3Handler::Collection3Handler(F* handler) :
        Collection3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(O* object, M method) :
        Collection3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(com_ptr<O>&& object, M method) :
        Collection3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection3Handler::Collection3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection3Handler::Collection3Handler(std::shared_ptr<O>&& object, M method) :
        Collection3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection3Handler::Collection3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection3Handler::operator()(param::map<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMap<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection3Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection4Handler::Collection4Handler(L handler) :
        Collection4Handler(impl::make_delegate<Collection4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection4Handler::Collection4Handler(F* handler) :
        Collection4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(O* object, M method) :
        Collection4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(com_ptr<O>&& object, M method) :
        Collection4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection4Handler::Collection4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection4Handler::Collection4Handler(std::shared_ptr<O>&& object, M method) :
        Collection4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection4Handler::Collection4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection4Handler::operator()(param::map_view<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection4Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection5Handler::Collection5Handler(L handler) :
        Collection5Handler(impl::make_delegate<Collection5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection5Handler::Collection5Handler(F* handler) :
        Collection5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(O* object, M method) :
        Collection5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(com_ptr<O>&& object, M method) :
        Collection5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection5Handler::Collection5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection5Handler::Collection5Handler(std::shared_ptr<O>&& object, M method) :
        Collection5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection5Handler::Collection5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection5Handler::operator()(param::vector<hstring> const& a, winrt::Windows::Foundation::Collections::IVector<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection5Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVector<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Collection6Handler::Collection6Handler(L handler) :
        Collection6Handler(impl::make_delegate<Collection6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Collection6Handler::Collection6Handler(F* handler) :
        Collection6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(O* object, M method) :
        Collection6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(com_ptr<O>&& object, M method) :
        Collection6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection6Handler::Collection6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Collection6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Collection6Handler::Collection6Handler(std::shared_ptr<O>&& object, M method) :
        Collection6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Collection6Handler::Collection6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Collection6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Collection6Handler::operator()(param::vector_view<hstring> const& a, winrt::Windows::Foundation::Collections::IVectorView<hstring>& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Collection6Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return winrt::Windows::Foundation::Collections::IVectorView<hstring>{ result, take_ownership_from_abi };
    }
    template <typename L> Param10Handler::Param10Handler(L handler) :
        Param10Handler(impl::make_delegate<Param10Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param10Handler::Param10Handler(F* handler) :
        Param10Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(O* object, M method) :
        Param10Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(com_ptr<O>&& object, M method) :
        Param10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param10Handler::Param10Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param10Handler::Param10Handler(std::shared_ptr<O>&& object, M method) :
        Param10Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param10Handler::Param10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param10Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param10Handler::operator()(double a, double& b) const
    {
        double result{};
        check_hresult((*(impl::abi_t<Param10Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param11Handler::Param11Handler(L handler) :
        Param11Handler(impl::make_delegate<Param11Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param11Handler::Param11Handler(F* handler) :
        Param11Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(O* object, M method) :
        Param11Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(com_ptr<O>&& object, M method) :
        Param11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param11Handler::Param11Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param11Handler::Param11Handler(std::shared_ptr<O>&& object, M method) :
        Param11Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param11Handler::Param11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param11Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param11Handler::operator()(char16_t a, char16_t& b) const
    {
        char16_t result{};
        check_hresult((*(impl::abi_t<Param11Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param12Handler::Param12Handler(L handler) :
        Param12Handler(impl::make_delegate<Param12Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param12Handler::Param12Handler(F* handler) :
        Param12Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(O* object, M method) :
        Param12Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(com_ptr<O>&& object, M method) :
        Param12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param12Handler::Param12Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param12Handler::Param12Handler(std::shared_ptr<O>&& object, M method) :
        Param12Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param12Handler::Param12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param12Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param12Handler::operator()(param::hstring const& a, hstring& b) const
    {
        void* result{};
        check_hresult((*(impl::abi_t<Param12Handler>**)this)->Invoke(*(void**)(&a), impl::bind_out(b), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename L> Param13Handler::Param13Handler(L handler) :
        Param13Handler(impl::make_delegate<Param13Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param13Handler::Param13Handler(F* handler) :
        Param13Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(O* object, M method) :
        Param13Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(com_ptr<O>&& object, M method) :
        Param13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param13Handler::Param13Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param13Handler::Param13Handler(std::shared_ptr<O>&& object, M method) :
        Param13Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param13Handler::Param13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param13Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param13Handler::operator()(winrt::TestComponent::Blittable const& a, winrt::TestComponent::Blittable const& b, winrt::TestComponent::Blittable& c) const
    {
        winrt::TestComponent::Blittable result{};
        check_hresult((*(impl::abi_t<Param13Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param14Handler::Param14Handler(L handler) :
        Param14Handler(impl::make_delegate<Param14Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param14Handler::Param14Handler(F* handler) :
        Param14Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(O* object, M method) :
        Param14Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(com_ptr<O>&& object, M method) :
        Param14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param14Handler::Param14Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param14Handler::Param14Handler(std::shared_ptr<O>&& object, M method) :
        Param14Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param14Handler::Param14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param14Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param14Handler::operator()(winrt::TestComponent::NonBlittable const& a, winrt::TestComponent::NonBlittable const& b, winrt::TestComponent::NonBlittable& c) const
    {
        winrt::TestComponent::NonBlittable result{};
        check_hresult((*(impl::abi_t<Param14Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param15Handler::Param15Handler(L handler) :
        Param15Handler(impl::make_delegate<Param15Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param15Handler::Param15Handler(F* handler) :
        Param15Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(O* object, M method) :
        Param15Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(com_ptr<O>&& object, M method) :
        Param15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param15Handler::Param15Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param15Handler::Param15Handler(std::shared_ptr<O>&& object, M method) :
        Param15Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param15Handler::Param15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param15Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param15Handler::operator()(winrt::TestComponent::Nested const& a, winrt::TestComponent::Nested const& b, winrt::TestComponent::Nested& c) const
    {
        winrt::TestComponent::Nested result{};
        check_hresult((*(impl::abi_t<Param15Handler>**)this)->Invoke(impl::bind_in(a), impl::bind_in(b), impl::bind_out(c), put_abi(result)));
        return result;
    }
    template <typename L> Param1Handler::Param1Handler(L handler) :
        Param1Handler(impl::make_delegate<Param1Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param1Handler::Param1Handler(F* handler) :
        Param1Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(O* object, M method) :
        Param1Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(com_ptr<O>&& object, M method) :
        Param1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param1Handler::Param1Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param1Handler::Param1Handler(std::shared_ptr<O>&& object, M method) :
        Param1Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param1Handler::Param1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param1Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param1Handler::operator()(bool a, bool& b) const
    {
        bool result{};
        check_hresult((*(impl::abi_t<Param1Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param2Handler::Param2Handler(L handler) :
        Param2Handler(impl::make_delegate<Param2Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param2Handler::Param2Handler(F* handler) :
        Param2Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(O* object, M method) :
        Param2Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(com_ptr<O>&& object, M method) :
        Param2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param2Handler::Param2Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param2Handler::Param2Handler(std::shared_ptr<O>&& object, M method) :
        Param2Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param2Handler::Param2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param2Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param2Handler::operator()(uint8_t a, uint8_t& b) const
    {
        uint8_t result{};
        check_hresult((*(impl::abi_t<Param2Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param3Handler::Param3Handler(L handler) :
        Param3Handler(impl::make_delegate<Param3Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param3Handler::Param3Handler(F* handler) :
        Param3Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(O* object, M method) :
        Param3Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(com_ptr<O>&& object, M method) :
        Param3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param3Handler::Param3Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param3Handler::Param3Handler(std::shared_ptr<O>&& object, M method) :
        Param3Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param3Handler::Param3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param3Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param3Handler::operator()(uint16_t a, uint16_t& b) const
    {
        uint16_t result{};
        check_hresult((*(impl::abi_t<Param3Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param4Handler::Param4Handler(L handler) :
        Param4Handler(impl::make_delegate<Param4Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param4Handler::Param4Handler(F* handler) :
        Param4Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(O* object, M method) :
        Param4Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(com_ptr<O>&& object, M method) :
        Param4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param4Handler::Param4Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param4Handler::Param4Handler(std::shared_ptr<O>&& object, M method) :
        Param4Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param4Handler::Param4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param4Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param4Handler::operator()(uint32_t a, uint32_t& b) const
    {
        uint32_t result{};
        check_hresult((*(impl::abi_t<Param4Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param5Handler::Param5Handler(L handler) :
        Param5Handler(impl::make_delegate<Param5Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param5Handler::Param5Handler(F* handler) :
        Param5Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(O* object, M method) :
        Param5Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(com_ptr<O>&& object, M method) :
        Param5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param5Handler::Param5Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param5Handler::Param5Handler(std::shared_ptr<O>&& object, M method) :
        Param5Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param5Handler::Param5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param5Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param5Handler::operator()(uint64_t a, uint64_t& b) const
    {
        uint64_t result{};
        check_hresult((*(impl::abi_t<Param5Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param6Handler::Param6Handler(L handler) :
        Param6Handler(impl::make_delegate<Param6Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param6Handler::Param6Handler(F* handler) :
        Param6Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(O* object, M method) :
        Param6Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(com_ptr<O>&& object, M method) :
        Param6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param6Handler::Param6Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param6Handler::Param6Handler(std::shared_ptr<O>&& object, M method) :
        Param6Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param6Handler::Param6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param6Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param6Handler::operator()(int16_t a, int16_t& b) const
    {
        int16_t result{};
        check_hresult((*(impl::abi_t<Param6Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param7Handler::Param7Handler(L handler) :
        Param7Handler(impl::make_delegate<Param7Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param7Handler::Param7Handler(F* handler) :
        Param7Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(O* object, M method) :
        Param7Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(com_ptr<O>&& object, M method) :
        Param7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param7Handler::Param7Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param7Handler::Param7Handler(std::shared_ptr<O>&& object, M method) :
        Param7Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param7Handler::Param7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param7Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param7Handler::operator()(int32_t a, int32_t& b) const
    {
        int32_t result{};
        check_hresult((*(impl::abi_t<Param7Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param8Handler::Param8Handler(L handler) :
        Param8Handler(impl::make_delegate<Param8Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param8Handler::Param8Handler(F* handler) :
        Param8Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(O* object, M method) :
        Param8Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(com_ptr<O>&& object, M method) :
        Param8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param8Handler::Param8Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param8Handler::Param8Handler(std::shared_ptr<O>&& object, M method) :
        Param8Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param8Handler::Param8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param8Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param8Handler::operator()(int64_t a, int64_t& b) const
    {
        int64_t result{};
        check_hresult((*(impl::abi_t<Param8Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> Param9Handler::Param9Handler(L handler) :
        Param9Handler(impl::make_delegate<Param9Handler>(std::forward<L>(handler)))
    {
    }
    template <typename F> Param9Handler::Param9Handler(F* handler) :
        Param9Handler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(O* object, M method) :
        Param9Handler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(com_ptr<O>&& object, M method) :
        Param9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param9Handler::Param9Handler(weak_ref<O>&& object, LM&& lambda_or_method) :
        Param9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> Param9Handler::Param9Handler(std::shared_ptr<O>&& object, M method) :
        Param9Handler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> Param9Handler::Param9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        Param9Handler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto Param9Handler::operator()(float a, float& b) const
    {
        float result{};
        check_hresult((*(impl::abi_t<Param9Handler>**)this)->Invoke(a, &b, &result));
        return result;
    }
    template <typename L> TestHandler::TestHandler(L handler) :
        TestHandler(impl::make_delegate<TestHandler>(std::forward<L>(handler)))
    {
    }
    template <typename F> TestHandler::TestHandler(F* handler) :
        TestHandler([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(O* object, M method) :
        TestHandler([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(com_ptr<O>&& object, M method) :
        TestHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> TestHandler::TestHandler(weak_ref<O>&& object, LM&& lambda_or_method) :
        TestHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.get()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    template <typename O, typename M> TestHandler::TestHandler(std::shared_ptr<O>&& object, M method) :
        TestHandler([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename LM> TestHandler::TestHandler(std::weak_ptr<O>&& object, LM&& lambda_or_method) :
        TestHandler([o = std::move(object), lm = std::forward<LM>(lambda_or_method)](auto&&... args) { if (auto s = o.lock()) {
            if constexpr (std::is_member_function_pointer_v<LM>) ((*s).*(lm))(args...);
            else lm(args...);
        } })
    {
    }
    inline auto TestHandler::operator()(winrt::TestComponent::ITests const& tests) const
    {
        check_hresult((*(impl::abi_t<TestHandler>**)this)->Invoke(*(void**)(&tests)));
    }
    template <typename D> auto IOverloadClassOverridesT<D>::Overload(int32_t a) const
    {
        return shim().template try_as<IOverloadClassOverrides>().Overload(a);
    }
    template <typename D> auto IOverloadClassOverrides2T<D>::Overload(int32_t a, int32_t b) const
    {
        return shim().template try_as<IOverloadClassOverrides2>().Overload(a, b);
    }
    template <typename D> auto IOverrideOverridesT<D>::OnOverridable() const
    {
        return shim().template try_as<IOverrideOverrides>().OnOverridable();
    }
    template <typename D, typename... Interfaces>
    struct ComposableT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::TestComponent::IComposable, winrt::TestComponent::IRequiredOne, winrt::TestComponent::IRequiredTwo, winrt::TestComponent::IRequiredThree, winrt::TestComponent::IRequiredFour>,
        impl::base<D, Composable>
    {
        using composable = Composable;
    protected:
        ComposableT()
        {
            impl::call_factory<Composable, IComposableFactory>([&](IComposableFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
        ComposableT(int32_t init)
        {
            impl::call_factory<Composable, IComposableFactory>([&](IComposableFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateWithValue(init, *this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct DerivedT :
        implements<D, winrt::Windows::Foundation::IInspectable, composing, Interfaces...>,
        impl::require<D, winrt::TestComponent::IDerived, winrt::TestComponent::IComposable, winrt::TestComponent::IRequiredOne, winrt::TestComponent::IRequiredTwo, winrt::TestComponent::IRequiredThree, winrt::TestComponent::IRequiredFour>,
        impl::base<D, Derived, winrt::TestComponent::Composable>
    {
        using composable = Derived;
    protected:
        DerivedT()
        {
            impl::call_factory<Derived, IDerivedFactory>([&](IDerivedFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
    template <typename D, typename... Interfaces>
    struct OverloadClassT :
        implements<D, winrt::TestComponent::IOverloadClassOverrides, winrt::TestComponent::IOverloadClassOverrides2, composing, Interfaces...>,
        impl::require<D, winrt::TestComponent::IOverloadClass>,
        protected impl::require<D, winrt::TestComponent::IOverloadClassProtected>,
        impl::base<D, OverloadClass>,
        winrt::TestComponent::IOverloadClassOverridesT<D>, winrt::TestComponent::IOverloadClassOverrides2T<D>
    {
        using composable = OverloadClass;
        friend impl::consume_t<D, winrt::TestComponent::IOverloadClassProtected>;
        friend impl::require_one<D, winrt::TestComponent::IOverloadClassProtected>;
        friend impl::produce<D, winrt::TestComponent::IOverloadClassOverrides>;
        friend impl::produce<D, winrt::TestComponent::IOverloadClassOverrides2>;
    protected:
        OverloadClassT()
        {
            impl::call_factory<OverloadClass, IOverloadClassFactory>([&](IOverloadClassFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
        using impl::consume_t<D, winrt::TestComponent::IOverloadClass>::Overload;
        using winrt::TestComponent::IOverloadClassOverridesT<D>::Overload;
        using winrt::TestComponent::IOverloadClassOverrides2T<D>::Overload;
        using impl::consume_t<D, winrt::TestComponent::IOverloadClassProtected>::Overload;
    };
    template <typename D, typename... Interfaces>
    struct OverrideT :
        implements<D, winrt::TestComponent::IOverrideOverrides, composing, Interfaces...>,
        impl::require<D, winrt::TestComponent::IOverride>,
        protected impl::require<D, winrt::TestComponent::IOverrideProtected>,
        impl::base<D, Override>,
        winrt::TestComponent::IOverrideOverridesT<D>
    {
        using composable = Override;
        friend impl::consume_t<D, winrt::TestComponent::IOverrideProtected>;
        friend impl::require_one<D, winrt::TestComponent::IOverrideProtected>;
        friend impl::produce<D, winrt::TestComponent::IOverrideOverrides>;
    protected:
        OverrideT()
        {
            impl::call_factory<Override, IOverrideFactory>([&](IOverrideFactory const& f) { [[maybe_unused]] auto winrt_impl_discarded = f.CreateInstance(*this, this->m_inner); });
        }
    };
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::TestComponent::IClass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IComposable> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IComposableFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IComposableStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IDerived> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IDerivedFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverloadClass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverloadClassFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverloadClassOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverloadClassOverrides2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverloadClassProtected> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverride> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverrideFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverrideOverrides> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IOverrideProtected> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IRequiredFour> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IRequiredOne> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IRequiredThree> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::IRequiredTwo> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::ITestRunnerStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::ITests> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::Class> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::Composable> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::Derived> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::OverloadClass> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::Override> : winrt::impl::hash_base {};
    template<> struct hash<winrt::TestComponent::TestRunner> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
