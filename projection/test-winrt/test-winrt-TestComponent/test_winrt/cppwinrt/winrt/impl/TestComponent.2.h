// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.240111.5

#pragma once
#ifndef WINRT_TestComponent_2_H
#define WINRT_TestComponent_2_H
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/TestComponent.1.h"
WINRT_EXPORT namespace winrt::TestComponent
{
    struct Array10Handler : winrt::Windows::Foundation::IUnknown
    {
        Array10Handler(std::nullptr_t = nullptr) noexcept {}
        Array10Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array10Handler(L lambda);
        template <typename F> Array10Handler(F* function);
        template <typename O, typename M> Array10Handler(O* object, M method);
        template <typename O, typename M> Array10Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array10Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array10Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<double const> a, array_view<double> b, com_array<double>& c) const;
    };
    struct Array11Handler : winrt::Windows::Foundation::IUnknown
    {
        Array11Handler(std::nullptr_t = nullptr) noexcept {}
        Array11Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array11Handler(L lambda);
        template <typename F> Array11Handler(F* function);
        template <typename O, typename M> Array11Handler(O* object, M method);
        template <typename O, typename M> Array11Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array11Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array11Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<char16_t const> a, array_view<char16_t> b, com_array<char16_t>& c) const;
    };
    struct Array12Handler : winrt::Windows::Foundation::IUnknown
    {
        Array12Handler(std::nullptr_t = nullptr) noexcept {}
        Array12Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array12Handler(L lambda);
        template <typename F> Array12Handler(F* function);
        template <typename O, typename M> Array12Handler(O* object, M method);
        template <typename O, typename M> Array12Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array12Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array12Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<hstring const> a, array_view<hstring> b, com_array<hstring>& c) const;
    };
    struct Array13Handler : winrt::Windows::Foundation::IUnknown
    {
        Array13Handler(std::nullptr_t = nullptr) noexcept {}
        Array13Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array13Handler(L lambda);
        template <typename F> Array13Handler(F* function);
        template <typename O, typename M> Array13Handler(O* object, M method);
        template <typename O, typename M> Array13Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array13Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array13Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<winrt::TestComponent::Blittable const> a, array_view<winrt::TestComponent::Blittable> b, com_array<winrt::TestComponent::Blittable>& c) const;
    };
    struct Array14Handler : winrt::Windows::Foundation::IUnknown
    {
        Array14Handler(std::nullptr_t = nullptr) noexcept {}
        Array14Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array14Handler(L lambda);
        template <typename F> Array14Handler(F* function);
        template <typename O, typename M> Array14Handler(O* object, M method);
        template <typename O, typename M> Array14Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array14Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array14Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<winrt::TestComponent::NonBlittable const> a, array_view<winrt::TestComponent::NonBlittable> b, com_array<winrt::TestComponent::NonBlittable>& c) const;
    };
    struct Array15Handler : winrt::Windows::Foundation::IUnknown
    {
        Array15Handler(std::nullptr_t = nullptr) noexcept {}
        Array15Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array15Handler(L lambda);
        template <typename F> Array15Handler(F* function);
        template <typename O, typename M> Array15Handler(O* object, M method);
        template <typename O, typename M> Array15Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array15Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array15Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<winrt::TestComponent::Nested const> a, array_view<winrt::TestComponent::Nested> b, com_array<winrt::TestComponent::Nested>& c) const;
    };
    struct Array16Handler : winrt::Windows::Foundation::IUnknown
    {
        Array16Handler(std::nullptr_t = nullptr) noexcept {}
        Array16Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array16Handler(L lambda);
        template <typename F> Array16Handler(F* function);
        template <typename O, typename M> Array16Handler(O* object, M method);
        template <typename O, typename M> Array16Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array16Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array16Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array16Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<winrt::Windows::Foundation::IStringable const> a, array_view<winrt::Windows::Foundation::IStringable> b, com_array<winrt::Windows::Foundation::IStringable>& c) const;
    };
    struct Array1Handler : winrt::Windows::Foundation::IUnknown
    {
        Array1Handler(std::nullptr_t = nullptr) noexcept {}
        Array1Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array1Handler(L lambda);
        template <typename F> Array1Handler(F* function);
        template <typename O, typename M> Array1Handler(O* object, M method);
        template <typename O, typename M> Array1Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array1Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array1Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<bool const> a, array_view<bool> b, com_array<bool>& c) const;
    };
    struct Array2Handler : winrt::Windows::Foundation::IUnknown
    {
        Array2Handler(std::nullptr_t = nullptr) noexcept {}
        Array2Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array2Handler(L lambda);
        template <typename F> Array2Handler(F* function);
        template <typename O, typename M> Array2Handler(O* object, M method);
        template <typename O, typename M> Array2Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array2Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array2Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<uint8_t const> a, array_view<uint8_t> b, com_array<uint8_t>& c) const;
    };
    struct Array3Handler : winrt::Windows::Foundation::IUnknown
    {
        Array3Handler(std::nullptr_t = nullptr) noexcept {}
        Array3Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array3Handler(L lambda);
        template <typename F> Array3Handler(F* function);
        template <typename O, typename M> Array3Handler(O* object, M method);
        template <typename O, typename M> Array3Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array3Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array3Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<uint16_t const> a, array_view<uint16_t> b, com_array<uint16_t>& c) const;
    };
    struct Array4Handler : winrt::Windows::Foundation::IUnknown
    {
        Array4Handler(std::nullptr_t = nullptr) noexcept {}
        Array4Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array4Handler(L lambda);
        template <typename F> Array4Handler(F* function);
        template <typename O, typename M> Array4Handler(O* object, M method);
        template <typename O, typename M> Array4Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array4Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array4Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<uint32_t const> a, array_view<uint32_t> b, com_array<uint32_t>& c) const;
    };
    struct Array5Handler : winrt::Windows::Foundation::IUnknown
    {
        Array5Handler(std::nullptr_t = nullptr) noexcept {}
        Array5Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array5Handler(L lambda);
        template <typename F> Array5Handler(F* function);
        template <typename O, typename M> Array5Handler(O* object, M method);
        template <typename O, typename M> Array5Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array5Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array5Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<uint64_t const> a, array_view<uint64_t> b, com_array<uint64_t>& c) const;
    };
    struct Array6Handler : winrt::Windows::Foundation::IUnknown
    {
        Array6Handler(std::nullptr_t = nullptr) noexcept {}
        Array6Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array6Handler(L lambda);
        template <typename F> Array6Handler(F* function);
        template <typename O, typename M> Array6Handler(O* object, M method);
        template <typename O, typename M> Array6Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array6Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array6Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<int16_t const> a, array_view<int16_t> b, com_array<int16_t>& c) const;
    };
    struct Array7Handler : winrt::Windows::Foundation::IUnknown
    {
        Array7Handler(std::nullptr_t = nullptr) noexcept {}
        Array7Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array7Handler(L lambda);
        template <typename F> Array7Handler(F* function);
        template <typename O, typename M> Array7Handler(O* object, M method);
        template <typename O, typename M> Array7Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array7Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array7Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<int32_t const> a, array_view<int32_t> b, com_array<int32_t>& c) const;
    };
    struct Array8Handler : winrt::Windows::Foundation::IUnknown
    {
        Array8Handler(std::nullptr_t = nullptr) noexcept {}
        Array8Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array8Handler(L lambda);
        template <typename F> Array8Handler(F* function);
        template <typename O, typename M> Array8Handler(O* object, M method);
        template <typename O, typename M> Array8Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array8Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array8Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<int64_t const> a, array_view<int64_t> b, com_array<int64_t>& c) const;
    };
    struct Array9Handler : winrt::Windows::Foundation::IUnknown
    {
        Array9Handler(std::nullptr_t = nullptr) noexcept {}
        Array9Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Array9Handler(L lambda);
        template <typename F> Array9Handler(F* function);
        template <typename O, typename M> Array9Handler(O* object, M method);
        template <typename O, typename M> Array9Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Array9Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Array9Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Array9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(array_view<float const> a, array_view<float> b, com_array<float>& c) const;
    };
    struct Async1Handler : winrt::Windows::Foundation::IUnknown
    {
        Async1Handler(std::nullptr_t = nullptr) noexcept {}
        Async1Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Async1Handler(L lambda);
        template <typename F> Async1Handler(F* function);
        template <typename O, typename M> Async1Handler(O* object, M method);
        template <typename O, typename M> Async1Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Async1Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Async1Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Async1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail) const;
    };
    struct Async2Handler : winrt::Windows::Foundation::IUnknown
    {
        Async2Handler(std::nullptr_t = nullptr) noexcept {}
        Async2Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Async2Handler(L lambda);
        template <typename F> Async2Handler(F* function);
        template <typename O, typename M> Async2Handler(O* object, M method);
        template <typename O, typename M> Async2Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Async2Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Async2Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Async2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t progress) const;
    };
    struct Async3Handler : winrt::Windows::Foundation::IUnknown
    {
        Async3Handler(std::nullptr_t = nullptr) noexcept {}
        Async3Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Async3Handler(L lambda);
        template <typename F> Async3Handler(F* function);
        template <typename O, typename M> Async3Handler(O* object, M method);
        template <typename O, typename M> Async3Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Async3Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Async3Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Async3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result) const;
    };
    struct Async4Handler : winrt::Windows::Foundation::IUnknown
    {
        Async4Handler(std::nullptr_t = nullptr) noexcept {}
        Async4Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Async4Handler(L lambda);
        template <typename F> Async4Handler(F* function);
        template <typename O, typename M> Async4Handler(O* object, M method);
        template <typename O, typename M> Async4Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Async4Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Async4Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Async4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::Windows::Foundation::IAsyncAction const& suspend, bool fail, int32_t result, int32_t progress) const;
    };
    struct Collection1Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection1Handler(std::nullptr_t = nullptr) noexcept {}
        Collection1Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection1Handler(L lambda);
        template <typename F> Collection1Handler(F* function);
        template <typename O, typename M> Collection1Handler(O* object, M method);
        template <typename O, typename M> Collection1Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection1Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection1Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::iterable<hstring> const& a, winrt::Windows::Foundation::Collections::IIterable<hstring>& b) const;
    };
    struct Collection2Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection2Handler(std::nullptr_t = nullptr) noexcept {}
        Collection2Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection2Handler(L lambda);
        template <typename F> Collection2Handler(F* function);
        template <typename O, typename M> Collection2Handler(O* object, M method);
        template <typename O, typename M> Collection2Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection2Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection2Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::iterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>> const& a, winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, hstring>>& b) const;
    };
    struct Collection3Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection3Handler(std::nullptr_t = nullptr) noexcept {}
        Collection3Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection3Handler(L lambda);
        template <typename F> Collection3Handler(F* function);
        template <typename O, typename M> Collection3Handler(O* object, M method);
        template <typename O, typename M> Collection3Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection3Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection3Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::map<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMap<hstring, hstring>& b) const;
    };
    struct Collection4Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection4Handler(std::nullptr_t = nullptr) noexcept {}
        Collection4Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection4Handler(L lambda);
        template <typename F> Collection4Handler(F* function);
        template <typename O, typename M> Collection4Handler(O* object, M method);
        template <typename O, typename M> Collection4Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection4Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection4Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::map_view<hstring, hstring> const& a, winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>& b) const;
    };
    struct Collection5Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection5Handler(std::nullptr_t = nullptr) noexcept {}
        Collection5Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection5Handler(L lambda);
        template <typename F> Collection5Handler(F* function);
        template <typename O, typename M> Collection5Handler(O* object, M method);
        template <typename O, typename M> Collection5Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection5Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection5Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::vector<hstring> const& a, winrt::Windows::Foundation::Collections::IVector<hstring>& b) const;
    };
    struct Collection6Handler : winrt::Windows::Foundation::IUnknown
    {
        Collection6Handler(std::nullptr_t = nullptr) noexcept {}
        Collection6Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Collection6Handler(L lambda);
        template <typename F> Collection6Handler(F* function);
        template <typename O, typename M> Collection6Handler(O* object, M method);
        template <typename O, typename M> Collection6Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection6Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Collection6Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Collection6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::vector_view<hstring> const& a, winrt::Windows::Foundation::Collections::IVectorView<hstring>& b) const;
    };
    struct Param10Handler : winrt::Windows::Foundation::IUnknown
    {
        Param10Handler(std::nullptr_t = nullptr) noexcept {}
        Param10Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param10Handler(L lambda);
        template <typename F> Param10Handler(F* function);
        template <typename O, typename M> Param10Handler(O* object, M method);
        template <typename O, typename M> Param10Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param10Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param10Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param10Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(double a, double& b) const;
    };
    struct Param11Handler : winrt::Windows::Foundation::IUnknown
    {
        Param11Handler(std::nullptr_t = nullptr) noexcept {}
        Param11Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param11Handler(L lambda);
        template <typename F> Param11Handler(F* function);
        template <typename O, typename M> Param11Handler(O* object, M method);
        template <typename O, typename M> Param11Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param11Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param11Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param11Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(char16_t a, char16_t& b) const;
    };
    struct Param12Handler : winrt::Windows::Foundation::IUnknown
    {
        Param12Handler(std::nullptr_t = nullptr) noexcept {}
        Param12Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param12Handler(L lambda);
        template <typename F> Param12Handler(F* function);
        template <typename O, typename M> Param12Handler(O* object, M method);
        template <typename O, typename M> Param12Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param12Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param12Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param12Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(param::hstring const& a, hstring& b) const;
    };
    struct Param13Handler : winrt::Windows::Foundation::IUnknown
    {
        Param13Handler(std::nullptr_t = nullptr) noexcept {}
        Param13Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param13Handler(L lambda);
        template <typename F> Param13Handler(F* function);
        template <typename O, typename M> Param13Handler(O* object, M method);
        template <typename O, typename M> Param13Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param13Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param13Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param13Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::TestComponent::Blittable const& a, winrt::TestComponent::Blittable const& b, winrt::TestComponent::Blittable& c) const;
    };
    struct Param14Handler : winrt::Windows::Foundation::IUnknown
    {
        Param14Handler(std::nullptr_t = nullptr) noexcept {}
        Param14Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param14Handler(L lambda);
        template <typename F> Param14Handler(F* function);
        template <typename O, typename M> Param14Handler(O* object, M method);
        template <typename O, typename M> Param14Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param14Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param14Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param14Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::TestComponent::NonBlittable const& a, winrt::TestComponent::NonBlittable const& b, winrt::TestComponent::NonBlittable& c) const;
    };
    struct Param15Handler : winrt::Windows::Foundation::IUnknown
    {
        Param15Handler(std::nullptr_t = nullptr) noexcept {}
        Param15Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param15Handler(L lambda);
        template <typename F> Param15Handler(F* function);
        template <typename O, typename M> Param15Handler(O* object, M method);
        template <typename O, typename M> Param15Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param15Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param15Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param15Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::TestComponent::Nested const& a, winrt::TestComponent::Nested const& b, winrt::TestComponent::Nested& c) const;
    };
    struct Param1Handler : winrt::Windows::Foundation::IUnknown
    {
        Param1Handler(std::nullptr_t = nullptr) noexcept {}
        Param1Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param1Handler(L lambda);
        template <typename F> Param1Handler(F* function);
        template <typename O, typename M> Param1Handler(O* object, M method);
        template <typename O, typename M> Param1Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param1Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param1Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param1Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(bool a, bool& b) const;
    };
    struct Param2Handler : winrt::Windows::Foundation::IUnknown
    {
        Param2Handler(std::nullptr_t = nullptr) noexcept {}
        Param2Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param2Handler(L lambda);
        template <typename F> Param2Handler(F* function);
        template <typename O, typename M> Param2Handler(O* object, M method);
        template <typename O, typename M> Param2Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param2Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param2Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param2Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(uint8_t a, uint8_t& b) const;
    };
    struct Param3Handler : winrt::Windows::Foundation::IUnknown
    {
        Param3Handler(std::nullptr_t = nullptr) noexcept {}
        Param3Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param3Handler(L lambda);
        template <typename F> Param3Handler(F* function);
        template <typename O, typename M> Param3Handler(O* object, M method);
        template <typename O, typename M> Param3Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param3Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param3Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param3Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(uint16_t a, uint16_t& b) const;
    };
    struct Param4Handler : winrt::Windows::Foundation::IUnknown
    {
        Param4Handler(std::nullptr_t = nullptr) noexcept {}
        Param4Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param4Handler(L lambda);
        template <typename F> Param4Handler(F* function);
        template <typename O, typename M> Param4Handler(O* object, M method);
        template <typename O, typename M> Param4Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param4Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param4Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param4Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(uint32_t a, uint32_t& b) const;
    };
    struct Param5Handler : winrt::Windows::Foundation::IUnknown
    {
        Param5Handler(std::nullptr_t = nullptr) noexcept {}
        Param5Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param5Handler(L lambda);
        template <typename F> Param5Handler(F* function);
        template <typename O, typename M> Param5Handler(O* object, M method);
        template <typename O, typename M> Param5Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param5Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param5Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param5Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(uint64_t a, uint64_t& b) const;
    };
    struct Param6Handler : winrt::Windows::Foundation::IUnknown
    {
        Param6Handler(std::nullptr_t = nullptr) noexcept {}
        Param6Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param6Handler(L lambda);
        template <typename F> Param6Handler(F* function);
        template <typename O, typename M> Param6Handler(O* object, M method);
        template <typename O, typename M> Param6Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param6Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param6Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param6Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(int16_t a, int16_t& b) const;
    };
    struct Param7Handler : winrt::Windows::Foundation::IUnknown
    {
        Param7Handler(std::nullptr_t = nullptr) noexcept {}
        Param7Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param7Handler(L lambda);
        template <typename F> Param7Handler(F* function);
        template <typename O, typename M> Param7Handler(O* object, M method);
        template <typename O, typename M> Param7Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param7Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param7Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param7Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(int32_t a, int32_t& b) const;
    };
    struct Param8Handler : winrt::Windows::Foundation::IUnknown
    {
        Param8Handler(std::nullptr_t = nullptr) noexcept {}
        Param8Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param8Handler(L lambda);
        template <typename F> Param8Handler(F* function);
        template <typename O, typename M> Param8Handler(O* object, M method);
        template <typename O, typename M> Param8Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param8Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param8Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param8Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(int64_t a, int64_t& b) const;
    };
    struct Param9Handler : winrt::Windows::Foundation::IUnknown
    {
        Param9Handler(std::nullptr_t = nullptr) noexcept {}
        Param9Handler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> Param9Handler(L lambda);
        template <typename F> Param9Handler(F* function);
        template <typename O, typename M> Param9Handler(O* object, M method);
        template <typename O, typename M> Param9Handler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> Param9Handler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> Param9Handler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> Param9Handler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(float a, float& b) const;
    };
    struct TestHandler : winrt::Windows::Foundation::IUnknown
    {
        TestHandler(std::nullptr_t = nullptr) noexcept {}
        TestHandler(void* ptr, take_ownership_from_abi_t) noexcept : winrt::Windows::Foundation::IUnknown(ptr, take_ownership_from_abi) {}
        template <typename L> TestHandler(L lambda);
        template <typename F> TestHandler(F* function);
        template <typename O, typename M> TestHandler(O* object, M method);
        template <typename O, typename M> TestHandler(com_ptr<O>&& object, M method);
        template <typename O, typename LM> TestHandler(weak_ref<O>&& object, LM&& lambda_or_method);
        template <typename O, typename M> TestHandler(std::shared_ptr<O>&& object, M method);
        template <typename O, typename LM> TestHandler(std::weak_ptr<O>&& object, LM&& lambda_or_method);
        auto operator()(winrt::TestComponent::ITests const& tests) const;
    };
    struct Blittable
    {
        uint8_t A;
        uint16_t B;
        uint32_t C;
        uint64_t D;
        int16_t E;
        int32_t F;
        int64_t G;
        float H;
        double I;
        winrt::guid J;
    };
    inline bool operator==(Blittable const& left, Blittable const& right) noexcept
    {
        return left.A == right.A && left.B == right.B && left.C == right.C && left.D == right.D && left.E == right.E && left.F == right.F && left.G == right.G && left.H == right.H && left.I == right.I && left.J == right.J;
    }
    inline bool operator!=(Blittable const& left, Blittable const& right) noexcept
    {
        return !(left == right);
    }
    struct NonBlittable
    {
        bool A;
        char16_t B;
        hstring C;
        winrt::Windows::Foundation::IReference<int64_t> D;
    };
    inline bool operator==(NonBlittable const& left, NonBlittable const& right) noexcept
    {
        return left.A == right.A && left.B == right.B && left.C == right.C && left.D == right.D;
    }
    inline bool operator!=(NonBlittable const& left, NonBlittable const& right) noexcept
    {
        return !(left == right);
    }
    struct Nested
    {
        winrt::TestComponent::Blittable Blittable;
        winrt::TestComponent::NonBlittable NonBlittable;
    };
    inline bool operator==(Nested const& left, Nested const& right) noexcept
    {
        return left.Blittable == right.Blittable && left.NonBlittable == right.NonBlittable;
    }
    inline bool operator!=(Nested const& left, Nested const& right) noexcept
    {
        return !(left == right);
    }
    struct WINRT_IMPL_EMPTY_BASES Class : winrt::TestComponent::IClass,
        impl::require<Class, winrt::TestComponent::IRequiredOne>
    {
        Class(std::nullptr_t) noexcept {}
        Class(void* ptr, take_ownership_from_abi_t) noexcept : winrt::TestComponent::IClass(ptr, take_ownership_from_abi) {}
        Class();
    };
    struct WINRT_IMPL_EMPTY_BASES Composable : winrt::TestComponent::IComposable,
        impl::require<Composable, winrt::TestComponent::IRequiredOne, winrt::TestComponent::IRequiredTwo, winrt::TestComponent::IRequiredThree, winrt::TestComponent::IRequiredFour>
    {
        Composable(std::nullptr_t) noexcept {}
        Composable(void* ptr, take_ownership_from_abi_t) noexcept : winrt::TestComponent::IComposable(ptr, take_ownership_from_abi) {}
        Composable();
        explicit Composable(int32_t init);
        static auto ExpectComposable(winrt::TestComponent::Composable const& t);
        static auto ExpectRequiredOne(winrt::TestComponent::IRequiredOne const& t);
        static auto ExpectRequiredTwo(winrt::TestComponent::IRequiredTwo const& t);
        static auto ExpectRequiredThree(winrt::TestComponent::IRequiredThree const& t);
        static auto ExpectRequiredFour(winrt::TestComponent::IRequiredFour const& t);
    };
    struct WINRT_IMPL_EMPTY_BASES Derived : winrt::TestComponent::IDerived,
        impl::base<Derived, winrt::TestComponent::Composable>,
        impl::require<Derived, winrt::TestComponent::IComposable, winrt::TestComponent::IRequiredOne, winrt::TestComponent::IRequiredTwo, winrt::TestComponent::IRequiredThree, winrt::TestComponent::IRequiredFour>
    {
        Derived(std::nullptr_t) noexcept {}
        Derived(void* ptr, take_ownership_from_abi_t) noexcept : winrt::TestComponent::IDerived(ptr, take_ownership_from_abi) {}
        Derived();
    };
    struct WINRT_IMPL_EMPTY_BASES OverloadClass : winrt::TestComponent::IOverloadClass
    {
        OverloadClass(std::nullptr_t) noexcept {}
        OverloadClass(void* ptr, take_ownership_from_abi_t) noexcept : winrt::TestComponent::IOverloadClass(ptr, take_ownership_from_abi) {}
        OverloadClass();
    };
    struct WINRT_IMPL_EMPTY_BASES Override : winrt::TestComponent::IOverride
    {
        Override(std::nullptr_t) noexcept {}
        Override(void* ptr, take_ownership_from_abi_t) noexcept : winrt::TestComponent::IOverride(ptr, take_ownership_from_abi) {}
        Override();
    };
    struct TestRunner
    {
        TestRunner() = delete;
        static auto TestProducer(winrt::TestComponent::ITests const& callee);
        static auto TestConsumer(winrt::TestComponent::TestHandler const& caller);
        static auto TestSelf();
        static auto MakeTests();
        static auto CreateInt32Vector();
        static auto CreateStringVector();
        static auto CreateStringableVector();
        static auto CreateTimeSpan(uint32_t milliseconds);
        static auto CreateAsyncAction(uint32_t milliseconds);
        static auto CreateAsyncActionWithError(uint32_t milliseconds, int32_t error);
        static auto CreateAsyncOperation(uint32_t milliseconds, int32_t result);
        static auto CreateAsyncOperationWithError(uint32_t milliseconds, int32_t result, int32_t error);
        static auto CreateAsyncActionWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items);
        static auto CreateAsyncActionWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t error);
        static auto CreateAsyncOperationWithProgress(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result);
        static auto CreateAsyncOperationWithProgressWithError(uint32_t milliseconds, param::async_vector_view<int32_t> const& items, int32_t result, int32_t error);
        static auto ExpectObject(winrt::Windows::Foundation::IInspectable const& value);
    };
    template <typename D>
    class IOverloadClassOverridesT
    {
        D& shim() noexcept { return *static_cast<D*>(this); }
        D const& shim() const noexcept { return *static_cast<const D*>(this); }
    public:
        using IOverloadClassOverrides = winrt::TestComponent::IOverloadClassOverrides;
        auto Overload(int32_t a) const;
    };
    template <typename D>
    class IOverloadClassOverrides2T
    {
        D& shim() noexcept { return *static_cast<D*>(this); }
        D const& shim() const noexcept { return *static_cast<const D*>(this); }
    public:
        using IOverloadClassOverrides2 = winrt::TestComponent::IOverloadClassOverrides2;
        auto Overload(int32_t a, int32_t b) const;
    };
    template <typename D>
    class IOverrideOverridesT
    {
        D& shim() noexcept { return *static_cast<D*>(this); }
        D const& shim() const noexcept { return *static_cast<const D*>(this); }
    public:
        using IOverrideOverrides = winrt::TestComponent::IOverrideOverrides;
        auto OnOverridable() const;
    };
}
#endif
