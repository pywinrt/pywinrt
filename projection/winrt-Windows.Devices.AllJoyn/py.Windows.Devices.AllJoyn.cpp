// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.AllJoyn.h"


namespace py::cpp::Windows::Devices::AllJoyn
{
    // ----- AllJoynAboutData class --------------------

    static PyObject* _new_AllJoynAboutData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynAboutData(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAboutData_get_DefaultDescription(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultDescription(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DefaultAppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultAppName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultAppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultAppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultAppName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultAppName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DateOfManufacture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateOfManufacture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DateOfManufacture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.DateOfManufacture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DefaultManufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultManufacturer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultManufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultManufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultManufacturer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultManufacturer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.AppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SupportUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SupportUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.SupportUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SoftwareVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SoftwareVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SoftwareVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"ModelNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"ModelNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_IsEnabled(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_IsEnabled(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_AppNames(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppNames"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutData_get_Manufacturers(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"Manufacturers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Manufacturers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutData_get_Descriptions(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"Descriptions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Descriptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAboutData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAboutData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAboutData[] = {
        { "_assign_array_", _assign_array_AllJoynAboutData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAboutData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAboutData[] = {
        { "default_description", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultDescription), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultDescription), nullptr, nullptr },
        { "default_app_name", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultAppName), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultAppName), nullptr, nullptr },
        { "date_of_manufacture", reinterpret_cast<getter>(AllJoynAboutData_get_DateOfManufacture), reinterpret_cast<setter>(AllJoynAboutData_put_DateOfManufacture), nullptr, nullptr },
        { "default_manufacturer", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultManufacturer), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultManufacturer), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AllJoynAboutData_get_AppId), reinterpret_cast<setter>(AllJoynAboutData_put_AppId), nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(AllJoynAboutData_get_SupportUrl), reinterpret_cast<setter>(AllJoynAboutData_put_SupportUrl), nullptr, nullptr },
        { "software_version", reinterpret_cast<getter>(AllJoynAboutData_get_SoftwareVersion), reinterpret_cast<setter>(AllJoynAboutData_put_SoftwareVersion), nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(AllJoynAboutData_get_ModelNumber), reinterpret_cast<setter>(AllJoynAboutData_put_ModelNumber), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(AllJoynAboutData_get_IsEnabled), reinterpret_cast<setter>(AllJoynAboutData_put_IsEnabled), nullptr, nullptr },
        { "app_names", reinterpret_cast<getter>(AllJoynAboutData_get_AppNames), nullptr, nullptr, nullptr },
        { "manufacturers", reinterpret_cast<getter>(AllJoynAboutData_get_Manufacturers), nullptr, nullptr, nullptr },
        { "descriptions", reinterpret_cast<getter>(AllJoynAboutData_get_Descriptions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAboutData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAboutData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAboutData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAboutData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAboutData) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAboutData = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynAboutData",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAboutData};

    // ----- AllJoynAboutDataView class --------------------

    static PyObject* _new_AllJoynAboutDataView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynAboutDataView(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAboutDataView_GetDataBySessionPortAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"GetDataBySessionPortAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView::GetDataBySessionPortAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"GetDataBySessionPortAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Globalization::Language>(args, 3);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView::GetDataBySessionPortAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AJSoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AJSoftwareVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AJSoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AppId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AppName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DateOfManufacture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateOfManufacture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DefaultLanguage(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DefaultLanguage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Description(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DeviceId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DeviceName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DeviceName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_HardwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"HardwareVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Manufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Manufacturer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"ModelNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Properties(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SoftwareVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SupportUrl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SupportedLanguages(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SupportedLanguages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAboutDataView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAboutDataView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAboutDataView[] = {
        { "_assign_array_", _assign_array_AllJoynAboutDataView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAboutDataView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAboutDataView[] = {
        { "a_j_software_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_AJSoftwareVersion), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AllJoynAboutDataView_get_AppId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(AllJoynAboutDataView_get_AppName), nullptr, nullptr, nullptr },
        { "date_of_manufacture", reinterpret_cast<getter>(AllJoynAboutDataView_get_DateOfManufacture), nullptr, nullptr, nullptr },
        { "default_language", reinterpret_cast<getter>(AllJoynAboutDataView_get_DefaultLanguage), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(AllJoynAboutDataView_get_Description), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(AllJoynAboutDataView_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_name", reinterpret_cast<getter>(AllJoynAboutDataView_get_DeviceName), nullptr, nullptr, nullptr },
        { "hardware_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_HardwareVersion), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(AllJoynAboutDataView_get_Manufacturer), nullptr, nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(AllJoynAboutDataView_get_ModelNumber), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AllJoynAboutDataView_get_Properties), nullptr, nullptr, nullptr },
        { "software_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_SoftwareVersion), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynAboutDataView_get_Status), nullptr, nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(AllJoynAboutDataView_get_SupportUrl), nullptr, nullptr, nullptr },
        { "supported_languages", reinterpret_cast<getter>(AllJoynAboutDataView_get_SupportedLanguages), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAboutDataView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAboutDataView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAboutDataView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAboutDataView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAboutDataView) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAboutDataView = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynAboutDataView",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAboutDataView};

    static PyGetSetDef getset_AllJoynAboutDataView_Static[] = {
        { }
    };

    static PyMethodDef methods_AllJoynAboutDataView_Static[] = {
        { "get_data_by_session_port_async", reinterpret_cast<PyCFunction>(AllJoynAboutDataView_GetDataBySessionPortAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AllJoynAboutDataView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynAboutDataView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AllJoynAboutDataView_Static) },
        { }
    };

    static PyType_Spec type_spec_AllJoynAboutDataView_Static =
    {
        "winrt._winrt_windows_devices_alljoyn.AllJoynAboutDataView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynAboutDataView_Static
    };

    // ----- AllJoynAcceptSessionJoinerEventArgs class --------------------

    static PyObject* _new_AllJoynAcceptSessionJoinerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynTrafficType>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>(args, 4);

                winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynAcceptSessionJoinerEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_Accept(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"Accept", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SameNetwork(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SameNetwork"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SameNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SamePhysicalNode(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SamePhysicalNode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SamePhysicalNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SessionPort(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SessionPort"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_TrafficType(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"TrafficType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAcceptSessionJoinerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAcceptSessionJoinerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAcceptSessionJoinerEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(AllJoynAcceptSessionJoinerEventArgs_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynAcceptSessionJoinerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAcceptSessionJoinerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAcceptSessionJoinerEventArgs[] = {
        { "same_network", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SameNetwork), nullptr, nullptr, nullptr },
        { "same_physical_node", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SamePhysicalNode), nullptr, nullptr, nullptr },
        { "session_port", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SessionPort), nullptr, nullptr, nullptr },
        { "traffic_type", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_TrafficType), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAcceptSessionJoinerEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAcceptSessionJoinerEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAcceptSessionJoinerEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynAcceptSessionJoinerEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAcceptSessionJoinerEventArgs};

    // ----- AllJoynAuthenticationCompleteEventArgs class --------------------

    static PyObject* _new_AllJoynAuthenticationCompleteEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynAuthenticationCompleteEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"AuthenticationMechanism"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"PeerUniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_Succeeded(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"Succeeded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAuthenticationCompleteEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAuthenticationCompleteEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAuthenticationCompleteEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynAuthenticationCompleteEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAuthenticationCompleteEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAuthenticationCompleteEventArgs[] = {
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAuthenticationCompleteEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAuthenticationCompleteEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAuthenticationCompleteEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynAuthenticationCompleteEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAuthenticationCompleteEventArgs};

    // ----- AllJoynBusAttachment class --------------------

    static PyObject* _new_AllJoynBusAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusAttachment(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusAttachment_Connect(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"Connect", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Connect();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_Disconnect(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"Disconnect", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Disconnect();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetAboutDataAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetAboutDataAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);

                return py::convert(self->obj.GetAboutDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetAboutDataAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                return py::convert(self->obj.GetAboutDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetDefault", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetWatcher", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment::GetWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_PingAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"PingAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.PingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_AboutData(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AboutData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AboutData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_AuthenticationMechanisms(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationMechanisms"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationMechanisms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_ConnectionSpecification(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"ConnectionSpecification"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionSpecification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_State(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_AuthenticationComplete(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationComplete(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_AuthenticationComplete(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationComplete"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationComplete(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_CredentialsRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>>(arg);

            return py::convert(self->obj.CredentialsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_CredentialsRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CredentialsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_CredentialsVerificationRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsVerificationRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>>(arg);

            return py::convert(self->obj.CredentialsVerificationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_CredentialsVerificationRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsVerificationRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CredentialsVerificationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_StateChanged(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_StateChanged(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"StateChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_AcceptSessionJoinerRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AcceptSessionJoinerRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>>(arg);

            return py::convert(self->obj.AcceptSessionJoinerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_AcceptSessionJoinerRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AcceptSessionJoinerRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceptSessionJoinerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_SessionJoined(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"SessionJoined"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>>(arg);

            return py::convert(self->obj.SessionJoined(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_SessionJoined(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"SessionJoined"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionJoined(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusAttachment[] = {
        { "connect", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_Connect), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_Disconnect), METH_VARARGS, nullptr },
        { "get_about_data_async", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetAboutDataAsync), METH_VARARGS, nullptr },
        { "ping_async", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_PingAsync), METH_VARARGS, nullptr },
        { "add_authentication_complete", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_AuthenticationComplete), METH_O, nullptr },
        { "remove_authentication_complete", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_AuthenticationComplete), METH_O, nullptr },
        { "add_credentials_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_CredentialsRequested), METH_O, nullptr },
        { "remove_credentials_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_CredentialsRequested), METH_O, nullptr },
        { "add_credentials_verification_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_CredentialsVerificationRequested), METH_O, nullptr },
        { "remove_credentials_verification_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_CredentialsVerificationRequested), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_StateChanged), METH_O, nullptr },
        { "add_accept_session_joiner_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_AcceptSessionJoinerRequested), METH_O, nullptr },
        { "remove_accept_session_joiner_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_AcceptSessionJoinerRequested), METH_O, nullptr },
        { "add_session_joined", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_SessionJoined), METH_O, nullptr },
        { "remove_session_joined", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_SessionJoined), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynBusAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusAttachment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusAttachment[] = {
        { "about_data", reinterpret_cast<getter>(AllJoynBusAttachment_get_AboutData), nullptr, nullptr, nullptr },
        { "authentication_mechanisms", reinterpret_cast<getter>(AllJoynBusAttachment_get_AuthenticationMechanisms), nullptr, nullptr, nullptr },
        { "connection_specification", reinterpret_cast<getter>(AllJoynBusAttachment_get_ConnectionSpecification), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AllJoynBusAttachment_get_State), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynBusAttachment_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusAttachment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusAttachment) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusAttachment = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynBusAttachment",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusAttachment};

    static PyGetSetDef getset_AllJoynBusAttachment_Static[] = {
        { }
    };

    static PyMethodDef methods_AllJoynBusAttachment_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetDefault), METH_VARARGS, nullptr },
        { "get_watcher", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetWatcher), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AllJoynBusAttachment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynBusAttachment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AllJoynBusAttachment_Static) },
        { }
    };

    static PyType_Spec type_spec_AllJoynBusAttachment_Static =
    {
        "winrt._winrt_windows_devices_alljoyn.AllJoynBusAttachment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynBusAttachment_Static
    };

    // ----- AllJoynBusAttachmentStateChangedEventArgs class --------------------

    static PyObject* _new_AllJoynBusAttachmentStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynBusAttachmentStateChangedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusAttachmentStateChangedEventArgs_get_State(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachmentStateChangedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusAttachmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusAttachmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusAttachmentStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynBusAttachmentStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusAttachmentStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusAttachmentStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(AllJoynBusAttachmentStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynBusAttachmentStateChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusAttachmentStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusAttachmentStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusAttachmentStateChangedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynBusAttachmentStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusAttachmentStateChangedEventArgs};

    // ----- AllJoynBusObject class --------------------

    static PyObject* _new_AllJoynBusObject(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusObject(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusObject_AddProducer(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"AddProducer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>(args, 0);

                self->obj.AddProducer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_Start(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Start", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_Stop(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_get_BusAttachment(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"BusAttachment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BusAttachment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_get_Session(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_add_Stopped(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusObject, winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_remove_Stopped(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stopped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusObject[] = {
        { "add_producer", reinterpret_cast<PyCFunction>(AllJoynBusObject_AddProducer), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AllJoynBusObject_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AllJoynBusObject_Stop), METH_VARARGS, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AllJoynBusObject_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AllJoynBusObject_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynBusObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusObject), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusObject[] = {
        { "bus_attachment", reinterpret_cast<getter>(AllJoynBusObject_get_BusAttachment), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(AllJoynBusObject_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusObject[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusObject) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusObject = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynBusObject",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusObject};

    // ----- AllJoynBusObjectStoppedEventArgs class --------------------

    static PyObject* _new_AllJoynBusObjectStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusObjectStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusObjectStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObjectStoppedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusObjectStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusObjectStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusObjectStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynBusObjectStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusObjectStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusObjectStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynBusObjectStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusObjectStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusObjectStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusObjectStoppedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynBusObjectStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusObjectStoppedEventArgs};

    // ----- AllJoynCredentials class --------------------

    static PyObject* _new_AllJoynCredentials(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentials(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentials_get_Timeout(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Timeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Timeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_Timeout(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Timeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Timeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_PasswordCredential(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"PasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_PasswordCredential(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"PasswordCredential"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.PasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_Certificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Certificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_Certificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Certificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"AuthenticationMechanism"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentials[] = {
        { "_assign_array_", _assign_array_AllJoynCredentials, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentials), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentials[] = {
        { "timeout", reinterpret_cast<getter>(AllJoynCredentials_get_Timeout), reinterpret_cast<setter>(AllJoynCredentials_put_Timeout), nullptr, nullptr },
        { "password_credential", reinterpret_cast<getter>(AllJoynCredentials_get_PasswordCredential), reinterpret_cast<setter>(AllJoynCredentials_put_PasswordCredential), nullptr, nullptr },
        { "certificate", reinterpret_cast<getter>(AllJoynCredentials_get_Certificate), reinterpret_cast<setter>(AllJoynCredentials_put_Certificate), nullptr, nullptr },
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynCredentials_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentials[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentials) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentials) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentials) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentials) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentials = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynCredentials",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentials};

    // ----- AllJoynCredentialsRequestedEventArgs class --------------------

    static PyObject* _new_AllJoynCredentialsRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentialsRequestedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_AttemptCount(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"AttemptCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_Credentials(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"Credentials"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Credentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"PeerUniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_RequestedUserName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"RequestedUserName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentialsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentialsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentialsRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(AllJoynCredentialsRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynCredentialsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentialsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentialsRequestedEventArgs[] = {
        { "attempt_count", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_AttemptCount), nullptr, nullptr, nullptr },
        { "credentials", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_Credentials), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { "requested_user_name", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_RequestedUserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentialsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentialsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentialsRequestedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynCredentialsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentialsRequestedEventArgs};

    // ----- AllJoynCredentialsVerificationRequestedEventArgs class --------------------

    static PyObject* _new_AllJoynCredentialsVerificationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentialsVerificationRequestedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_Accept(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"Accept", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"AuthenticationMechanism"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrorSeverity(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificateErrorSeverity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrors(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificateErrors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerIntermediateCertificates(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerIntermediateCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerUniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentialsVerificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentialsVerificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentialsVerificationRequestedEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(AllJoynCredentialsVerificationRequestedEventArgs_Accept), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(AllJoynCredentialsVerificationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynCredentialsVerificationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentialsVerificationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentialsVerificationRequestedEventArgs[] = {
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { "peer_certificate", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificate), nullptr, nullptr, nullptr },
        { "peer_certificate_error_severity", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "peer_certificate_errors", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrors), nullptr, nullptr, nullptr },
        { "peer_intermediate_certificates", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerIntermediateCertificates), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentialsVerificationRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentialsVerificationRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentialsVerificationRequestedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynCredentialsVerificationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentialsVerificationRequestedEventArgs};

    // ----- AllJoynMessageInfo class --------------------

    static PyObject* _new_AllJoynMessageInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynMessageInfo(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynMessageInfo_get_SenderUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynMessageInfo", L"SenderUniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SenderUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynMessageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynMessageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynMessageInfo[] = {
        { "_assign_array_", _assign_array_AllJoynMessageInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynMessageInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynMessageInfo[] = {
        { "sender_unique_name", reinterpret_cast<getter>(AllJoynMessageInfo_get_SenderUniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynMessageInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynMessageInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynMessageInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynMessageInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynMessageInfo) },
        { },
    };

    static PyType_Spec type_spec_AllJoynMessageInfo = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynMessageInfo",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynMessageInfo};

    // ----- AllJoynProducerStoppedEventArgs class --------------------

    static PyObject* _new_AllJoynProducerStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynProducerStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynProducerStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynProducerStoppedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynProducerStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynProducerStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynProducerStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynProducerStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynProducerStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynProducerStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynProducerStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynProducerStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynProducerStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynProducerStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynProducerStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynProducerStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynProducerStoppedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynProducerStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynProducerStoppedEventArgs};

    // ----- AllJoynServiceInfo class --------------------

    static PyObject* _new_AllJoynServiceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynServiceInfo(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynServiceInfo_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_ObjectPath(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"ObjectPath"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ObjectPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_SessionPort(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"SessionPort"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynServiceInfo[] = {
        { "_assign_array_", _assign_array_AllJoynServiceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynServiceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynServiceInfo[] = {
        { "object_path", reinterpret_cast<getter>(AllJoynServiceInfo_get_ObjectPath), nullptr, nullptr, nullptr },
        { "session_port", reinterpret_cast<getter>(AllJoynServiceInfo_get_SessionPort), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynServiceInfo_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynServiceInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynServiceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynServiceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynServiceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynServiceInfo) },
        { },
    };

    static PyType_Spec type_spec_AllJoynServiceInfo = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynServiceInfo",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynServiceInfo};

    static PyGetSetDef getset_AllJoynServiceInfo_Static[] = {
        { }
    };

    static PyMethodDef methods_AllJoynServiceInfo_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(AllJoynServiceInfo_FromIdAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AllJoynServiceInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynServiceInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AllJoynServiceInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_AllJoynServiceInfo_Static =
    {
        "winrt._winrt_windows_devices_alljoyn.AllJoynServiceInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynServiceInfo_Static
    };

    // ----- AllJoynServiceInfoRemovedEventArgs class --------------------

    static PyObject* _new_AllJoynServiceInfoRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynServiceInfoRemovedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynServiceInfoRemovedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfoRemovedEventArgs", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynServiceInfoRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynServiceInfoRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynServiceInfoRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynServiceInfoRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynServiceInfoRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynServiceInfoRemovedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynServiceInfoRemovedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynServiceInfoRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynServiceInfoRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynServiceInfoRemovedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynServiceInfoRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynServiceInfoRemovedEventArgs};

    // ----- AllJoynSession class --------------------

    static PyObject* _new_AllJoynSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynSession>::type_name);
        return nullptr;
    }

    static void _dealloc_AllJoynSession(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSession_GetFromServiceInfoAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"GetFromServiceInfoAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynSession::GetFromServiceInfoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"GetFromServiceInfoAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynSession::GetFromServiceInfoAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_RemoveMemberAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"RemoveMemberAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemoveMemberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_get_Id(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_Lost(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Lost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>>(arg);

            return py::convert(self->obj.Lost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_Lost(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Lost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Lost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_MemberAdded(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>>(arg);

            return py::convert(self->obj.MemberAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_MemberAdded(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberAdded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MemberAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_MemberRemoved(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>>(arg);

            return py::convert(self->obj.MemberRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_MemberRemoved(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MemberRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSession[] = {
        { "remove_member_async", reinterpret_cast<PyCFunction>(AllJoynSession_RemoveMemberAsync), METH_VARARGS, nullptr },
        { "add_lost", reinterpret_cast<PyCFunction>(AllJoynSession_add_Lost), METH_O, nullptr },
        { "remove_lost", reinterpret_cast<PyCFunction>(AllJoynSession_remove_Lost), METH_O, nullptr },
        { "add_member_added", reinterpret_cast<PyCFunction>(AllJoynSession_add_MemberAdded), METH_O, nullptr },
        { "remove_member_added", reinterpret_cast<PyCFunction>(AllJoynSession_remove_MemberAdded), METH_O, nullptr },
        { "add_member_removed", reinterpret_cast<PyCFunction>(AllJoynSession_add_MemberRemoved), METH_O, nullptr },
        { "remove_member_removed", reinterpret_cast<PyCFunction>(AllJoynSession_remove_MemberRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSession[] = {
        { "id", reinterpret_cast<getter>(AllJoynSession_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynSession_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSession) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSession = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSession",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSession};

    static PyGetSetDef getset_AllJoynSession_Static[] = {
        { }
    };

    static PyMethodDef methods_AllJoynSession_Static[] = {
        { "get_from_service_info_async", reinterpret_cast<PyCFunction>(AllJoynSession_GetFromServiceInfoAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AllJoynSession_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynSession_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AllJoynSession_Static) },
        { }
    };

    static PyType_Spec type_spec_AllJoynSession_Static =
    {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSession_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynSession_Static
    };

    // ----- AllJoynSessionJoinedEventArgs class --------------------

    static PyObject* _new_AllJoynSessionJoinedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynSession>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionJoinedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionJoinedEventArgs_get_Session(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionJoinedEventArgs", L"Session"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionJoinedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionJoinedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionJoinedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionJoinedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionJoinedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionJoinedEventArgs[] = {
        { "session", reinterpret_cast<getter>(AllJoynSessionJoinedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionJoinedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionJoinedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionJoinedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionJoinedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionJoinedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionJoinedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSessionJoinedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionJoinedEventArgs};

    // ----- AllJoynSessionLostEventArgs class --------------------

    static PyObject* _new_AllJoynSessionLostEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostReason>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionLostEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionLostEventArgs_get_Reason(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionLostEventArgs", L"Reason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionLostEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionLostEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionLostEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionLostEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionLostEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionLostEventArgs[] = {
        { "reason", reinterpret_cast<getter>(AllJoynSessionLostEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionLostEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionLostEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionLostEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionLostEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionLostEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionLostEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSessionLostEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionLostEventArgs};

    // ----- AllJoynSessionMemberAddedEventArgs class --------------------

    static PyObject* _new_AllJoynSessionMemberAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionMemberAddedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionMemberAddedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionMemberAddedEventArgs", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionMemberAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionMemberAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionMemberAddedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionMemberAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionMemberAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionMemberAddedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynSessionMemberAddedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionMemberAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionMemberAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionMemberAddedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSessionMemberAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionMemberAddedEventArgs};

    // ----- AllJoynSessionMemberRemovedEventArgs class --------------------

    static PyObject* _new_AllJoynSessionMemberRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionMemberRemovedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionMemberRemovedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionMemberRemovedEventArgs", L"UniqueName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionMemberRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionMemberRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionMemberRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionMemberRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionMemberRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionMemberRemovedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynSessionMemberRemovedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionMemberRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionMemberRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionMemberRemovedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynSessionMemberRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionMemberRemovedEventArgs};

    // ----- AllJoynStatus class --------------------

    static PyObject* _new_AllJoynStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::AllJoynStatus>::type_name);
        return nullptr;
    }

    static PyObject* AllJoynStatus_get_AuthenticationFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"AuthenticationFailed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::AuthenticationFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_AuthenticationRejectedByUser(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"AuthenticationRejectedByUser"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::AuthenticationRejectedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_ConnectionRefused(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"ConnectionRefused"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::ConnectionRefused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_Fail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"Fail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::Fail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InsufficientSecurity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InsufficientSecurity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InsufficientSecurity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument4"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument6(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument6"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument6());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument7"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_Ok(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"Ok"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::Ok());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_OperationTimedOut(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"OperationTimedOut"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::OperationTimedOut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_OtherEndClosed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"OtherEndClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::OtherEndClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_SslConnectFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"SslConnectFailed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::SslConnectFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_SslIdentityVerificationFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"SslIdentityVerificationFailed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::SslIdentityVerificationFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynStatus[] = {
        { }
    };

    static PyGetSetDef _getset_AllJoynStatus[] = {
        { }
    };

    static PyType_Slot _type_slots_AllJoynStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynStatus) },
        { },
    };

    static PyType_Spec type_spec_AllJoynStatus = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynStatus",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynStatus};

    static PyGetSetDef getset_AllJoynStatus_Static[] = {
        { "authentication_failed", reinterpret_cast<getter>(AllJoynStatus_get_AuthenticationFailed), nullptr, nullptr, nullptr },
        { "authentication_rejected_by_user", reinterpret_cast<getter>(AllJoynStatus_get_AuthenticationRejectedByUser), nullptr, nullptr, nullptr },
        { "connection_refused", reinterpret_cast<getter>(AllJoynStatus_get_ConnectionRefused), nullptr, nullptr, nullptr },
        { "fail", reinterpret_cast<getter>(AllJoynStatus_get_Fail), nullptr, nullptr, nullptr },
        { "insufficient_security", reinterpret_cast<getter>(AllJoynStatus_get_InsufficientSecurity), nullptr, nullptr, nullptr },
        { "invalid_argument1", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument1), nullptr, nullptr, nullptr },
        { "invalid_argument2", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument2), nullptr, nullptr, nullptr },
        { "invalid_argument3", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument3), nullptr, nullptr, nullptr },
        { "invalid_argument4", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument4), nullptr, nullptr, nullptr },
        { "invalid_argument5", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument5), nullptr, nullptr, nullptr },
        { "invalid_argument6", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument6), nullptr, nullptr, nullptr },
        { "invalid_argument7", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument7), nullptr, nullptr, nullptr },
        { "invalid_argument8", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument8), nullptr, nullptr, nullptr },
        { "ok", reinterpret_cast<getter>(AllJoynStatus_get_Ok), nullptr, nullptr, nullptr },
        { "operation_timed_out", reinterpret_cast<getter>(AllJoynStatus_get_OperationTimedOut), nullptr, nullptr, nullptr },
        { "other_end_closed", reinterpret_cast<getter>(AllJoynStatus_get_OtherEndClosed), nullptr, nullptr, nullptr },
        { "ssl_connect_failed", reinterpret_cast<getter>(AllJoynStatus_get_SslConnectFailed), nullptr, nullptr, nullptr },
        { "ssl_identity_verification_failed", reinterpret_cast<getter>(AllJoynStatus_get_SslIdentityVerificationFailed), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AllJoynStatus_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AllJoynStatus_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynStatus_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AllJoynStatus_Static) },
        { }
    };

    static PyType_Spec type_spec_AllJoynStatus_Static =
    {
        "winrt._winrt_windows_devices_alljoyn.AllJoynStatus_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynStatus_Static
    };

    // ----- AllJoynWatcherStoppedEventArgs class --------------------

    static PyObject* _new_AllJoynWatcherStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynWatcherStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynWatcherStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynWatcherStoppedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynWatcherStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynWatcherStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynWatcherStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynWatcherStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynWatcherStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynWatcherStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynWatcherStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynWatcherStoppedEventArgs = {
        "winrt._winrt_windows_devices_alljoyn.AllJoynWatcherStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynWatcherStoppedEventArgs};

    // ----- IAllJoynAcceptSessionJoiner interface --------------------

    static PyObject* _new_IAllJoynAcceptSessionJoiner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>::type_name);
        return nullptr;
    }

    static void _dealloc_IAllJoynAcceptSessionJoiner(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAllJoynAcceptSessionJoiner_Accept(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner", L"Accept", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAllJoynAcceptSessionJoiner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAllJoynAcceptSessionJoiner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAllJoynAcceptSessionJoiner[] = {
        { "accept", reinterpret_cast<PyCFunction>(IAllJoynAcceptSessionJoiner_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAllJoynAcceptSessionJoiner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAllJoynAcceptSessionJoiner), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAllJoynAcceptSessionJoiner[] = {
        { }
    };

    static PyType_Slot _type_slots_IAllJoynAcceptSessionJoiner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAllJoynAcceptSessionJoiner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAllJoynAcceptSessionJoiner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAllJoynAcceptSessionJoiner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAllJoynAcceptSessionJoiner) },
        { },
    };

    static PyType_Spec type_spec_IAllJoynAcceptSessionJoiner = {
        "winrt._winrt_windows_devices_alljoyn.IAllJoynAcceptSessionJoiner",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAllJoynAcceptSessionJoiner};

    // ----- IAllJoynProducer interface --------------------

    static PyObject* _new_IAllJoynProducer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>::type_name);
        return nullptr;
    }

    static void _dealloc_IAllJoynProducer(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAllJoynProducer_SetBusObject(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.IAllJoynProducer", L"SetBusObject", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>(args, 0);

                self->obj.SetBusObject(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAllJoynProducer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAllJoynProducer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAllJoynProducer[] = {
        { "set_bus_object", reinterpret_cast<PyCFunction>(IAllJoynProducer_SetBusObject), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAllJoynProducer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAllJoynProducer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAllJoynProducer[] = {
        { }
    };

    static PyType_Slot _type_slots_IAllJoynProducer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAllJoynProducer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAllJoynProducer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAllJoynProducer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAllJoynProducer) },
        { },
    };

    static PyType_Spec type_spec_IAllJoynProducer = {
        "winrt._winrt_windows_devices_alljoyn.IAllJoynProducer",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAllJoynProducer};

    // ----- Windows.Devices.AllJoyn Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.AllJoyn");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_alljoyn",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::AllJoyn

PyMODINIT_FUNC PyInit__winrt_windows_devices_alljoyn(void) noexcept
{
    using namespace py::cpp::Windows::Devices::AllJoyn;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynAboutData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynAboutDataView_Static{PyType_FromSpec(&type_spec_AllJoynAboutDataView_Static)};
    if (!type_AllJoynAboutDataView_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynAboutDataView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynAboutDataView_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynAcceptSessionJoinerEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynAuthenticationCompleteEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynBusAttachment_Static{PyType_FromSpec(&type_spec_AllJoynBusAttachment_Static)};
    if (!type_AllJoynBusAttachment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynBusAttachment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynBusAttachment_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynBusAttachmentStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynBusObject, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynBusObjectStoppedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynCredentials, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynCredentialsRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynCredentialsVerificationRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynMessageInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynProducerStoppedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynServiceInfo_Static{PyType_FromSpec(&type_spec_AllJoynServiceInfo_Static)};
    if (!type_AllJoynServiceInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynServiceInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynServiceInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynServiceInfoRemovedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynSession_Static{PyType_FromSpec(&type_spec_AllJoynSession_Static)};
    if (!type_AllJoynSession_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynSession, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynSession_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynSessionJoinedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynSessionLostEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynSessionMemberAddedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynSessionMemberRemovedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynStatus_Static{PyType_FromSpec(&type_spec_AllJoynStatus_Static)};
    if (!type_AllJoynStatus_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynStatus, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynStatus_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AllJoynWatcherStoppedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAllJoynAcceptSessionJoiner, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAllJoynProducer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
