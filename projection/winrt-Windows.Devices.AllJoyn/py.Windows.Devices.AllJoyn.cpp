// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Devices.AllJoyn.h"


namespace py::cpp::Windows::Devices::AllJoyn
{
    struct module_state
    {
        PyTypeObject* type_AllJoynAboutData;
        PyTypeObject* type_AllJoynAboutDataView;
        PyTypeObject* type_AllJoynAcceptSessionJoinerEventArgs;
        PyTypeObject* type_AllJoynAuthenticationCompleteEventArgs;
        PyTypeObject* type_AllJoynBusAttachment;
        PyTypeObject* type_AllJoynBusAttachmentStateChangedEventArgs;
        PyTypeObject* type_AllJoynBusObject;
        PyTypeObject* type_AllJoynBusObjectStoppedEventArgs;
        PyTypeObject* type_AllJoynCredentials;
        PyTypeObject* type_AllJoynCredentialsRequestedEventArgs;
        PyTypeObject* type_AllJoynCredentialsVerificationRequestedEventArgs;
        PyTypeObject* type_AllJoynMessageInfo;
        PyTypeObject* type_AllJoynProducerStoppedEventArgs;
        PyTypeObject* type_AllJoynServiceInfo;
        PyTypeObject* type_AllJoynServiceInfoRemovedEventArgs;
        PyTypeObject* type_AllJoynSession;
        PyTypeObject* type_AllJoynSessionJoinedEventArgs;
        PyTypeObject* type_AllJoynSessionLostEventArgs;
        PyTypeObject* type_AllJoynSessionMemberAddedEventArgs;
        PyTypeObject* type_AllJoynSessionMemberRemovedEventArgs;
        PyTypeObject* type_AllJoynStatus;
        PyTypeObject* type_AllJoynWatcherStoppedEventArgs;
        PyTypeObject* type_IAllJoynAcceptSessionJoiner;
        PyTypeObject* type_IAllJoynProducer;
    };

    // ----- AllJoynAboutData class --------------------
    static constexpr const char* const type_name_AllJoynAboutData = "AllJoynAboutData";

    static PyObject* _new_AllJoynAboutData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynAboutData);
        return nullptr;
    }

    static void _dealloc_AllJoynAboutData(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAboutData_get_DefaultDescription(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultDescription(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DefaultAppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultAppName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultAppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultAppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultAppName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultAppName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DateOfManufacture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DateOfManufacture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DateOfManufacture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.DateOfManufacture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_DefaultManufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultManufacturer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultManufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_DefaultManufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"DefaultManufacturer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultManufacturer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.AppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SupportUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SupportUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.SupportUrl(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SoftwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"SoftwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SoftwareVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ModelNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_IsEnabled(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynAboutData_put_IsEnabled(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynAboutData_get_AppNames(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"AppNames"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutData_get_Manufacturers(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"Manufacturers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Manufacturers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutData_get_Descriptions(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutData", L"Descriptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Descriptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAboutData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAboutData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAboutData[] = {
        { "_assign_array_", _assign_array_AllJoynAboutData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAboutData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAboutData[] = {
        { "default_description", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultDescription), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultDescription), nullptr, nullptr },
        { "default_app_name", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultAppName), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultAppName), nullptr, nullptr },
        { "date_of_manufacture", reinterpret_cast<getter>(AllJoynAboutData_get_DateOfManufacture), reinterpret_cast<setter>(AllJoynAboutData_put_DateOfManufacture), nullptr, nullptr },
        { "default_manufacturer", reinterpret_cast<getter>(AllJoynAboutData_get_DefaultManufacturer), reinterpret_cast<setter>(AllJoynAboutData_put_DefaultManufacturer), nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AllJoynAboutData_get_AppId), reinterpret_cast<setter>(AllJoynAboutData_put_AppId), nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(AllJoynAboutData_get_SupportUrl), reinterpret_cast<setter>(AllJoynAboutData_put_SupportUrl), nullptr, nullptr },
        { "software_version", reinterpret_cast<getter>(AllJoynAboutData_get_SoftwareVersion), reinterpret_cast<setter>(AllJoynAboutData_put_SoftwareVersion), nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(AllJoynAboutData_get_ModelNumber), reinterpret_cast<setter>(AllJoynAboutData_put_ModelNumber), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(AllJoynAboutData_get_IsEnabled), reinterpret_cast<setter>(AllJoynAboutData_put_IsEnabled), nullptr, nullptr },
        { "app_names", reinterpret_cast<getter>(AllJoynAboutData_get_AppNames), nullptr, nullptr, nullptr },
        { "manufacturers", reinterpret_cast<getter>(AllJoynAboutData_get_Manufacturers), nullptr, nullptr, nullptr },
        { "descriptions", reinterpret_cast<getter>(AllJoynAboutData_get_Descriptions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAboutData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAboutData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAboutData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAboutData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAboutData) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAboutData =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynAboutData",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAboutData
    };

    // ----- AllJoynAboutDataView class --------------------
    static constexpr const char* const type_name_AllJoynAboutDataView = "AllJoynAboutDataView";

    static PyObject* _new_AllJoynAboutDataView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynAboutDataView);
        return nullptr;
    }

    static void _dealloc_AllJoynAboutDataView(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAboutDataView_GetDataBySessionPortAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"GetDataBySessionPortAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView::GetDataBySessionPortAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"GetDataBySessionPortAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Globalization::Language>(args, 3);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView::GetDataBySessionPortAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AJSoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AJSoftwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AJSoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AppId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_AppName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"AppName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DateOfManufacture(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DateOfManufacture"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DateOfManufacture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DefaultLanguage(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DefaultLanguage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Description(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DeviceId(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_DeviceName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"DeviceName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_HardwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"HardwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Manufacturer(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Manufacturer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_ModelNumber(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"ModelNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Properties(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SoftwareVersion(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SoftwareVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoftwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SupportUrl(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SupportUrl"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAboutDataView_get_SupportedLanguages(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAboutDataView", L"SupportedLanguages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAboutDataView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAboutDataView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAboutDataView[] = {
        { "get_data_by_session_port_async", reinterpret_cast<PyCFunction>(AllJoynAboutDataView_GetDataBySessionPortAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AllJoynAboutDataView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAboutDataView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAboutDataView[] = {
        { "a_j_software_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_AJSoftwareVersion), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AllJoynAboutDataView_get_AppId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(AllJoynAboutDataView_get_AppName), nullptr, nullptr, nullptr },
        { "date_of_manufacture", reinterpret_cast<getter>(AllJoynAboutDataView_get_DateOfManufacture), nullptr, nullptr, nullptr },
        { "default_language", reinterpret_cast<getter>(AllJoynAboutDataView_get_DefaultLanguage), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(AllJoynAboutDataView_get_Description), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(AllJoynAboutDataView_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_name", reinterpret_cast<getter>(AllJoynAboutDataView_get_DeviceName), nullptr, nullptr, nullptr },
        { "hardware_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_HardwareVersion), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(AllJoynAboutDataView_get_Manufacturer), nullptr, nullptr, nullptr },
        { "model_number", reinterpret_cast<getter>(AllJoynAboutDataView_get_ModelNumber), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AllJoynAboutDataView_get_Properties), nullptr, nullptr, nullptr },
        { "software_version", reinterpret_cast<getter>(AllJoynAboutDataView_get_SoftwareVersion), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynAboutDataView_get_Status), nullptr, nullptr, nullptr },
        { "support_url", reinterpret_cast<getter>(AllJoynAboutDataView_get_SupportUrl), nullptr, nullptr, nullptr },
        { "supported_languages", reinterpret_cast<getter>(AllJoynAboutDataView_get_SupportedLanguages), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAboutDataView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAboutDataView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAboutDataView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAboutDataView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAboutDataView) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAboutDataView =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynAboutDataView",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAboutDataView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAboutDataView
    };

    // ----- AllJoynAcceptSessionJoinerEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynAcceptSessionJoinerEventArgs = "AllJoynAcceptSessionJoinerEventArgs";

    static PyObject* _new_AllJoynAcceptSessionJoinerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynTrafficType>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>(args, 4);

                winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynAcceptSessionJoinerEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_Accept(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SameNetwork(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SameNetwork"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SameNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SamePhysicalNode(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SamePhysicalNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SamePhysicalNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_SessionPort(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"SessionPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_TrafficType(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"TrafficType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrafficType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAcceptSessionJoinerEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAcceptSessionJoinerEventArgs", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAcceptSessionJoinerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAcceptSessionJoinerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAcceptSessionJoinerEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(AllJoynAcceptSessionJoinerEventArgs_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynAcceptSessionJoinerEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAcceptSessionJoinerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAcceptSessionJoinerEventArgs[] = {
        { "same_network", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SameNetwork), nullptr, nullptr, nullptr },
        { "same_physical_node", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SamePhysicalNode), nullptr, nullptr, nullptr },
        { "session_port", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_SessionPort), nullptr, nullptr, nullptr },
        { "traffic_type", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_TrafficType), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynAcceptSessionJoinerEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAcceptSessionJoinerEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAcceptSessionJoinerEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAcceptSessionJoinerEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAcceptSessionJoinerEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynAcceptSessionJoinerEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAcceptSessionJoinerEventArgs
    };

    // ----- AllJoynAuthenticationCompleteEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynAuthenticationCompleteEventArgs = "AllJoynAuthenticationCompleteEventArgs";

    static PyObject* _new_AllJoynAuthenticationCompleteEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynAuthenticationCompleteEventArgs);
        return nullptr;
    }

    static void _dealloc_AllJoynAuthenticationCompleteEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"AuthenticationMechanism"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"PeerUniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynAuthenticationCompleteEventArgs_get_Succeeded(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynAuthenticationCompleteEventArgs", L"Succeeded"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynAuthenticationCompleteEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynAuthenticationCompleteEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynAuthenticationCompleteEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynAuthenticationCompleteEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynAuthenticationCompleteEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynAuthenticationCompleteEventArgs[] = {
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(AllJoynAuthenticationCompleteEventArgs_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynAuthenticationCompleteEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynAuthenticationCompleteEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynAuthenticationCompleteEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynAuthenticationCompleteEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynAuthenticationCompleteEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynAuthenticationCompleteEventArgs
    };

    // ----- AllJoynBusAttachment class --------------------
    static constexpr const char* const type_name_AllJoynBusAttachment = "AllJoynBusAttachment";

    static PyObject* _new_AllJoynBusAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusAttachment(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusAttachment_Connect(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"Connect", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Connect();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_Disconnect(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"Disconnect", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Disconnect();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetAboutDataAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetAboutDataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);

                return py::convert(self->obj.GetAboutDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetAboutDataAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Globalization::Language>(args, 1);

                return py::convert(self->obj.GetAboutDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_GetWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"GetWatcher", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment::GetWatcher(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_PingAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"PingAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.PingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_AboutData(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AboutData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AboutData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_AuthenticationMechanisms(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationMechanisms"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationMechanisms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_ConnectionSpecification(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"ConnectionSpecification"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionSpecification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_State(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_AuthenticationComplete(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>>(arg);

            return py::convert(self->obj.AuthenticationComplete(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_AuthenticationComplete(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AuthenticationComplete"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AuthenticationComplete(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_CredentialsRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>>(arg);

            return py::convert(self->obj.CredentialsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_CredentialsRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CredentialsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_CredentialsVerificationRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsVerificationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>>(arg);

            return py::convert(self->obj.CredentialsVerificationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_CredentialsVerificationRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"CredentialsVerificationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CredentialsVerificationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_StateChanged(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_StateChanged(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_AcceptSessionJoinerRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AcceptSessionJoinerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>>(arg);

            return py::convert(self->obj.AcceptSessionJoinerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_AcceptSessionJoinerRequested(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"AcceptSessionJoinerRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceptSessionJoinerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_add_SessionJoined(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"SessionJoined"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment, winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>>(arg);

            return py::convert(self->obj.SessionJoined(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachment_remove_SessionJoined(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachment", L"SessionJoined"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionJoined(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusAttachment[] = {
        { "connect", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_Connect), METH_VARARGS, nullptr },
        { "disconnect", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_Disconnect), METH_VARARGS, nullptr },
        { "get_about_data_async", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetAboutDataAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_watcher", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_GetWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "ping_async", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_PingAsync), METH_VARARGS, nullptr },
        { "add_authentication_complete", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_AuthenticationComplete), METH_O, nullptr },
        { "remove_authentication_complete", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_AuthenticationComplete), METH_O, nullptr },
        { "add_credentials_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_CredentialsRequested), METH_O, nullptr },
        { "remove_credentials_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_CredentialsRequested), METH_O, nullptr },
        { "add_credentials_verification_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_CredentialsVerificationRequested), METH_O, nullptr },
        { "remove_credentials_verification_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_CredentialsVerificationRequested), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_StateChanged), METH_O, nullptr },
        { "add_accept_session_joiner_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_AcceptSessionJoinerRequested), METH_O, nullptr },
        { "remove_accept_session_joiner_requested", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_AcceptSessionJoinerRequested), METH_O, nullptr },
        { "add_session_joined", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_add_SessionJoined), METH_O, nullptr },
        { "remove_session_joined", reinterpret_cast<PyCFunction>(AllJoynBusAttachment_remove_SessionJoined), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynBusAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusAttachment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusAttachment[] = {
        { "about_data", reinterpret_cast<getter>(AllJoynBusAttachment_get_AboutData), nullptr, nullptr, nullptr },
        { "authentication_mechanisms", reinterpret_cast<getter>(AllJoynBusAttachment_get_AuthenticationMechanisms), nullptr, nullptr, nullptr },
        { "connection_specification", reinterpret_cast<getter>(AllJoynBusAttachment_get_ConnectionSpecification), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AllJoynBusAttachment_get_State), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynBusAttachment_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusAttachment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusAttachment) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusAttachment =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynBusAttachment",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusAttachment
    };

    // ----- AllJoynBusAttachmentStateChangedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynBusAttachmentStateChangedEventArgs = "AllJoynBusAttachmentStateChangedEventArgs";

    static PyObject* _new_AllJoynBusAttachmentStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynBusAttachmentStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AllJoynBusAttachmentStateChangedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusAttachmentStateChangedEventArgs_get_State(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusAttachmentStateChangedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusAttachmentStateChangedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusAttachmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusAttachmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusAttachmentStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynBusAttachmentStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusAttachmentStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusAttachmentStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(AllJoynBusAttachmentStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynBusAttachmentStateChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusAttachmentStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusAttachmentStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusAttachmentStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusAttachmentStateChangedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynBusAttachmentStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusAttachmentStateChangedEventArgs
    };

    // ----- AllJoynBusObject class --------------------
    static constexpr const char* const type_name_AllJoynBusObject = "AllJoynBusObject";

    static PyObject* _new_AllJoynBusObject(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::AllJoyn::AllJoynBusObject instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusObject(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusObject_AddProducer(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"AddProducer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>(args, 0);

                self->obj.AddProducer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_Start(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_Stop(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_get_BusAttachment(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"BusAttachment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BusAttachment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_get_Session(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Session"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_add_Stopped(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynBusObject, winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynBusObject_remove_Stopped(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynBusObject", L"Stopped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusObject[] = {
        { "add_producer", reinterpret_cast<PyCFunction>(AllJoynBusObject_AddProducer), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AllJoynBusObject_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AllJoynBusObject_Stop), METH_VARARGS, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(AllJoynBusObject_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(AllJoynBusObject_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynBusObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusObject), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusObject[] = {
        { "bus_attachment", reinterpret_cast<getter>(AllJoynBusObject_get_BusAttachment), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(AllJoynBusObject_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusObject[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusObject) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusObject =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynBusObject",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObject),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusObject
    };

    // ----- AllJoynBusObjectStoppedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynBusObjectStoppedEventArgs = "AllJoynBusObjectStoppedEventArgs";

    static PyObject* _new_AllJoynBusObjectStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynBusObjectStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynBusObjectStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynBusObjectStoppedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynBusObjectStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynBusObjectStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynBusObjectStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynBusObjectStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynBusObjectStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynBusObjectStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynBusObjectStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynBusObjectStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynBusObjectStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynBusObjectStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynBusObjectStoppedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynBusObjectStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynBusObjectStoppedEventArgs
    };

    // ----- AllJoynCredentials class --------------------
    static constexpr const char* const type_name_AllJoynCredentials = "AllJoynCredentials";

    static PyObject* _new_AllJoynCredentials(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynCredentials);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentials(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentials_get_Timeout(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Timeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_Timeout(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Timeout"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Timeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_PasswordCredential(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"PasswordCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_PasswordCredential(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"PasswordCredential"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.PasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_Certificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AllJoynCredentials_put_Certificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AllJoynCredentials_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentials", L"AuthenticationMechanism"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentials(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentials[] = {
        { "_assign_array_", _assign_array_AllJoynCredentials, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentials), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentials[] = {
        { "timeout", reinterpret_cast<getter>(AllJoynCredentials_get_Timeout), reinterpret_cast<setter>(AllJoynCredentials_put_Timeout), nullptr, nullptr },
        { "password_credential", reinterpret_cast<getter>(AllJoynCredentials_get_PasswordCredential), reinterpret_cast<setter>(AllJoynCredentials_put_PasswordCredential), nullptr, nullptr },
        { "certificate", reinterpret_cast<getter>(AllJoynCredentials_get_Certificate), reinterpret_cast<setter>(AllJoynCredentials_put_Certificate), nullptr, nullptr },
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynCredentials_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentials[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentials) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentials) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentials) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentials) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentials =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynCredentials",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentials),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentials
    };

    // ----- AllJoynCredentialsRequestedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynCredentialsRequestedEventArgs = "AllJoynCredentialsRequestedEventArgs";

    static PyObject* _new_AllJoynCredentialsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynCredentialsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentialsRequestedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_AttemptCount(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"AttemptCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_Credentials(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"Credentials"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Credentials());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"PeerUniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsRequestedEventArgs_get_RequestedUserName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsRequestedEventArgs", L"RequestedUserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedUserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentialsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentialsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentialsRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(AllJoynCredentialsRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynCredentialsRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentialsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentialsRequestedEventArgs[] = {
        { "attempt_count", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_AttemptCount), nullptr, nullptr, nullptr },
        { "credentials", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_Credentials), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { "requested_user_name", reinterpret_cast<getter>(AllJoynCredentialsRequestedEventArgs_get_RequestedUserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentialsRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentialsRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentialsRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentialsRequestedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynCredentialsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentialsRequestedEventArgs
    };

    // ----- AllJoynCredentialsVerificationRequestedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynCredentialsVerificationRequestedEventArgs = "AllJoynCredentialsVerificationRequestedEventArgs";

    static PyObject* _new_AllJoynCredentialsVerificationRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynCredentialsVerificationRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_AllJoynCredentialsVerificationRequestedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_Accept(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_AuthenticationMechanism(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"AuthenticationMechanism"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AuthenticationMechanism());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificate(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrorSeverity(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificateErrorSeverity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrors(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerCertificateErrors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerIntermediateCertificates(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerIntermediateCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynCredentialsVerificationRequestedEventArgs_get_PeerUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs", L"PeerUniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PeerUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynCredentialsVerificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynCredentialsVerificationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynCredentialsVerificationRequestedEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(AllJoynCredentialsVerificationRequestedEventArgs_Accept), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(AllJoynCredentialsVerificationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AllJoynCredentialsVerificationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynCredentialsVerificationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynCredentialsVerificationRequestedEventArgs[] = {
        { "authentication_mechanism", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_AuthenticationMechanism), nullptr, nullptr, nullptr },
        { "peer_certificate", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificate), nullptr, nullptr, nullptr },
        { "peer_certificate_error_severity", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "peer_certificate_errors", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerCertificateErrors), nullptr, nullptr, nullptr },
        { "peer_intermediate_certificates", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerIntermediateCertificates), nullptr, nullptr, nullptr },
        { "peer_unique_name", reinterpret_cast<getter>(AllJoynCredentialsVerificationRequestedEventArgs_get_PeerUniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynCredentialsVerificationRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynCredentialsVerificationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynCredentialsVerificationRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynCredentialsVerificationRequestedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynCredentialsVerificationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynCredentialsVerificationRequestedEventArgs
    };

    // ----- AllJoynMessageInfo class --------------------
    static constexpr const char* const type_name_AllJoynMessageInfo = "AllJoynMessageInfo";

    static PyObject* _new_AllJoynMessageInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynMessageInfo(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynMessageInfo_get_SenderUniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynMessageInfo", L"SenderUniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SenderUniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynMessageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynMessageInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynMessageInfo[] = {
        { "_assign_array_", _assign_array_AllJoynMessageInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynMessageInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynMessageInfo[] = {
        { "sender_unique_name", reinterpret_cast<getter>(AllJoynMessageInfo_get_SenderUniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynMessageInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynMessageInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynMessageInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynMessageInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynMessageInfo) },
        { },
    };

    static PyType_Spec type_spec_AllJoynMessageInfo =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynMessageInfo",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynMessageInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynMessageInfo
    };

    // ----- AllJoynProducerStoppedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynProducerStoppedEventArgs = "AllJoynProducerStoppedEventArgs";

    static PyObject* _new_AllJoynProducerStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynProducerStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynProducerStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynProducerStoppedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynProducerStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynProducerStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynProducerStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynProducerStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynProducerStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynProducerStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynProducerStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynProducerStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynProducerStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynProducerStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynProducerStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynProducerStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynProducerStoppedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynProducerStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynProducerStoppedEventArgs
    };

    // ----- AllJoynServiceInfo class --------------------
    static constexpr const char* const type_name_AllJoynServiceInfo = "AllJoynServiceInfo";

    static PyObject* _new_AllJoynServiceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynServiceInfo(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynServiceInfo_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"FromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_ObjectPath(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"ObjectPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ObjectPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_SessionPort(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"SessionPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynServiceInfo_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfo", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynServiceInfo[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(AllJoynServiceInfo_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_AllJoynServiceInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynServiceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynServiceInfo[] = {
        { "object_path", reinterpret_cast<getter>(AllJoynServiceInfo_get_ObjectPath), nullptr, nullptr, nullptr },
        { "session_port", reinterpret_cast<getter>(AllJoynServiceInfo_get_SessionPort), nullptr, nullptr, nullptr },
        { "unique_name", reinterpret_cast<getter>(AllJoynServiceInfo_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynServiceInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynServiceInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynServiceInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynServiceInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynServiceInfo) },
        { },
    };

    static PyType_Spec type_spec_AllJoynServiceInfo =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynServiceInfo",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynServiceInfo
    };

    // ----- AllJoynServiceInfoRemovedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynServiceInfoRemovedEventArgs = "AllJoynServiceInfoRemovedEventArgs";

    static PyObject* _new_AllJoynServiceInfoRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynServiceInfoRemovedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynServiceInfoRemovedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynServiceInfoRemovedEventArgs", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynServiceInfoRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynServiceInfoRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynServiceInfoRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynServiceInfoRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynServiceInfoRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynServiceInfoRemovedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynServiceInfoRemovedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynServiceInfoRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynServiceInfoRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynServiceInfoRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynServiceInfoRemovedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynServiceInfoRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynServiceInfoRemovedEventArgs
    };

    // ----- AllJoynSession class --------------------
    static constexpr const char* const type_name_AllJoynSession = "AllJoynSession";

    static PyObject* _new_AllJoynSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynSession);
        return nullptr;
    }

    static void _dealloc_AllJoynSession(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSession_GetFromServiceInfoAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"GetFromServiceInfoAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynSession::GetFromServiceInfoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"GetFromServiceInfoAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>(args, 1);

                return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynSession::GetFromServiceInfoAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_RemoveMemberAsync(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"RemoveMemberAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemoveMemberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_get_Id(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_Lost(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Lost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>>(arg);

            return py::convert(self->obj.Lost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_Lost(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"Lost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Lost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_MemberAdded(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>>(arg);

            return py::convert(self->obj.MemberAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_MemberAdded(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberAdded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MemberAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_add_MemberRemoved(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::AllJoyn::AllJoynSession, winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>>(arg);

            return py::convert(self->obj.MemberRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynSession_remove_MemberRemoved(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.AllJoyn.AllJoynSession", L"MemberRemoved"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MemberRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSession[] = {
        { "get_from_service_info_async", reinterpret_cast<PyCFunction>(AllJoynSession_GetFromServiceInfoAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_member_async", reinterpret_cast<PyCFunction>(AllJoynSession_RemoveMemberAsync), METH_VARARGS, nullptr },
        { "add_lost", reinterpret_cast<PyCFunction>(AllJoynSession_add_Lost), METH_O, nullptr },
        { "remove_lost", reinterpret_cast<PyCFunction>(AllJoynSession_remove_Lost), METH_O, nullptr },
        { "add_member_added", reinterpret_cast<PyCFunction>(AllJoynSession_add_MemberAdded), METH_O, nullptr },
        { "remove_member_added", reinterpret_cast<PyCFunction>(AllJoynSession_remove_MemberAdded), METH_O, nullptr },
        { "add_member_removed", reinterpret_cast<PyCFunction>(AllJoynSession_add_MemberRemoved), METH_O, nullptr },
        { "remove_member_removed", reinterpret_cast<PyCFunction>(AllJoynSession_remove_MemberRemoved), METH_O, nullptr },
        { "_assign_array_", _assign_array_AllJoynSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSession[] = {
        { "id", reinterpret_cast<getter>(AllJoynSession_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AllJoynSession_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSession) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSession =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynSession",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSession
    };

    // ----- AllJoynSessionJoinedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynSessionJoinedEventArgs = "AllJoynSessionJoinedEventArgs";

    static PyObject* _new_AllJoynSessionJoinedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynSession>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionJoinedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionJoinedEventArgs_get_Session(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionJoinedEventArgs", L"Session"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionJoinedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionJoinedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionJoinedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionJoinedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionJoinedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionJoinedEventArgs[] = {
        { "session", reinterpret_cast<getter>(AllJoynSessionJoinedEventArgs_get_Session), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionJoinedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionJoinedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionJoinedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionJoinedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionJoinedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionJoinedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynSessionJoinedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionJoinedEventArgs
    };

    // ----- AllJoynSessionLostEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynSessionLostEventArgs = "AllJoynSessionLostEventArgs";

    static PyObject* _new_AllJoynSessionLostEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostReason>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionLostEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionLostEventArgs_get_Reason(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionLostEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionLostEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionLostEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionLostEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionLostEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionLostEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionLostEventArgs[] = {
        { "reason", reinterpret_cast<getter>(AllJoynSessionLostEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionLostEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionLostEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionLostEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionLostEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionLostEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionLostEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynSessionLostEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionLostEventArgs
    };

    // ----- AllJoynSessionMemberAddedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynSessionMemberAddedEventArgs = "AllJoynSessionMemberAddedEventArgs";

    static PyObject* _new_AllJoynSessionMemberAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionMemberAddedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionMemberAddedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionMemberAddedEventArgs", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionMemberAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionMemberAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionMemberAddedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionMemberAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionMemberAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionMemberAddedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynSessionMemberAddedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionMemberAddedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionMemberAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionMemberAddedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionMemberAddedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynSessionMemberAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionMemberAddedEventArgs
    };

    // ----- AllJoynSessionMemberRemovedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynSessionMemberRemovedEventArgs = "AllJoynSessionMemberRemovedEventArgs";

    static PyObject* _new_AllJoynSessionMemberRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynSessionMemberRemovedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynSessionMemberRemovedEventArgs_get_UniqueName(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynSessionMemberRemovedEventArgs", L"UniqueName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UniqueName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynSessionMemberRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynSessionMemberRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynSessionMemberRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynSessionMemberRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynSessionMemberRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynSessionMemberRemovedEventArgs[] = {
        { "unique_name", reinterpret_cast<getter>(AllJoynSessionMemberRemovedEventArgs_get_UniqueName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynSessionMemberRemovedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynSessionMemberRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynSessionMemberRemovedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynSessionMemberRemovedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynSessionMemberRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynSessionMemberRemovedEventArgs
    };

    // ----- AllJoynStatus class --------------------
    static constexpr const char* const type_name_AllJoynStatus = "AllJoynStatus";

    static PyObject* _new_AllJoynStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AllJoynStatus);
        return nullptr;
    }

    static PyObject* AllJoynStatus_get_AuthenticationFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"AuthenticationFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::AuthenticationFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_AuthenticationRejectedByUser(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"AuthenticationRejectedByUser"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::AuthenticationRejectedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_ConnectionRefused(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"ConnectionRefused"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::ConnectionRefused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_Fail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"Fail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::Fail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InsufficientSecurity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InsufficientSecurity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InsufficientSecurity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument5"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument6(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument6"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument6());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument7"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_InvalidArgument8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"InvalidArgument8"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::InvalidArgument8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_Ok(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"Ok"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::Ok());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_OperationTimedOut(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"OperationTimedOut"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::OperationTimedOut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_OtherEndClosed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"OtherEndClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::OtherEndClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_SslConnectFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"SslConnectFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::SslConnectFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AllJoynStatus_get_SslIdentityVerificationFailed(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynStatus", L"SslIdentityVerificationFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Devices::AllJoyn::AllJoynStatus::SslIdentityVerificationFailed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynStatus[] = {
        { }
    };

    static PyGetSetDef _getset_AllJoynStatus[] = {
        { }
    };

    static PyType_Slot _type_slots_AllJoynStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynStatus) },
        { },
    };

    static PyType_Spec type_spec_AllJoynStatus =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynStatus",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynStatus
    };

    static PyGetSetDef getset_AllJoynStatus_Meta[] = {
        { "authentication_failed", reinterpret_cast<getter>(AllJoynStatus_get_AuthenticationFailed), nullptr, nullptr, nullptr },
        { "authentication_rejected_by_user", reinterpret_cast<getter>(AllJoynStatus_get_AuthenticationRejectedByUser), nullptr, nullptr, nullptr },
        { "connection_refused", reinterpret_cast<getter>(AllJoynStatus_get_ConnectionRefused), nullptr, nullptr, nullptr },
        { "fail", reinterpret_cast<getter>(AllJoynStatus_get_Fail), nullptr, nullptr, nullptr },
        { "insufficient_security", reinterpret_cast<getter>(AllJoynStatus_get_InsufficientSecurity), nullptr, nullptr, nullptr },
        { "invalid_argument1", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument1), nullptr, nullptr, nullptr },
        { "invalid_argument2", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument2), nullptr, nullptr, nullptr },
        { "invalid_argument3", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument3), nullptr, nullptr, nullptr },
        { "invalid_argument4", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument4), nullptr, nullptr, nullptr },
        { "invalid_argument5", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument5), nullptr, nullptr, nullptr },
        { "invalid_argument6", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument6), nullptr, nullptr, nullptr },
        { "invalid_argument7", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument7), nullptr, nullptr, nullptr },
        { "invalid_argument8", reinterpret_cast<getter>(AllJoynStatus_get_InvalidArgument8), nullptr, nullptr, nullptr },
        { "ok", reinterpret_cast<getter>(AllJoynStatus_get_Ok), nullptr, nullptr, nullptr },
        { "operation_timed_out", reinterpret_cast<getter>(AllJoynStatus_get_OperationTimedOut), nullptr, nullptr, nullptr },
        { "other_end_closed", reinterpret_cast<getter>(AllJoynStatus_get_OtherEndClosed), nullptr, nullptr, nullptr },
        { "ssl_connect_failed", reinterpret_cast<getter>(AllJoynStatus_get_SslConnectFailed), nullptr, nullptr, nullptr },
        { "ssl_identity_verification_failed", reinterpret_cast<getter>(AllJoynStatus_get_SslIdentityVerificationFailed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AllJoynStatus_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AllJoynStatus_Meta) },
        { }
    };

    static PyType_Spec type_spec_AllJoynStatus_Meta =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynStatus_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AllJoynStatus_Meta
    };

    // ----- AllJoynWatcherStoppedEventArgs class --------------------
    static constexpr const char* const type_name_AllJoynWatcherStoppedEventArgs = "AllJoynWatcherStoppedEventArgs";

    static PyObject* _new_AllJoynWatcherStoppedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AllJoynWatcherStoppedEventArgs(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AllJoynWatcherStoppedEventArgs_get_Status(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.AllJoyn.AllJoynWatcherStoppedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AllJoynWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AllJoynWatcherStoppedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AllJoynWatcherStoppedEventArgs[] = {
        { "_assign_array_", _assign_array_AllJoynWatcherStoppedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AllJoynWatcherStoppedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AllJoynWatcherStoppedEventArgs[] = {
        { "status", reinterpret_cast<getter>(AllJoynWatcherStoppedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AllJoynWatcherStoppedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AllJoynWatcherStoppedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AllJoynWatcherStoppedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AllJoynWatcherStoppedEventArgs =
    {
        "_winrt_Windows_Devices_AllJoyn.AllJoynWatcherStoppedEventArgs",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AllJoynWatcherStoppedEventArgs
    };

    // ----- IAllJoynAcceptSessionJoiner interface --------------------
    static constexpr const char* const type_name_IAllJoynAcceptSessionJoiner = "IAllJoynAcceptSessionJoiner";

    static PyObject* _new_IAllJoynAcceptSessionJoiner(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAllJoynAcceptSessionJoiner);
        return nullptr;
    }

    static void _dealloc_IAllJoynAcceptSessionJoiner(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAllJoynAcceptSessionJoiner_Accept(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.IAllJoynAcceptSessionJoiner", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAllJoynAcceptSessionJoiner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAllJoynAcceptSessionJoiner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAllJoynAcceptSessionJoiner[] = {
        { "accept", reinterpret_cast<PyCFunction>(IAllJoynAcceptSessionJoiner_Accept), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAllJoynAcceptSessionJoiner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAllJoynAcceptSessionJoiner), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAllJoynAcceptSessionJoiner[] = {
        { }
    };

    static PyType_Slot _type_slots_IAllJoynAcceptSessionJoiner[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAllJoynAcceptSessionJoiner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAllJoynAcceptSessionJoiner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAllJoynAcceptSessionJoiner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAllJoynAcceptSessionJoiner) },
        { },
    };

    static PyType_Spec type_spec_IAllJoynAcceptSessionJoiner =
    {
        "_winrt_Windows_Devices_AllJoyn.IAllJoynAcceptSessionJoiner",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAllJoynAcceptSessionJoiner
    };

    // ----- IAllJoynProducer interface --------------------
    static constexpr const char* const type_name_IAllJoynProducer = "IAllJoynProducer";

    static PyObject* _new_IAllJoynProducer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAllJoynProducer);
        return nullptr;
    }

    static void _dealloc_IAllJoynProducer(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAllJoynProducer_SetBusObject(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.AllJoyn.IAllJoynProducer", L"SetBusObject", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>(args, 0);

                self->obj.SetBusObject(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAllJoynProducer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAllJoynProducer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAllJoynProducer[] = {
        { "set_bus_object", reinterpret_cast<PyCFunction>(IAllJoynProducer_SetBusObject), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAllJoynProducer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAllJoynProducer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAllJoynProducer[] = {
        { }
    };

    static PyType_Slot _type_slots_IAllJoynProducer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAllJoynProducer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAllJoynProducer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAllJoynProducer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAllJoynProducer) },
        { },
    };

    static PyType_Spec type_spec_IAllJoynProducer =
    {
        "_winrt_Windows_Devices_AllJoyn.IAllJoynProducer",
        sizeof(py::wrapper::Windows::Devices::AllJoyn::IAllJoynProducer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAllJoynProducer
    };

    // ----- Windows.Devices.AllJoyn Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::AllJoyn");


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AllJoynAboutData);
        Py_VISIT(state->type_AllJoynAboutDataView);
        Py_VISIT(state->type_AllJoynAcceptSessionJoinerEventArgs);
        Py_VISIT(state->type_AllJoynAuthenticationCompleteEventArgs);
        Py_VISIT(state->type_AllJoynBusAttachment);
        Py_VISIT(state->type_AllJoynBusAttachmentStateChangedEventArgs);
        Py_VISIT(state->type_AllJoynBusObject);
        Py_VISIT(state->type_AllJoynBusObjectStoppedEventArgs);
        Py_VISIT(state->type_AllJoynCredentials);
        Py_VISIT(state->type_AllJoynCredentialsRequestedEventArgs);
        Py_VISIT(state->type_AllJoynCredentialsVerificationRequestedEventArgs);
        Py_VISIT(state->type_AllJoynMessageInfo);
        Py_VISIT(state->type_AllJoynProducerStoppedEventArgs);
        Py_VISIT(state->type_AllJoynServiceInfo);
        Py_VISIT(state->type_AllJoynServiceInfoRemovedEventArgs);
        Py_VISIT(state->type_AllJoynSession);
        Py_VISIT(state->type_AllJoynSessionJoinedEventArgs);
        Py_VISIT(state->type_AllJoynSessionLostEventArgs);
        Py_VISIT(state->type_AllJoynSessionMemberAddedEventArgs);
        Py_VISIT(state->type_AllJoynSessionMemberRemovedEventArgs);
        Py_VISIT(state->type_AllJoynStatus);
        Py_VISIT(state->type_AllJoynWatcherStoppedEventArgs);
        Py_VISIT(state->type_IAllJoynAcceptSessionJoiner);
        Py_VISIT(state->type_IAllJoynProducer);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AllJoynAboutData);
        Py_CLEAR(state->type_AllJoynAboutDataView);
        Py_CLEAR(state->type_AllJoynAcceptSessionJoinerEventArgs);
        Py_CLEAR(state->type_AllJoynAuthenticationCompleteEventArgs);
        Py_CLEAR(state->type_AllJoynBusAttachment);
        Py_CLEAR(state->type_AllJoynBusAttachmentStateChangedEventArgs);
        Py_CLEAR(state->type_AllJoynBusObject);
        Py_CLEAR(state->type_AllJoynBusObjectStoppedEventArgs);
        Py_CLEAR(state->type_AllJoynCredentials);
        Py_CLEAR(state->type_AllJoynCredentialsRequestedEventArgs);
        Py_CLEAR(state->type_AllJoynCredentialsVerificationRequestedEventArgs);
        Py_CLEAR(state->type_AllJoynMessageInfo);
        Py_CLEAR(state->type_AllJoynProducerStoppedEventArgs);
        Py_CLEAR(state->type_AllJoynServiceInfo);
        Py_CLEAR(state->type_AllJoynServiceInfoRemovedEventArgs);
        Py_CLEAR(state->type_AllJoynSession);
        Py_CLEAR(state->type_AllJoynSessionJoinedEventArgs);
        Py_CLEAR(state->type_AllJoynSessionLostEventArgs);
        Py_CLEAR(state->type_AllJoynSessionMemberAddedEventArgs);
        Py_CLEAR(state->type_AllJoynSessionMemberRemovedEventArgs);
        Py_CLEAR(state->type_AllJoynStatus);
        Py_CLEAR(state->type_AllJoynWatcherStoppedEventArgs);
        Py_CLEAR(state->type_IAllJoynAcceptSessionJoiner);
        Py_CLEAR(state->type_IAllJoynProducer);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_Devices_AllJoyn",
           module_doc,
           sizeof(module_state),
           nullptr,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::AllJoyn

PyMODINIT_FUNC PyInit__winrt_Windows_Devices_AllJoyn(void) noexcept
{
    using namespace py::cpp::Windows::Devices::AllJoyn;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    WINRT_ASSERT(state);

    state->type_AllJoynAboutData = py::register_python_type(module.get(), type_name_AllJoynAboutData, &type_spec_AllJoynAboutData, object_bases.get(), nullptr);
    if (!state->type_AllJoynAboutData)
    {
        return nullptr;
    }

    state->type_AllJoynAboutDataView = py::register_python_type(module.get(), type_name_AllJoynAboutDataView, &type_spec_AllJoynAboutDataView, object_bases.get(), nullptr);
    if (!state->type_AllJoynAboutDataView)
    {
        return nullptr;
    }

    state->type_AllJoynAcceptSessionJoinerEventArgs = py::register_python_type(module.get(), type_name_AllJoynAcceptSessionJoinerEventArgs, &type_spec_AllJoynAcceptSessionJoinerEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynAcceptSessionJoinerEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynAuthenticationCompleteEventArgs = py::register_python_type(module.get(), type_name_AllJoynAuthenticationCompleteEventArgs, &type_spec_AllJoynAuthenticationCompleteEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynAuthenticationCompleteEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynBusAttachment = py::register_python_type(module.get(), type_name_AllJoynBusAttachment, &type_spec_AllJoynBusAttachment, object_bases.get(), nullptr);
    if (!state->type_AllJoynBusAttachment)
    {
        return nullptr;
    }

    state->type_AllJoynBusAttachmentStateChangedEventArgs = py::register_python_type(module.get(), type_name_AllJoynBusAttachmentStateChangedEventArgs, &type_spec_AllJoynBusAttachmentStateChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynBusAttachmentStateChangedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynBusObject = py::register_python_type(module.get(), type_name_AllJoynBusObject, &type_spec_AllJoynBusObject, object_bases.get(), nullptr);
    if (!state->type_AllJoynBusObject)
    {
        return nullptr;
    }

    state->type_AllJoynBusObjectStoppedEventArgs = py::register_python_type(module.get(), type_name_AllJoynBusObjectStoppedEventArgs, &type_spec_AllJoynBusObjectStoppedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynBusObjectStoppedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynCredentials = py::register_python_type(module.get(), type_name_AllJoynCredentials, &type_spec_AllJoynCredentials, object_bases.get(), nullptr);
    if (!state->type_AllJoynCredentials)
    {
        return nullptr;
    }

    state->type_AllJoynCredentialsRequestedEventArgs = py::register_python_type(module.get(), type_name_AllJoynCredentialsRequestedEventArgs, &type_spec_AllJoynCredentialsRequestedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynCredentialsRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynCredentialsVerificationRequestedEventArgs = py::register_python_type(module.get(), type_name_AllJoynCredentialsVerificationRequestedEventArgs, &type_spec_AllJoynCredentialsVerificationRequestedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynCredentialsVerificationRequestedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynMessageInfo = py::register_python_type(module.get(), type_name_AllJoynMessageInfo, &type_spec_AllJoynMessageInfo, object_bases.get(), nullptr);
    if (!state->type_AllJoynMessageInfo)
    {
        return nullptr;
    }

    state->type_AllJoynProducerStoppedEventArgs = py::register_python_type(module.get(), type_name_AllJoynProducerStoppedEventArgs, &type_spec_AllJoynProducerStoppedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynProducerStoppedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynServiceInfo = py::register_python_type(module.get(), type_name_AllJoynServiceInfo, &type_spec_AllJoynServiceInfo, object_bases.get(), nullptr);
    if (!state->type_AllJoynServiceInfo)
    {
        return nullptr;
    }

    state->type_AllJoynServiceInfoRemovedEventArgs = py::register_python_type(module.get(), type_name_AllJoynServiceInfoRemovedEventArgs, &type_spec_AllJoynServiceInfoRemovedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynServiceInfoRemovedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynSession = py::register_python_type(module.get(), type_name_AllJoynSession, &type_spec_AllJoynSession, object_bases.get(), nullptr);
    if (!state->type_AllJoynSession)
    {
        return nullptr;
    }

    state->type_AllJoynSessionJoinedEventArgs = py::register_python_type(module.get(), type_name_AllJoynSessionJoinedEventArgs, &type_spec_AllJoynSessionJoinedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynSessionJoinedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynSessionLostEventArgs = py::register_python_type(module.get(), type_name_AllJoynSessionLostEventArgs, &type_spec_AllJoynSessionLostEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynSessionLostEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynSessionMemberAddedEventArgs = py::register_python_type(module.get(), type_name_AllJoynSessionMemberAddedEventArgs, &type_spec_AllJoynSessionMemberAddedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynSessionMemberAddedEventArgs)
    {
        return nullptr;
    }

    state->type_AllJoynSessionMemberRemovedEventArgs = py::register_python_type(module.get(), type_name_AllJoynSessionMemberRemovedEventArgs, &type_spec_AllJoynSessionMemberRemovedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynSessionMemberRemovedEventArgs)
    {
        return nullptr;
    }

    py::pyobj_handle type_AllJoynStatus_Meta{PyType_FromSpec(&type_spec_AllJoynStatus_Meta)};
    if (!type_AllJoynStatus_Meta)
    {
        return nullptr;
    }

    state->type_AllJoynStatus = py::register_python_type(module.get(), type_name_AllJoynStatus, &type_spec_AllJoynStatus, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AllJoynStatus_Meta.get()));
    if (!state->type_AllJoynStatus)
    {
        return nullptr;
    }

    state->type_AllJoynWatcherStoppedEventArgs = py::register_python_type(module.get(), type_name_AllJoynWatcherStoppedEventArgs, &type_spec_AllJoynWatcherStoppedEventArgs, object_bases.get(), nullptr);
    if (!state->type_AllJoynWatcherStoppedEventArgs)
    {
        return nullptr;
    }

    state->type_IAllJoynAcceptSessionJoiner = py::register_python_type(module.get(), type_name_IAllJoynAcceptSessionJoiner, &type_spec_IAllJoynAcceptSessionJoiner, object_bases.get(), nullptr);
    if (!state->type_IAllJoynAcceptSessionJoiner)
    {
        return nullptr;
    }

    state->type_IAllJoynProducer = py::register_python_type(module.get(), type_name_IAllJoynProducer, &type_spec_IAllJoynProducer, object_bases.get(), nullptr);
    if (!state->type_IAllJoynProducer)
    {
        return nullptr;
    }


    return module.detach();
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynAboutData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynAboutData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynAboutDataView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynAboutDataView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynAcceptSessionJoinerEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynAcceptSessionJoinerEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynAuthenticationCompleteEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynAuthenticationCompleteEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynBusAttachment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynBusAttachment is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynBusAttachmentStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynBusAttachmentStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynBusObject>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynBusObject;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynBusObject is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynBusObjectStoppedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynBusObjectStoppedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentials>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynCredentials;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynCredentials is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynCredentialsRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynCredentialsRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynCredentialsVerificationRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynCredentialsVerificationRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynMessageInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynMessageInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynProducerStoppedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynProducerStoppedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynServiceInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynServiceInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynServiceInfoRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynServiceInfoRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynSessionJoinedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynSessionJoinedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynSessionLostEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynSessionLostEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynSessionMemberAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynSessionMemberRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynSessionMemberRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AllJoynWatcherStoppedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::AllJoynWatcherStoppedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAllJoynAcceptSessionJoiner;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::IAllJoynAcceptSessionJoiner is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::AllJoyn::IAllJoynProducer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::AllJoyn;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::AllJoyn");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAllJoynProducer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::AllJoyn::IAllJoynProducer is not registered");
        return nullptr;
    }

    return python_type;
}
