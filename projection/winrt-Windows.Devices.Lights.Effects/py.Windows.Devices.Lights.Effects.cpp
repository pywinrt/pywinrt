// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Devices.Lights.Effects.h"


namespace py::cpp::Windows::Devices::Lights::Effects
{
    // ----- LampArrayBitmapEffect class --------------------

    static PyObject* _new_LampArrayBitmapEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBitmapEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayBitmapEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"UpdateInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"UpdateInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_SuggestedBitmapSize(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"SuggestedBitmapSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuggestedBitmapSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_add_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"BitmapRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect, winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>>(arg);

            return py::convert(self->obj.BitmapRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_remove_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapEffect", L"BitmapRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BitmapRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LampArrayBitmapEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayBitmapEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapEffect[] = {
        { "add_bitmap_requested", reinterpret_cast<PyCFunction>(LampArrayBitmapEffect_add_BitmapRequested), METH_O, nullptr },
        { "remove_bitmap_requested", reinterpret_cast<PyCFunction>(LampArrayBitmapEffect_remove_BitmapRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LampArrayBitmapEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBitmapEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBitmapEffect[] = {
        { "update_interval", reinterpret_cast<getter>(LampArrayBitmapEffect_get_UpdateInterval), reinterpret_cast<setter>(LampArrayBitmapEffect_put_UpdateInterval), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArrayBitmapEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayBitmapEffect_put_StartDelay), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArrayBitmapEffect_get_Duration), reinterpret_cast<setter>(LampArrayBitmapEffect_put_Duration), nullptr, nullptr },
        { "suggested_bitmap_size", reinterpret_cast<getter>(LampArrayBitmapEffect_get_SuggestedBitmapSize), nullptr, nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayBitmapEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayBitmapEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBitmapEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayBitmapEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayBitmapEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayBitmapEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayBitmapEffect) },
        { },
    };

    static PyType_Spec type_spec_LampArrayBitmapEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayBitmapEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapEffect
    };

    // ----- LampArrayBitmapRequestedEventArgs class --------------------

    static PyObject* _new_LampArrayBitmapRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LampArrayBitmapRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_UpdateBitmap(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapRequestedEventArgs", L"UpdateBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.UpdateBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBitmapRequestedEventArgs", L"SinceStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LampArrayBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapRequestedEventArgs[] = {
        { "update_bitmap", reinterpret_cast<PyCFunction>(LampArrayBitmapRequestedEventArgs_UpdateBitmap), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LampArrayBitmapRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBitmapRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBitmapRequestedEventArgs[] = {
        { "since_started", reinterpret_cast<getter>(LampArrayBitmapRequestedEventArgs_get_SinceStarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBitmapRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayBitmapRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayBitmapRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayBitmapRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayBitmapRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LampArrayBitmapRequestedEventArgs =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayBitmapRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapRequestedEventArgs
    };

    // ----- LampArrayBlinkEffect class --------------------

    static PyObject* _new_LampArrayBlinkEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBlinkEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayBlinkEffect_get_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"SustainDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SustainDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"SustainDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SustainDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"RepetitionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"RepetitionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"RepetitionDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepetitionDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"RepetitionDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepetitionDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"Occurrences"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"Occurrences"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"DecayDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecayDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"DecayDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecayDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"AttackDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AttackDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"AttackDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AttackDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayBlinkEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LampArrayBlinkEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayBlinkEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBlinkEffect[] = {
        { "_assign_array_", _assign_array_LampArrayBlinkEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBlinkEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBlinkEffect[] = {
        { "sustain_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_SustainDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_SustainDuration), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArrayBlinkEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayBlinkEffect_put_StartDelay), nullptr, nullptr },
        { "repetition_mode", reinterpret_cast<getter>(LampArrayBlinkEffect_get_RepetitionMode), reinterpret_cast<setter>(LampArrayBlinkEffect_put_RepetitionMode), nullptr, nullptr },
        { "repetition_delay", reinterpret_cast<getter>(LampArrayBlinkEffect_get_RepetitionDelay), reinterpret_cast<setter>(LampArrayBlinkEffect_put_RepetitionDelay), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(LampArrayBlinkEffect_get_Occurrences), reinterpret_cast<setter>(LampArrayBlinkEffect_put_Occurrences), nullptr, nullptr },
        { "decay_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_DecayDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_DecayDuration), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArrayBlinkEffect_get_Color), reinterpret_cast<setter>(LampArrayBlinkEffect_put_Color), nullptr, nullptr },
        { "attack_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_AttackDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_AttackDuration), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayBlinkEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayBlinkEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBlinkEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayBlinkEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayBlinkEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayBlinkEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayBlinkEffect) },
        { },
    };

    static PyType_Spec type_spec_LampArrayBlinkEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayBlinkEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBlinkEffect
    };

    // ----- LampArrayColorRampEffect class --------------------

    static PyObject* _new_LampArrayColorRampEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayColorRampEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayColorRampEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"RampDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RampDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"RampDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RampDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"CompletionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"CompletionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayColorRampEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LampArrayColorRampEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayColorRampEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayColorRampEffect[] = {
        { "_assign_array_", _assign_array_LampArrayColorRampEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayColorRampEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayColorRampEffect[] = {
        { "start_delay", reinterpret_cast<getter>(LampArrayColorRampEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayColorRampEffect_put_StartDelay), nullptr, nullptr },
        { "ramp_duration", reinterpret_cast<getter>(LampArrayColorRampEffect_get_RampDuration), reinterpret_cast<setter>(LampArrayColorRampEffect_put_RampDuration), nullptr, nullptr },
        { "completion_behavior", reinterpret_cast<getter>(LampArrayColorRampEffect_get_CompletionBehavior), reinterpret_cast<setter>(LampArrayColorRampEffect_put_CompletionBehavior), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArrayColorRampEffect_get_Color), reinterpret_cast<setter>(LampArrayColorRampEffect_put_Color), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayColorRampEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayColorRampEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayColorRampEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayColorRampEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayColorRampEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayColorRampEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayColorRampEffect) },
        { },
    };

    static PyType_Spec type_spec_LampArrayColorRampEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayColorRampEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayColorRampEffect
    };

    // ----- LampArrayCustomEffect class --------------------

    static PyObject* _new_LampArrayCustomEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayCustomEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayCustomEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"UpdateInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"UpdateInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_add_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"UpdateRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect, winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.UpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayCustomEffect_remove_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Lights.Effects.LampArrayCustomEffect", L"UpdateRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LampArrayCustomEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayCustomEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayCustomEffect[] = {
        { "add_update_requested", reinterpret_cast<PyCFunction>(LampArrayCustomEffect_add_UpdateRequested), METH_O, nullptr },
        { "remove_update_requested", reinterpret_cast<PyCFunction>(LampArrayCustomEffect_remove_UpdateRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LampArrayCustomEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayCustomEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayCustomEffect[] = {
        { "update_interval", reinterpret_cast<getter>(LampArrayCustomEffect_get_UpdateInterval), reinterpret_cast<setter>(LampArrayCustomEffect_put_UpdateInterval), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArrayCustomEffect_get_Duration), reinterpret_cast<setter>(LampArrayCustomEffect_put_Duration), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayCustomEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayCustomEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayCustomEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayCustomEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayCustomEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayCustomEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayCustomEffect) },
        { },
    };

    static PyType_Spec type_spec_LampArrayCustomEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayCustomEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayCustomEffect
    };

    // ----- LampArrayEffectPlaylist class --------------------

    static PyObject* _new_LampArrayEffectPlaylist(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayEffectPlaylist_Append(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_First(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetAt(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetMany(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_IndexOf(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_OverrideZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"OverrideZIndex", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.OverrideZIndex(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Pause(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_PauseAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"PauseAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::PauseAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Start(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StartAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"StartAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StartAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Stop(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StopAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"StopAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StopAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"RepetitionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"RepetitionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Occurrences"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Occurrences"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"EffectStartMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectStartMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"EffectStartMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectStartMode>(arg);

            self->obj.EffectStartMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Size(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayEffectPlaylist", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LampArrayEffectPlaylist(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayEffectPlaylist(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_LampArrayEffectPlaylist(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayEffectPlaylist[] = {
        { "append", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Append), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_IndexOf), METH_VARARGS, nullptr },
        { "override_z_index", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_OverrideZIndex), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Pause), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LampArrayEffectPlaylist, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayEffectPlaylist), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayEffectPlaylist[] = {
        { "repetition_mode", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_RepetitionMode), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_RepetitionMode), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_Occurrences), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_Occurrences), nullptr, nullptr },
        { "effect_start_mode", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_EffectStartMode), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_EffectStartMode), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayEffectPlaylist[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayEffectPlaylist) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayEffectPlaylist) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayEffectPlaylist) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayEffectPlaylist) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_LampArrayEffectPlaylist) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_LampArrayEffectPlaylist) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_LampArrayEffectPlaylist) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_LampArrayEffectPlaylist) },
        { },
    };

    static PyType_Spec type_spec_LampArrayEffectPlaylist =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayEffectPlaylist",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayEffectPlaylist
    };

    static PyGetSetDef getset_LampArrayEffectPlaylist_Static[] = {
        { }
    };

    static PyMethodDef methods_LampArrayEffectPlaylist_Static[] = {
        { "pause_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_PauseAll), METH_VARARGS, nullptr },
        { "start_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_StartAll), METH_VARARGS, nullptr },
        { "stop_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_StopAll), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LampArrayEffectPlaylist_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LampArrayEffectPlaylist_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LampArrayEffectPlaylist_Static) },
        { }
    };

    static PyType_Spec type_spec_LampArrayEffectPlaylist_Static =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayEffectPlaylist_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LampArrayEffectPlaylist_Static
    };

    // ----- LampArraySolidEffect class --------------------

    static PyObject* _new_LampArraySolidEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArraySolidEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArraySolidEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"StartDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"CompletionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"CompletionBehavior"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArraySolidEffect", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LampArraySolidEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArraySolidEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArraySolidEffect[] = {
        { "_assign_array_", _assign_array_LampArraySolidEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArraySolidEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArraySolidEffect[] = {
        { "z_index", reinterpret_cast<getter>(LampArraySolidEffect_get_ZIndex), reinterpret_cast<setter>(LampArraySolidEffect_put_ZIndex), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArraySolidEffect_get_StartDelay), reinterpret_cast<setter>(LampArraySolidEffect_put_StartDelay), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArraySolidEffect_get_Duration), reinterpret_cast<setter>(LampArraySolidEffect_put_Duration), nullptr, nullptr },
        { "completion_behavior", reinterpret_cast<getter>(LampArraySolidEffect_get_CompletionBehavior), reinterpret_cast<setter>(LampArraySolidEffect_put_CompletionBehavior), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArraySolidEffect_get_Color), reinterpret_cast<setter>(LampArraySolidEffect_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArraySolidEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArraySolidEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArraySolidEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArraySolidEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArraySolidEffect) },
        { },
    };

    static PyType_Spec type_spec_LampArraySolidEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArraySolidEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArraySolidEffect
    };

    // ----- LampArrayUpdateRequestedEventArgs class --------------------

    static PyObject* _new_LampArrayUpdateRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LampArrayUpdateRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColor(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayUpdateRequestedEventArgs", L"SetColor", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                self->obj.SetColor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorForIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayUpdateRequestedEventArgs", L"SetColorForIndex", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.SetColorForIndex(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorsForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayUpdateRequestedEventArgs", L"SetColorsForIndices", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Color, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                self->obj.SetColorsForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Lights.Effects.LampArrayUpdateRequestedEventArgs", L"SetSingleColorForIndices", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<int32_t, false>>(args, 1);

                self->obj.SetSingleColorForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.LampArrayUpdateRequestedEventArgs", L"SinceStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LampArrayUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LampArrayUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayUpdateRequestedEventArgs[] = {
        { "set_color", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColor), METH_VARARGS, nullptr },
        { "set_color_for_index", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColorForIndex), METH_VARARGS, nullptr },
        { "set_colors_for_indices", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColorsForIndices), METH_VARARGS, nullptr },
        { "set_single_color_for_indices", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LampArrayUpdateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayUpdateRequestedEventArgs[] = {
        { "since_started", reinterpret_cast<getter>(LampArrayUpdateRequestedEventArgs_get_SinceStarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LampArrayUpdateRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LampArrayUpdateRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LampArrayUpdateRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LampArrayUpdateRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LampArrayUpdateRequestedEventArgs =
    {
        "winrt._winrt_windows_devices_lights_effects.LampArrayUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayUpdateRequestedEventArgs
    };

    // ----- ILampArrayEffect interface --------------------

    static PyObject* _new_ILampArrayEffect(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::type_name);
        return nullptr;
    }

    static void _dealloc_ILampArrayEffect(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILampArrayEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.ILampArrayEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILampArrayEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Lights.Effects.ILampArrayEffect", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ILampArrayEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ILampArrayEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILampArrayEffect[] = {
        { "_assign_array_", _assign_array_ILampArrayEffect, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILampArrayEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILampArrayEffect[] = {
        { "z_index", reinterpret_cast<getter>(ILampArrayEffect_get_ZIndex), reinterpret_cast<setter>(ILampArrayEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILampArrayEffect[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ILampArrayEffect) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ILampArrayEffect) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ILampArrayEffect) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ILampArrayEffect) },
        { },
    };

    static PyType_Spec type_spec_ILampArrayEffect =
    {
        "winrt._winrt_windows_devices_lights_effects.ILampArrayEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILampArrayEffect
    };

    // ----- Windows.Devices.Lights.Effects Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Lights::Effects");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_devices_lights_effects",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Devices::Lights::Effects

PyMODINIT_FUNC PyInit__winrt_windows_devices_lights_effects(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Lights::Effects;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayBitmapEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayBitmapRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayBlinkEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayColorRampEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayCustomEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LampArrayEffectPlaylist_Static{PyType_FromSpec(&type_spec_LampArrayEffectPlaylist_Static)};
    if (!type_LampArrayEffectPlaylist_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayEffectPlaylist, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LampArrayEffectPlaylist_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArraySolidEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LampArrayUpdateRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ILampArrayEffect, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
