// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Gaming.Input.Custom.h"


namespace py::cpp::Windows::Gaming::Input::Custom
{
    // ----- GameControllerFactoryManager class --------------------

    static PyObject* _new_GameControllerFactoryManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::type_name);
        return nullptr;
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForGipInterface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForGipInterface", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForGipInterface(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForHardwareId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForHardwareId", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForHardwareId(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForXusbType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForXusbType", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForXusbType(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_TryGetFactoryControllerFromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"TryGetFactoryControllerFromGameController", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 1);

                return py::convert(winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::TryGetFactoryControllerFromGameController(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameControllerFactoryManager[] = {
        { }
    };

    static PyGetSetDef _getset_GameControllerFactoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GameControllerFactoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerFactoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameControllerFactoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerFactoryManager) },
        { },
    };

    static PyType_Spec type_spec_GameControllerFactoryManager =
    {
        "winrt._winrt_windows_gaming_input_custom.GameControllerFactoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerFactoryManager
    };

    static PyGetSetDef getset_GameControllerFactoryManager_Static[] = {
        { }
    };

    static PyMethodDef methods_GameControllerFactoryManager_Static[] = {
        { "register_custom_factory_for_gip_interface", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForGipInterface), METH_VARARGS, nullptr },
        { "register_custom_factory_for_hardware_id", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForHardwareId), METH_VARARGS, nullptr },
        { "register_custom_factory_for_xusb_type", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForXusbType), METH_VARARGS, nullptr },
        { "try_get_factory_controller_from_game_controller", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_TryGetFactoryControllerFromGameController), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GameControllerFactoryManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GameControllerFactoryManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GameControllerFactoryManager_Static) },
        { }
    };

    static PyType_Spec type_spec_GameControllerFactoryManager_Static =
    {
        "winrt._winrt_windows_gaming_input_custom.GameControllerFactoryManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GameControllerFactoryManager_Static
    };

    // ----- GipFirmwareUpdateResult class --------------------

    static PyObject* _new_GipFirmwareUpdateResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GipFirmwareUpdateResult(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipFirmwareUpdateResult_get_ExtendedErrorCode(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"ExtendedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_FinalComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"FinalComponentId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FinalComponentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_Status(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipFirmwareUpdateResult[] = {
        { "_assign_array_", _assign_array_GipFirmwareUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipFirmwareUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipFirmwareUpdateResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "final_component_id", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_FinalComponentId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipFirmwareUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateResult) },
        { },
    };

    static PyType_Spec type_spec_GipFirmwareUpdateResult =
    {
        "winrt._winrt_windows_gaming_input_custom.GipFirmwareUpdateResult",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateResult
    };

    // ----- GipGameControllerProvider class --------------------

    static PyObject* _new_GipGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_GipGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipGameControllerProvider_SendMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendMessage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.SendMessage(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_SendReceiveMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendReceiveMessage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 3);

                self->obj.SendReceiveMessage(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_UpdateFirmwareAsync(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"UpdateFirmwareAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.UpdateFirmwareAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipGameControllerProvider[] = {
        { "send_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendMessage), METH_VARARGS, nullptr },
        { "send_receive_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendReceiveMessage), METH_VARARGS, nullptr },
        { "update_firmware_async", reinterpret_cast<PyCFunction>(GipGameControllerProvider_UpdateFirmwareAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GipGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(GipGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_GipGameControllerProvider =
    {
        "winrt._winrt_windows_gaming_input_custom.GipGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipGameControllerProvider
    };

    // ----- HidGameControllerProvider class --------------------

    static PyObject* _new_HidGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_HidGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidGameControllerProvider_GetFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"GetFeatureReport", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 1);

                self->obj.GetFeatureReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendFeatureReport", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                self->obj.SendFeatureReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendOutputReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendOutputReport", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                self->obj.SendOutputReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsageId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsagePage(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsagePage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidGameControllerProvider[] = {
        { "get_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_GetFeatureReport), METH_VARARGS, nullptr },
        { "send_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendFeatureReport), METH_VARARGS, nullptr },
        { "send_output_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendOutputReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(HidGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidGameControllerProvider_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidGameControllerProvider_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_HidGameControllerProvider =
    {
        "winrt._winrt_windows_gaming_input_custom.HidGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidGameControllerProvider
    };

    // ----- XusbGameControllerProvider class --------------------

    static PyObject* _new_XusbGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_XusbGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XusbGameControllerProvider_SetVibration(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"SetVibration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetVibration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XusbGameControllerProvider[] = {
        { "set_vibration", reinterpret_cast<PyCFunction>(XusbGameControllerProvider_SetVibration), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XusbGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XusbGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XusbGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(XusbGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XusbGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XusbGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XusbGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XusbGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XusbGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_XusbGameControllerProvider =
    {
        "winrt._winrt_windows_gaming_input_custom.XusbGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XusbGameControllerProvider
    };

    // ----- ICustomGameControllerFactory interface --------------------

    static PyObject* _new_ICustomGameControllerFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomGameControllerFactory(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomGameControllerFactory_CreateGameController(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"CreateGameController", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>(args, 0);

                return py::convert(self->obj.CreateGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerAdded(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerAdded", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerAdded(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerRemoved(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerRemoved", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerRemoved(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomGameControllerFactory[] = {
        { "create_game_controller", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_CreateGameController), METH_VARARGS, nullptr },
        { "on_game_controller_added", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerAdded), METH_VARARGS, nullptr },
        { "on_game_controller_removed", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerRemoved), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomGameControllerFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomGameControllerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomGameControllerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ICustomGameControllerFactory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomGameControllerFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomGameControllerFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomGameControllerFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomGameControllerFactory) },
        { },
    };

    static PyType_Spec type_spec_ICustomGameControllerFactory =
    {
        "winrt._winrt_windows_gaming_input_custom.ICustomGameControllerFactory",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomGameControllerFactory
    };

    // ----- IGameControllerInputSink interface --------------------

    static PyObject* _new_IGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IGameControllerInputSink =
    {
        "winrt._winrt_windows_gaming_input_custom.IGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerInputSink
    };

    // ----- IGameControllerProvider interface --------------------

    static PyObject* _new_IGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"FirmwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareProductId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVendorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerProvider[] = {
        { "_assign_array_", _assign_array_IGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(IGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameControllerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerProvider) },
        { },
    };

    static PyType_Spec type_spec_IGameControllerProvider =
    {
        "winrt._winrt_windows_gaming_input_custom.IGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerProvider
    };

    // ----- IGipGameControllerInputSink interface --------------------

    static PyObject* _new_IGipGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IGipGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGipGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnKeyReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnKeyReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.OnKeyReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnMessageReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnMessageReceived", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 4);

                self->obj.OnMessageReceived(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGipGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "on_key_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnKeyReceived), METH_VARARGS, nullptr },
        { "on_message_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnMessageReceived), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGipGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGipGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGipGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGipGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGipGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGipGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGipGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGipGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IGipGameControllerInputSink =
    {
        "winrt._winrt_windows_gaming_input_custom.IGipGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGipGameControllerInputSink
    };

    // ----- IHidGameControllerInputSink interface --------------------

    static PyObject* _new_IHidGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IHidGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IHidGameControllerInputSink_OnInputReportReceived(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IHidGameControllerInputSink", L"OnInputReportReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnInputReportReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHidGameControllerInputSink[] = {
        { "on_input_report_received", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputReportReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IHidGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHidGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IHidGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IHidGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IHidGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IHidGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IHidGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IHidGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IHidGameControllerInputSink =
    {
        "winrt._winrt_windows_gaming_input_custom.IHidGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHidGameControllerInputSink
    };

    // ----- IXusbGameControllerInputSink interface --------------------

    static PyObject* _new_IXusbGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IXusbGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXusbGameControllerInputSink_OnInputReceived(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IXusbGameControllerInputSink", L"OnInputReceived", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                self->obj.OnInputReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXusbGameControllerInputSink[] = {
        { "on_input_received", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXusbGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXusbGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXusbGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IXusbGameControllerInputSink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXusbGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXusbGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXusbGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXusbGameControllerInputSink) },
        { },
    };

    static PyType_Spec type_spec_IXusbGameControllerInputSink =
    {
        "winrt._winrt_windows_gaming_input_custom.IXusbGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXusbGameControllerInputSink
    };

    // ----- GameControllerVersionInfo struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>* _new_GameControllerVersionInfo(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GameControllerVersionInfo(winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return -1;
        }

        try
        {
            self->obj = {_Major, _Minor, _Build, _Revision};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GameControllerVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GameControllerVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GameControllerVersionInfo[] = {
        { "_assign_array_", _assign_array_GameControllerVersionInfo, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GameControllerVersionInfo_get_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GameControllerVersionInfo[] = {
        { "major", reinterpret_cast<getter>(GameControllerVersionInfo_get_Major), reinterpret_cast<setter>(GameControllerVersionInfo_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(GameControllerVersionInfo_get_Minor), reinterpret_cast<setter>(GameControllerVersionInfo_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(GameControllerVersionInfo_get_Build), reinterpret_cast<setter>(GameControllerVersionInfo_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(GameControllerVersionInfo_get_Revision), reinterpret_cast<setter>(GameControllerVersionInfo_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameControllerVersionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerVersionInfo) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GameControllerVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameControllerVersionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameControllerVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerVersionInfo) },
        { },
    };

    static PyType_Spec type_spec_GameControllerVersionInfo =
    {
        "winrt._winrt_windows_gaming_input_custom.GameControllerVersionInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerVersionInfo
    };

    // ----- GipFirmwareUpdateProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>* _new_GipFirmwareUpdateProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GipFirmwareUpdateProgress(winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _PercentCompleted{};
        uint32_t _CurrentComponentId{};

        static const char* kwlist[] = {"percent_completed", "current_component_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dI", const_cast<char**>(kwlist), &_PercentCompleted, &_CurrentComponentId))
        {
            return -1;
        }

        try
        {
            self->obj = {_PercentCompleted, _CurrentComponentId};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GipFirmwareUpdateProgress(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GipFirmwareUpdateProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GipFirmwareUpdateProgress[] = {
        { "_assign_array_", _assign_array_GipFirmwareUpdateProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GipFirmwareUpdateProgress_get_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentCompleted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentCompleted = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GipFirmwareUpdateProgress_get_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentComponentId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.CurrentComponentId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GipFirmwareUpdateProgress[] = {
        { "percent_completed", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_PercentCompleted), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_PercentCompleted), nullptr, nullptr },
        { "current_component_id", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_CurrentComponentId), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_CurrentComponentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateProgress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GipFirmwareUpdateProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipFirmwareUpdateProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateProgress) },
        { },
    };

    static PyType_Spec type_spec_GipFirmwareUpdateProgress =
    {
        "winrt._winrt_windows_gaming_input_custom.GipFirmwareUpdateProgress",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateProgress
    };

    // ----- Windows.Gaming.Input.Custom Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Gaming::Input::Custom");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_gaming_input_custom",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Gaming::Input::Custom

PyMODINIT_FUNC PyInit__winrt_windows_gaming_input_custom(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GameControllerFactoryManager_Static{PyType_FromSpec(&type_spec_GameControllerFactoryManager_Static)};
    if (!type_GameControllerFactoryManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameControllerFactoryManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GameControllerFactoryManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GipFirmwareUpdateResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GipGameControllerProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HidGameControllerProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XusbGameControllerProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICustomGameControllerFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGameControllerInputSink, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGameControllerProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGipGameControllerInputSink, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IHidGameControllerInputSink, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IXusbGameControllerInputSink, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GameControllerVersionInfo, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GipFirmwareUpdateProgress, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
