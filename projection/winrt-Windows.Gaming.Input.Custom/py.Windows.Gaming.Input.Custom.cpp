// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Gaming.Input.Custom.h"

namespace py::cpp::Windows::Gaming::Input::Custom
{
    // ----- GameControllerFactoryManager class --------------------

    static PyObject* _new_GameControllerFactoryManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::type_name);
        return nullptr;
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForGipInterface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForGipInterface", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForGipInterface(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForHardwareId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForHardwareId", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForHardwareId(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForXusbType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"RegisterCustomFactoryForXusbType", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype>(args, 2);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForXusbType(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_TryGetFactoryControllerFromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GameControllerFactoryManager", L"TryGetFactoryControllerFromGameController", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::TryGetFactoryControllerFromGameController(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameControllerFactoryManager[] = {
        { }};

    static PyGetSetDef _getset_GameControllerFactoryManager[] = {
        { }};

    static PyType_Slot _type_slots_GameControllerFactoryManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerFactoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameControllerFactoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerFactoryManager) },
        { }};

    static PyType_Spec type_spec_GameControllerFactoryManager = {
        "winrt._winrt_windows_gaming_input_custom.GameControllerFactoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerFactoryManager};

    static PyGetSetDef getset_GameControllerFactoryManager_Static[] = {
        { }};

    static PyMethodDef methods_GameControllerFactoryManager_Static[] = {
        { "register_custom_factory_for_gip_interface", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForGipInterface), METH_VARARGS, nullptr },
        { "register_custom_factory_for_hardware_id", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForHardwareId), METH_VARARGS, nullptr },
        { "register_custom_factory_for_xusb_type", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForXusbType), METH_VARARGS, nullptr },
        { "try_get_factory_controller_from_game_controller", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_TryGetFactoryControllerFromGameController), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_GameControllerFactoryManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GameControllerFactoryManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GameControllerFactoryManager_Static) },
        { }
    };

    static PyType_Spec type_spec_GameControllerFactoryManager_Static = {
        "winrt._winrt_windows_gaming_input_custom.GameControllerFactoryManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GameControllerFactoryManager_Static};

    // ----- GipFirmwareUpdateResult class --------------------

    static PyObject* _new_GipFirmwareUpdateResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::type_name);
        return nullptr;
    }

    static void _dealloc_GipFirmwareUpdateResult(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipFirmwareUpdateResult_get_ExtendedErrorCode(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"ExtendedErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_FinalComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"FinalComponentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FinalComponentId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_Status(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipFirmwareUpdateResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipFirmwareUpdateResult[] = {
        { "_assign_array_", _assign_array_GipFirmwareUpdateResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipFirmwareUpdateResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GipFirmwareUpdateResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "final_component_id", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_FinalComponentId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GipFirmwareUpdateResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipFirmwareUpdateResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateResult) },
        { }};

    static PyType_Spec type_spec_GipFirmwareUpdateResult = {
        "winrt._winrt_windows_gaming_input_custom.GipFirmwareUpdateResult",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateResult};

    // ----- GipGameControllerProvider class --------------------

    static PyObject* _new_GipGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_GipGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GipGameControllerProvider_SendMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendMessage", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.SendMessage(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_SendReceiveMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"SendReceiveMessage", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);
                auto param3 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 3);

                {
                    auto _gil = release_gil();
                    self->obj.SendReceiveMessage(param0, param1, param2, param3);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_UpdateFirmwareAsync(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"UpdateFirmwareAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UpdateFirmwareAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"FirmwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FirmwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"HardwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.GipGameControllerProvider", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipGameControllerProvider[] = {
        { "send_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendMessage), METH_VARARGS, nullptr },
        { "send_receive_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendReceiveMessage), METH_VARARGS, nullptr },
        { "update_firmware_async", reinterpret_cast<PyCFunction>(GipGameControllerProvider_UpdateFirmwareAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GipGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GipGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(GipGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GipGameControllerProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipGameControllerProvider) },
        { }};

    static PyType_Spec type_spec_GipGameControllerProvider = {
        "winrt._winrt_windows_gaming_input_custom.GipGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipGameControllerProvider};

    // ----- HidGameControllerProvider class --------------------

    static PyObject* _new_HidGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_HidGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HidGameControllerProvider_GetFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"GetFeatureReport", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.GetFeatureReport(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendFeatureReport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SendFeatureReport(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendOutputReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"SendOutputReport", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SendOutputReport(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"FirmwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FirmwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"HardwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsageId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsagePage(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.HidGameControllerProvider", L"UsagePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UsagePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidGameControllerProvider[] = {
        { "get_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_GetFeatureReport), METH_VARARGS, nullptr },
        { "send_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendFeatureReport), METH_VARARGS, nullptr },
        { "send_output_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendOutputReport), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HidGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HidGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(HidGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidGameControllerProvider_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidGameControllerProvider_get_UsagePage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HidGameControllerProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HidGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HidGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HidGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HidGameControllerProvider) },
        { }};

    static PyType_Spec type_spec_HidGameControllerProvider = {
        "winrt._winrt_windows_gaming_input_custom.HidGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidGameControllerProvider};

    // ----- XusbGameControllerProvider class --------------------

    static PyObject* _new_XusbGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_XusbGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XusbGameControllerProvider_SetVibration(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"SetVibration", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetVibration(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"FirmwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FirmwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"HardwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.XusbGameControllerProvider", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XusbGameControllerProvider[] = {
        { "set_vibration", reinterpret_cast<PyCFunction>(XusbGameControllerProvider_SetVibration), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XusbGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XusbGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XusbGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(XusbGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_XusbGameControllerProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XusbGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XusbGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XusbGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XusbGameControllerProvider) },
        { }};

    static PyType_Spec type_spec_XusbGameControllerProvider = {
        "winrt._winrt_windows_gaming_input_custom.XusbGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XusbGameControllerProvider};

    // ----- ICustomGameControllerFactory interface --------------------

    static PyObject* _new_ICustomGameControllerFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomGameControllerFactory(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomGameControllerFactory_CreateGameController(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"CreateGameController", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateGameController(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerAdded(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerAdded", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnGameControllerAdded(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerRemoved(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.ICustomGameControllerFactory", L"OnGameControllerRemoved", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnGameControllerRemoved(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomGameControllerFactory[] = {
        { "create_game_controller", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_CreateGameController), METH_VARARGS, nullptr },
        { "on_game_controller_added", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerAdded), METH_VARARGS, nullptr },
        { "on_game_controller_removed", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerRemoved), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomGameControllerFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomGameControllerFactory), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ICustomGameControllerFactory[] = {
        { }};

    static PyType_Slot _type_slots_ICustomGameControllerFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomGameControllerFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomGameControllerFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomGameControllerFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomGameControllerFactory) },
        { }};

    static PyType_Spec type_spec_ICustomGameControllerFactory = {
        "winrt._winrt_windows_gaming_input_custom.ICustomGameControllerFactory",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomGameControllerFactory};

    struct ImplementsICustomGameControllerFactory : py::ImplementsInterfaceT<ImplementsICustomGameControllerFactory, winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>
    {
        ImplementsICustomGameControllerFactory() = delete;
        ImplementsICustomGameControllerFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsICustomGameControllerFactory, winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(py_obj, runtime_class)
        {
        }

        auto CreateGameController(winrt::Windows::Gaming::Input::Custom::IGameControllerProvider const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_game_controller")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IInspectable>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnGameControllerAdded(winrt::Windows::Gaming::Input::IGameController const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_game_controller_added")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnGameControllerRemoved(winrt::Windows::Gaming::Input::IGameController const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_game_controller_removed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsICustomGameControllerFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsICustomGameControllerFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsICustomGameControllerFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsICustomGameControllerFactory[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsICustomGameControllerFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsICustomGameControllerFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsICustomGameControllerFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsICustomGameControllerFactory) },
        { }};

    static PyType_Spec type_spec_ImplementsICustomGameControllerFactory = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsICustomGameControllerFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsICustomGameControllerFactory};

    // ----- IGameControllerInputSink interface --------------------

    static PyObject* _new_IGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputResumed(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputSuspended(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IGameControllerInputSink[] = {
        { }};

    static PyType_Slot _type_slots_IGameControllerInputSink[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_IGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.IGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerInputSink};

    struct ImplementsIGameControllerInputSink : py::ImplementsInterfaceT<ImplementsIGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>
    {
        ImplementsIGameControllerInputSink() = delete;
        ImplementsIGameControllerInputSink(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>(py_obj, runtime_class)
        {
        }

        auto OnInputResumed(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_resumed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputSuspended(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_suspended")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIGameControllerInputSink(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGameControllerInputSink(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGameControllerInputSink>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGameControllerInputSink[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGameControllerInputSink), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGameControllerInputSink), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGameControllerInputSink[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_ImplementsIGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsIGameControllerInputSink",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGameControllerInputSink};

    // ----- IGameControllerProvider interface --------------------

    static PyObject* _new_IGameControllerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"FirmwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FirmwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareProductId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareProductId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVendorId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVendorId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"HardwareVersionInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardwareVersionInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Gaming.Input.Custom.IGameControllerProvider", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerProvider[] = {
        { "_assign_array_", _assign_array_IGameControllerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(IGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IGameControllerProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGameControllerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGameControllerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGameControllerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGameControllerProvider) },
        { }};

    static PyType_Spec type_spec_IGameControllerProvider = {
        "winrt._winrt_windows_gaming_input_custom.IGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerProvider};

    struct ImplementsIGameControllerProvider : py::ImplementsInterfaceT<ImplementsIGameControllerProvider, winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>
    {
        ImplementsIGameControllerProvider() = delete;
        ImplementsIGameControllerProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGameControllerProvider, winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>(py_obj, runtime_class)
        {
        }

        auto FirmwareVersionInfo()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "firmware_version_info")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HardwareProductId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "hardware_product_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint16_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HardwareVendorId()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "hardware_vendor_id")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<uint16_t>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HardwareVersionInfo()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "hardware_version_info")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto IsConnected()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "is_connected")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIGameControllerProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGameControllerProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGameControllerProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGameControllerProvider[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGameControllerProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGameControllerProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGameControllerProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGameControllerProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIGameControllerProvider = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsIGameControllerProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGameControllerProvider};

    // ----- IGipGameControllerInputSink interface --------------------

    static PyObject* _new_IGipGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IGipGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGipGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputResumed(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputSuspended(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnKeyReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnKeyReceived", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.OnKeyReceived(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnMessageReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGipGameControllerInputSink", L"OnMessageReceived", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 4);

                {
                    auto _gil = release_gil();
                    self->obj.OnMessageReceived(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGipGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "on_key_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnKeyReceived), METH_VARARGS, nullptr },
        { "on_message_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnMessageReceived), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGipGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGipGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IGipGameControllerInputSink[] = {
        { }};

    static PyType_Slot _type_slots_IGipGameControllerInputSink[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGipGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGipGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGipGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGipGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_IGipGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.IGipGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGipGameControllerInputSink};

    struct ImplementsIGipGameControllerInputSink : py::ImplementsInterfaceT<ImplementsIGipGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>
    {
        ImplementsIGipGameControllerInputSink() = delete;
        ImplementsIGipGameControllerInputSink(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIGipGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>(py_obj, runtime_class)
        {
        }

        auto OnInputResumed(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_resumed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputSuspended(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_suspended")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnKeyReceived(uint64_t param0, uint8_t param1, bool param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_key_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnMessageReceived(uint64_t param0, winrt::Windows::Gaming::Input::Custom::GipMessageClass param1, uint8_t param2, uint8_t param3, winrt::array_view<uint8_t const> param4)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_message_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param3{py::convert(param3)};
                if (!py_param3)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param4{py::convert(param4)};
                if (!py_param4)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(5, py_param0.get(), py_param1.get(), py_param2.get(), py_param3.get(), py_param4.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIGipGameControllerInputSink(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIGipGameControllerInputSink(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIGipGameControllerInputSink>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIGipGameControllerInputSink[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIGipGameControllerInputSink), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIGipGameControllerInputSink), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIGipGameControllerInputSink[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIGipGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_ImplementsIGipGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsIGipGameControllerInputSink",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIGipGameControllerInputSink};

    // ----- IHidGameControllerInputSink interface --------------------

    static PyObject* _new_IHidGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IHidGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IHidGameControllerInputSink_OnInputReportReceived(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IHidGameControllerInputSink", L"OnInputReportReceived", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputReportReceived(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputResumed(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputSuspended(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHidGameControllerInputSink[] = {
        { "on_input_report_received", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputReportReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IHidGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHidGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IHidGameControllerInputSink[] = {
        { }};

    static PyType_Slot _type_slots_IHidGameControllerInputSink[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IHidGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IHidGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IHidGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IHidGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_IHidGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.IHidGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHidGameControllerInputSink};

    struct ImplementsIHidGameControllerInputSink : py::ImplementsInterfaceT<ImplementsIHidGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>
    {
        ImplementsIHidGameControllerInputSink() = delete;
        ImplementsIHidGameControllerInputSink(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIHidGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>(py_obj, runtime_class)
        {
        }

        auto OnInputReportReceived(uint64_t param0, uint8_t param1, winrt::array_view<uint8_t const> param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_report_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputResumed(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_resumed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputSuspended(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_suspended")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIHidGameControllerInputSink(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIHidGameControllerInputSink(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIHidGameControllerInputSink>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIHidGameControllerInputSink[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIHidGameControllerInputSink), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIHidGameControllerInputSink), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIHidGameControllerInputSink[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIHidGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_ImplementsIHidGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsIHidGameControllerInputSink",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIHidGameControllerInputSink};

    // ----- IXusbGameControllerInputSink interface --------------------

    static PyObject* _new_IXusbGameControllerInputSink(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::type_name);
        return nullptr;
    }

    static void _dealloc_IXusbGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IXusbGameControllerInputSink_OnInputReceived(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IXusbGameControllerInputSink", L"OnInputReceived", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputReceived(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputResumed", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputResumed(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Gaming.Input.Custom.IGameControllerInputSink", L"OnInputSuspended", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnInputSuspended(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXusbGameControllerInputSink[] = {
        { "on_input_received", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IXusbGameControllerInputSink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXusbGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IXusbGameControllerInputSink[] = {
        { }};

    static PyType_Slot _type_slots_IXusbGameControllerInputSink[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IXusbGameControllerInputSink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IXusbGameControllerInputSink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IXusbGameControllerInputSink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IXusbGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_IXusbGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.IXusbGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXusbGameControllerInputSink};

    struct ImplementsIXusbGameControllerInputSink : py::ImplementsInterfaceT<ImplementsIXusbGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>
    {
        ImplementsIXusbGameControllerInputSink() = delete;
        ImplementsIXusbGameControllerInputSink(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIXusbGameControllerInputSink, winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>(py_obj, runtime_class)
        {
        }

        auto OnInputReceived(uint64_t param0, uint8_t param1, winrt::array_view<uint8_t const> param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param2{py::convert(param2)};
                if (!py_param2)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(3, py_param0.get(), py_param1.get(), py_param2.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputResumed(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_resumed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnInputSuspended(uint64_t param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_input_suspended")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIXusbGameControllerInputSink>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIXusbGameControllerInputSink[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIXusbGameControllerInputSink), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIXusbGameControllerInputSink), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIXusbGameControllerInputSink[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIXusbGameControllerInputSink) },
        { }};

    static PyType_Spec type_spec_ImplementsIXusbGameControllerInputSink = {
        "winrt._winrt_windows_gaming_input_custom.ImplementsIXusbGameControllerInputSink",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIXusbGameControllerInputSink};

    // ----- GameControllerVersionInfo struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>* _new_GameControllerVersionInfo(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GameControllerVersionInfo(winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return -1;
        }

        try
        {
            self->obj.Major = _Major;
            self->obj.Minor = _Minor;
            self->obj.Build = _Build;
            self->obj.Revision = _Revision;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GameControllerVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GameControllerVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GameControllerVersionInfo[] = {
        { "_assign_array_", _assign_array_GameControllerVersionInfo, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* GameControllerVersionInfo_get_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Major = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Minor = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Build = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Revision = py::convert_to<uint16_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GameControllerVersionInfo[] = {
        { "major", reinterpret_cast<getter>(GameControllerVersionInfo_get_Major), reinterpret_cast<setter>(GameControllerVersionInfo_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(GameControllerVersionInfo_get_Minor), reinterpret_cast<setter>(GameControllerVersionInfo_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(GameControllerVersionInfo_get_Build), reinterpret_cast<setter>(GameControllerVersionInfo_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(GameControllerVersionInfo_get_Revision), reinterpret_cast<setter>(GameControllerVersionInfo_set_Revision), nullptr, nullptr },
        { }};

    static PyObject* _richcompare_GameControllerVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GameControllerVersionInfo(PyObject* self) noexcept
    {
        py::pyobj_handle Major{PyObject_GetAttrString(self, "major")};
        if (!Major)
        {
            return nullptr;
        }

        py::pyobj_handle Minor{PyObject_GetAttrString(self, "minor")};
        if (!Minor)
        {
            return nullptr;
        }

        py::pyobj_handle Build{PyObject_GetAttrString(self, "build")};
        if (!Build)
        {
            return nullptr;
        }

        py::pyobj_handle Revision{PyObject_GetAttrString(self, "revision")};
        if (!Revision)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GameControllerVersionInfo(major=%R, minor=%R, build=%R, revision=%R)", Major.get(), Minor.get(), Build.get(), Revision.get());
    }

    static PyType_Slot _type_slots_GameControllerVersionInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GameControllerVersionInfo) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GameControllerVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GameControllerVersionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GameControllerVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GameControllerVersionInfo) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GameControllerVersionInfo) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GameControllerVersionInfo) },
        { }};

    static PyType_Spec type_spec_GameControllerVersionInfo = {
        "winrt._winrt_windows_gaming_input_custom.GameControllerVersionInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerVersionInfo};

    // ----- GipFirmwareUpdateProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>* _new_GipFirmwareUpdateProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GipFirmwareUpdateProgress(winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (!kwds))
        {
            self->obj = {};
            return 0;
        }

        double _PercentCompleted{};
        uint32_t _CurrentComponentId{};

        static const char* kwlist[] = {"percent_completed", "current_component_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dI", const_cast<char**>(kwlist), &_PercentCompleted, &_CurrentComponentId))
        {
            return -1;
        }

        try
        {
            self->obj.PercentCompleted = _PercentCompleted;
            self->obj.CurrentComponentId = _CurrentComponentId;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GipFirmwareUpdateProgress(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GipFirmwareUpdateProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GipFirmwareUpdateProgress[] = {
        { "_assign_array_", _assign_array_GipFirmwareUpdateProgress, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* GipFirmwareUpdateProgress_get_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentCompleted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PercentCompleted = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GipFirmwareUpdateProgress_get_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentComponentId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.CurrentComponentId = py::convert_to<uint32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GipFirmwareUpdateProgress[] = {
        { "percent_completed", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_PercentCompleted), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_PercentCompleted), nullptr, nullptr },
        { "current_component_id", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_CurrentComponentId), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_CurrentComponentId), nullptr, nullptr },
        { }};

    static PyObject* _richcompare_GipFirmwareUpdateProgress(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GipFirmwareUpdateProgress(PyObject* self) noexcept
    {
        py::pyobj_handle PercentCompleted{PyObject_GetAttrString(self, "percent_completed")};
        if (!PercentCompleted)
        {
            return nullptr;
        }

        py::pyobj_handle CurrentComponentId{PyObject_GetAttrString(self, "current_component_id")};
        if (!CurrentComponentId)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GipFirmwareUpdateProgress(percent_completed=%R, current_component_id=%R)", PercentCompleted.get(), CurrentComponentId.get());
    }

    static PyType_Slot _type_slots_GipFirmwareUpdateProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GipFirmwareUpdateProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GipFirmwareUpdateProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GipFirmwareUpdateProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GipFirmwareUpdateProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GipFirmwareUpdateProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GipFirmwareUpdateProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GipFirmwareUpdateProgress) },
        { }};

    static PyType_Spec type_spec_GipFirmwareUpdateProgress = {
        "winrt._winrt_windows_gaming_input_custom.GipFirmwareUpdateProgress",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateProgress};

    // ----- Windows.Gaming.Input.Custom Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Gaming.Input.Custom");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_gaming_input_custom",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Gaming::Input::Custom

PyMODINIT_FUNC PyInit__winrt_windows_gaming_input_custom(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input::Custom;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GameControllerFactoryManager_Static{PyType_FromSpec(&type_spec_GameControllerFactoryManager_Static)};
    if (!type_GameControllerFactoryManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle GameControllerFactoryManager_type{py::register_python_type(module.get(), &type_spec_GameControllerFactoryManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GameControllerFactoryManager_Static.get()))};
    if (!GameControllerFactoryManager_type)
    {
        return nullptr;
    }

    py::pytype_handle GipFirmwareUpdateResult_type{py::register_python_type(module.get(), &type_spec_GipFirmwareUpdateResult, object_bases.get(), nullptr)};
    if (!GipFirmwareUpdateResult_type)
    {
        return nullptr;
    }

    py::pytype_handle GipGameControllerProvider_type{py::register_python_type(module.get(), &type_spec_GipGameControllerProvider, object_bases.get(), nullptr)};
    if (!GipGameControllerProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle HidGameControllerProvider_type{py::register_python_type(module.get(), &type_spec_HidGameControllerProvider, object_bases.get(), nullptr)};
    if (!HidGameControllerProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle XusbGameControllerProvider_type{py::register_python_type(module.get(), &type_spec_XusbGameControllerProvider, object_bases.get(), nullptr)};
    if (!XusbGameControllerProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ICustomGameControllerFactory_type{py::register_python_type(module.get(), &type_spec_ICustomGameControllerFactory, object_bases.get(), nullptr)};
    if (!ICustomGameControllerFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsICustomGameControllerFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsICustomGameControllerFactory, nullptr))};
    if (!ImplementsICustomGameControllerFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsICustomGameControllerFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGameControllerInputSink_type{py::register_python_type(module.get(), &type_spec_IGameControllerInputSink, object_bases.get(), nullptr)};
    if (!IGameControllerInputSink_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGameControllerInputSink_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIGameControllerInputSink, nullptr))};
    if (!ImplementsIGameControllerInputSink_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGameControllerInputSink_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGameControllerProvider_type{py::register_python_type(module.get(), &type_spec_IGameControllerProvider, object_bases.get(), nullptr)};
    if (!IGameControllerProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGameControllerProvider_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIGameControllerProvider, nullptr))};
    if (!ImplementsIGameControllerProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGameControllerProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IGipGameControllerInputSink_type{py::register_python_type(module.get(), &type_spec_IGipGameControllerInputSink, object_bases.get(), nullptr)};
    if (!IGipGameControllerInputSink_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIGipGameControllerInputSink_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIGipGameControllerInputSink, nullptr))};
    if (!ImplementsIGipGameControllerInputSink_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIGipGameControllerInputSink_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IHidGameControllerInputSink_type{py::register_python_type(module.get(), &type_spec_IHidGameControllerInputSink, object_bases.get(), nullptr)};
    if (!IHidGameControllerInputSink_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIHidGameControllerInputSink_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIHidGameControllerInputSink, nullptr))};
    if (!ImplementsIHidGameControllerInputSink_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIHidGameControllerInputSink_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IXusbGameControllerInputSink_type{py::register_python_type(module.get(), &type_spec_IXusbGameControllerInputSink, object_bases.get(), nullptr)};
    if (!IXusbGameControllerInputSink_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIXusbGameControllerInputSink_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIXusbGameControllerInputSink, nullptr))};
    if (!ImplementsIXusbGameControllerInputSink_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIXusbGameControllerInputSink_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle GameControllerVersionInfo_type{py::register_python_type(module.get(), &type_spec_GameControllerVersionInfo, nullptr, nullptr)};
    if (!GameControllerVersionInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle GipFirmwareUpdateProgress_type{py::register_python_type(module.get(), &type_spec_GipFirmwareUpdateProgress, nullptr, nullptr)};
    if (!GipFirmwareUpdateProgress_type)
    {
        return nullptr;
    }


    return module.detach();
}
