// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Microsoft.Windows.AppNotifications.Builder.h"


namespace py::cpp::Microsoft::Windows::AppNotifications::Builder
{
    // ----- AppNotificationBuilder class --------------------

    static PyObject* _new_AppNotificationBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationBuilder(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationBuilder_AddArgument(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddArgument", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.AddArgument(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddButton(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddButton", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>(args, 0);

                return py::convert(self->obj.AddButton(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddComboBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddComboBox", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>(args, 0);

                return py::convert(self->obj.AddComboBox(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddProgressBar(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddProgressBar", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>(args, 0);

                return py::convert(self->obj.AddProgressBar(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddText(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddText", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>(args, 1);

                return py::convert(self->obj.AddText(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_AddTextBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddTextBox", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddTextBox(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"AddTextBox", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.AddTextBox(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_BuildNotification(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"BuildNotification", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.BuildNotification());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_IsUrgentScenarioSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"IsUrgentScenarioSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder::IsUrgentScenarioSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_MuteAudio(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"MuteAudio", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MuteAudio());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAppLogoOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetAppLogoOverride(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);

                return py::convert(self->obj.SetAppLogoOverride(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAppLogoOverride", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.SetAppLogoOverride(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAttributionText(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAttributionText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetAttributionText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAttributionText", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SetAttributionText(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioEvent(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioEvent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationSoundEvent>(args, 0);

                return py::convert(self->obj.SetAudioEvent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioEvent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationSoundEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationAudioLooping>(args, 1);

                return py::convert(self->obj.SetAudioEvent(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetAudioUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetAudioUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetAudioUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationAudioLooping>(args, 1);

                return py::convert(self->obj.SetAudioUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetDuration(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetDuration", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationDuration>(args, 0);

                return py::convert(self->obj.SetDuration(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetGroup(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetGroup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetHeroImage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetHeroImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetHeroImage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetHeroImage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SetHeroImage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetInlineImage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetInlineImage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);

                return py::convert(self->obj.SetInlineImage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetInlineImage", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationImageCrop>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.SetInlineImage(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetScenario(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetScenario", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationScenario>(args, 0);

                return py::convert(self->obj.SetScenario(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetTag(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetTag", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetTag(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationBuilder_SetTimeStamp(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationBuilder", L"SetTimeStamp", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.SetTimeStamp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppNotificationBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationBuilder[] = {
        { "add_argument", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddArgument), METH_VARARGS, nullptr },
        { "add_button", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddButton), METH_VARARGS, nullptr },
        { "add_combo_box", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddComboBox), METH_VARARGS, nullptr },
        { "add_progress_bar", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddProgressBar), METH_VARARGS, nullptr },
        { "add_text", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddText), METH_VARARGS, nullptr },
        { "add_text_box", reinterpret_cast<PyCFunction>(AppNotificationBuilder_AddTextBox), METH_VARARGS, nullptr },
        { "build_notification", reinterpret_cast<PyCFunction>(AppNotificationBuilder_BuildNotification), METH_VARARGS, nullptr },
        { "mute_audio", reinterpret_cast<PyCFunction>(AppNotificationBuilder_MuteAudio), METH_VARARGS, nullptr },
        { "set_app_logo_override", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAppLogoOverride), METH_VARARGS, nullptr },
        { "set_attribution_text", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAttributionText), METH_VARARGS, nullptr },
        { "set_audio_event", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioEvent), METH_VARARGS, nullptr },
        { "set_audio_uri", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetAudioUri), METH_VARARGS, nullptr },
        { "set_duration", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetDuration), METH_VARARGS, nullptr },
        { "set_group", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetGroup), METH_VARARGS, nullptr },
        { "set_hero_image", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetHeroImage), METH_VARARGS, nullptr },
        { "set_inline_image", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetInlineImage), METH_VARARGS, nullptr },
        { "set_scenario", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetScenario), METH_VARARGS, nullptr },
        { "set_tag", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetTag), METH_VARARGS, nullptr },
        { "set_time_stamp", reinterpret_cast<PyCFunction>(AppNotificationBuilder_SetTimeStamp), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationBuilder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationBuilder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationBuilder[] = {
        { }
    };

    static PyType_Slot _type_slots_AppNotificationBuilder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationBuilder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationBuilder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationBuilder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationBuilder) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationBuilder =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationBuilder",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationBuilder
    };

    static PyGetSetDef getset_AppNotificationBuilder_Static[] = {
        { }
    };

    static PyMethodDef methods_AppNotificationBuilder_Static[] = {
        { "is_urgent_scenario_supported", reinterpret_cast<PyCFunction>(AppNotificationBuilder_IsUrgentScenarioSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppNotificationBuilder_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppNotificationBuilder_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppNotificationBuilder_Static) },
        { }
    };

    static PyType_Spec type_spec_AppNotificationBuilder_Static =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationBuilder_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppNotificationBuilder_Static
    };

    // ----- AppNotificationButton class --------------------

    static PyObject* _new_AppNotificationButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationButton(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationButton_AddArgument(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"AddArgument", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.AddArgument(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_IsButtonStyleSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"IsButtonStyleSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton::IsButtonStyleSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_IsToolTipSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"IsToolTipSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton::IsToolTipSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetButtonStyle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButtonStyle>(args, 0);

                return py::convert(self->obj.SetButtonStyle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetContextMenuPlacement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SetContextMenuPlacement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetIcon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetIcon", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetIcon(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetInputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInputId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetInputId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetInvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInvokeUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.SetInvokeUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetInvokeUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SetInvokeUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_SetToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"SetToolTip", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetToolTip(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationButton_get_ToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ToolTip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToolTip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ToolTip(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ToolTip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ToolTip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_TargetAppId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"TargetAppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetAppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_TargetAppId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"TargetAppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetAppId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_InvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InvokeUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InvokeUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_InvokeUri(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InvokeUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.InvokeUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_InputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InputId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_InputId(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"InputId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.InputId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Icon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Icon(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_ContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ContextMenuPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContextMenuPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ContextMenuPlacement(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ContextMenuPlacement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ContextMenuPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Content(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Content(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_ButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ButtonStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_ButtonStyle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"ButtonStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButtonStyle>(arg);

            self->obj.ButtonStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationButton_get_Arguments(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationButton_put_Arguments(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationButton", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(arg);

            self->obj.Arguments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationButton[] = {
        { "add_argument", reinterpret_cast<PyCFunction>(AppNotificationButton_AddArgument), METH_VARARGS, nullptr },
        { "set_button_style", reinterpret_cast<PyCFunction>(AppNotificationButton_SetButtonStyle), METH_VARARGS, nullptr },
        { "set_context_menu_placement", reinterpret_cast<PyCFunction>(AppNotificationButton_SetContextMenuPlacement), METH_VARARGS, nullptr },
        { "set_icon", reinterpret_cast<PyCFunction>(AppNotificationButton_SetIcon), METH_VARARGS, nullptr },
        { "set_input_id", reinterpret_cast<PyCFunction>(AppNotificationButton_SetInputId), METH_VARARGS, nullptr },
        { "set_invoke_uri", reinterpret_cast<PyCFunction>(AppNotificationButton_SetInvokeUri), METH_VARARGS, nullptr },
        { "set_tool_tip", reinterpret_cast<PyCFunction>(AppNotificationButton_SetToolTip), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationButton[] = {
        { "tool_tip", reinterpret_cast<getter>(AppNotificationButton_get_ToolTip), reinterpret_cast<setter>(AppNotificationButton_put_ToolTip), nullptr, nullptr },
        { "target_app_id", reinterpret_cast<getter>(AppNotificationButton_get_TargetAppId), reinterpret_cast<setter>(AppNotificationButton_put_TargetAppId), nullptr, nullptr },
        { "invoke_uri", reinterpret_cast<getter>(AppNotificationButton_get_InvokeUri), reinterpret_cast<setter>(AppNotificationButton_put_InvokeUri), nullptr, nullptr },
        { "input_id", reinterpret_cast<getter>(AppNotificationButton_get_InputId), reinterpret_cast<setter>(AppNotificationButton_put_InputId), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(AppNotificationButton_get_Icon), reinterpret_cast<setter>(AppNotificationButton_put_Icon), nullptr, nullptr },
        { "context_menu_placement", reinterpret_cast<getter>(AppNotificationButton_get_ContextMenuPlacement), reinterpret_cast<setter>(AppNotificationButton_put_ContextMenuPlacement), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(AppNotificationButton_get_Content), reinterpret_cast<setter>(AppNotificationButton_put_Content), nullptr, nullptr },
        { "button_style", reinterpret_cast<getter>(AppNotificationButton_get_ButtonStyle), reinterpret_cast<setter>(AppNotificationButton_put_ButtonStyle), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(AppNotificationButton_get_Arguments), reinterpret_cast<setter>(AppNotificationButton_put_Arguments), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationButton[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationButton) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationButton =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationButton",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationButton
    };

    static PyGetSetDef getset_AppNotificationButton_Static[] = {
        { }
    };

    static PyMethodDef methods_AppNotificationButton_Static[] = {
        { "is_button_style_supported", reinterpret_cast<PyCFunction>(AppNotificationButton_IsButtonStyleSupported), METH_VARARGS, nullptr },
        { "is_tool_tip_supported", reinterpret_cast<PyCFunction>(AppNotificationButton_IsToolTipSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppNotificationButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppNotificationButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppNotificationButton_Static) },
        { }
    };

    static PyType_Spec type_spec_AppNotificationButton_Static =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppNotificationButton_Static
    };

    // ----- AppNotificationComboBox class --------------------

    static PyObject* _new_AppNotificationComboBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationComboBox(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationComboBox_AddItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"AddItem", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.AddItem(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_SetSelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SetSelectedItem", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetSelectedItem(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_SetTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SetTitle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetTitle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationComboBox_get_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationComboBox_get_SelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_SelectedItem(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"SelectedItem"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationComboBox_get_Items(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationComboBox_put_Items(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationComboBox", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::hstring>>(arg);

            self->obj.Items(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationComboBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationComboBox[] = {
        { "add_item", reinterpret_cast<PyCFunction>(AppNotificationComboBox_AddItem), METH_VARARGS, nullptr },
        { "set_selected_item", reinterpret_cast<PyCFunction>(AppNotificationComboBox_SetSelectedItem), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(AppNotificationComboBox_SetTitle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationComboBox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationComboBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationComboBox[] = {
        { "title", reinterpret_cast<getter>(AppNotificationComboBox_get_Title), reinterpret_cast<setter>(AppNotificationComboBox_put_Title), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(AppNotificationComboBox_get_SelectedItem), reinterpret_cast<setter>(AppNotificationComboBox_put_SelectedItem), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(AppNotificationComboBox_get_Items), reinterpret_cast<setter>(AppNotificationComboBox_put_Items), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationComboBox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationComboBox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationComboBox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationComboBox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationComboBox) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationComboBox =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationComboBox",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationComboBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationComboBox
    };

    // ----- AppNotificationProgressBar class --------------------

    static PyObject* _new_AppNotificationProgressBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationProgressBar(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationProgressBar_BindStatus(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.BindStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindTitle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.BindTitle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindValue(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindValue", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.BindValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_BindValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"BindValueStringOverride", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.BindValueStringOverride());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetStatus(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetStatus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetTitle(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetTitle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetTitle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetValue(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.SetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_SetValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"SetValueStringOverride", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetValueStringOverride(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationProgressBar_get_ValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"ValueStringOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValueStringOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_ValueStringOverride(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"ValueStringOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ValueStringOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Value(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Value(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Title(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationProgressBar_get_Status(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationProgressBar_put_Status(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationProgressBar", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationProgressBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationProgressBar[] = {
        { "bind_status", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindStatus), METH_VARARGS, nullptr },
        { "bind_title", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindTitle), METH_VARARGS, nullptr },
        { "bind_value", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindValue), METH_VARARGS, nullptr },
        { "bind_value_string_override", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_BindValueStringOverride), METH_VARARGS, nullptr },
        { "set_status", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetStatus), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetTitle), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetValue), METH_VARARGS, nullptr },
        { "set_value_string_override", reinterpret_cast<PyCFunction>(AppNotificationProgressBar_SetValueStringOverride), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationProgressBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationProgressBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationProgressBar[] = {
        { "value_string_override", reinterpret_cast<getter>(AppNotificationProgressBar_get_ValueStringOverride), reinterpret_cast<setter>(AppNotificationProgressBar_put_ValueStringOverride), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(AppNotificationProgressBar_get_Value), reinterpret_cast<setter>(AppNotificationProgressBar_put_Value), nullptr, nullptr },
        { "title", reinterpret_cast<getter>(AppNotificationProgressBar_get_Title), reinterpret_cast<setter>(AppNotificationProgressBar_put_Title), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AppNotificationProgressBar_get_Status), reinterpret_cast<setter>(AppNotificationProgressBar_put_Status), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationProgressBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationProgressBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationProgressBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationProgressBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationProgressBar) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationProgressBar =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationProgressBar",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationProgressBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationProgressBar
    };

    // ----- AppNotificationTextProperties class --------------------

    static PyObject* _new_AppNotificationTextProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppNotificationTextProperties(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationTextProperties_SetIncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetIncomingCallAlignment", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SetIncomingCallAlignment());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_SetLanguage(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetLanguage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetLanguage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_SetMaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"SetMaxLines", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetMaxLines(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppNotificationTextProperties_get_MaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"MaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_MaxLines(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"MaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MaxLines(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationTextProperties_get_Language(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_Language(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppNotificationTextProperties_get_IncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"IncomingCallAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IncomingCallAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppNotificationTextProperties_put_IncomingCallAlignment(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.AppNotifications.Builder.AppNotificationTextProperties", L"IncomingCallAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncomingCallAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AppNotificationTextProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationTextProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationTextProperties[] = {
        { "set_incoming_call_alignment", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetIncomingCallAlignment), METH_VARARGS, nullptr },
        { "set_language", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetLanguage), METH_VARARGS, nullptr },
        { "set_max_lines", reinterpret_cast<PyCFunction>(AppNotificationTextProperties_SetMaxLines), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppNotificationTextProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationTextProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationTextProperties[] = {
        { "max_lines", reinterpret_cast<getter>(AppNotificationTextProperties_get_MaxLines), reinterpret_cast<setter>(AppNotificationTextProperties_put_MaxLines), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AppNotificationTextProperties_get_Language), reinterpret_cast<setter>(AppNotificationTextProperties_put_Language), nullptr, nullptr },
        { "incoming_call_alignment", reinterpret_cast<getter>(AppNotificationTextProperties_get_IncomingCallAlignment), reinterpret_cast<setter>(AppNotificationTextProperties_put_IncomingCallAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationTextProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationTextProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationTextProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationTextProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationTextProperties) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationTextProperties =
    {
        "winrt._winrt_microsoft_windows_appnotifications_builder.AppNotificationTextProperties",
        sizeof(py::wrapper::Microsoft::Windows::AppNotifications::Builder::AppNotificationTextProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationTextProperties
    };

    // ----- Microsoft.Windows.AppNotifications.Builder Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::Windows::AppNotifications::Builder");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_windows_appnotifications_builder",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::Windows::AppNotifications::Builder

PyMODINIT_FUNC PyInit__winrt_microsoft_windows_appnotifications_builder(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::AppNotifications::Builder;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppNotificationBuilder_Static{PyType_FromSpec(&type_spec_AppNotificationBuilder_Static)};
    if (!type_AppNotificationBuilder_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationBuilder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppNotificationBuilder_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppNotificationButton_Static{PyType_FromSpec(&type_spec_AppNotificationButton_Static)};
    if (!type_AppNotificationButton_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationButton, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppNotificationButton_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationComboBox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationProgressBar, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationTextProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
