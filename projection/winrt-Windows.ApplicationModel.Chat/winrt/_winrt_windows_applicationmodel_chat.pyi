# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.media.mediaproperties
import winrt.windows.security.credentials
import winrt.windows.storage.streams

from winrt.windows.applicationmodel.chat import ChatConversationThreadingKind, ChatItemKind, ChatMessageChangeType, ChatMessageKind, ChatMessageOperatorKind, ChatMessageStatus, ChatMessageTransportKind, ChatMessageValidationStatus, ChatRestoreHistorySpan, ChatStoreChangedEventKind, ChatTransportErrorCodeCategory, ChatTransportInterpretedErrorCode, RcsServiceKind

Self = typing.TypeVar('Self')

@typing.final
class ChatCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatCapabilities: ...
    @_property
    def is_chat_capable(self) -> bool: ...
    @_property
    def is_file_transfer_capable(self) -> bool: ...
    @_property
    def is_geo_location_push_capable(self) -> bool: ...
    @_property
    def is_integrated_messaging_capable(self) -> bool: ...
    @_property
    def is_online(self) -> bool: ...

@typing.final
class ChatCapabilitiesManager_Static(type):
    @typing.overload
    def get_cached_capabilities_async(cls, address: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    def get_cached_capabilities_async(cls, address: str, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    def get_capabilities_from_network_async(cls, address: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...
    @typing.overload
    def get_capabilities_from_network_async(cls, address: str, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatCapabilities]: ...

@typing.final
class ChatCapabilitiesManager(winrt.system.Object, metaclass=ChatCapabilitiesManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatCapabilitiesManager: ...

@typing.final
class ChatConversation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversation: ...
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def get_message_reader(self) -> typing.Optional[ChatMessageReader]: ...
    @typing.overload
    def mark_messages_as_read_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def mark_messages_as_read_async(self, value: datetime.datetime, /) -> winrt.windows.foundation.IAsyncAction: ...
    def notify_local_participant_composing(self, transport_id: str, participant_address: str, is_composing: bool, /) -> None: ...
    def notify_remote_participant_composing(self, transport_id: str, participant_address: str, is_composing: bool, /) -> None: ...
    def save_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_remote_participant_composing_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ChatConversation, RemoteParticipantComposingChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_remote_participant_composing_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def subject(self) -> str: ...
    @subject.setter
    def subject(self, value: str) -> None: ...
    @_property
    def is_conversation_muted(self) -> bool: ...
    @is_conversation_muted.setter
    def is_conversation_muted(self, value: bool) -> None: ...
    @_property
    def has_unread_messages(self) -> bool: ...
    @_property
    def id(self) -> str: ...
    @_property
    def most_recent_message_id(self) -> str: ...
    @_property
    def participants(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def threading_info(self) -> typing.Optional[ChatConversationThreadingInfo]: ...
    @_property
    def can_modify_participants(self) -> bool: ...
    @can_modify_participants.setter
    def can_modify_participants(self, value: bool) -> None: ...
    @_property
    def item_kind(self) -> ChatItemKind: ...

@typing.final
class ChatConversationReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversationReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatConversation]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatConversation]]: ...

@typing.final
class ChatConversationThreadingInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatConversationThreadingInfo: ...
    def __new__(cls: typing.Type[ChatConversationThreadingInfo]) -> ChatConversationThreadingInfo:...
    @_property
    def kind(self) -> ChatConversationThreadingKind: ...
    @kind.setter
    def kind(self, value: ChatConversationThreadingKind) -> None: ...
    @_property
    def custom(self) -> str: ...
    @custom.setter
    def custom(self, value: str) -> None: ...
    @_property
    def conversation_id(self) -> str: ...
    @conversation_id.setter
    def conversation_id(self, value: str) -> None: ...
    @_property
    def contact_id(self) -> str: ...
    @contact_id.setter
    def contact_id(self, value: str) -> None: ...
    @_property
    def participants(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class ChatMessage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessage: ...
    def __new__(cls: typing.Type[ChatMessage]) -> ChatMessage:...
    @_property
    def item_kind(self) -> ChatItemKind: ...
    @_property
    def is_incoming(self) -> bool: ...
    @is_incoming.setter
    def is_incoming(self, value: bool) -> None: ...
    @_property
    def is_forwarding_disabled(self) -> bool: ...
    @is_forwarding_disabled.setter
    def is_forwarding_disabled(self, value: bool) -> None: ...
    @_property
    def transport_id(self) -> str: ...
    @transport_id.setter
    def transport_id(self, value: str) -> None: ...
    @_property
    def status(self) -> ChatMessageStatus: ...
    @status.setter
    def status(self, value: ChatMessageStatus) -> None: ...
    @_property
    def from_(self) -> str: ...
    @from_.setter
    def from_(self, value: str) -> None: ...
    @_property
    def body(self) -> str: ...
    @body.setter
    def body(self, value: str) -> None: ...
    @_property
    def subject(self) -> str: ...
    @subject.setter
    def subject(self, value: str) -> None: ...
    @_property
    def is_read(self) -> bool: ...
    @is_read.setter
    def is_read(self, value: bool) -> None: ...
    @_property
    def network_timestamp(self) -> datetime.datetime: ...
    @network_timestamp.setter
    def network_timestamp(self, value: datetime.datetime) -> None: ...
    @_property
    def local_timestamp(self) -> datetime.datetime: ...
    @local_timestamp.setter
    def local_timestamp(self, value: datetime.datetime) -> None: ...
    @_property
    def recipient_send_statuses(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, ChatMessageStatus]]: ...
    @_property
    def recipients(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def transport_friendly_name(self) -> str: ...
    @_property
    def attachments(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[ChatMessageAttachment]]: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_seen(self) -> bool: ...
    @is_seen.setter
    def is_seen(self, value: bool) -> None: ...
    @_property
    def message_kind(self) -> ChatMessageKind: ...
    @message_kind.setter
    def message_kind(self, value: ChatMessageKind) -> None: ...
    @_property
    def is_received_during_quiet_hours(self) -> bool: ...
    @is_received_during_quiet_hours.setter
    def is_received_during_quiet_hours(self, value: bool) -> None: ...
    @_property
    def is_auto_reply(self) -> bool: ...
    @is_auto_reply.setter
    def is_auto_reply(self, value: bool) -> None: ...
    @_property
    def estimated_download_size(self) -> winrt.system.UInt64: ...
    @estimated_download_size.setter
    def estimated_download_size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def threading_info(self) -> typing.Optional[ChatConversationThreadingInfo]: ...
    @threading_info.setter
    def threading_info(self, value: typing.Optional[ChatConversationThreadingInfo]) -> None: ...
    @_property
    def should_suppress_notification(self) -> bool: ...
    @should_suppress_notification.setter
    def should_suppress_notification(self, value: bool) -> None: ...
    @_property
    def remote_id(self) -> str: ...
    @remote_id.setter
    def remote_id(self, value: str) -> None: ...
    @_property
    def message_operator_kind(self) -> ChatMessageOperatorKind: ...
    @message_operator_kind.setter
    def message_operator_kind(self, value: ChatMessageOperatorKind) -> None: ...
    @_property
    def is_reply_disabled(self) -> bool: ...
    @_property
    def is_sim_message(self) -> bool: ...
    @_property
    def recipients_delivery_infos(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[ChatRecipientDeliveryInfo]]: ...
    @_property
    def sync_id(self) -> str: ...
    @sync_id.setter
    def sync_id(self, value: str) -> None: ...

@typing.final
class ChatMessageAttachment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageAttachment: ...
    def __new__(cls: typing.Type[ChatMessageAttachment], mime_type: str, data_stream_reference: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> ChatMessageAttachment:...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def mime_type(self) -> str: ...
    @mime_type.setter
    def mime_type(self, value: str) -> None: ...
    @_property
    def group_id(self) -> winrt.system.UInt32: ...
    @group_id.setter
    def group_id(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def data_stream_reference(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @data_stream_reference.setter
    def data_stream_reference(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def transfer_progress(self) -> winrt.system.Double: ...
    @transfer_progress.setter
    def transfer_progress(self, value: winrt.system.Double) -> None: ...
    @_property
    def thumbnail(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @thumbnail.setter
    def thumbnail(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def original_file_name(self) -> str: ...
    @original_file_name.setter
    def original_file_name(self, value: str) -> None: ...

@typing.final
class ChatMessageBlocking_Static(type):
    def mark_message_as_blocked_async(cls, local_chat_message_id: str, blocked: bool, /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class ChatMessageBlocking(winrt.system.Object, metaclass=ChatMessageBlocking_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageBlocking: ...

@typing.final
class ChatMessageChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChange: ...
    @_property
    def change_type(self) -> ChatMessageChangeType: ...
    @_property
    def message(self) -> typing.Optional[ChatMessage]: ...

@typing.final
class ChatMessageChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangeReader: ...
    def accept_changes(self) -> None: ...
    def accept_changes_through(self, last_change_to_acknowledge: typing.Optional[ChatMessageChange], /) -> None: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessageChange]]: ...

@typing.final
class ChatMessageChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangeTracker: ...
    def enable(self) -> None: ...
    def get_change_reader(self) -> typing.Optional[ChatMessageChangeReader]: ...
    def reset(self) -> None: ...

@typing.final
class ChatMessageChangedDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangedDeferral: ...
    def complete(self) -> None: ...

@typing.final
class ChatMessageChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[ChatMessageChangedDeferral]: ...

@typing.final
class ChatMessageManager_Static(type):
    def get_transport_async(cls, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessageTransport]: ...
    def get_transports_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessageTransport]]: ...
    def register_transport_async(cls) -> winrt.windows.foundation.IAsyncOperation[str]: ...
    def request_store_async(cls) -> winrt.windows.foundation.IAsyncOperation[ChatMessageStore]: ...
    def request_sync_manager_async(cls) -> winrt.windows.foundation.IAsyncOperation[ChatSyncManager]: ...
    def show_compose_sms_message_async(cls, message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    def show_sms_settings(cls) -> None: ...

@typing.final
class ChatMessageManager(winrt.system.Object, metaclass=ChatMessageManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageManager: ...

@typing.final
class ChatMessageNotificationTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageNotificationTriggerDetails: ...
    @_property
    def chat_message(self) -> typing.Optional[ChatMessage]: ...
    @_property
    def should_display_toast(self) -> bool: ...
    @_property
    def should_update_action_center(self) -> bool: ...
    @_property
    def should_update_badge(self) -> bool: ...
    @_property
    def should_update_detail_text(self) -> bool: ...

@typing.final
class ChatMessageReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessage]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[ChatMessage]]: ...

@typing.final
class ChatMessageStore(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageStore: ...
    def delete_message_async(self, local_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def download_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def forward_message_async(self, local_chat_message_id: str, addresses: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    @typing.overload
    def get_conversation_async(self, conversation_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    @typing.overload
    def get_conversation_async(self, conversation_id: str, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    def get_conversation_from_threading_info_async(self, threading_info: typing.Optional[ChatConversationThreadingInfo], /) -> winrt.windows.foundation.IAsyncOperation[ChatConversation]: ...
    @typing.overload
    def get_conversation_reader(self) -> typing.Optional[ChatConversationReader]: ...
    @typing.overload
    def get_conversation_reader(self, transport_ids: typing.Iterable[str], /) -> typing.Optional[ChatConversationReader]: ...
    def get_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    def get_message_by_remote_id_async(self, transport_id: str, remote_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    def get_message_by_sync_id_async(self, sync_id: str, /) -> winrt.windows.foundation.IAsyncOperation[ChatMessage]: ...
    @typing.overload
    def get_message_reader(self) -> typing.Optional[ChatMessageReader]: ...
    @typing.overload
    def get_message_reader(self, recent_time_limit: datetime.timedelta, /) -> typing.Optional[ChatMessageReader]: ...
    def get_search_reader(self, value: typing.Optional[ChatQueryOptions], /) -> typing.Optional[ChatSearchReader]: ...
    @typing.overload
    def get_unseen_count_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Int32]: ...
    @typing.overload
    def get_unseen_count_async(self, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.system.Int32]: ...
    @typing.overload
    def mark_as_seen_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def mark_as_seen_async(self, transport_ids: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncAction: ...
    def mark_message_read_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def retry_send_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def save_message_async(self, chat_message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    def send_message_async(self, chat_message: typing.Optional[ChatMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_cancel_download_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_cancel_send_message_async(self, local_chat_message_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def validate_message(self, chat_message: typing.Optional[ChatMessage], /) -> typing.Optional[ChatMessageValidationResult]: ...
    def add_message_changed(self, value: winrt.windows.foundation.TypedEventHandler[ChatMessageStore, ChatMessageChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_changed(self, value: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_store_changed(self, handler: winrt.windows.foundation.TypedEventHandler[ChatMessageStore, ChatMessageStoreChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_store_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def change_tracker(self) -> typing.Optional[ChatMessageChangeTracker]: ...

@typing.final
class ChatMessageStoreChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageStoreChangedEventArgs: ...
    @_property
    def id(self) -> str: ...
    @_property
    def kind(self) -> ChatStoreChangedEventKind: ...

@typing.final
class ChatMessageTransport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageTransport: ...
    def request_set_as_notification_provider_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def is_active(self) -> bool: ...
    @_property
    def is_app_set_as_notification_provider(self) -> bool: ...
    @_property
    def transport_friendly_name(self) -> str: ...
    @_property
    def transport_id(self) -> str: ...
    @_property
    def configuration(self) -> typing.Optional[ChatMessageTransportConfiguration]: ...
    @_property
    def transport_kind(self) -> ChatMessageTransportKind: ...

@typing.final
class ChatMessageTransportConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageTransportConfiguration: ...
    @_property
    def extended_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def max_attachment_count(self) -> winrt.system.Int32: ...
    @_property
    def max_message_size_in_kilobytes(self) -> winrt.system.Int32: ...
    @_property
    def max_recipient_count(self) -> winrt.system.Int32: ...
    @_property
    def supported_video_format(self) -> typing.Optional[winrt.windows.media.mediaproperties.MediaEncodingProfile]: ...

@typing.final
class ChatMessageValidationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatMessageValidationResult: ...
    @_property
    def max_part_count(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def part_count(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def remaining_character_count_in_part(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @_property
    def status(self) -> ChatMessageValidationStatus: ...

@typing.final
class ChatQueryOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatQueryOptions: ...
    def __new__(cls: typing.Type[ChatQueryOptions]) -> ChatQueryOptions:...
    @_property
    def search_string(self) -> str: ...
    @search_string.setter
    def search_string(self, value: str) -> None: ...

@typing.final
class ChatRecipientDeliveryInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatRecipientDeliveryInfo: ...
    def __new__(cls: typing.Type[ChatRecipientDeliveryInfo]) -> ChatRecipientDeliveryInfo:...
    @_property
    def transport_address(self) -> str: ...
    @transport_address.setter
    def transport_address(self, value: str) -> None: ...
    @_property
    def read_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @read_time.setter
    def read_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def delivery_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @delivery_time.setter
    def delivery_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def is_error_permanent(self) -> bool: ...
    @_property
    def status(self) -> ChatMessageStatus: ...
    @_property
    def transport_error_code(self) -> winrt.system.Int32: ...
    @_property
    def transport_error_code_category(self) -> ChatTransportErrorCodeCategory: ...
    @_property
    def transport_interpreted_error_code(self) -> ChatTransportInterpretedErrorCode: ...

@typing.final
class ChatSearchReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSearchReader: ...
    @typing.overload
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IChatItem]]: ...
    @typing.overload
    def read_batch_async(self, count: winrt.system.Int32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[IChatItem]]: ...

@typing.final
class ChatSyncConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSyncConfiguration: ...
    @_property
    def restore_history_span(self) -> ChatRestoreHistorySpan: ...
    @restore_history_span.setter
    def restore_history_span(self, value: ChatRestoreHistorySpan) -> None: ...
    @_property
    def is_sync_enabled(self) -> bool: ...
    @is_sync_enabled.setter
    def is_sync_enabled(self, value: bool) -> None: ...

@typing.final
class ChatSyncManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ChatSyncManager: ...
    def associate_account_async(self, web_account: typing.Optional[winrt.windows.security.credentials.WebAccount], /) -> winrt.windows.foundation.IAsyncAction: ...
    def is_account_associated(self, web_account: typing.Optional[winrt.windows.security.credentials.WebAccount], /) -> bool: ...
    def set_configuration_async(self, configuration: typing.Optional[ChatSyncConfiguration], /) -> winrt.windows.foundation.IAsyncAction: ...
    def start_sync(self) -> None: ...
    def unassociate_account_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def configuration(self) -> typing.Optional[ChatSyncConfiguration]: ...

@typing.final
class RcsEndUserMessage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessage: ...
    def send_response_async(self, action: typing.Optional[RcsEndUserMessageAction], /) -> winrt.windows.foundation.IAsyncAction: ...
    def send_response_with_pin_async(self, action: typing.Optional[RcsEndUserMessageAction], pin: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def actions(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[RcsEndUserMessageAction]]: ...
    @_property
    def is_pin_required(self) -> bool: ...
    @_property
    def text(self) -> str: ...
    @_property
    def title(self) -> str: ...
    @_property
    def transport_id(self) -> str: ...

@typing.final
class RcsEndUserMessageAction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAction: ...
    @_property
    def label(self) -> str: ...

@typing.final
class RcsEndUserMessageAvailableEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableEventArgs: ...
    @_property
    def is_message_available(self) -> bool: ...
    @_property
    def message(self) -> typing.Optional[RcsEndUserMessage]: ...

@typing.final
class RcsEndUserMessageAvailableTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageAvailableTriggerDetails: ...
    @_property
    def text(self) -> str: ...
    @_property
    def title(self) -> str: ...

@typing.final
class RcsEndUserMessageManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsEndUserMessageManager: ...
    def add_message_available_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RcsEndUserMessageManager, RcsEndUserMessageAvailableEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_message_available_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class RcsManager_Static(type):
    def get_end_user_message_manager(cls) -> typing.Optional[RcsEndUserMessageManager]: ...
    def get_transport_async(cls, transport_id: str, /) -> winrt.windows.foundation.IAsyncOperation[RcsTransport]: ...
    def get_transports_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[RcsTransport]]: ...
    def leave_conversation_async(cls, conversation: typing.Optional[ChatConversation], /) -> winrt.windows.foundation.IAsyncAction: ...
    def add_transport_list_changed(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_transport_list_changed(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class RcsManager(winrt.system.Object, metaclass=RcsManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsManager: ...

@typing.final
class RcsServiceKindSupportedChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsServiceKindSupportedChangedEventArgs: ...
    @_property
    def service_kind(self) -> RcsServiceKind: ...

@typing.final
class RcsTransport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsTransport: ...
    def is_service_kind_supported(self, service_kind: RcsServiceKind, /) -> bool: ...
    def is_store_and_forward_enabled(self, service_kind: RcsServiceKind, /) -> bool: ...
    def add_service_kind_supported_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RcsTransport, RcsServiceKindSupportedChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_service_kind_supported_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def configuration(self) -> typing.Optional[RcsTransportConfiguration]: ...
    @_property
    def extended_properties(self) -> typing.Optional[winrt.windows.foundation.collections.IMapView[str, winrt.system.Object]]: ...
    @_property
    def is_active(self) -> bool: ...
    @_property
    def transport_friendly_name(self) -> str: ...
    @_property
    def transport_id(self) -> str: ...

@typing.final
class RcsTransportConfiguration(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RcsTransportConfiguration: ...
    @_property
    def max_attachment_count(self) -> winrt.system.Int32: ...
    @_property
    def max_file_size_in_kilobytes(self) -> winrt.system.Int32: ...
    @_property
    def max_group_message_size_in_kilobytes(self) -> winrt.system.Int32: ...
    @_property
    def max_message_size_in_kilobytes(self) -> winrt.system.Int32: ...
    @_property
    def max_recipient_count(self) -> winrt.system.Int32: ...
    @_property
    def warning_file_size_in_kilobytes(self) -> winrt.system.Int32: ...

@typing.final
class RemoteParticipantComposingChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemoteParticipantComposingChangedEventArgs: ...
    @_property
    def is_composing(self) -> bool: ...
    @_property
    def participant_address(self) -> str: ...
    @_property
    def transport_id(self) -> str: ...

@typing.final
class IChatItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IChatItem: ...
    @_property
    def item_kind(self) -> ChatItemKind: ...

