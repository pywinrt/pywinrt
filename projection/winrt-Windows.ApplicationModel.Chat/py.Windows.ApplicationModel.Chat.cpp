// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.ApplicationModel.Chat.h"


namespace py::cpp::Windows::ApplicationModel::Chat
{
    // ----- ChatCapabilities class --------------------

    static PyObject* _new_ChatCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatCapabilities(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatCapabilities_get_IsChatCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsChatCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChatCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsFileTransferCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsFileTransferCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFileTransferCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsGeoLocationPushCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsGeoLocationPushCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGeoLocationPushCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsIntegratedMessagingCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsIntegratedMessagingCapable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIntegratedMessagingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsOnline(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsOnline"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsOnline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilities[] = {
        { "_assign_array_", _assign_array_ChatCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatCapabilities[] = {
        { "is_chat_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsChatCapable), nullptr, nullptr, nullptr },
        { "is_file_transfer_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsFileTransferCapable), nullptr, nullptr, nullptr },
        { "is_geo_location_push_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsGeoLocationPushCapable), nullptr, nullptr, nullptr },
        { "is_integrated_messaging_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsIntegratedMessagingCapable), nullptr, nullptr, nullptr },
        { "is_online", reinterpret_cast<getter>(ChatCapabilities_get_IsOnline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatCapabilities) },
        { },
    };

    static PyType_Spec type_spec_ChatCapabilities =
    {
        "_winrt_windows_applicationmodel_chat.ChatCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilities
    };

    // ----- ChatCapabilitiesManager class --------------------

    static PyObject* _new_ChatCapabilitiesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::type_name);
        return nullptr;
    }

    static PyObject* ChatCapabilitiesManager_GetCachedCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCachedCapabilitiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCachedCapabilitiesAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCapabilitiesFromNetworkAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCapabilitiesFromNetworkAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilitiesManager[] = {
        { "get_cached_capabilities_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCachedCapabilitiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_capabilities_from_network_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatCapabilitiesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatCapabilitiesManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatCapabilitiesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatCapabilitiesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatCapabilitiesManager) },
        { },
    };

    static PyType_Spec type_spec_ChatCapabilitiesManager =
    {
        "_winrt_windows_applicationmodel_chat.ChatCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilitiesManager
    };

    // ----- ChatConversation class --------------------

    static PyObject* _new_ChatConversation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatConversation(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversation_DeleteAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"DeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"GetMessageReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_MarkMessagesAsReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MarkMessagesAsReadAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MarkMessagesAsReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MarkMessagesAsReadAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.MarkMessagesAsReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyLocalParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"NotifyLocalParticipantComposing", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyLocalParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyRemoteParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"NotifyRemoteParticipantComposing", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyRemoteParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_SaveAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"SaveAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"IsConversationMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConversationMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"IsConversationMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConversationMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_HasUnreadMessages(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"HasUnreadMessages"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasUnreadMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MostRecentMessageId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MostRecentMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Participants"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"ThreadingInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"CanModifyParticipants"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanModifyParticipants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"CanModifyParticipants"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanModifyParticipants(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"ItemKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_add_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"RemoteParticipantComposingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatConversation, winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>(arg);

            return py::convert(self->obj.RemoteParticipantComposingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_remove_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"RemoteParticipantComposingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteParticipantComposingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversation[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(ChatConversation_DeleteAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(ChatConversation_GetMessageReader), METH_VARARGS, nullptr },
        { "mark_messages_as_read_async", reinterpret_cast<PyCFunction>(ChatConversation_MarkMessagesAsReadAsync), METH_VARARGS, nullptr },
        { "notify_local_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyLocalParticipantComposing), METH_VARARGS, nullptr },
        { "notify_remote_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyRemoteParticipantComposing), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(ChatConversation_SaveAsync), METH_VARARGS, nullptr },
        { "add_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_add_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "remove_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_remove_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ChatConversation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversation[] = {
        { "subject", reinterpret_cast<getter>(ChatConversation_get_Subject), reinterpret_cast<setter>(ChatConversation_put_Subject), nullptr, nullptr },
        { "is_conversation_muted", reinterpret_cast<getter>(ChatConversation_get_IsConversationMuted), reinterpret_cast<setter>(ChatConversation_put_IsConversationMuted), nullptr, nullptr },
        { "has_unread_messages", reinterpret_cast<getter>(ChatConversation_get_HasUnreadMessages), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatConversation_get_Id), nullptr, nullptr, nullptr },
        { "most_recent_message_id", reinterpret_cast<getter>(ChatConversation_get_MostRecentMessageId), nullptr, nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversation_get_Participants), nullptr, nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatConversation_get_ThreadingInfo), nullptr, nullptr, nullptr },
        { "can_modify_participants", reinterpret_cast<getter>(ChatConversation_get_CanModifyParticipants), reinterpret_cast<setter>(ChatConversation_put_CanModifyParticipants), nullptr, nullptr },
        { "item_kind", reinterpret_cast<getter>(ChatConversation_get_ItemKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatConversation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversation) },
        { },
    };

    static PyType_Spec type_spec_ChatConversation =
    {
        "_winrt_windows_applicationmodel_chat.ChatConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversation
    };

    // ----- ChatConversationReader class --------------------

    static PyObject* _new_ChatConversationReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversationReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversationReader", L"ReadBatchAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatConversationReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatConversationReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversationReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatConversationReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversationReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversationReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversationReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversationReader) },
        { },
    };

    static PyType_Spec type_spec_ChatConversationReader =
    {
        "_winrt_windows_applicationmodel_chat.ChatConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationReader
    };

    // ----- ChatConversationThreadingInfo class --------------------

    static PyObject* _new_ChatConversationThreadingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatConversationThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversationThreadingInfo_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Custom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Custom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Custom(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ConversationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConversationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ConversationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ConversationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ContactId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Participants"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationThreadingInfo[] = {
        { "_assign_array_", _assign_array_ChatConversationThreadingInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationThreadingInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversationThreadingInfo[] = {
        { "kind", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Kind), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Kind), nullptr, nullptr },
        { "custom", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Custom), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Custom), nullptr, nullptr },
        { "conversation_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ConversationId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ConversationId), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ContactId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ContactId), nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Participants), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatConversationThreadingInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversationThreadingInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversationThreadingInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversationThreadingInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversationThreadingInfo) },
        { },
    };

    static PyType_Spec type_spec_ChatConversationThreadingInfo =
    {
        "_winrt_windows_applicationmodel_chat.ChatConversationThreadingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationThreadingInfo
    };

    // ----- ChatMessage class --------------------

    static PyObject* _new_ChatMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessage_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ItemKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsIncoming"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsForwardingDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsForwardingDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsForwardingDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsForwardingDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"From"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Body"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Body"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"NetworkTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"NetworkTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.NetworkTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"LocalTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"LocalTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LocalTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RecipientSendStatuses(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RecipientSendStatuses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecipientSendStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Recipients(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Recipients"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportFriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Attachments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Attachments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSeen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageKind>(arg);

            self->obj.MessageKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReceivedDuringQuietHours"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReceivedDuringQuietHours());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReceivedDuringQuietHours"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReceivedDuringQuietHours(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsAutoReply"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAutoReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsAutoReply"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoReply(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"EstimatedDownloadSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EstimatedDownloadSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"EstimatedDownloadSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.EstimatedDownloadSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ThreadingInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ThreadingInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(arg);

            self->obj.ThreadingInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ShouldSuppressNotification"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldSuppressNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ShouldSuppressNotification"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldSuppressNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageOperatorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageOperatorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageOperatorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageOperatorKind>(arg);

            self->obj.MessageOperatorKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReplyDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReplyDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReplyDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSimMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSimMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSimMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_RecipientsDeliveryInfos(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RecipientsDeliveryInfos"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RecipientsDeliveryInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"SyncId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SyncId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"SyncId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SyncId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessage[] = {
        { "_assign_array_", _assign_array_ChatMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessage[] = {
        { "item_kind", reinterpret_cast<getter>(ChatMessage_get_ItemKind), nullptr, nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(ChatMessage_get_IsIncoming), reinterpret_cast<setter>(ChatMessage_put_IsIncoming), nullptr, nullptr },
        { "is_forwarding_disabled", reinterpret_cast<getter>(ChatMessage_get_IsForwardingDisabled), reinterpret_cast<setter>(ChatMessage_put_IsForwardingDisabled), nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessage_get_TransportId), reinterpret_cast<setter>(ChatMessage_put_TransportId), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessage_get_Status), reinterpret_cast<setter>(ChatMessage_put_Status), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ChatMessage_get_From), reinterpret_cast<setter>(ChatMessage_put_From), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(ChatMessage_get_Body), reinterpret_cast<setter>(ChatMessage_put_Body), nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(ChatMessage_get_Subject), reinterpret_cast<setter>(ChatMessage_put_Subject), nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(ChatMessage_get_IsRead), reinterpret_cast<setter>(ChatMessage_put_IsRead), nullptr, nullptr },
        { "network_timestamp", reinterpret_cast<getter>(ChatMessage_get_NetworkTimestamp), reinterpret_cast<setter>(ChatMessage_put_NetworkTimestamp), nullptr, nullptr },
        { "local_timestamp", reinterpret_cast<getter>(ChatMessage_get_LocalTimestamp), reinterpret_cast<setter>(ChatMessage_put_LocalTimestamp), nullptr, nullptr },
        { "recipient_send_statuses", reinterpret_cast<getter>(ChatMessage_get_RecipientSendStatuses), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(ChatMessage_get_Recipients), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessage_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "attachments", reinterpret_cast<getter>(ChatMessage_get_Attachments), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatMessage_get_Id), nullptr, nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(ChatMessage_get_IsSeen), reinterpret_cast<setter>(ChatMessage_put_IsSeen), nullptr, nullptr },
        { "message_kind", reinterpret_cast<getter>(ChatMessage_get_MessageKind), reinterpret_cast<setter>(ChatMessage_put_MessageKind), nullptr, nullptr },
        { "is_received_during_quiet_hours", reinterpret_cast<getter>(ChatMessage_get_IsReceivedDuringQuietHours), reinterpret_cast<setter>(ChatMessage_put_IsReceivedDuringQuietHours), nullptr, nullptr },
        { "is_auto_reply", reinterpret_cast<getter>(ChatMessage_get_IsAutoReply), reinterpret_cast<setter>(ChatMessage_put_IsAutoReply), nullptr, nullptr },
        { "estimated_download_size", reinterpret_cast<getter>(ChatMessage_get_EstimatedDownloadSize), reinterpret_cast<setter>(ChatMessage_put_EstimatedDownloadSize), nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatMessage_get_ThreadingInfo), reinterpret_cast<setter>(ChatMessage_put_ThreadingInfo), nullptr, nullptr },
        { "should_suppress_notification", reinterpret_cast<getter>(ChatMessage_get_ShouldSuppressNotification), reinterpret_cast<setter>(ChatMessage_put_ShouldSuppressNotification), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ChatMessage_get_RemoteId), reinterpret_cast<setter>(ChatMessage_put_RemoteId), nullptr, nullptr },
        { "message_operator_kind", reinterpret_cast<getter>(ChatMessage_get_MessageOperatorKind), reinterpret_cast<setter>(ChatMessage_put_MessageOperatorKind), nullptr, nullptr },
        { "is_reply_disabled", reinterpret_cast<getter>(ChatMessage_get_IsReplyDisabled), nullptr, nullptr, nullptr },
        { "is_sim_message", reinterpret_cast<getter>(ChatMessage_get_IsSimMessage), nullptr, nullptr, nullptr },
        { "recipients_delivery_infos", reinterpret_cast<getter>(ChatMessage_get_RecipientsDeliveryInfos), nullptr, nullptr, nullptr },
        { "sync_id", reinterpret_cast<getter>(ChatMessage_get_SyncId), reinterpret_cast<setter>(ChatMessage_put_SyncId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessage) },
        { },
    };

    static PyType_Spec type_spec_ChatMessage =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessage
    };

    // ----- ChatMessageAttachment class --------------------

    static PyObject* _new_ChatMessageAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageAttachment(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageAttachment_get_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"MimeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"MimeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MimeType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"GroupId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"GroupId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GroupId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"DataStreamReference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataStreamReference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"DataStreamReference"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.DataStreamReference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"TransferProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransferProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"TransferProgress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TransferProgress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"OriginalFileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OriginalFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"OriginalFileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OriginalFileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageAttachment[] = {
        { "_assign_array_", _assign_array_ChatMessageAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageAttachment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageAttachment[] = {
        { "text", reinterpret_cast<getter>(ChatMessageAttachment_get_Text), reinterpret_cast<setter>(ChatMessageAttachment_put_Text), nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(ChatMessageAttachment_get_MimeType), reinterpret_cast<setter>(ChatMessageAttachment_put_MimeType), nullptr, nullptr },
        { "group_id", reinterpret_cast<getter>(ChatMessageAttachment_get_GroupId), reinterpret_cast<setter>(ChatMessageAttachment_put_GroupId), nullptr, nullptr },
        { "data_stream_reference", reinterpret_cast<getter>(ChatMessageAttachment_get_DataStreamReference), reinterpret_cast<setter>(ChatMessageAttachment_put_DataStreamReference), nullptr, nullptr },
        { "transfer_progress", reinterpret_cast<getter>(ChatMessageAttachment_get_TransferProgress), reinterpret_cast<setter>(ChatMessageAttachment_put_TransferProgress), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(ChatMessageAttachment_get_Thumbnail), reinterpret_cast<setter>(ChatMessageAttachment_put_Thumbnail), nullptr, nullptr },
        { "original_file_name", reinterpret_cast<getter>(ChatMessageAttachment_get_OriginalFileName), reinterpret_cast<setter>(ChatMessageAttachment_put_OriginalFileName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageAttachment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageAttachment) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageAttachment =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageAttachment
    };

    // ----- ChatMessageBlocking class --------------------

    static PyObject* _new_ChatMessageBlocking(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::type_name);
        return nullptr;
    }

    static PyObject* ChatMessageBlocking_MarkMessageAsBlockedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageBlocking", L"MarkMessageAsBlockedAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking::MarkMessageAsBlockedAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageBlocking[] = {
        { "mark_message_as_blocked_async", reinterpret_cast<PyCFunction>(ChatMessageBlocking_MarkMessageAsBlockedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageBlocking[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageBlocking[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageBlocking) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageBlocking) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageBlocking) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageBlocking =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageBlocking
    };

    // ----- ChatMessageChange class --------------------

    static PyObject* _new_ChatMessageChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChange(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageChange", L"ChangeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageChange_get_Message(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageChange", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChange[] = {
        { "_assign_array_", _assign_array_ChatMessageChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChange[] = {
        { "change_type", reinterpret_cast<getter>(ChatMessageChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(ChatMessageChange_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChange) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageChange =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChange
    };

    // ----- ChatMessageChangeReader class --------------------

    static PyObject* _new_ChatMessageChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"AcceptChanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"AcceptChangesThrough", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangeReader) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageChangeReader =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeReader
    };

    // ----- ChatMessageChangeTracker class --------------------

    static PyObject* _new_ChatMessageChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"Enable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"GetChangeReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangeTracker[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangeTracker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangeTracker) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageChangeTracker =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeTracker
    };

    // ----- ChatMessageChangedDeferral class --------------------

    static PyObject* _new_ChatMessageChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangedDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ChatMessageChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangedDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangedDeferral) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageChangedDeferral =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedDeferral
    };

    // ----- ChatMessageChangedEventArgs class --------------------

    static PyObject* _new_ChatMessageChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ChatMessageChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageChangedEventArgs =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedEventArgs
    };

    // ----- ChatMessageManager class --------------------

    static PyObject* _new_ChatMessageManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::type_name);
        return nullptr;
    }

    static PyObject* ChatMessageManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"GetTransportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"GetTransportsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RegisterTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RegisterTransportAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RegisterTransportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RequestStoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestSyncManagerAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RequestSyncManagerAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowComposeSmsMessageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"ShowComposeSmsMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowComposeSmsMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowSmsSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"ShowSmsSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowSmsSettings();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageManager[] = {
        { "get_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "register_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RegisterTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_sync_manager_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestSyncManagerAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_compose_sms_message_async", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowComposeSmsMessageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_sms_settings", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowSmsSettings), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageManager) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageManager =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageManager
    };

    // ----- ChatMessageNotificationTriggerDetails class --------------------

    static PyObject* _new_ChatMessageNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ChatMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChatMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldDisplayToast"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDisplayToast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateActionCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldUpdateActionCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateBadge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldUpdateBadge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateDetailText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldUpdateDetailText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ChatMessageNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTriggerDetails[] = {
        { "chat_message", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ChatMessage), nullptr, nullptr, nullptr },
        { "should_display_toast", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast), nullptr, nullptr, nullptr },
        { "should_update_action_center", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter), nullptr, nullptr, nullptr },
        { "should_update_badge", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge), nullptr, nullptr, nullptr },
        { "should_update_detail_text", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageNotificationTriggerDetails =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTriggerDetails
    };

    // ----- ChatMessageReader class --------------------

    static PyObject* _new_ChatMessageReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageReader", L"ReadBatchAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageReader) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageReader =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReader
    };

    // ----- ChatMessageStore class --------------------

    static PyObject* _new_ChatMessageStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageStore(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageStore_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"DeleteMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"DownloadMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ForwardMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ForwardMessageAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.ForwardMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetConversationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationFromThreadingInfoAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationFromThreadingInfoAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(args, 0);

                return py::convert(self->obj.GetConversationFromThreadingInfoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageByRemoteIdAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetMessageByRemoteIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageBySyncIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageBySyncIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageBySyncIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageReader", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetSearchReader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>(args, 0);

                return py::convert(self->obj.GetSearchReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetUnseenCountAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetUnseenCountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkAsSeenAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkAsSeenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MarkAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkAsSeenAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkMessageReadAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkMessageReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_RetrySendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"RetrySendMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RetrySendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"SaveMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"SendMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelDownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"TryCancelDownloadMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelDownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelSendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"TryCancelSendMessageAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelSendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ValidateMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ValidateMessage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.ValidateMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ChangeTracker"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MessageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>(arg);

            return py::convert(self->obj.MessageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MessageChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"StoreChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>(arg);

            return py::convert(self->obj.StoreChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"StoreChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StoreChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStore[] = {
        { "delete_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DownloadMessageAsync), METH_VARARGS, nullptr },
        { "forward_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_ForwardMessageAsync), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_from_threading_info_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationFromThreadingInfoAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationReader), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_by_remote_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_message_by_sync_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageBySyncIdAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageReader), METH_VARARGS, nullptr },
        { "get_search_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetSearchReader), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "mark_as_seen_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_message_read_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkMessageReadAsync), METH_VARARGS, nullptr },
        { "retry_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_RetrySendMessageAsync), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SaveMessageAsync), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SendMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelDownloadMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelSendMessageAsync), METH_VARARGS, nullptr },
        { "validate_message", reinterpret_cast<PyCFunction>(ChatMessageStore_ValidateMessage), METH_VARARGS, nullptr },
        { "add_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_MessageChanged), METH_O, nullptr },
        { "remove_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_MessageChanged), METH_O, nullptr },
        { "add_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_StoreChanged), METH_O, nullptr },
        { "remove_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_StoreChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ChatMessageStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageStore[] = {
        { "change_tracker", reinterpret_cast<getter>(ChatMessageStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageStore) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageStore =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStore
    };

    // ----- ChatMessageStoreChangedEventArgs class --------------------

    static PyObject* _new_ChatMessageStoreChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStoreChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ChatMessageStoreChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStoreChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageStoreChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageStoreChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageStoreChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageStoreChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageStoreChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageStoreChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageStoreChangedEventArgs =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStoreChangedEventArgs
    };

    // ----- ChatMessageTransport class --------------------

    static PyObject* _new_ChatMessageTransport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransport(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageTransport_RequestSetAsNotificationProviderAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"RequestSetAsNotificationProviderAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestSetAsNotificationProviderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsAppSetAsNotificationProvider(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"IsAppSetAsNotificationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAppSetAsNotificationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportFriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransport[] = {
        { "request_set_as_notification_provider_async", reinterpret_cast<PyCFunction>(ChatMessageTransport_RequestSetAsNotificationProviderAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageTransport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageTransport[] = {
        { "is_active", reinterpret_cast<getter>(ChatMessageTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "is_app_set_as_notification_provider", reinterpret_cast<getter>(ChatMessageTransport_get_IsAppSetAsNotificationProvider), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessageTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessageTransport_get_TransportId), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(ChatMessageTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "transport_kind", reinterpret_cast<getter>(ChatMessageTransport_get_TransportKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageTransport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageTransport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageTransport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageTransport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageTransport) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageTransport =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransport
    };

    // ----- ChatMessageTransportConfiguration class --------------------

    static PyObject* _new_ChatMessageTransportConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageTransportConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxAttachmentCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxMessageSizeInKilobytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxRecipientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_SupportedVideoFormat(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"SupportedVideoFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedVideoFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransportConfiguration[] = {
        { "_assign_array_", _assign_array_ChatMessageTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageTransportConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "max_attachment_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "supported_video_format", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_SupportedVideoFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageTransportConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageTransportConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageTransportConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageTransportConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageTransportConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageTransportConfiguration =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransportConfiguration
    };

    // ----- ChatMessageValidationResult class --------------------

    static PyObject* _new_ChatMessageValidationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageValidationResult(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageValidationResult_get_MaxPartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"MaxPartCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_PartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"PartCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_RemainingCharacterCountInPart(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"RemainingCharacterCountInPart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemainingCharacterCountInPart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageValidationResult[] = {
        { "_assign_array_", _assign_array_ChatMessageValidationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageValidationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageValidationResult[] = {
        { "max_part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_MaxPartCount), nullptr, nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_PartCount), nullptr, nullptr, nullptr },
        { "remaining_character_count_in_part", reinterpret_cast<getter>(ChatMessageValidationResult_get_RemainingCharacterCountInPart), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessageValidationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageValidationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageValidationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageValidationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageValidationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageValidationResult) },
        { },
    };

    static PyType_Spec type_spec_ChatMessageValidationResult =
    {
        "_winrt_windows_applicationmodel_chat.ChatMessageValidationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageValidationResult
    };

    // ----- ChatQueryOptions class --------------------

    static PyObject* _new_ChatQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatQueryOptions(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatQueryOptions_get_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatQueryOptions", L"SearchString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SearchString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatQueryOptions_put_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatQueryOptions", L"SearchString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SearchString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatQueryOptions[] = {
        { "_assign_array_", _assign_array_ChatQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatQueryOptions[] = {
        { "search_string", reinterpret_cast<getter>(ChatQueryOptions_get_SearchString), reinterpret_cast<setter>(ChatQueryOptions_put_SearchString), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_ChatQueryOptions =
    {
        "_winrt_windows_applicationmodel_chat.ChatQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatQueryOptions
    };

    // ----- ChatRecipientDeliveryInfo class --------------------

    static PyObject* _new_ChatRecipientDeliveryInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatRecipientDeliveryInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"ReadTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReadTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"ReadTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ReadTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"DeliveryTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"DeliveryTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.DeliveryTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_IsErrorPermanent(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"IsErrorPermanent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsErrorPermanent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportErrorCodeCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportErrorCodeCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportInterpretedErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportInterpretedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatRecipientDeliveryInfo[] = {
        { "_assign_array_", _assign_array_ChatRecipientDeliveryInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatRecipientDeliveryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatRecipientDeliveryInfo[] = {
        { "transport_address", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportAddress), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_TransportAddress), nullptr, nullptr },
        { "read_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_ReadTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_ReadTime), nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_DeliveryTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_DeliveryTime), nullptr, nullptr },
        { "is_error_permanent", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_IsErrorPermanent), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_Status), nullptr, nullptr, nullptr },
        { "transport_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCode), nullptr, nullptr, nullptr },
        { "transport_error_code_category", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory), nullptr, nullptr, nullptr },
        { "transport_interpreted_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatRecipientDeliveryInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatRecipientDeliveryInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatRecipientDeliveryInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatRecipientDeliveryInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatRecipientDeliveryInfo) },
        { },
    };

    static PyType_Spec type_spec_ChatRecipientDeliveryInfo =
    {
        "_winrt_windows_applicationmodel_chat.ChatRecipientDeliveryInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatRecipientDeliveryInfo
    };

    // ----- ChatSearchReader class --------------------

    static PyObject* _new_ChatSearchReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSearchReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSearchReader", L"ReadBatchAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSearchReader", L"ReadBatchAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSearchReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatSearchReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatSearchReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSearchReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSearchReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatSearchReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSearchReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSearchReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSearchReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSearchReader) },
        { },
    };

    static PyType_Spec type_spec_ChatSearchReader =
    {
        "_winrt_windows_applicationmodel_chat.ChatSearchReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSearchReader
    };

    // ----- ChatSyncConfiguration class --------------------

    static PyObject* _new_ChatSyncConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSyncConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSyncConfiguration_get_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"RestoreHistorySpan"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RestoreHistorySpan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"RestoreHistorySpan"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatRestoreHistorySpan>(arg);

            self->obj.RestoreHistorySpan(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatSyncConfiguration_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"IsSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"IsSyncEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncConfiguration[] = {
        { "_assign_array_", _assign_array_ChatSyncConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSyncConfiguration[] = {
        { "restore_history_span", reinterpret_cast<getter>(ChatSyncConfiguration_get_RestoreHistorySpan), reinterpret_cast<setter>(ChatSyncConfiguration_put_RestoreHistorySpan), nullptr, nullptr },
        { "is_sync_enabled", reinterpret_cast<getter>(ChatSyncConfiguration_get_IsSyncEnabled), reinterpret_cast<setter>(ChatSyncConfiguration_put_IsSyncEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatSyncConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSyncConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSyncConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSyncConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSyncConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ChatSyncConfiguration =
    {
        "_winrt_windows_applicationmodel_chat.ChatSyncConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncConfiguration
    };

    // ----- ChatSyncManager class --------------------

    static PyObject* _new_ChatSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSyncManager(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSyncManager_AssociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"AssociateAccountAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.AssociateAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_IsAccountAssociated(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"IsAccountAssociated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.IsAccountAssociated(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_SetConfigurationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"SetConfigurationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_StartSync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"StartSync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StartSync();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_UnassociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"UnassociateAccountAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.UnassociateAccountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncManager[] = {
        { "associate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_AssociateAccountAsync), METH_VARARGS, nullptr },
        { "is_account_associated", reinterpret_cast<PyCFunction>(ChatSyncManager_IsAccountAssociated), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(ChatSyncManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "start_sync", reinterpret_cast<PyCFunction>(ChatSyncManager_StartSync), METH_VARARGS, nullptr },
        { "unassociate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_UnassociateAccountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSyncManager[] = {
        { "configuration", reinterpret_cast<getter>(ChatSyncManager_get_Configuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatSyncManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSyncManager) },
        { },
    };

    static PyType_Spec type_spec_ChatSyncManager =
    {
        "_winrt_windows_applicationmodel_chat.ChatSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncManager
    };

    // ----- RcsEndUserMessage class --------------------

    static PyObject* _new_RcsEndUserMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessage(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessage_SendResponseAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"SendResponseAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);

                return py::convert(self->obj.SendResponseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_SendResponseWithPinAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"SendResponseWithPinAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SendResponseWithPinAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Actions(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Actions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Actions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_IsPinRequired(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"IsPinRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPinRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessage[] = {
        { "send_response_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseAsync), METH_VARARGS, nullptr },
        { "send_response_with_pin_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseWithPinAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RcsEndUserMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessage[] = {
        { "actions", reinterpret_cast<getter>(RcsEndUserMessage_get_Actions), nullptr, nullptr, nullptr },
        { "is_pin_required", reinterpret_cast<getter>(RcsEndUserMessage_get_IsPinRequired), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(RcsEndUserMessage_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessage_get_Title), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsEndUserMessage_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessage) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessage =
    {
        "_winrt_windows_applicationmodel_chat.RcsEndUserMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessage
    };

    // ----- RcsEndUserMessageAction class --------------------

    static PyObject* _new_RcsEndUserMessageAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAction(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAction_get_Label(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAction", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAction[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAction[] = {
        { "label", reinterpret_cast<getter>(RcsEndUserMessageAction_get_Label), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAction) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageAction =
    {
        "_winrt_windows_applicationmodel_chat.RcsEndUserMessageAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAction
    };

    // ----- RcsEndUserMessageAvailableEventArgs class --------------------

    static PyObject* _new_RcsEndUserMessageAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs", L"IsMessageAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMessageAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_Message(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableEventArgs[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableEventArgs[] = {
        { "is_message_available", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageAvailableEventArgs =
    {
        "_winrt_windows_applicationmodel_chat.RcsEndUserMessageAvailableEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableEventArgs
    };

    // ----- RcsEndUserMessageAvailableTriggerDetails class --------------------

    static PyObject* _new_RcsEndUserMessageAvailableTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "text", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageAvailableTriggerDetails =
    {
        "_winrt_windows_applicationmodel_chat.RcsEndUserMessageAvailableTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTriggerDetails
    };

    // ----- RcsEndUserMessageManager class --------------------

    static PyObject* _new_RcsEndUserMessageManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageManager(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageManager_add_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageManager", L"MessageAvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager, winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>(arg);

            return py::convert(self->obj.MessageAvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageManager_remove_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageManager", L"MessageAvailableChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageAvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageManager[] = {
        { "add_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_add_MessageAvailableChanged), METH_O, nullptr },
        { "remove_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_remove_MessageAvailableChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RcsEndUserMessageManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageManager[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageManager) },
        { },
    };

    static PyType_Spec type_spec_RcsEndUserMessageManager =
    {
        "_winrt_windows_applicationmodel_chat.RcsEndUserMessageManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageManager
    };

    // ----- RcsManager class --------------------

    static PyObject* _new_RcsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::type_name);
        return nullptr;
    }

    static PyObject* RcsManager_GetEndUserMessageManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetEndUserMessageManager", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetEndUserMessageManager());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetTransportAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetTransportsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_LeaveConversationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"LeaveConversationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversation>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::LeaveConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_add_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"TransportListChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsManager_remove_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"TransportListChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsManager[] = {
        { "get_end_user_message_manager", reinterpret_cast<PyCFunction>(RcsManager_GetEndUserMessageManager), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transport_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "leave_conversation_async", reinterpret_cast<PyCFunction>(RcsManager_LeaveConversationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_add_TransportListChanged), METH_O | METH_STATIC, nullptr },
        { "remove_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_remove_TransportListChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsManager) },
        { },
    };

    static PyType_Spec type_spec_RcsManager =
    {
        "_winrt_windows_applicationmodel_chat.RcsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsManager
    };

    // ----- RcsServiceKindSupportedChangedEventArgs class --------------------

    static PyObject* _new_RcsServiceKindSupportedChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsServiceKindSupportedChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsServiceKindSupportedChangedEventArgs_get_ServiceKind(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs", L"ServiceKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServiceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsServiceKindSupportedChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RcsServiceKindSupportedChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsServiceKindSupportedChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsServiceKindSupportedChangedEventArgs[] = {
        { "service_kind", reinterpret_cast<getter>(RcsServiceKindSupportedChangedEventArgs_get_ServiceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsServiceKindSupportedChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsServiceKindSupportedChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RcsServiceKindSupportedChangedEventArgs =
    {
        "_winrt_windows_applicationmodel_chat.RcsServiceKindSupportedChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsServiceKindSupportedChangedEventArgs
    };

    // ----- RcsTransport class --------------------

    static PyObject* _new_RcsTransport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsTransport(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsTransport_IsServiceKindSupported(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsServiceKindSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsServiceKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_IsStoreAndForwardEnabled(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsStoreAndForwardEnabled", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsStoreAndForwardEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"TransportFriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_add_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ServiceKindSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsTransport, winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>(arg);

            return py::convert(self->obj.ServiceKindSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_remove_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ServiceKindSupportedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServiceKindSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsTransport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransport[] = {
        { "is_service_kind_supported", reinterpret_cast<PyCFunction>(RcsTransport_IsServiceKindSupported), METH_VARARGS, nullptr },
        { "is_store_and_forward_enabled", reinterpret_cast<PyCFunction>(RcsTransport_IsStoreAndForwardEnabled), METH_VARARGS, nullptr },
        { "add_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_add_ServiceKindSupportedChanged), METH_O, nullptr },
        { "remove_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_remove_ServiceKindSupportedChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RcsTransport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsTransport[] = {
        { "configuration", reinterpret_cast<getter>(RcsTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(RcsTransport_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(RcsTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(RcsTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsTransport_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsTransport[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsTransport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsTransport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsTransport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsTransport) },
        { },
    };

    static PyType_Spec type_spec_RcsTransport =
    {
        "_winrt_windows_applicationmodel_chat.RcsTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransport
    };

    // ----- RcsTransportConfiguration class --------------------

    static PyObject* _new_RcsTransportConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxAttachmentCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxFileSizeInKilobytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxGroupMessageSizeInKilobytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxGroupMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxMessageSizeInKilobytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxRecipientCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_WarningFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"WarningFileSizeInKilobytes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WarningFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransportConfiguration[] = {
        { "_assign_array_", _assign_array_RcsTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsTransportConfiguration[] = {
        { "max_attachment_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_group_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "warning_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_WarningFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsTransportConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsTransportConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsTransportConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsTransportConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsTransportConfiguration) },
        { },
    };

    static PyType_Spec type_spec_RcsTransportConfiguration =
    {
        "_winrt_windows_applicationmodel_chat.RcsTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransportConfiguration
    };

    // ----- RemoteParticipantComposingChangedEventArgs class --------------------

    static PyObject* _new_RemoteParticipantComposingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteParticipantComposingChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_IsComposing(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"IsComposing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsComposing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"ParticipantAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParticipantAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"TransportId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteParticipantComposingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteParticipantComposingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteParticipantComposingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteParticipantComposingChangedEventArgs[] = {
        { "is_composing", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_IsComposing), nullptr, nullptr, nullptr },
        { "participant_address", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteParticipantComposingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteParticipantComposingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RemoteParticipantComposingChangedEventArgs =
    {
        "_winrt_windows_applicationmodel_chat.RemoteParticipantComposingChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteParticipantComposingChangedEventArgs
    };

    // ----- IChatItem interface --------------------

    static PyObject* _new_IChatItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::type_name);
        return nullptr;
    }

    static void _dealloc_IChatItem(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IChatItem_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.IChatItem", L"ItemKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::IChatItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::IChatItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IChatItem[] = {
        { "_assign_array_", _assign_array_IChatItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IChatItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IChatItem[] = {
        { "item_kind", reinterpret_cast<getter>(IChatItem_get_ItemKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IChatItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IChatItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IChatItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IChatItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IChatItem) },
        { },
    };

    static PyType_Spec type_spec_IChatItem =
    {
        "_winrt_windows_applicationmodel_chat.IChatItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::IChatItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IChatItem
    };

    // ----- Windows.ApplicationModel.Chat Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Chat");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_chat",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Chat

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_chat(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Chat;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatCapabilitiesManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatConversation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatConversationReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatConversationThreadingInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageAttachment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageBlocking, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageChange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageChangeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageChangeTracker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageChangedDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageStoreChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageTransport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageTransportConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatMessageValidationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatQueryOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatRecipientDeliveryInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatSearchReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatSyncConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ChatSyncManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAvailableEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAvailableTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsEndUserMessageManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsServiceKindSupportedChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsTransport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RcsTransportConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RemoteParticipantComposingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IChatItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
