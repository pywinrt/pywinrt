// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Chat.h"

namespace py::cpp::Windows::ApplicationModel::Chat
{
    // ----- ChatCapabilities class --------------------

    static PyObject* _new_ChatCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatCapabilities(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatCapabilities_get_IsChatCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsChatCapable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsChatCapable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsFileTransferCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsFileTransferCapable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFileTransferCapable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsGeoLocationPushCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsGeoLocationPushCapable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsGeoLocationPushCapable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsIntegratedMessagingCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsIntegratedMessagingCapable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIntegratedMessagingCapable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsOnline(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatCapabilities", L"IsOnline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsOnline();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilities[] = {
        { "_assign_array_", _assign_array_ChatCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatCapabilities[] = {
        { "is_chat_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsChatCapable), nullptr, nullptr, nullptr },
        { "is_file_transfer_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsFileTransferCapable), nullptr, nullptr, nullptr },
        { "is_geo_location_push_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsGeoLocationPushCapable), nullptr, nullptr, nullptr },
        { "is_integrated_messaging_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsIntegratedMessagingCapable), nullptr, nullptr, nullptr },
        { "is_online", reinterpret_cast<getter>(ChatCapabilities_get_IsOnline), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatCapabilities) },
        { }};

    static PyType_Spec type_spec_ChatCapabilities = {
        "winrt._winrt_windows_applicationmodel_chat.ChatCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilities};

    // ----- ChatCapabilitiesManager class --------------------

    static PyObject* _new_ChatCapabilitiesManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::type_name);
        return nullptr;
    }

    static PyObject* ChatCapabilitiesManager_GetCachedCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCachedCapabilitiesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCachedCapabilitiesForTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCachedCapabilitiesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCapabilitiesFromNetworkAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCapabilitiesFromNetworkForTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatCapabilitiesManager", L"GetCapabilitiesFromNetworkAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilitiesManager[] = {
        { }};

    static PyGetSetDef _getset_ChatCapabilitiesManager[] = {
        { }};

    static PyType_Slot _type_slots_ChatCapabilitiesManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatCapabilitiesManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatCapabilitiesManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatCapabilitiesManager) },
        { }};

    static PyType_Spec type_spec_ChatCapabilitiesManager = {
        "winrt._winrt_windows_applicationmodel_chat.ChatCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilitiesManager};

    static PyGetSetDef getset_ChatCapabilitiesManager_Static[] = {
        { }};

    static PyMethodDef methods_ChatCapabilitiesManager_Static[] = {
        { "get_cached_capabilities_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCachedCapabilitiesAsync), METH_VARARGS, nullptr },
        { "get_cached_capabilities_for_transport_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCachedCapabilitiesForTransportAsync), METH_VARARGS, nullptr },
        { "get_capabilities_from_network_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync), METH_VARARGS, nullptr },
        { "get_capabilities_from_network_for_transport_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCapabilitiesFromNetworkForTransportAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ChatCapabilitiesManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ChatCapabilitiesManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ChatCapabilitiesManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ChatCapabilitiesManager_Static = {
        "winrt._winrt_windows_applicationmodel_chat.ChatCapabilitiesManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ChatCapabilitiesManager_Static};

    // ----- ChatConversation class --------------------

    static PyObject* _new_ChatConversation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatConversation(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversation_DeleteAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"GetMessageReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_MarkAllMessagesAsReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MarkMessagesAsReadAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkMessagesAsReadAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_MarkMessagesAsReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MarkMessagesAsReadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkMessagesAsReadAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyLocalParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"NotifyLocalParticipantComposing", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.NotifyLocalParticipantComposing(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyRemoteParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"NotifyRemoteParticipantComposing", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.NotifyRemoteParticipantComposing(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_SaveAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Subject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Subject(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"IsConversationMuted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsConversationMuted();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"IsConversationMuted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsConversationMuted(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_HasUnreadMessages(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"HasUnreadMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasUnreadMessages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"MostRecentMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MostRecentMessageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"Participants");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Participants();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"ThreadingInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ThreadingInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"CanModifyParticipants");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanModifyParticipants();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"CanModifyParticipants");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanModifyParticipants(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"ItemKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_add_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"RemoteParticipantComposingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatConversation, winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteParticipantComposingChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_remove_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatConversation", L"RemoteParticipantComposingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteParticipantComposingChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversation[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(ChatConversation_DeleteAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(ChatConversation_GetMessageReader), METH_VARARGS, nullptr },
        { "mark_all_messages_as_read_async", reinterpret_cast<PyCFunction>(ChatConversation_MarkAllMessagesAsReadAsync), METH_VARARGS, nullptr },
        { "mark_messages_as_read_async", reinterpret_cast<PyCFunction>(ChatConversation_MarkMessagesAsReadAsync), METH_VARARGS, nullptr },
        { "notify_local_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyLocalParticipantComposing), METH_VARARGS, nullptr },
        { "notify_remote_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyRemoteParticipantComposing), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(ChatConversation_SaveAsync), METH_VARARGS, nullptr },
        { "add_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_add_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "remove_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_remove_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ChatConversation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatConversation[] = {
        { "subject", reinterpret_cast<getter>(ChatConversation_get_Subject), reinterpret_cast<setter>(ChatConversation_put_Subject), nullptr, nullptr },
        { "is_conversation_muted", reinterpret_cast<getter>(ChatConversation_get_IsConversationMuted), reinterpret_cast<setter>(ChatConversation_put_IsConversationMuted), nullptr, nullptr },
        { "has_unread_messages", reinterpret_cast<getter>(ChatConversation_get_HasUnreadMessages), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatConversation_get_Id), nullptr, nullptr, nullptr },
        { "most_recent_message_id", reinterpret_cast<getter>(ChatConversation_get_MostRecentMessageId), nullptr, nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversation_get_Participants), nullptr, nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatConversation_get_ThreadingInfo), nullptr, nullptr, nullptr },
        { "can_modify_participants", reinterpret_cast<getter>(ChatConversation_get_CanModifyParticipants), reinterpret_cast<setter>(ChatConversation_put_CanModifyParticipants), nullptr, nullptr },
        { "item_kind", reinterpret_cast<getter>(ChatConversation_get_ItemKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatConversation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversation) },
        { }};

    static PyType_Spec type_spec_ChatConversation = {
        "winrt._winrt_windows_applicationmodel_chat.ChatConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversation};

    // ----- ChatConversationReader class --------------------

    static PyObject* _new_ChatConversationReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversationReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversationReader_ReadBatchWithCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatConversationReader", L"ReadBatchAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatConversationReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "read_batch_with_count_async", reinterpret_cast<PyCFunction>(ChatConversationReader_ReadBatchWithCountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatConversationReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatConversationReader[] = {
        { }};

    static PyType_Slot _type_slots_ChatConversationReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversationReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversationReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversationReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversationReader) },
        { }};

    static PyType_Spec type_spec_ChatConversationReader = {
        "winrt._winrt_windows_applicationmodel_chat.ChatConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationReader};

    // ----- ChatConversationThreadingInfo class --------------------

    static PyObject* _new_ChatConversationThreadingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatConversationThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatConversationThreadingInfo_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.Kind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Custom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Custom();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Custom");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Custom(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ConversationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConversationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ConversationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ConversationId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ContactId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"ContactId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContactId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatConversationThreadingInfo", L"Participants");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Participants();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationThreadingInfo[] = {
        { "_assign_array_", _assign_array_ChatConversationThreadingInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationThreadingInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatConversationThreadingInfo[] = {
        { "kind", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Kind), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Kind), nullptr, nullptr },
        { "custom", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Custom), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Custom), nullptr, nullptr },
        { "conversation_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ConversationId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ConversationId), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ContactId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ContactId), nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Participants), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatConversationThreadingInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatConversationThreadingInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatConversationThreadingInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatConversationThreadingInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatConversationThreadingInfo) },
        { }};

    static PyType_Spec type_spec_ChatConversationThreadingInfo = {
        "winrt._winrt_windows_applicationmodel_chat.ChatConversationThreadingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationThreadingInfo};

    // ----- ChatMessage class --------------------

    static PyObject* _new_ChatMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessage_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ItemKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsIncoming");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIncoming();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsIncoming");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsIncoming(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsForwardingDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsForwardingDisabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsForwardingDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsForwardingDisabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransportId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.From();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"From");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.From(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Subject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Subject(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsRead");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRead();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsRead");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsRead(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"NetworkTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NetworkTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"NetworkTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.NetworkTimestamp(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"LocalTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LocalTimestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"LocalTimestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.LocalTimestamp(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RecipientSendStatuses(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RecipientSendStatuses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecipientSendStatuses();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Recipients(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Recipients");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Recipients();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"TransportFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportFriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Attachments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attachments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSeen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSeen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSeen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSeen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReceivedDuringQuietHours");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReceivedDuringQuietHours();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReceivedDuringQuietHours");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsReceivedDuringQuietHours(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsAutoReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAutoReply();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsAutoReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsAutoReply(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"EstimatedDownloadSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EstimatedDownloadSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"EstimatedDownloadSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.EstimatedDownloadSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ThreadingInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ThreadingInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ThreadingInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(arg);

            {
                auto _gil = release_gil();
                self->obj.ThreadingInfo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ShouldSuppressNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldSuppressNotification();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"ShouldSuppressNotification");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShouldSuppressNotification(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageOperatorKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageOperatorKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"MessageOperatorKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageOperatorKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageOperatorKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReplyDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsReplyDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReplyDisabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSimMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"IsSimMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSimMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_RecipientsDeliveryInfos(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"RecipientsDeliveryInfos");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecipientsDeliveryInfos();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"SyncId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SyncId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessage", L"SyncId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SyncId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessage[] = {
        { "_assign_array_", _assign_array_ChatMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessage[] = {
        { "item_kind", reinterpret_cast<getter>(ChatMessage_get_ItemKind), nullptr, nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(ChatMessage_get_IsIncoming), reinterpret_cast<setter>(ChatMessage_put_IsIncoming), nullptr, nullptr },
        { "is_forwarding_disabled", reinterpret_cast<getter>(ChatMessage_get_IsForwardingDisabled), reinterpret_cast<setter>(ChatMessage_put_IsForwardingDisabled), nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessage_get_TransportId), reinterpret_cast<setter>(ChatMessage_put_TransportId), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessage_get_Status), reinterpret_cast<setter>(ChatMessage_put_Status), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ChatMessage_get_From), reinterpret_cast<setter>(ChatMessage_put_From), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(ChatMessage_get_Body), reinterpret_cast<setter>(ChatMessage_put_Body), nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(ChatMessage_get_Subject), reinterpret_cast<setter>(ChatMessage_put_Subject), nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(ChatMessage_get_IsRead), reinterpret_cast<setter>(ChatMessage_put_IsRead), nullptr, nullptr },
        { "network_timestamp", reinterpret_cast<getter>(ChatMessage_get_NetworkTimestamp), reinterpret_cast<setter>(ChatMessage_put_NetworkTimestamp), nullptr, nullptr },
        { "local_timestamp", reinterpret_cast<getter>(ChatMessage_get_LocalTimestamp), reinterpret_cast<setter>(ChatMessage_put_LocalTimestamp), nullptr, nullptr },
        { "recipient_send_statuses", reinterpret_cast<getter>(ChatMessage_get_RecipientSendStatuses), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(ChatMessage_get_Recipients), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessage_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "attachments", reinterpret_cast<getter>(ChatMessage_get_Attachments), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatMessage_get_Id), nullptr, nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(ChatMessage_get_IsSeen), reinterpret_cast<setter>(ChatMessage_put_IsSeen), nullptr, nullptr },
        { "message_kind", reinterpret_cast<getter>(ChatMessage_get_MessageKind), reinterpret_cast<setter>(ChatMessage_put_MessageKind), nullptr, nullptr },
        { "is_received_during_quiet_hours", reinterpret_cast<getter>(ChatMessage_get_IsReceivedDuringQuietHours), reinterpret_cast<setter>(ChatMessage_put_IsReceivedDuringQuietHours), nullptr, nullptr },
        { "is_auto_reply", reinterpret_cast<getter>(ChatMessage_get_IsAutoReply), reinterpret_cast<setter>(ChatMessage_put_IsAutoReply), nullptr, nullptr },
        { "estimated_download_size", reinterpret_cast<getter>(ChatMessage_get_EstimatedDownloadSize), reinterpret_cast<setter>(ChatMessage_put_EstimatedDownloadSize), nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatMessage_get_ThreadingInfo), reinterpret_cast<setter>(ChatMessage_put_ThreadingInfo), nullptr, nullptr },
        { "should_suppress_notification", reinterpret_cast<getter>(ChatMessage_get_ShouldSuppressNotification), reinterpret_cast<setter>(ChatMessage_put_ShouldSuppressNotification), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ChatMessage_get_RemoteId), reinterpret_cast<setter>(ChatMessage_put_RemoteId), nullptr, nullptr },
        { "message_operator_kind", reinterpret_cast<getter>(ChatMessage_get_MessageOperatorKind), reinterpret_cast<setter>(ChatMessage_put_MessageOperatorKind), nullptr, nullptr },
        { "is_reply_disabled", reinterpret_cast<getter>(ChatMessage_get_IsReplyDisabled), nullptr, nullptr, nullptr },
        { "is_sim_message", reinterpret_cast<getter>(ChatMessage_get_IsSimMessage), nullptr, nullptr, nullptr },
        { "recipients_delivery_infos", reinterpret_cast<getter>(ChatMessage_get_RecipientsDeliveryInfos), nullptr, nullptr, nullptr },
        { "sync_id", reinterpret_cast<getter>(ChatMessage_get_SyncId), reinterpret_cast<setter>(ChatMessage_put_SyncId), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessage) },
        { }};

    static PyType_Spec type_spec_ChatMessage = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessage};

    // ----- ChatMessageAttachment class --------------------

    static PyObject* _new_ChatMessageAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageAttachment(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageAttachment_get_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"MimeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MimeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"MimeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.MimeType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"GroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"GroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.GroupId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"DataStreamReference");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DataStreamReference();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"DataStreamReference");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.DataStreamReference(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"TransferProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransferProgress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"TransferProgress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransferProgress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Thumbnail(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"OriginalFileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OriginalFileName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageAttachment", L"OriginalFileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.OriginalFileName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageAttachment[] = {
        { "_assign_array_", _assign_array_ChatMessageAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageAttachment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageAttachment[] = {
        { "text", reinterpret_cast<getter>(ChatMessageAttachment_get_Text), reinterpret_cast<setter>(ChatMessageAttachment_put_Text), nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(ChatMessageAttachment_get_MimeType), reinterpret_cast<setter>(ChatMessageAttachment_put_MimeType), nullptr, nullptr },
        { "group_id", reinterpret_cast<getter>(ChatMessageAttachment_get_GroupId), reinterpret_cast<setter>(ChatMessageAttachment_put_GroupId), nullptr, nullptr },
        { "data_stream_reference", reinterpret_cast<getter>(ChatMessageAttachment_get_DataStreamReference), reinterpret_cast<setter>(ChatMessageAttachment_put_DataStreamReference), nullptr, nullptr },
        { "transfer_progress", reinterpret_cast<getter>(ChatMessageAttachment_get_TransferProgress), reinterpret_cast<setter>(ChatMessageAttachment_put_TransferProgress), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(ChatMessageAttachment_get_Thumbnail), reinterpret_cast<setter>(ChatMessageAttachment_put_Thumbnail), nullptr, nullptr },
        { "original_file_name", reinterpret_cast<getter>(ChatMessageAttachment_get_OriginalFileName), reinterpret_cast<setter>(ChatMessageAttachment_put_OriginalFileName), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageAttachment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageAttachment) },
        { }};

    static PyType_Spec type_spec_ChatMessageAttachment = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageAttachment};

    // ----- ChatMessageBlocking class --------------------

    static PyObject* _new_ChatMessageBlocking(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::type_name);
        return nullptr;
    }

    static PyObject* ChatMessageBlocking_MarkMessageAsBlockedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageBlocking", L"MarkMessageAsBlockedAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking::MarkMessageAsBlockedAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageBlocking[] = {
        { }};

    static PyGetSetDef _getset_ChatMessageBlocking[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageBlocking[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageBlocking) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageBlocking) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageBlocking) },
        { }};

    static PyType_Spec type_spec_ChatMessageBlocking = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageBlocking};

    static PyGetSetDef getset_ChatMessageBlocking_Static[] = {
        { }};

    static PyMethodDef methods_ChatMessageBlocking_Static[] = {
        { "mark_message_as_blocked_async", reinterpret_cast<PyCFunction>(ChatMessageBlocking_MarkMessageAsBlockedAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ChatMessageBlocking_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ChatMessageBlocking_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ChatMessageBlocking_Static) },
        { }
    };

    static PyType_Spec type_spec_ChatMessageBlocking_Static = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageBlocking_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ChatMessageBlocking_Static};

    // ----- ChatMessageChange class --------------------

    static PyObject* _new_ChatMessageChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChange(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageChange", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageChange_get_Message(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageChange", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChange[] = {
        { "_assign_array_", _assign_array_ChatMessageChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChange), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageChange[] = {
        { "change_type", reinterpret_cast<getter>(ChatMessageChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(ChatMessageChange_get_Message), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageChange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChange) },
        { }};

    static PyType_Spec type_spec_ChatMessageChange = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChange};

    // ----- ChatMessageChangeReader class --------------------

    static PyObject* _new_ChatMessageChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"AcceptChanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AcceptChanges();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"AcceptChangesThrough", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AcceptChangesThrough(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageChangeReader[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageChangeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangeReader) },
        { }};

    static PyType_Spec type_spec_ChatMessageChangeReader = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeReader};

    // ----- ChatMessageChangeTracker class --------------------

    static PyObject* _new_ChatMessageChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"Enable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Enable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"GetChangeReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChangeReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangeTracker", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeTracker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageChangeTracker[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageChangeTracker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangeTracker) },
        { }};

    static PyType_Spec type_spec_ChatMessageChangeTracker = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeTracker};

    // ----- ChatMessageChangedDeferral class --------------------

    static PyObject* _new_ChatMessageChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangedDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ChatMessageChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageChangedDeferral[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageChangedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangedDeferral) },
        { }};

    static PyType_Spec type_spec_ChatMessageChangedDeferral = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedDeferral};

    // ----- ChatMessageChangedEventArgs class --------------------

    static PyObject* _new_ChatMessageChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageChangedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ChatMessageChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ChatMessageChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedEventArgs};

    // ----- ChatMessageManager class --------------------

    static PyObject* _new_ChatMessageManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::type_name);
        return nullptr;
    }

    static PyObject* ChatMessageManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"GetTransportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"GetTransportsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RegisterTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RegisterTransportAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RegisterTransportAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RequestStoreAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestStoreAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestSyncManagerAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"RequestSyncManagerAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestSyncManagerAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowComposeSmsMessageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"ShowComposeSmsMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowComposeSmsMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowSmsSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageManager", L"ShowSmsSettings", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowSmsSettings();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageManager[] = {
        { }};

    static PyGetSetDef _getset_ChatMessageManager[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageManager) },
        { }};

    static PyType_Spec type_spec_ChatMessageManager = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageManager};

    static PyGetSetDef getset_ChatMessageManager_Static[] = {
        { }};

    static PyMethodDef methods_ChatMessageManager_Static[] = {
        { "get_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportAsync), METH_VARARGS, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportsAsync), METH_VARARGS, nullptr },
        { "register_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RegisterTransportAsync), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { "request_sync_manager_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestSyncManagerAsync), METH_VARARGS, nullptr },
        { "show_compose_sms_message_async", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowComposeSmsMessageAsync), METH_VARARGS, nullptr },
        { "show_sms_settings", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowSmsSettings), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ChatMessageManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ChatMessageManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ChatMessageManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ChatMessageManager_Static = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ChatMessageManager_Static};

    // ----- ChatMessageNotificationTriggerDetails class --------------------

    static PyObject* _new_ChatMessageNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ChatMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChatMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldDisplayToast");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldDisplayToast();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateActionCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldUpdateActionCenter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateBadge");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldUpdateBadge();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageNotificationTriggerDetails", L"ShouldUpdateDetailText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShouldUpdateDetailText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ChatMessageNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageNotificationTriggerDetails[] = {
        { "chat_message", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ChatMessage), nullptr, nullptr, nullptr },
        { "should_display_toast", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast), nullptr, nullptr, nullptr },
        { "should_update_action_center", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter), nullptr, nullptr, nullptr },
        { "should_update_badge", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge), nullptr, nullptr, nullptr },
        { "should_update_detail_text", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageNotificationTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageNotificationTriggerDetails) },
        { }};

    static PyType_Spec type_spec_ChatMessageNotificationTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTriggerDetails};

    // ----- ChatMessageReader class --------------------

    static PyObject* _new_ChatMessageReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageReader_ReadBatchWithCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageReader", L"ReadBatchAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "read_batch_with_count_async", reinterpret_cast<PyCFunction>(ChatMessageReader_ReadBatchWithCountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageReader[] = {
        { }};

    static PyType_Slot _type_slots_ChatMessageReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageReader) },
        { }};

    static PyType_Spec type_spec_ChatMessageReader = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReader};

    // ----- ChatMessageStore class --------------------

    static PyObject* _new_ChatMessageStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageStore(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageStore_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"DeleteMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"DownloadMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DownloadMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ForwardMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ForwardMessageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ForwardMessageAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationForTransportsAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationForTransportsReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationFromThreadingInfoAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationFromThreadingInfoAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationFromThreadingInfoAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetConversationReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageByRemoteIdAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageByRemoteIdAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageBySyncIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageBySyncIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageBySyncIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageReader1(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageReader2(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetMessageReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetSearchReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSearchReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetUnseenCountAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUnseenCountAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetUnseenCountForTransportsReaderAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"GetUnseenCountAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUnseenCountAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkAsSeenAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkAsSeenAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkAsSeenAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkAsSeenForTransportsAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkAsSeenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkAsSeenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MarkMessageReadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkMessageReadAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_RetrySendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"RetrySendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RetrySendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"SaveMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"SendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelDownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"TryCancelDownloadMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancelDownloadMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelSendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"TryCancelSendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCancelSendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ValidateMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ValidateMessage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ValidateMessage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"ChangeTracker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeTracker();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MessageChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"MessageChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"StoreChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StoreChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.ChatMessageStore", L"StoreChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StoreChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStore[] = {
        { "delete_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DownloadMessageAsync), METH_VARARGS, nullptr },
        { "forward_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_ForwardMessageAsync), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_for_transports_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationForTransportsAsync), METH_VARARGS, nullptr },
        { "get_conversation_for_transports_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationForTransportsReader), METH_VARARGS, nullptr },
        { "get_conversation_from_threading_info_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationFromThreadingInfoAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationReader), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_by_remote_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_message_by_sync_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageBySyncIdAsync), METH_VARARGS, nullptr },
        { "get_message_reader1", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageReader1), METH_VARARGS, nullptr },
        { "get_message_reader2", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageReader2), METH_VARARGS, nullptr },
        { "get_search_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetSearchReader), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "get_unseen_count_for_transports_reader_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetUnseenCountForTransportsReaderAsync), METH_VARARGS, nullptr },
        { "mark_as_seen_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_as_seen_for_transports_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkAsSeenForTransportsAsync), METH_VARARGS, nullptr },
        { "mark_message_read_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkMessageReadAsync), METH_VARARGS, nullptr },
        { "retry_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_RetrySendMessageAsync), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SaveMessageAsync), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SendMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelDownloadMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelSendMessageAsync), METH_VARARGS, nullptr },
        { "validate_message", reinterpret_cast<PyCFunction>(ChatMessageStore_ValidateMessage), METH_VARARGS, nullptr },
        { "add_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_MessageChanged), METH_O, nullptr },
        { "remove_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_MessageChanged), METH_O, nullptr },
        { "add_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_StoreChanged), METH_O, nullptr },
        { "remove_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_StoreChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ChatMessageStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStore), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageStore[] = {
        { "change_tracker", reinterpret_cast<getter>(ChatMessageStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageStore) },
        { }};

    static PyType_Spec type_spec_ChatMessageStore = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStore};

    // ----- ChatMessageStoreChangedEventArgs class --------------------

    static PyObject* _new_ChatMessageStoreChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageStoreChangedEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStoreChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ChatMessageStoreChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStoreChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageStoreChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageStoreChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageStoreChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageStoreChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageStoreChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageStoreChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ChatMessageStoreChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStoreChangedEventArgs};

    // ----- ChatMessageTransport class --------------------

    static PyObject* _new_ChatMessageTransport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransport(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageTransport_RequestSetAsNotificationProviderAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"RequestSetAsNotificationProviderAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestSetAsNotificationProviderAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsAppSetAsNotificationProvider(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"IsAppSetAsNotificationProvider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAppSetAsNotificationProvider();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportFriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransport", L"TransportKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransport[] = {
        { "request_set_as_notification_provider_async", reinterpret_cast<PyCFunction>(ChatMessageTransport_RequestSetAsNotificationProviderAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatMessageTransport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageTransport[] = {
        { "is_active", reinterpret_cast<getter>(ChatMessageTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "is_app_set_as_notification_provider", reinterpret_cast<getter>(ChatMessageTransport_get_IsAppSetAsNotificationProvider), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessageTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessageTransport_get_TransportId), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(ChatMessageTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "transport_kind", reinterpret_cast<getter>(ChatMessageTransport_get_TransportKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageTransport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageTransport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageTransport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageTransport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageTransport) },
        { }};

    static PyType_Spec type_spec_ChatMessageTransport = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransport};

    // ----- ChatMessageTransportConfiguration class --------------------

    static PyObject* _new_ChatMessageTransportConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageTransportConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxAttachmentCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxAttachmentCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxMessageSizeInKilobytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxMessageSizeInKilobytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"MaxRecipientCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxRecipientCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_SupportedVideoFormat(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageTransportConfiguration", L"SupportedVideoFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedVideoFormat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransportConfiguration[] = {
        { "_assign_array_", _assign_array_ChatMessageTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageTransportConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "max_attachment_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "supported_video_format", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_SupportedVideoFormat), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageTransportConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageTransportConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageTransportConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageTransportConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageTransportConfiguration) },
        { }};

    static PyType_Spec type_spec_ChatMessageTransportConfiguration = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransportConfiguration};

    // ----- ChatMessageValidationResult class --------------------

    static PyObject* _new_ChatMessageValidationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatMessageValidationResult(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatMessageValidationResult_get_MaxPartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"MaxPartCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxPartCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_PartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"PartCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_RemainingCharacterCountInPart(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"RemainingCharacterCountInPart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemainingCharacterCountInPart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatMessageValidationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageValidationResult[] = {
        { "_assign_array_", _assign_array_ChatMessageValidationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageValidationResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatMessageValidationResult[] = {
        { "max_part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_MaxPartCount), nullptr, nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_PartCount), nullptr, nullptr, nullptr },
        { "remaining_character_count_in_part", reinterpret_cast<getter>(ChatMessageValidationResult_get_RemainingCharacterCountInPart), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessageValidationResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatMessageValidationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatMessageValidationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatMessageValidationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatMessageValidationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatMessageValidationResult) },
        { }};

    static PyType_Spec type_spec_ChatMessageValidationResult = {
        "winrt._winrt_windows_applicationmodel_chat.ChatMessageValidationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageValidationResult};

    // ----- ChatQueryOptions class --------------------

    static PyObject* _new_ChatQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatQueryOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatQueryOptions(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatQueryOptions_get_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatQueryOptions", L"SearchString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatQueryOptions_put_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatQueryOptions", L"SearchString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.SearchString(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatQueryOptions[] = {
        { "_assign_array_", _assign_array_ChatQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatQueryOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatQueryOptions[] = {
        { "search_string", reinterpret_cast<getter>(ChatQueryOptions_get_SearchString), reinterpret_cast<setter>(ChatQueryOptions_put_SearchString), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatQueryOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatQueryOptions) },
        { }};

    static PyType_Spec type_spec_ChatQueryOptions = {
        "winrt._winrt_windows_applicationmodel_chat.ChatQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatQueryOptions};

    // ----- ChatRecipientDeliveryInfo class --------------------

    static PyObject* _new_ChatRecipientDeliveryInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatRecipientDeliveryInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.TransportAddress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"ReadTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReadTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"ReadTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ReadTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"DeliveryTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeliveryTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"DeliveryTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeliveryTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_IsErrorPermanent(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"IsErrorPermanent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsErrorPermanent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportErrorCodeCategory");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportErrorCodeCategory();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatRecipientDeliveryInfo", L"TransportInterpretedErrorCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportInterpretedErrorCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatRecipientDeliveryInfo[] = {
        { "_assign_array_", _assign_array_ChatRecipientDeliveryInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatRecipientDeliveryInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatRecipientDeliveryInfo[] = {
        { "transport_address", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportAddress), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_TransportAddress), nullptr, nullptr },
        { "read_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_ReadTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_ReadTime), nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_DeliveryTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_DeliveryTime), nullptr, nullptr },
        { "is_error_permanent", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_IsErrorPermanent), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_Status), nullptr, nullptr, nullptr },
        { "transport_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCode), nullptr, nullptr, nullptr },
        { "transport_error_code_category", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory), nullptr, nullptr, nullptr },
        { "transport_interpreted_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatRecipientDeliveryInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatRecipientDeliveryInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatRecipientDeliveryInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatRecipientDeliveryInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatRecipientDeliveryInfo) },
        { }};

    static PyType_Spec type_spec_ChatRecipientDeliveryInfo = {
        "winrt._winrt_windows_applicationmodel_chat.ChatRecipientDeliveryInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatRecipientDeliveryInfo};

    // ----- ChatSearchReader class --------------------

    static PyObject* _new_ChatSearchReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSearchReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSearchReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSearchReader_ReadBatchWithCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSearchReader", L"ReadBatchAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSearchReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatSearchReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "read_batch_with_count_async", reinterpret_cast<PyCFunction>(ChatSearchReader_ReadBatchWithCountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatSearchReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSearchReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatSearchReader[] = {
        { }};

    static PyType_Slot _type_slots_ChatSearchReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSearchReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSearchReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSearchReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSearchReader) },
        { }};

    static PyType_Spec type_spec_ChatSearchReader = {
        "winrt._winrt_windows_applicationmodel_chat.ChatSearchReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSearchReader};

    // ----- ChatSyncConfiguration class --------------------

    static PyObject* _new_ChatSyncConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSyncConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSyncConfiguration_get_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"RestoreHistorySpan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RestoreHistorySpan();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"RestoreHistorySpan");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatRestoreHistorySpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.RestoreHistorySpan(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatSyncConfiguration_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"IsSyncEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSyncEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncConfiguration", L"IsSyncEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSyncEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncConfiguration[] = {
        { "_assign_array_", _assign_array_ChatSyncConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatSyncConfiguration[] = {
        { "restore_history_span", reinterpret_cast<getter>(ChatSyncConfiguration_get_RestoreHistorySpan), reinterpret_cast<setter>(ChatSyncConfiguration_put_RestoreHistorySpan), nullptr, nullptr },
        { "is_sync_enabled", reinterpret_cast<getter>(ChatSyncConfiguration_get_IsSyncEnabled), reinterpret_cast<setter>(ChatSyncConfiguration_put_IsSyncEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatSyncConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSyncConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSyncConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSyncConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSyncConfiguration) },
        { }};

    static PyType_Spec type_spec_ChatSyncConfiguration = {
        "winrt._winrt_windows_applicationmodel_chat.ChatSyncConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncConfiguration};

    // ----- ChatSyncManager class --------------------

    static PyObject* _new_ChatSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_ChatSyncManager(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChatSyncManager_AssociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"AssociateAccountAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.AssociateAccountAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_IsAccountAssociated(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"IsAccountAssociated", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsAccountAssociated(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_SetConfigurationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"SetConfigurationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetConfigurationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_StartSync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"StartSync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.StartSync();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_UnassociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"UnassociateAccountAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.UnassociateAccountAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.ChatSyncManager", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncManager[] = {
        { "associate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_AssociateAccountAsync), METH_VARARGS, nullptr },
        { "is_account_associated", reinterpret_cast<PyCFunction>(ChatSyncManager_IsAccountAssociated), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(ChatSyncManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "start_sync", reinterpret_cast<PyCFunction>(ChatSyncManager_StartSync), METH_VARARGS, nullptr },
        { "unassociate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_UnassociateAccountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ChatSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ChatSyncManager[] = {
        { "configuration", reinterpret_cast<getter>(ChatSyncManager_get_Configuration), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ChatSyncManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ChatSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ChatSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ChatSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ChatSyncManager) },
        { }};

    static PyType_Spec type_spec_ChatSyncManager = {
        "winrt._winrt_windows_applicationmodel_chat.ChatSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncManager};

    // ----- RcsEndUserMessage class --------------------

    static PyObject* _new_RcsEndUserMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessage(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessage_SendResponseAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"SendResponseAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendResponseAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_SendResponseWithPinAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"SendResponseWithPinAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendResponseWithPinAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Actions(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Actions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Actions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_IsPinRequired(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"IsPinRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPinRequired();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessage", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessage[] = {
        { "send_response_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseAsync), METH_VARARGS, nullptr },
        { "send_response_with_pin_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseWithPinAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RcsEndUserMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsEndUserMessage[] = {
        { "actions", reinterpret_cast<getter>(RcsEndUserMessage_get_Actions), nullptr, nullptr, nullptr },
        { "is_pin_required", reinterpret_cast<getter>(RcsEndUserMessage_get_IsPinRequired), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(RcsEndUserMessage_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessage_get_Title), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsEndUserMessage_get_TransportId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsEndUserMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessage) },
        { }};

    static PyType_Spec type_spec_RcsEndUserMessage = {
        "winrt._winrt_windows_applicationmodel_chat.RcsEndUserMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessage};

    // ----- RcsEndUserMessageAction class --------------------

    static PyObject* _new_RcsEndUserMessageAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAction(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAction_get_Label(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAction", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Label();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAction[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAction), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsEndUserMessageAction[] = {
        { "label", reinterpret_cast<getter>(RcsEndUserMessageAction_get_Label), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsEndUserMessageAction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAction) },
        { }};

    static PyType_Spec type_spec_RcsEndUserMessageAction = {
        "winrt._winrt_windows_applicationmodel_chat.RcsEndUserMessageAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAction};

    // ----- RcsEndUserMessageAvailableEventArgs class --------------------

    static PyObject* _new_RcsEndUserMessageAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs", L"IsMessageAvailable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMessageAvailable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_Message(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableEventArgs", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableEventArgs[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsEndUserMessageAvailableEventArgs[] = {
        { "is_message_available", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableEventArgs) },
        { }};

    static PyType_Spec type_spec_RcsEndUserMessageAvailableEventArgs = {
        "winrt._winrt_windows_applicationmodel_chat.RcsEndUserMessageAvailableEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableEventArgs};

    // ----- RcsEndUserMessageAvailableTriggerDetails class --------------------

    static PyObject* _new_RcsEndUserMessageAvailableTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageAvailableTriggerDetails", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "_assign_array_", _assign_array_RcsEndUserMessageAvailableTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "text", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageAvailableTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageAvailableTriggerDetails) },
        { }};

    static PyType_Spec type_spec_RcsEndUserMessageAvailableTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_chat.RcsEndUserMessageAvailableTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTriggerDetails};

    // ----- RcsEndUserMessageManager class --------------------

    static PyObject* _new_RcsEndUserMessageManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageManager(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsEndUserMessageManager_add_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageManager", L"MessageAvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager, winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageAvailableChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageManager_remove_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsEndUserMessageManager", L"MessageAvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageAvailableChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageManager[] = {
        { "add_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_add_MessageAvailableChanged), METH_O, nullptr },
        { "remove_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_remove_MessageAvailableChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RcsEndUserMessageManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsEndUserMessageManager[] = {
        { }};

    static PyType_Slot _type_slots_RcsEndUserMessageManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsEndUserMessageManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsEndUserMessageManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsEndUserMessageManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsEndUserMessageManager) },
        { }};

    static PyType_Spec type_spec_RcsEndUserMessageManager = {
        "winrt._winrt_windows_applicationmodel_chat.RcsEndUserMessageManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageManager};

    // ----- RcsManager class --------------------

    static PyObject* _new_RcsManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::type_name);
        return nullptr;
    }

    static PyObject* RcsManager_GetEndUserMessageManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetEndUserMessageManager", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::RcsManager::GetEndUserMessageManager();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetTransportAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"GetTransportsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_LeaveConversationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"LeaveConversationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversation>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Chat::RcsManager::LeaveConversationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_add_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"TransportListChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsManager_remove_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsManager", L"TransportListChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsManager[] = {
        { }};

    static PyGetSetDef _getset_RcsManager[] = {
        { }};

    static PyType_Slot _type_slots_RcsManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsManager) },
        { }};

    static PyType_Spec type_spec_RcsManager = {
        "winrt._winrt_windows_applicationmodel_chat.RcsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsManager};

    static PyGetSetDef getset_RcsManager_Static[] = {
        { }};

    static PyMethodDef methods_RcsManager_Static[] = {
        { "get_end_user_message_manager", reinterpret_cast<PyCFunction>(RcsManager_GetEndUserMessageManager), METH_VARARGS, nullptr },
        { "get_transport_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportAsync), METH_VARARGS, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportsAsync), METH_VARARGS, nullptr },
        { "leave_conversation_async", reinterpret_cast<PyCFunction>(RcsManager_LeaveConversationAsync), METH_VARARGS, nullptr },
        { "add_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_add_TransportListChanged), METH_O, nullptr },
        { "remove_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_remove_TransportListChanged), METH_O, nullptr },
        { }};

    static PyType_Slot type_slots_RcsManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RcsManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RcsManager_Static) },
        { }
    };

    static PyType_Spec type_spec_RcsManager_Static = {
        "winrt._winrt_windows_applicationmodel_chat.RcsManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RcsManager_Static};

    // ----- RcsServiceKindSupportedChangedEventArgs class --------------------

    static PyObject* _new_RcsServiceKindSupportedChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsServiceKindSupportedChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsServiceKindSupportedChangedEventArgs_get_ServiceKind(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsServiceKindSupportedChangedEventArgs", L"ServiceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsServiceKindSupportedChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RcsServiceKindSupportedChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsServiceKindSupportedChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsServiceKindSupportedChangedEventArgs[] = {
        { "service_kind", reinterpret_cast<getter>(RcsServiceKindSupportedChangedEventArgs_get_ServiceKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsServiceKindSupportedChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsServiceKindSupportedChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsServiceKindSupportedChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_RcsServiceKindSupportedChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_chat.RcsServiceKindSupportedChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsServiceKindSupportedChangedEventArgs};

    // ----- RcsTransport class --------------------

    static PyObject* _new_RcsTransport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsTransport(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsTransport_IsServiceKindSupported(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsServiceKindSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsServiceKindSupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_IsStoreAndForwardEnabled(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsStoreAndForwardEnabled", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsStoreAndForwardEnabled(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"Configuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Configuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ExtendedProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"TransportFriendlyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportFriendlyName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_add_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ServiceKindSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsTransport, winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ServiceKindSupportedChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_remove_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Chat.RcsTransport", L"ServiceKindSupportedChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ServiceKindSupportedChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsTransport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransport[] = {
        { "is_service_kind_supported", reinterpret_cast<PyCFunction>(RcsTransport_IsServiceKindSupported), METH_VARARGS, nullptr },
        { "is_store_and_forward_enabled", reinterpret_cast<PyCFunction>(RcsTransport_IsStoreAndForwardEnabled), METH_VARARGS, nullptr },
        { "add_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_add_ServiceKindSupportedChanged), METH_O, nullptr },
        { "remove_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_remove_ServiceKindSupportedChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RcsTransport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransport), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsTransport[] = {
        { "configuration", reinterpret_cast<getter>(RcsTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(RcsTransport_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(RcsTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(RcsTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsTransport_get_TransportId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsTransport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsTransport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsTransport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsTransport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsTransport) },
        { }};

    static PyType_Spec type_spec_RcsTransport = {
        "winrt._winrt_windows_applicationmodel_chat.RcsTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransport};

    // ----- RcsTransportConfiguration class --------------------

    static PyObject* _new_RcsTransportConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_RcsTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RcsTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxAttachmentCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxAttachmentCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxFileSizeInKilobytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxFileSizeInKilobytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxGroupMessageSizeInKilobytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxGroupMessageSizeInKilobytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxMessageSizeInKilobytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxMessageSizeInKilobytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"MaxRecipientCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxRecipientCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_WarningFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RcsTransportConfiguration", L"WarningFileSizeInKilobytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WarningFileSizeInKilobytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransportConfiguration[] = {
        { "_assign_array_", _assign_array_RcsTransportConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RcsTransportConfiguration[] = {
        { "max_attachment_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_group_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "warning_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_WarningFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RcsTransportConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RcsTransportConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RcsTransportConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RcsTransportConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RcsTransportConfiguration) },
        { }};

    static PyType_Spec type_spec_RcsTransportConfiguration = {
        "winrt._winrt_windows_applicationmodel_chat.RcsTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransportConfiguration};

    // ----- RemoteParticipantComposingChangedEventArgs class --------------------

    static PyObject* _new_RemoteParticipantComposingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteParticipantComposingChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_IsComposing(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"IsComposing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsComposing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"ParticipantAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ParticipantAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.RemoteParticipantComposingChangedEventArgs", L"TransportId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TransportId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteParticipantComposingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteParticipantComposingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteParticipantComposingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RemoteParticipantComposingChangedEventArgs[] = {
        { "is_composing", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_IsComposing), nullptr, nullptr, nullptr },
        { "participant_address", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_TransportId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RemoteParticipantComposingChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteParticipantComposingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteParticipantComposingChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_RemoteParticipantComposingChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_chat.RemoteParticipantComposingChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteParticipantComposingChangedEventArgs};

    // ----- IChatItem interface --------------------

    static PyObject* _new_IChatItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::type_name);
        return nullptr;
    }

    static void _dealloc_IChatItem(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IChatItem_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Chat.IChatItem", L"ItemKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Chat::IChatItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::IChatItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IChatItem[] = {
        { "_assign_array_", _assign_array_IChatItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IChatItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_IChatItem[] = {
        { "item_kind", reinterpret_cast<getter>(IChatItem_get_ItemKind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IChatItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IChatItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IChatItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IChatItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IChatItem) },
        { }};

    static PyType_Spec type_spec_IChatItem = {
        "winrt._winrt_windows_applicationmodel_chat.IChatItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::IChatItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IChatItem};

    struct ImplementsIChatItem : py::ImplementsInterfaceT<ImplementsIChatItem, winrt::Windows::ApplicationModel::Chat::IChatItem>
    {
        ImplementsIChatItem() = delete;
        ImplementsIChatItem(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIChatItem, winrt::Windows::ApplicationModel::Chat::IChatItem>(py_obj, runtime_class)
        {
        }

        auto ItemKind()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "item_kind")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatItemKind>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIChatItem(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::ApplicationModel::Chat::IChatItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIChatItem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIChatItem>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIChatItem[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIChatItem), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIChatItem), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIChatItem[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIChatItem) },
        { }};

    static PyType_Spec type_spec_ImplementsIChatItem = {
        "winrt._winrt_windows_applicationmodel_chat.ImplementsIChatItem",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIChatItem};

    // ----- Windows.ApplicationModel.Chat Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Chat");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_chat",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Chat

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_chat(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Chat;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle ChatCapabilities_type{py::register_python_type(module.get(), &type_spec_ChatCapabilities, object_bases.get(), nullptr)};
    if (!ChatCapabilities_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ChatCapabilitiesManager_Static{PyType_FromSpec(&type_spec_ChatCapabilitiesManager_Static)};
    if (!type_ChatCapabilitiesManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle ChatCapabilitiesManager_type{py::register_python_type(module.get(), &type_spec_ChatCapabilitiesManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ChatCapabilitiesManager_Static.get()))};
    if (!ChatCapabilitiesManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatConversation_type{py::register_python_type(module.get(), &type_spec_ChatConversation, object_bases.get(), nullptr)};
    if (!ChatConversation_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatConversationReader_type{py::register_python_type(module.get(), &type_spec_ChatConversationReader, object_bases.get(), nullptr)};
    if (!ChatConversationReader_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatConversationThreadingInfo_type{py::register_python_type(module.get(), &type_spec_ChatConversationThreadingInfo, object_bases.get(), nullptr)};
    if (!ChatConversationThreadingInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessage_type{py::register_python_type(module.get(), &type_spec_ChatMessage, object_bases.get(), nullptr)};
    if (!ChatMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageAttachment_type{py::register_python_type(module.get(), &type_spec_ChatMessageAttachment, object_bases.get(), nullptr)};
    if (!ChatMessageAttachment_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ChatMessageBlocking_Static{PyType_FromSpec(&type_spec_ChatMessageBlocking_Static)};
    if (!type_ChatMessageBlocking_Static)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageBlocking_type{py::register_python_type(module.get(), &type_spec_ChatMessageBlocking, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ChatMessageBlocking_Static.get()))};
    if (!ChatMessageBlocking_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageChange_type{py::register_python_type(module.get(), &type_spec_ChatMessageChange, object_bases.get(), nullptr)};
    if (!ChatMessageChange_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageChangeReader_type{py::register_python_type(module.get(), &type_spec_ChatMessageChangeReader, object_bases.get(), nullptr)};
    if (!ChatMessageChangeReader_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageChangeTracker_type{py::register_python_type(module.get(), &type_spec_ChatMessageChangeTracker, object_bases.get(), nullptr)};
    if (!ChatMessageChangeTracker_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageChangedDeferral_type{py::register_python_type(module.get(), &type_spec_ChatMessageChangedDeferral, object_bases.get(), nullptr)};
    if (!ChatMessageChangedDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ChatMessageChangedEventArgs, object_bases.get(), nullptr)};
    if (!ChatMessageChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ChatMessageManager_Static{PyType_FromSpec(&type_spec_ChatMessageManager_Static)};
    if (!type_ChatMessageManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageManager_type{py::register_python_type(module.get(), &type_spec_ChatMessageManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ChatMessageManager_Static.get()))};
    if (!ChatMessageManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageNotificationTriggerDetails_type{py::register_python_type(module.get(), &type_spec_ChatMessageNotificationTriggerDetails, object_bases.get(), nullptr)};
    if (!ChatMessageNotificationTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageReader_type{py::register_python_type(module.get(), &type_spec_ChatMessageReader, object_bases.get(), nullptr)};
    if (!ChatMessageReader_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageStore_type{py::register_python_type(module.get(), &type_spec_ChatMessageStore, object_bases.get(), nullptr)};
    if (!ChatMessageStore_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageStoreChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ChatMessageStoreChangedEventArgs, object_bases.get(), nullptr)};
    if (!ChatMessageStoreChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageTransport_type{py::register_python_type(module.get(), &type_spec_ChatMessageTransport, object_bases.get(), nullptr)};
    if (!ChatMessageTransport_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageTransportConfiguration_type{py::register_python_type(module.get(), &type_spec_ChatMessageTransportConfiguration, object_bases.get(), nullptr)};
    if (!ChatMessageTransportConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatMessageValidationResult_type{py::register_python_type(module.get(), &type_spec_ChatMessageValidationResult, object_bases.get(), nullptr)};
    if (!ChatMessageValidationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatQueryOptions_type{py::register_python_type(module.get(), &type_spec_ChatQueryOptions, object_bases.get(), nullptr)};
    if (!ChatQueryOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatRecipientDeliveryInfo_type{py::register_python_type(module.get(), &type_spec_ChatRecipientDeliveryInfo, object_bases.get(), nullptr)};
    if (!ChatRecipientDeliveryInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatSearchReader_type{py::register_python_type(module.get(), &type_spec_ChatSearchReader, object_bases.get(), nullptr)};
    if (!ChatSearchReader_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatSyncConfiguration_type{py::register_python_type(module.get(), &type_spec_ChatSyncConfiguration, object_bases.get(), nullptr)};
    if (!ChatSyncConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle ChatSyncManager_type{py::register_python_type(module.get(), &type_spec_ChatSyncManager, object_bases.get(), nullptr)};
    if (!ChatSyncManager_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsEndUserMessage_type{py::register_python_type(module.get(), &type_spec_RcsEndUserMessage, object_bases.get(), nullptr)};
    if (!RcsEndUserMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsEndUserMessageAction_type{py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAction, object_bases.get(), nullptr)};
    if (!RcsEndUserMessageAction_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsEndUserMessageAvailableEventArgs_type{py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAvailableEventArgs, object_bases.get(), nullptr)};
    if (!RcsEndUserMessageAvailableEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsEndUserMessageAvailableTriggerDetails_type{py::register_python_type(module.get(), &type_spec_RcsEndUserMessageAvailableTriggerDetails, object_bases.get(), nullptr)};
    if (!RcsEndUserMessageAvailableTriggerDetails_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsEndUserMessageManager_type{py::register_python_type(module.get(), &type_spec_RcsEndUserMessageManager, object_bases.get(), nullptr)};
    if (!RcsEndUserMessageManager_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RcsManager_Static{PyType_FromSpec(&type_spec_RcsManager_Static)};
    if (!type_RcsManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle RcsManager_type{py::register_python_type(module.get(), &type_spec_RcsManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RcsManager_Static.get()))};
    if (!RcsManager_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsServiceKindSupportedChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RcsServiceKindSupportedChangedEventArgs, object_bases.get(), nullptr)};
    if (!RcsServiceKindSupportedChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsTransport_type{py::register_python_type(module.get(), &type_spec_RcsTransport, object_bases.get(), nullptr)};
    if (!RcsTransport_type)
    {
        return nullptr;
    }

    py::pytype_handle RcsTransportConfiguration_type{py::register_python_type(module.get(), &type_spec_RcsTransportConfiguration, object_bases.get(), nullptr)};
    if (!RcsTransportConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle RemoteParticipantComposingChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RemoteParticipantComposingChangedEventArgs, object_bases.get(), nullptr)};
    if (!RemoteParticipantComposingChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IChatItem_type{py::register_python_type(module.get(), &type_spec_IChatItem, object_bases.get(), nullptr)};
    if (!IChatItem_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIChatItem_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIChatItem, nullptr))};
    if (!ImplementsIChatItem_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIChatItem_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
