// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Controls.Primitives.h"

namespace py::cpp::Windows::UI::Xaml::Controls::Primitives
{
    // ----- AppBarButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarButtonTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.AppBarButtonTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonTemplateSettings};

    // ----- AppBarTemplateSettings class --------------------

    static PyObject* _new_AppBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarTemplateSettings_get_ClipRect(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"ClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactRootMargin(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompactRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_CompactVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"CompactVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompactVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenRootMargin(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HiddenRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_HiddenVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"HiddenVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HiddenVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalRootMargin(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalRootMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimalRootMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_MinimalVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"MinimalVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinimalVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeCompactVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeCompactVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeCompactVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeHiddenVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeHiddenVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeHiddenVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarTemplateSettings_get_NegativeMinimalVerticalDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarTemplateSettings", L"NegativeMinimalVerticalDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeMinimalVerticalDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarTemplateSettings[] = {
        { "clip_rect", reinterpret_cast<getter>(AppBarTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "compact_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactRootMargin), nullptr, nullptr, nullptr },
        { "compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_CompactVerticalDelta), nullptr, nullptr, nullptr },
        { "hidden_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenRootMargin), nullptr, nullptr, nullptr },
        { "hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_HiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "minimal_root_margin", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalRootMargin), nullptr, nullptr, nullptr },
        { "minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_MinimalVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_compact_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeCompactVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_hidden_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeHiddenVerticalDelta), nullptr, nullptr, nullptr },
        { "negative_minimal_vertical_delta", reinterpret_cast<getter>(AppBarTemplateSettings_get_NegativeMinimalVerticalDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.AppBarTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarTemplateSettings};

    // ----- AppBarToggleButtonTemplateSettings class --------------------

    static PyObject* _new_AppBarToggleButtonTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AppBarToggleButtonTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.AppBarToggleButtonTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonTemplateSettings[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(AppBarToggleButtonTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.AppBarToggleButtonTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::AppBarToggleButtonTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonTemplateSettings};

    // ----- ButtonBase class --------------------

    struct PyWinrtButtonBase;
    using BasePyWinrtButtonBase = winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBaseT<PyWinrtButtonBase, py::IPywinrtObject>;

    struct PyWinrtButtonBase : py::py_obj_ref, BasePyWinrtButtonBase
    {

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtButtonBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ButtonBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonBase_get_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().CommandParameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_CommandParameter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().CommandParameter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_Command(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ICommand>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_ClickMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().ClickMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ButtonBase_put_ClickMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ClickMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().ClickMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOver(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOver");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().IsPointerOver());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().IsPressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_ClickModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"ClickModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase::ClickModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandParameterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandParameterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase::CommandParameterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_CommandProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"CommandProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase::CommandProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPointerOverProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPointerOverProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase::IsPointerOverProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_get_IsPressedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"IsPressedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase::IsPressedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_add_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().Click(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ButtonBase_remove_Click(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ButtonBase", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>().Click(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ButtonBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBase[] = {
        { "add_click", reinterpret_cast<PyCFunction>(ButtonBase_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(ButtonBase_remove_Click), METH_O, nullptr },
        { "_assign_array_", _assign_array_ButtonBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBase[] = {
        { "command_parameter", reinterpret_cast<getter>(ButtonBase_get_CommandParameter), reinterpret_cast<setter>(ButtonBase_put_CommandParameter), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(ButtonBase_get_Command), reinterpret_cast<setter>(ButtonBase_put_Command), nullptr, nullptr },
        { "click_mode", reinterpret_cast<getter>(ButtonBase_get_ClickMode), reinterpret_cast<setter>(ButtonBase_put_ClickMode), nullptr, nullptr },
        { "is_pointer_over", reinterpret_cast<getter>(ButtonBase_get_IsPointerOver), nullptr, nullptr, nullptr },
        { "is_pressed", reinterpret_cast<getter>(ButtonBase_get_IsPressed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ButtonBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBase) },
        { }
    };

    static PyType_Spec type_spec_ButtonBase = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ButtonBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ButtonBase};

    static PyGetSetDef getset_ButtonBase_Static[] = {
        { "click_mode_property", reinterpret_cast<getter>(ButtonBase_get_ClickModeProperty), nullptr, nullptr, nullptr },
        { "command_parameter_property", reinterpret_cast<getter>(ButtonBase_get_CommandParameterProperty), nullptr, nullptr, nullptr },
        { "command_property", reinterpret_cast<getter>(ButtonBase_get_CommandProperty), nullptr, nullptr, nullptr },
        { "is_pointer_over_property", reinterpret_cast<getter>(ButtonBase_get_IsPointerOverProperty), nullptr, nullptr, nullptr },
        { "is_pressed_property", reinterpret_cast<getter>(ButtonBase_get_IsPressedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ButtonBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonBase_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ButtonBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ButtonBase_Static
    };

    // ----- CalendarPanel class --------------------

    static PyObject* _new_CalendarPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::CalendarPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarPanel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarPanel[] = {
        { "_assign_array_", _assign_array_CalendarPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_CalendarPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarPanel) },
        { }
    };

    static PyType_Spec type_spec_CalendarPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CalendarPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarPanel};

    // ----- CalendarViewTemplateSettings class --------------------

    static PyObject* _new_CalendarViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CalendarViewTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterX(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_CenterY(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_ClipRect(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"ClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentAfter(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentAfter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasMoreContentAfter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreContentBefore(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreContentBefore");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasMoreContentBefore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HasMoreViews(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HasMoreViews");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasMoreViews());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_HeaderText(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"HeaderText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_MinViewWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"MinViewWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinViewWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay1(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay2(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay3(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay4(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay4");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay5(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay5");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay6(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay6");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay6());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarViewTemplateSettings_get_WeekDay7(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CalendarViewTemplateSettings", L"WeekDay7");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WeekDay7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_CalendarViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarViewTemplateSettings[] = {
        { "center_x", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterX), nullptr, nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_CenterY), nullptr, nullptr, nullptr },
        { "clip_rect", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_ClipRect), nullptr, nullptr, nullptr },
        { "has_more_content_after", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentAfter), nullptr, nullptr, nullptr },
        { "has_more_content_before", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreContentBefore), nullptr, nullptr, nullptr },
        { "has_more_views", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HasMoreViews), nullptr, nullptr, nullptr },
        { "header_text", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_HeaderText), nullptr, nullptr, nullptr },
        { "min_view_width", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_MinViewWidth), nullptr, nullptr, nullptr },
        { "week_day1", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay1), nullptr, nullptr, nullptr },
        { "week_day2", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay2), nullptr, nullptr, nullptr },
        { "week_day3", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay3), nullptr, nullptr, nullptr },
        { "week_day4", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay4), nullptr, nullptr, nullptr },
        { "week_day5", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay5), nullptr, nullptr, nullptr },
        { "week_day6", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay6), nullptr, nullptr, nullptr },
        { "week_day7", reinterpret_cast<getter>(CalendarViewTemplateSettings_get_WeekDay7), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarViewTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarViewTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CalendarViewTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CalendarViewTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CalendarViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarViewTemplateSettings};

    // ----- CarouselPanel class --------------------

    struct PyWinrtCarouselPanel;
    using BasePyWinrtCarouselPanel = winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanelT<PyWinrtCarouselPanel, py::IPywinrtObject>;

    struct PyWinrtCarouselPanel : py::py_obj_ref, BasePyWinrtCarouselPanel
    {
        PyWinrtCarouselPanel(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCarouselPanel() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCarouselPanel* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_CarouselPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCarouselPanel>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCarouselPanel>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CarouselPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CarouselPanel_GetIrregularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_GetRegularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().LineDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().LineLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().LineRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_LineUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"LineUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().LineUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MakeVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"MakeVisible", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().MakeVisible(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_MouseWheelUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"MouseWheelUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().MouseWheelUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().PageDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().PageLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().PageRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_PageUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"PageUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().PageUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetHorizontalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().SetHorizontalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_SetVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"SetVerticalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().SetVerticalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ScrollOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ScrollOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().CanVerticallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().CanVerticallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().CanHorizontallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CarouselPanel_put_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().CanHorizontallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CarouselPanel_get_ExtentHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ExtentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ExtentWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ExtentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ExtentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ViewportHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_ViewportWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"ViewportWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().ViewportWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreHorizontalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_get_AreVerticalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_add_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CarouselPanel_remove_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.CarouselPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>().VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CarouselPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CarouselPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CarouselPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(CarouselPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(CarouselPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(CarouselPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(CarouselPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(CarouselPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(CarouselPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(CarouselPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(CarouselPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(CarouselPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(CarouselPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(CarouselPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(CarouselPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(CarouselPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CarouselPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CarouselPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CarouselPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(CarouselPanel_get_ScrollOwner), reinterpret_cast<setter>(CarouselPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(CarouselPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(CarouselPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(CarouselPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(CarouselPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(CarouselPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(CarouselPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(CarouselPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(CarouselPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(CarouselPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CarouselPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CarouselPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CarouselPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CarouselPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CarouselPanel) },
        { }
    };

    static PyType_Spec type_spec_CarouselPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CarouselPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CarouselPanel};

    static PyGetSetDef getset_CarouselPanel_Static[] = {
        { }
    };

    static PyMethodDef methods_CarouselPanel_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CarouselPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CarouselPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CarouselPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_CarouselPanel_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CarouselPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CarouselPanel_Static
    };

    // ----- ColorSpectrum class --------------------

    struct PyWinrtColorSpectrum;
    using BasePyWinrtColorSpectrum = winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrumT<PyWinrtColorSpectrum, py::IPywinrtObject>;

    struct PyWinrtColorSpectrum : py::py_obj_ref, BasePyWinrtColorSpectrum
    {
        PyWinrtColorSpectrum(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtColorSpectrum() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtColorSpectrum* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ColorSpectrum(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtColorSpectrum>(self.get());

                    auto obj = py::make_py_obj<PyWinrtColorSpectrum>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ColorSpectrum_get_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Shape(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Shape");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ColorSpectrumShape>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Shape(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinSaturation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MinHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MinHue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxSaturation(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxSaturation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_MaxHue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().MaxHue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_HsvColor(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().HsvColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Components(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ColorSpectrumComponents>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Components(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ColorSpectrum_put_Color(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ColorSpectrum_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ComponentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ComponentsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::ComponentsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_HsvColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"HsvColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::HsvColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxHueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxSaturationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MaxValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MaxValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MaxValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinHueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinHueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MinHueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinSaturationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinSaturationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MinSaturationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_MinValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"MinValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::MinValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_get_ShapeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ShapeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum::ShapeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_add_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum, winrt::Windows::UI::Xaml::Controls::ColorChangedEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ColorSpectrum_remove_ColorChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ColorSpectrum", L"ColorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>().ColorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrum(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrum[] = {
        { "add_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_add_ColorChanged), METH_O, nullptr },
        { "remove_color_changed", reinterpret_cast<PyCFunction>(ColorSpectrum_remove_ColorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ColorSpectrum, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrum), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrum[] = {
        { "shape", reinterpret_cast<getter>(ColorSpectrum_get_Shape), reinterpret_cast<setter>(ColorSpectrum_put_Shape), nullptr, nullptr },
        { "min_value", reinterpret_cast<getter>(ColorSpectrum_get_MinValue), reinterpret_cast<setter>(ColorSpectrum_put_MinValue), nullptr, nullptr },
        { "min_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MinSaturation), nullptr, nullptr },
        { "min_hue", reinterpret_cast<getter>(ColorSpectrum_get_MinHue), reinterpret_cast<setter>(ColorSpectrum_put_MinHue), nullptr, nullptr },
        { "max_value", reinterpret_cast<getter>(ColorSpectrum_get_MaxValue), reinterpret_cast<setter>(ColorSpectrum_put_MaxValue), nullptr, nullptr },
        { "max_saturation", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturation), reinterpret_cast<setter>(ColorSpectrum_put_MaxSaturation), nullptr, nullptr },
        { "max_hue", reinterpret_cast<getter>(ColorSpectrum_get_MaxHue), reinterpret_cast<setter>(ColorSpectrum_put_MaxHue), nullptr, nullptr },
        { "hsv_color", reinterpret_cast<getter>(ColorSpectrum_get_HsvColor), reinterpret_cast<setter>(ColorSpectrum_put_HsvColor), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(ColorSpectrum_get_Components), reinterpret_cast<setter>(ColorSpectrum_put_Components), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(ColorSpectrum_get_Color), reinterpret_cast<setter>(ColorSpectrum_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrum[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrum) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrum) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrum) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrum) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ColorSpectrum",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ColorSpectrum};

    static PyGetSetDef getset_ColorSpectrum_Static[] = {
        { "color_property", reinterpret_cast<getter>(ColorSpectrum_get_ColorProperty), nullptr, nullptr, nullptr },
        { "components_property", reinterpret_cast<getter>(ColorSpectrum_get_ComponentsProperty), nullptr, nullptr, nullptr },
        { "hsv_color_property", reinterpret_cast<getter>(ColorSpectrum_get_HsvColorProperty), nullptr, nullptr, nullptr },
        { "max_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxHueProperty), nullptr, nullptr, nullptr },
        { "max_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxSaturationProperty), nullptr, nullptr, nullptr },
        { "max_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MaxValueProperty), nullptr, nullptr, nullptr },
        { "min_hue_property", reinterpret_cast<getter>(ColorSpectrum_get_MinHueProperty), nullptr, nullptr, nullptr },
        { "min_saturation_property", reinterpret_cast<getter>(ColorSpectrum_get_MinSaturationProperty), nullptr, nullptr, nullptr },
        { "min_value_property", reinterpret_cast<getter>(ColorSpectrum_get_MinValueProperty), nullptr, nullptr, nullptr },
        { "shape_property", reinterpret_cast<getter>(ColorSpectrum_get_ShapeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ColorSpectrum_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorSpectrum_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrum_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrum_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrum_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ColorSpectrum_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ColorSpectrum_Static
    };

    // ----- ComboBoxTemplateSettings class --------------------

    static PyObject* _new_ComboBoxTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ComboBoxTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownClosedHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownClosedHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropDownClosedHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropDownOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownOpenedHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownOpenedHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropDownOpenedHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_SelectedItemDirection(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"SelectedItemDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItemDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxTemplateSettings_get_DropDownContentMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings", L"DropDownContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropDownContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxTemplateSettings[] = {
        { "_assign_array_", _assign_array_ComboBoxTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxTemplateSettings[] = {
        { "drop_down_closed_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownClosedHeight), nullptr, nullptr, nullptr },
        { "drop_down_offset", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOffset), nullptr, nullptr, nullptr },
        { "drop_down_opened_height", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownOpenedHeight), nullptr, nullptr, nullptr },
        { "selected_item_direction", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_SelectedItemDirection), nullptr, nullptr, nullptr },
        { "drop_down_content_min_width", reinterpret_cast<getter>(ComboBoxTemplateSettings_get_DropDownContentMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ComboBoxTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ComboBoxTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxTemplateSettings};

    // ----- CommandBarFlyoutCommandBar class --------------------

    struct PyWinrtCommandBarFlyoutCommandBar;
    using BasePyWinrtCommandBarFlyoutCommandBar = winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarT<PyWinrtCommandBarFlyoutCommandBar, py::IPywinrtObject>;

    struct PyWinrtCommandBarFlyoutCommandBar : py::py_obj_ref, BasePyWinrtCommandBarFlyoutCommandBar
    {
        PyWinrtCommandBarFlyoutCommandBar(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtCommandBarFlyoutCommandBar() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtCommandBarFlyoutCommandBar* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_CommandBarFlyoutCommandBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtCommandBarFlyoutCommandBar>(self.get());

                    auto obj = py::make_py_obj<PyWinrtCommandBarFlyoutCommandBar>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CommandBarFlyoutCommandBar(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBar", L"FlyoutTemplateSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>().FlyoutTemplateSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBar[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBar[] = {
        { "flyout_template_settings", reinterpret_cast<getter>(CommandBarFlyoutCommandBar_get_FlyoutTemplateSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBar) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CommandBarFlyoutCommandBar};

    static PyGetSetDef getset_CommandBarFlyoutCommandBar_Static[] = {
        { }
    };

    static PyMethodDef methods_CommandBarFlyoutCommandBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CommandBarFlyoutCommandBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CommandBarFlyoutCommandBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CommandBarFlyoutCommandBar_Static) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CommandBarFlyoutCommandBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CommandBarFlyoutCommandBar_Static
    };

    // ----- CommandBarFlyoutCommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarFlyoutCommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarFlyoutCommandBarTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CloseAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CloseAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"CurrentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandDownAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandDownAnimationHoldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandDownAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandDownOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandDownOverflowVerticalPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandUpAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationHoldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandUpAnimationHoldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandUpAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandUpOverflowVerticalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandUpOverflowVerticalPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"ExpandedWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandedWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpenAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OpenAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpenAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"OverflowContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidthExpansionAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidthExpansionAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidthExpansionDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidthExpansionMoreButtonAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarFlyoutCommandBarTemplateSettings", L"WidthExpansionMoreButtonAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WidthExpansionMoreButtonAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarFlyoutCommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarFlyoutCommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarFlyoutCommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { "close_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CloseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ContentClipRect), nullptr, nullptr, nullptr },
        { "current_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_CurrentWidth), nullptr, nullptr, nullptr },
        { "expand_down_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_down_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_down_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandDownOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationEndPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_hold_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationHoldPosition), nullptr, nullptr, nullptr },
        { "expand_up_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpAnimationStartPosition), nullptr, nullptr, nullptr },
        { "expand_up_overflow_vertical_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandUpOverflowVerticalPosition), nullptr, nullptr, nullptr },
        { "expanded_width", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_ExpandedWidth), nullptr, nullptr, nullptr },
        { "open_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationEndPosition), nullptr, nullptr, nullptr },
        { "open_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OpenAnimationStartPosition), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "width_expansion_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionAnimationStartPosition), nullptr, nullptr, nullptr },
        { "width_expansion_delta", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionDelta), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_end_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationEndPosition), nullptr, nullptr, nullptr },
        { "width_expansion_more_button_animation_start_position", reinterpret_cast<getter>(CommandBarFlyoutCommandBarTemplateSettings_get_WidthExpansionMoreButtonAnimationStartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarFlyoutCommandBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarFlyoutCommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarFlyoutCommandBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CommandBarFlyoutCommandBarTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CommandBarFlyoutCommandBarTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarFlyoutCommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarFlyoutCommandBarTemplateSettings};

    // ----- CommandBarTemplateSettings class --------------------

    static PyObject* _new_CommandBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CommandBarTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandBarTemplateSettings_get_ContentHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"ContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_NegativeOverflowContentHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"NegativeOverflowContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeOverflowContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentClipRect(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentClipRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentClipRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentMaxHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMaxWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMaxWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentMaxWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"EffectiveOverflowButtonVisibility");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EffectiveOverflowButtonVisibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentCompactYTranslation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentCompactYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentCompactYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentHiddenYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentHiddenYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.CommandBarTemplateSettings", L"OverflowContentMinimalYTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverflowContentMinimalYTranslation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CommandBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_CommandBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandBarTemplateSettings[] = {
        { "content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_ContentHeight), nullptr, nullptr, nullptr },
        { "negative_overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_NegativeOverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_clip_rect", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentClipRect), nullptr, nullptr, nullptr },
        { "overflow_content_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHeight), nullptr, nullptr, nullptr },
        { "overflow_content_horizontal_offset", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHorizontalOffset), nullptr, nullptr, nullptr },
        { "overflow_content_max_height", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxHeight), nullptr, nullptr, nullptr },
        { "overflow_content_min_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinWidth), nullptr, nullptr, nullptr },
        { "overflow_content_max_width", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMaxWidth), nullptr, nullptr, nullptr },
        { "effective_overflow_button_visibility", reinterpret_cast<getter>(CommandBarTemplateSettings_get_EffectiveOverflowButtonVisibility), nullptr, nullptr, nullptr },
        { "overflow_content_compact_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentCompactYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_hidden_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentHiddenYTranslation), nullptr, nullptr, nullptr },
        { "overflow_content_minimal_y_translation", reinterpret_cast<getter>(CommandBarTemplateSettings_get_OverflowContentMinimalYTranslation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CommandBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CommandBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CommandBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CommandBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_CommandBarTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.CommandBarTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::CommandBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandBarTemplateSettings};

    // ----- DragCompletedEventArgs class --------------------

    struct PyWinrtDragCompletedEventArgs;
    using BasePyWinrtDragCompletedEventArgs = winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgsT<PyWinrtDragCompletedEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragCompletedEventArgs : py::py_obj_ref, BasePyWinrtDragCompletedEventArgs
    {
        PyWinrtDragCompletedEventArgs(PyObject* py_obj, double horizontalChange, double verticalChange, bool canceled) : py::py_obj_ref(py_obj), BasePyWinrtDragCompletedEventArgs(horizontalChange, verticalChange, canceled) {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragCompletedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragCompletedEventArgs>(self.get(), param0, param1, param2);

                    auto obj = py::make_py_obj<PyWinrtDragCompletedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragCompletedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragCompletedEventArgs_get_Canceled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"Canceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().Canceled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_HorizontalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"HorizontalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().HorizontalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragCompletedEventArgs_get_VerticalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragCompletedEventArgs", L"VerticalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>().VerticalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_DragCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragCompletedEventArgs[] = {
        { "canceled", reinterpret_cast<getter>(DragCompletedEventArgs_get_Canceled), nullptr, nullptr, nullptr },
        { "horizontal_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragCompletedEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragCompletedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragCompletedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragCompletedEventArgs};

    static PyGetSetDef getset_DragCompletedEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragCompletedEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragCompletedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragCompletedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragCompletedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragCompletedEventArgs_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragCompletedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragCompletedEventArgs_Static
    };

    // ----- DragDeltaEventArgs class --------------------

    struct PyWinrtDragDeltaEventArgs;
    using BasePyWinrtDragDeltaEventArgs = winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgsT<PyWinrtDragDeltaEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragDeltaEventArgs : py::py_obj_ref, BasePyWinrtDragDeltaEventArgs
    {
        PyWinrtDragDeltaEventArgs(PyObject* py_obj, double horizontalChange, double verticalChange) : py::py_obj_ref(py_obj), BasePyWinrtDragDeltaEventArgs(horizontalChange, verticalChange) {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragDeltaEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragDeltaEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragDeltaEventArgs>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtDragDeltaEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragDeltaEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragDeltaEventArgs_get_HorizontalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"HorizontalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>().HorizontalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragDeltaEventArgs_get_VerticalChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragDeltaEventArgs", L"VerticalChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>().VerticalChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragDeltaEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragDeltaEventArgs[] = {
        { "_assign_array_", _assign_array_DragDeltaEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragDeltaEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragDeltaEventArgs[] = {
        { "horizontal_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_HorizontalChange), nullptr, nullptr, nullptr },
        { "vertical_change", reinterpret_cast<getter>(DragDeltaEventArgs_get_VerticalChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragDeltaEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragDeltaEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragDeltaEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragDeltaEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragDeltaEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragDeltaEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragDeltaEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragDeltaEventArgs};

    static PyGetSetDef getset_DragDeltaEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragDeltaEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragDeltaEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragDeltaEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragDeltaEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragDeltaEventArgs_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragDeltaEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragDeltaEventArgs_Static
    };

    // ----- DragStartedEventArgs class --------------------

    struct PyWinrtDragStartedEventArgs;
    using BasePyWinrtDragStartedEventArgs = winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgsT<PyWinrtDragStartedEventArgs, py::IPywinrtObject>;

    struct PyWinrtDragStartedEventArgs : py::py_obj_ref, BasePyWinrtDragStartedEventArgs
    {
        PyWinrtDragStartedEventArgs(PyObject* py_obj, double horizontalOffset, double verticalOffset) : py::py_obj_ref(py_obj), BasePyWinrtDragStartedEventArgs(horizontalOffset, verticalOffset) {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtDragStartedEventArgs* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_DragStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtDragStartedEventArgs>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtDragStartedEventArgs>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DragStartedEventArgs(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DragStartedEventArgs_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs>().HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DragStartedEventArgs_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.DragStartedEventArgs", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs>().VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DragStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DragStartedEventArgs[] = {
        { "_assign_array_", _assign_array_DragStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DragStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DragStartedEventArgs[] = {
        { "horizontal_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(DragStartedEventArgs_get_VerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DragStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DragStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DragStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DragStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DragStartedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_DragStartedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragStartedEventArgs",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DragStartedEventArgs};

    static PyGetSetDef getset_DragStartedEventArgs_Static[] = {
        { }
    };

    static PyMethodDef methods_DragStartedEventArgs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DragStartedEventArgs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DragStartedEventArgs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DragStartedEventArgs_Static) },
        { }
    };

    static PyType_Spec type_spec_DragStartedEventArgs_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.DragStartedEventArgs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DragStartedEventArgs_Static
    };

    // ----- FlyoutBase class --------------------

    struct PyWinrtFlyoutBase;
    using BasePyWinrtFlyoutBase = winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseT<PyWinrtFlyoutBase, py::IPywinrtObject>;

    struct PyWinrtFlyoutBase : py::py_obj_ref, BasePyWinrtFlyoutBase
    {

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtFlyoutBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        winrt::Windows::UI::Xaml::Controls::Control CreatePresenter()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_create_presenter")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Xaml::Controls::Control>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnProcessKeyboardAccelerators(winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_process_keyboard_accelerators")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_FlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBase_CreatePresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"CreatePresenter", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides>().CreatePresenter());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_GetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"GetAttachedFlyout", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::GetAttachedFlyout(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_Hide(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Hide", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_OnProcessKeyboardAccelerators(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"OnProcessKeyboardAccelerators", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IFlyoutBaseOverrides4>().OnProcessKeyboardAccelerators(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_SetAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"SetAttachedFlyout", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::SetAttachedFlyout(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAt(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_ShowAttachedFlyout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowAttachedFlyout", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::ShowAttachedFlyout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_TryInvokeKeyboardAccelerator(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"TryInvokeKeyboardAccelerator", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().TryInvokeKeyboardAccelerator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Placement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Placement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_LightDismissOverlayMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ElementSoundMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ElementSoundMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementSoundMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ElementSoundMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusWhenDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusWhenDisabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusWhenDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusOnInteraction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AllowFocusOnInteraction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_Target(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Target");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().OverlayInputPassThroughElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_OverlayInputPassThroughElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().OverlayInputPassThroughElement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShowMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AreOpenCloseAnimationsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_AreOpenCloseAnimationsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().AreOpenCloseAnimationsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommands(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().InputDevicePrefersPrimaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpen(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().XamlRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::XamlRoot>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().XamlRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShouldConstrainToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBase_put_ShouldConstrainToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().ShouldConstrainToRootBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutBase_get_IsConstrainedToRootBounds(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsConstrainedToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().IsConstrainedToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AttachedFlyoutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AttachedFlyoutProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::AttachedFlyoutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_PlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"PlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::PlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusOnInteractionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusOnInteractionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AllowFocusWhenDisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AllowFocusWhenDisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::AllowFocusWhenDisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ElementSoundModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ElementSoundModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::ElementSoundModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_OverlayInputPassThroughElementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"OverlayInputPassThroughElementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::OverlayInputPassThroughElementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"AreOpenCloseAnimationsEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::AreOpenCloseAnimationsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"InputDevicePrefersPrimaryCommandsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::InputDevicePrefersPrimaryCommandsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::IsOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShowModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShowModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::ShowModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_TargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"TargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::TargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"ShouldConstrainToRootBoundsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase::ShouldConstrainToRootBoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Opening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Opening(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Opening(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Opening");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Opening(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_add_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase, winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlyoutBase_remove_Closing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBase", L"Closing");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>().Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBase[] = {
        { "_create_presenter", reinterpret_cast<PyCFunction>(FlyoutBase_CreatePresenter), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(FlyoutBase_Hide), METH_VARARGS, nullptr },
        { "_on_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(FlyoutBase_OnProcessKeyboardAccelerators), METH_VARARGS, nullptr },
        { "show_at", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAt), METH_VARARGS, nullptr },
        { "try_invoke_keyboard_accelerator", reinterpret_cast<PyCFunction>(FlyoutBase_TryInvokeKeyboardAccelerator), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opened), METH_O, nullptr },
        { "add_opening", reinterpret_cast<PyCFunction>(FlyoutBase_add_Opening), METH_O, nullptr },
        { "remove_opening", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Opening), METH_O, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(FlyoutBase_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(FlyoutBase_remove_Closing), METH_O, nullptr },
        { "_assign_array_", _assign_array_FlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBase[] = {
        { "placement", reinterpret_cast<getter>(FlyoutBase_get_Placement), reinterpret_cast<setter>(FlyoutBase_put_Placement), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayMode), reinterpret_cast<setter>(FlyoutBase_put_LightDismissOverlayMode), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundMode), reinterpret_cast<setter>(FlyoutBase_put_ElementSoundMode), nullptr, nullptr },
        { "allow_focus_when_disabled", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabled), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusWhenDisabled), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteraction), reinterpret_cast<setter>(FlyoutBase_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "target", reinterpret_cast<getter>(FlyoutBase_get_Target), nullptr, nullptr, nullptr },
        { "overlay_input_pass_through_element", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElement), reinterpret_cast<setter>(FlyoutBase_put_OverlayInputPassThroughElement), nullptr, nullptr },
        { "show_mode", reinterpret_cast<getter>(FlyoutBase_get_ShowMode), reinterpret_cast<setter>(FlyoutBase_put_ShowMode), nullptr, nullptr },
        { "are_open_close_animations_enabled", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabled), reinterpret_cast<setter>(FlyoutBase_put_AreOpenCloseAnimationsEnabled), nullptr, nullptr },
        { "input_device_prefers_primary_commands", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommands), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(FlyoutBase_get_IsOpen), nullptr, nullptr, nullptr },
        { "xaml_root", reinterpret_cast<getter>(FlyoutBase_get_XamlRoot), reinterpret_cast<setter>(FlyoutBase_put_XamlRoot), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(FlyoutBase_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(FlyoutBase_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBase) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBase = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.FlyoutBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlyoutBase};

    static PyGetSetDef getset_FlyoutBase_Static[] = {
        { "attached_flyout_property", reinterpret_cast<getter>(FlyoutBase_get_AttachedFlyoutProperty), nullptr, nullptr, nullptr },
        { "placement_property", reinterpret_cast<getter>(FlyoutBase_get_PlacementProperty), nullptr, nullptr, nullptr },
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "allow_focus_when_disabled_property", reinterpret_cast<getter>(FlyoutBase_get_AllowFocusWhenDisabledProperty), nullptr, nullptr, nullptr },
        { "element_sound_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ElementSoundModeProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(FlyoutBase_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "overlay_input_pass_through_element_property", reinterpret_cast<getter>(FlyoutBase_get_OverlayInputPassThroughElementProperty), nullptr, nullptr, nullptr },
        { "are_open_close_animations_enabled_property", reinterpret_cast<getter>(FlyoutBase_get_AreOpenCloseAnimationsEnabledProperty), nullptr, nullptr, nullptr },
        { "input_device_prefers_primary_commands_property", reinterpret_cast<getter>(FlyoutBase_get_InputDevicePrefersPrimaryCommandsProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(FlyoutBase_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "show_mode_property", reinterpret_cast<getter>(FlyoutBase_get_ShowModeProperty), nullptr, nullptr, nullptr },
        { "target_property", reinterpret_cast<getter>(FlyoutBase_get_TargetProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(FlyoutBase_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FlyoutBase_Static[] = {
        { "get_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_GetAttachedFlyout), METH_VARARGS, nullptr },
        { "set_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_SetAttachedFlyout), METH_VARARGS, nullptr },
        { "show_attached_flyout", reinterpret_cast<PyCFunction>(FlyoutBase_ShowAttachedFlyout), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.FlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlyoutBase_Static
    };

    // ----- FlyoutBaseClosingEventArgs class --------------------

    static PyObject* _new_FlyoutBaseClosingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FlyoutBaseClosingEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutBaseClosingEventArgs_get_Cancel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutBaseClosingEventArgs_put_Cancel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutBaseClosingEventArgs", L"Cancel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutBaseClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutBaseClosingEventArgs[] = {
        { "_assign_array_", _assign_array_FlyoutBaseClosingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutBaseClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutBaseClosingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(FlyoutBaseClosingEventArgs_get_Cancel), reinterpret_cast<setter>(FlyoutBaseClosingEventArgs_put_Cancel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutBaseClosingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutBaseClosingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutBaseClosingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutBaseClosingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutBaseClosingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FlyoutBaseClosingEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.FlyoutBaseClosingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::FlyoutBaseClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutBaseClosingEventArgs};

    // ----- FlyoutShowOptions class --------------------

    struct PyWinrtFlyoutShowOptions;
    using BasePyWinrtFlyoutShowOptions = winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptionsT<PyWinrtFlyoutShowOptions, py::IPywinrtObject>;

    struct PyWinrtFlyoutShowOptions : py::py_obj_ref, BasePyWinrtFlyoutShowOptions
    {
        PyWinrtFlyoutShowOptions(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtFlyoutShowOptions() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtFlyoutShowOptions* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_FlyoutShowOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtFlyoutShowOptions>(self.get());

                    auto obj = py::make_py_obj<PyWinrtFlyoutShowOptions>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutShowOptions(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlyoutShowOptions_get_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ShowMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ShowMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ShowMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ShowMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Position(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Point>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Placement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_Placement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"Placement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutPlacementMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().Placement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlyoutShowOptions_get_ExclusionRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ExclusionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlyoutShowOptions_put_ExclusionRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.FlyoutShowOptions", L"ExclusionRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>().ExclusionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutShowOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutShowOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutShowOptions[] = {
        { "_assign_array_", _assign_array_FlyoutShowOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutShowOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutShowOptions[] = {
        { "show_mode", reinterpret_cast<getter>(FlyoutShowOptions_get_ShowMode), reinterpret_cast<setter>(FlyoutShowOptions_put_ShowMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(FlyoutShowOptions_get_Position), reinterpret_cast<setter>(FlyoutShowOptions_put_Position), nullptr, nullptr },
        { "placement", reinterpret_cast<getter>(FlyoutShowOptions_get_Placement), reinterpret_cast<setter>(FlyoutShowOptions_put_Placement), nullptr, nullptr },
        { "exclusion_rect", reinterpret_cast<getter>(FlyoutShowOptions_get_ExclusionRect), reinterpret_cast<setter>(FlyoutShowOptions_put_ExclusionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlyoutShowOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutShowOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutShowOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutShowOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutShowOptions) },
        { }
    };

    static PyType_Spec type_spec_FlyoutShowOptions = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.FlyoutShowOptions",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FlyoutShowOptions};

    static PyGetSetDef getset_FlyoutShowOptions_Static[] = {
        { }
    };

    static PyMethodDef methods_FlyoutShowOptions_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlyoutShowOptions_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutShowOptions_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutShowOptions_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutShowOptions_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.FlyoutShowOptions_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FlyoutShowOptions_Static
    };

    // ----- GeneratorPositionHelper class --------------------

    static PyObject* _new_GeneratorPositionHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_GeneratorPositionHelper(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeneratorPositionHelper_FromIndexAndOffset(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.GeneratorPositionHelper", L"FromIndexAndOffset", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper::FromIndexAndOffset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeneratorPositionHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeneratorPositionHelper[] = {
        { "_assign_array_", _assign_array_GeneratorPositionHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeneratorPositionHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeneratorPositionHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_GeneratorPositionHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPositionHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPositionHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPositionHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPositionHelper) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPositionHelper = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GeneratorPositionHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPositionHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPositionHelper};

    static PyGetSetDef getset_GeneratorPositionHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_GeneratorPositionHelper_Static[] = {
        { "from_index_and_offset", reinterpret_cast<PyCFunction>(GeneratorPositionHelper_FromIndexAndOffset), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_GeneratorPositionHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeneratorPositionHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeneratorPositionHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPositionHelper_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GeneratorPositionHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeneratorPositionHelper_Static
    };

    // ----- GridViewItemPresenter class --------------------

    struct PyWinrtGridViewItemPresenter;
    using BasePyWinrtGridViewItemPresenter = winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenterT<PyWinrtGridViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtGridViewItemPresenter : py::py_obj_ref, BasePyWinrtGridViewItemPresenter
    {
        PyWinrtGridViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtGridViewItemPresenter() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtGridViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_GridViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtGridViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtGridViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectionCheckMarkVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectionCheckMarkVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedPointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().SelectedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ReorderHintOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ReorderHintOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackgroundMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackgroundMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PlaceholderBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().PlaceholderBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterVerticalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterVerticalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterHorizontalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().GridViewItemPresenterHorizontalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().FocusBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().FocusBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DragBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DisabledOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().DisabledOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ContentMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().ContentMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckSelectingBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckSelectingBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckHintBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckHintBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GridViewItemPresenter_put_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>().CheckBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckHintBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckHintBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"CheckSelectingBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::CheckSelectingBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ContentMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ContentMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DisabledOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DisabledOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"DragOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::DragOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"FocusBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::FocusBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterHorizontalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterHorizontalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"GridViewItemPresenterVerticalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::GridViewItemPresenterVerticalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PlaceholderBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PlaceholderBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"PointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::PointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"ReorderHintOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::ReorderHintOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectedPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectedPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter::SelectionCheckMarkVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemPresenter[] = {
        { "_assign_array_", _assign_array_GridViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemPresenter[] = {
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(GridViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "grid_view_item_presenter_padding", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPadding), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterPadding), nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(GridViewItemPresenter_put_GridViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(GridViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(GridViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(GridViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(GridViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemPresenter = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GridViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GridViewItemPresenter};

    static PyGetSetDef getset_GridViewItemPresenter_Static[] = {
        { "check_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(GridViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_padding_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "grid_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(GridViewItemPresenter_get_GridViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(GridViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(GridViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GridViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemPresenter_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GridViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GridViewItemPresenter_Static
    };

    // ----- GridViewItemTemplateSettings class --------------------

    static PyObject* _new_GridViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_GridViewItemTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings", L"DragItemsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DragItemsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_GridViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(GridViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GridViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GridViewItemTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GridViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemTemplateSettings};

    // ----- ItemsChangedEventArgs class --------------------

    static PyObject* _new_ItemsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ItemsChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsChangedEventArgs_get_Action(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemCount(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_ItemUICount(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"ItemUICount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemUICount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_OldPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"OldPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsChangedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ItemsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsChangedEventArgs[] = {
        { "action", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "item_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemCount), nullptr, nullptr, nullptr },
        { "item_ui_count", reinterpret_cast<getter>(ItemsChangedEventArgs_get_ItemUICount), nullptr, nullptr, nullptr },
        { "old_position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_OldPosition), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ItemsChangedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemsChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ItemsChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ItemsChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ItemsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsChangedEventArgs};

    // ----- JumpListItemBackgroundConverter class --------------------

    static PyObject* _new_JumpListItemBackgroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemBackgroundConverter(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemBackgroundConverter_Convert(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_ConvertBack(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Enabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Enabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_Disabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemBackgroundConverter_put_Disabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Disabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"DisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::DisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemBackgroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemBackgroundConverter", L"EnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter::EnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemBackgroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemBackgroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemBackgroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemBackgroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemBackgroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemBackgroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemBackgroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemBackgroundConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemBackgroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemBackgroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemBackgroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemBackgroundConverter) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.JumpListItemBackgroundConverter",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemBackgroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemBackgroundConverter};

    static PyGetSetDef getset_JumpListItemBackgroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemBackgroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemBackgroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemBackgroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemBackgroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemBackgroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemBackgroundConverter_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.JumpListItemBackgroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemBackgroundConverter_Static
    };

    // ----- JumpListItemForegroundConverter class --------------------

    static PyObject* _new_JumpListItemForegroundConverter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_JumpListItemForegroundConverter(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JumpListItemForegroundConverter_Convert(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Convert", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.Convert(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_ConvertBack(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"ConvertBack", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::TypeName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.ConvertBack(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Enabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Enabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Enabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_Disabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int JumpListItemForegroundConverter_put_Disabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"Disabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Disabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_DisabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"DisabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::DisabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JumpListItemForegroundConverter_get_EnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.JumpListItemForegroundConverter", L"EnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter::EnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JumpListItemForegroundConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JumpListItemForegroundConverter[] = {
        { "convert", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_Convert), METH_VARARGS, nullptr },
        { "convert_back", reinterpret_cast<PyCFunction>(JumpListItemForegroundConverter_ConvertBack), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JumpListItemForegroundConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JumpListItemForegroundConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JumpListItemForegroundConverter[] = {
        { "enabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Enabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Enabled), nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_Disabled), reinterpret_cast<setter>(JumpListItemForegroundConverter_put_Disabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JumpListItemForegroundConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JumpListItemForegroundConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JumpListItemForegroundConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JumpListItemForegroundConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JumpListItemForegroundConverter) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.JumpListItemForegroundConverter",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::JumpListItemForegroundConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JumpListItemForegroundConverter};

    static PyGetSetDef getset_JumpListItemForegroundConverter_Static[] = {
        { "disabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_DisabledProperty), nullptr, nullptr, nullptr },
        { "enabled_property", reinterpret_cast<getter>(JumpListItemForegroundConverter_get_EnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_JumpListItemForegroundConverter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_JumpListItemForegroundConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_JumpListItemForegroundConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_JumpListItemForegroundConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_JumpListItemForegroundConverter_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.JumpListItemForegroundConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_JumpListItemForegroundConverter_Static
    };

    // ----- LayoutInformation class --------------------

    static PyObject* _new_LayoutInformation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_LayoutInformation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LayoutInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LayoutInformation_GetAvailableSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetAvailableSize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation::GetAvailableSize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutExceptionElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutExceptionElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutExceptionElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LayoutInformation_GetLayoutSlot(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.LayoutInformation", L"GetLayoutSlot", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation::GetLayoutSlot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LayoutInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::LayoutInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LayoutInformation[] = {
        { "_assign_array_", _assign_array_LayoutInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LayoutInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LayoutInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_LayoutInformation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LayoutInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LayoutInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LayoutInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LayoutInformation) },
        { }
    };

    static PyType_Spec type_spec_LayoutInformation = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LayoutInformation",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LayoutInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LayoutInformation};

    static PyGetSetDef getset_LayoutInformation_Static[] = {
        { }
    };

    static PyMethodDef methods_LayoutInformation_Static[] = {
        { "get_available_size", reinterpret_cast<PyCFunction>(LayoutInformation_GetAvailableSize), METH_VARARGS, nullptr },
        { "get_layout_exception_element", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutExceptionElement), METH_VARARGS, nullptr },
        { "get_layout_slot", reinterpret_cast<PyCFunction>(LayoutInformation_GetLayoutSlot), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LayoutInformation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LayoutInformation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LayoutInformation_Static) },
        { }
    };

    static PyType_Spec type_spec_LayoutInformation_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LayoutInformation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LayoutInformation_Static
    };

    // ----- ListViewItemPresenter class --------------------

    struct PyWinrtListViewItemPresenter;
    using BasePyWinrtListViewItemPresenter = winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenterT<PyWinrtListViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtListViewItemPresenter : py::py_obj_ref, BasePyWinrtListViewItemPresenter
    {
        PyWinrtListViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtListViewItemPresenter() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtListViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_ListViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtListViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtListViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionCheckMarkVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionCheckMarkVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ReorderHintOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ReorderHintOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ReorderHintOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PlaceholderBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PlaceholderBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PlaceholderBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterVerticalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterVerticalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterPadding(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPadding");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterHorizontalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ListViewItemPresenterHorizontalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DragBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DragBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DisabledOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_DisabledOpacity(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().DisabledOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ContentMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_ContentMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().ContentMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckSelectingBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckSelectingBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckSelectingBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckHintBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckHintBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckHintBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackgroundMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBackgroundMargin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMargin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBackgroundMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PressedBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PressedBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PressedBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverForeground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverForeground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusSecondaryBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_FocusSecondaryBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().FocusSecondaryBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenterCheckMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackgroundShowsAboveContent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBackgroundShowsAboveContent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBackgroundShowsAboveContent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderThickness(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_RevealBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().RevealBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenterSelectionIndicatorMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorCornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::CornerRadius>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorCornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedPressedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedInnerBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedInnerBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedInnerBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedDisabledBackground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedDisabledBackground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_PointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().PointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorVisualEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_SelectionIndicatorVisualEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().SelectionIndicatorVisualEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxSelectedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxSelectedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPressedBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPressedBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxPointerOverBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxDisabledBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxDisabledBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxCornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxCornerRadius(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::CornerRadius>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxCornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ListViewItemPresenter_put_CheckBoxBorderBrush(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>().CheckBoxBorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ReorderHintOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ReorderHintOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ReorderHintOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PlaceholderBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PlaceholderBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PlaceholderBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterVerticalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterVerticalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterPaddingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ListViewItemPresenterHorizontalContentAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ListViewItemPresenterHorizontalContentAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DragBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DragBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DragBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_DisabledOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"DisabledOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::DisabledOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_ContentMarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"ContentMarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::ContentMarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckSelectingBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckSelectingBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckSelectingBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckHintBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckHintBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckHintBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionCheckMarkVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionCheckMarkVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PressedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PressedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"FocusSecondaryBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::FocusSecondaryBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundShowsAboveContentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundShowsAboveContentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBorderThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBorderThicknessProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBorderThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_RevealBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"RevealBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::RevealBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorCornerRadiusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorCornerRadiusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedPressedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedPressedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedInnerBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedInnerBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedInnerBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedDisabledBackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedDisabledBackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedDisabledBackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_PointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"PointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::PointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxSelectedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxSelectedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxSelectedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPressedBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPressedBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPressedBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxPointerOverBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxPointerOverBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxDisabledBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxDisabledBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxCornerRadiusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxCornerRadiusProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxCornerRadiusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_CheckBoxBorderBrushProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"CheckBoxBorderBrushProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::CheckBoxBorderBrushProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemPresenter", L"SelectionIndicatorVisualEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter::SelectionIndicatorVisualEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemPresenter[] = {
        { "_assign_array_", _assign_array_ListViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemPresenter[] = {
        { "selection_check_mark_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionCheckMarkVisualEnabled), nullptr, nullptr },
        { "selected_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBorderBrush), nullptr, nullptr },
        { "selected_pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPointerOverBackground), nullptr, nullptr },
        { "selected_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedForeground), nullptr, nullptr },
        { "selected_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderThickness), nullptr, nullptr },
        { "selected_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBackground), nullptr, nullptr },
        { "reorder_hint_offset", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffset), reinterpret_cast<setter>(ListViewItemPresenter_put_ReorderHintOffset), nullptr, nullptr },
        { "check_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBrush), nullptr, nullptr },
        { "pointer_over_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackground), nullptr, nullptr },
        { "placeholder_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PlaceholderBackground), nullptr, nullptr },
        { "list_view_item_presenter_vertical_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterVerticalContentAlignment), nullptr, nullptr },
        { "list_view_item_presenter_padding", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPadding), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterPadding), nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignment), reinterpret_cast<setter>(ListViewItemPresenter_put_ListViewItemPresenterHorizontalContentAlignment), nullptr, nullptr },
        { "focus_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusBorderBrush), nullptr, nullptr },
        { "drag_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DragOpacity), nullptr, nullptr },
        { "drag_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragForeground), nullptr, nullptr },
        { "drag_background", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_DragBackground), nullptr, nullptr },
        { "disabled_opacity", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacity), reinterpret_cast<setter>(ListViewItemPresenter_put_DisabledOpacity), nullptr, nullptr },
        { "content_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_ContentMargin), nullptr, nullptr },
        { "check_selecting_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckSelectingBrush), nullptr, nullptr },
        { "check_hint_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckHintBrush), nullptr, nullptr },
        { "pointer_over_background_margin", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMargin), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBackgroundMargin), nullptr, nullptr },
        { "selected_pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBackground), nullptr, nullptr },
        { "pressed_background", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_PressedBackground), nullptr, nullptr },
        { "pointer_over_foreground", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForeground), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverForeground), nullptr, nullptr },
        { "focus_secondary_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_FocusSecondaryBorderBrush), nullptr, nullptr },
        { "check_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckMode), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckMode), nullptr, nullptr },
        { "check_box_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBrush), nullptr, nullptr },
        { "reveal_background", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackground), nullptr, nullptr },
        { "reveal_background_shows_above_content", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContent), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBackgroundShowsAboveContent), nullptr, nullptr },
        { "reveal_border_thickness", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThickness), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderThickness), nullptr, nullptr },
        { "reveal_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_RevealBorderBrush), nullptr, nullptr },
        { "check_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckDisabledBrush), nullptr, nullptr },
        { "selection_indicator_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPressedBrush), nullptr, nullptr },
        { "selection_indicator_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorPointerOverBrush), nullptr, nullptr },
        { "selection_indicator_mode", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorMode), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorMode), nullptr, nullptr },
        { "selection_indicator_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorDisabledBrush), nullptr, nullptr },
        { "selection_indicator_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorCornerRadius), nullptr, nullptr },
        { "selection_indicator_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorBrush), nullptr, nullptr },
        { "selected_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedPressedBorderBrush), nullptr, nullptr },
        { "selected_inner_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedInnerBorderBrush), nullptr, nullptr },
        { "selected_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBorderBrush), nullptr, nullptr },
        { "selected_disabled_background", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackground), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedDisabledBackground), nullptr, nullptr },
        { "selected_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectedBorderBrush), nullptr, nullptr },
        { "pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_PointerOverBorderBrush), nullptr, nullptr },
        { "check_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckPressedBrush), nullptr, nullptr },
        { "selection_indicator_visual_enabled", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabled), reinterpret_cast<setter>(ListViewItemPresenter_put_SelectionIndicatorVisualEnabled), nullptr, nullptr },
        { "check_box_selected_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPressedBrush), nullptr, nullptr },
        { "check_box_selected_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedPointerOverBrush), nullptr, nullptr },
        { "check_box_selected_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedDisabledBrush), nullptr, nullptr },
        { "check_box_selected_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxSelectedBrush), nullptr, nullptr },
        { "check_box_pressed_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBrush), nullptr, nullptr },
        { "check_box_pressed_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPressedBorderBrush), nullptr, nullptr },
        { "check_box_pointer_over_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBrush), nullptr, nullptr },
        { "check_box_pointer_over_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxPointerOverBorderBrush), nullptr, nullptr },
        { "check_box_disabled_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBrush), nullptr, nullptr },
        { "check_box_disabled_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxDisabledBorderBrush), nullptr, nullptr },
        { "check_box_corner_radius", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadius), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxCornerRadius), nullptr, nullptr },
        { "check_box_border_brush", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrush), reinterpret_cast<setter>(ListViewItemPresenter_put_CheckBoxBorderBrush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemPresenter = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ListViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ListViewItemPresenter};

    static PyGetSetDef getset_ListViewItemPresenter_Static[] = {
        { "selected_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedForegroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "selected_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBackgroundProperty), nullptr, nullptr, nullptr },
        { "reorder_hint_offset_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ReorderHintOffsetProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundMarginProperty), nullptr, nullptr, nullptr },
        { "pointer_over_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBackgroundProperty), nullptr, nullptr, nullptr },
        { "placeholder_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PlaceholderBackgroundProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_vertical_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterVerticalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_padding_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterPaddingProperty), nullptr, nullptr, nullptr },
        { "list_view_item_presenter_horizontal_content_alignment_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ListViewItemPresenterHorizontalContentAlignmentProperty), nullptr, nullptr, nullptr },
        { "focus_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusBorderBrushProperty), nullptr, nullptr, nullptr },
        { "drag_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragOpacityProperty), nullptr, nullptr, nullptr },
        { "drag_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragForegroundProperty), nullptr, nullptr, nullptr },
        { "drag_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DragBackgroundProperty), nullptr, nullptr, nullptr },
        { "disabled_opacity_property", reinterpret_cast<getter>(ListViewItemPresenter_get_DisabledOpacityProperty), nullptr, nullptr, nullptr },
        { "content_margin_property", reinterpret_cast<getter>(ListViewItemPresenter_get_ContentMarginProperty), nullptr, nullptr, nullptr },
        { "check_selecting_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckSelectingBrushProperty), nullptr, nullptr, nullptr },
        { "check_hint_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckHintBrushProperty), nullptr, nullptr, nullptr },
        { "check_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBrushProperty), nullptr, nullptr, nullptr },
        { "selection_check_mark_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionCheckMarkVisualEnabledProperty), nullptr, nullptr, nullptr },
        { "pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBackgroundProperty), nullptr, nullptr, nullptr },
        { "pointer_over_foreground_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverForegroundProperty), nullptr, nullptr, nullptr },
        { "focus_secondary_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_FocusSecondaryBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckModeProperty), nullptr, nullptr, nullptr },
        { "check_box_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBrushProperty), nullptr, nullptr, nullptr },
        { "reveal_background_shows_above_content_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundShowsAboveContentProperty), nullptr, nullptr, nullptr },
        { "reveal_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderBrushProperty), nullptr, nullptr, nullptr },
        { "reveal_border_thickness_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBorderThicknessProperty), nullptr, nullptr, nullptr },
        { "reveal_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_RevealBackgroundProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPressedBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_mode_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorModeProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorBrushProperty), nullptr, nullptr, nullptr },
        { "selected_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_inner_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedInnerBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selected_disabled_background_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedDisabledBackgroundProperty), nullptr, nullptr, nullptr },
        { "selected_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_PointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_selected_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxSelectedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pressed_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPressedBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_pointer_over_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxPointerOverBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_disabled_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxDisabledBorderBrushProperty), nullptr, nullptr, nullptr },
        { "check_box_corner_radius_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxCornerRadiusProperty), nullptr, nullptr, nullptr },
        { "check_box_border_brush_property", reinterpret_cast<getter>(ListViewItemPresenter_get_CheckBoxBorderBrushProperty), nullptr, nullptr, nullptr },
        { "selection_indicator_visual_enabled_property", reinterpret_cast<getter>(ListViewItemPresenter_get_SelectionIndicatorVisualEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ListViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemPresenter_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ListViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ListViewItemPresenter_Static
    };

    // ----- ListViewItemTemplateSettings class --------------------

    static PyObject* _new_ListViewItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewItemTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemTemplateSettings_get_DragItemsCount(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings", L"DragItemsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DragItemsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_ListViewItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemTemplateSettings[] = {
        { "drag_items_count", reinterpret_cast<getter>(ListViewItemTemplateSettings_get_DragItemsCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ListViewItemTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ListViewItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemTemplateSettings};

    // ----- LoopingSelector class --------------------

    static PyObject* _new_LoopingSelector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelector(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelector_get_ShouldLoop(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldLoop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ShouldLoop(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldLoop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedItem(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_SelectedIndex(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_Items(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_Items(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Foundation::IInspectable>>(arg);

            self->obj.Items(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ItemWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoopingSelector_put_ItemHeight(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ItemHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoopingSelector_get_ItemHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::ItemHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemTemplateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::ItemWidthProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ItemsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::ItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_get_ShouldLoopProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"ShouldLoopProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector::ShouldLoopProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_add_SelectionChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert(self->obj.SelectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelector_remove_SelectionChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(LoopingSelector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelector[] = {
        { "should_loop", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoop), reinterpret_cast<setter>(LoopingSelector_put_ShouldLoop), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(LoopingSelector_get_SelectedItem), reinterpret_cast<setter>(LoopingSelector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndex), reinterpret_cast<setter>(LoopingSelector_put_SelectedIndex), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(LoopingSelector_get_Items), reinterpret_cast<setter>(LoopingSelector_put_Items), nullptr, nullptr },
        { "item_width", reinterpret_cast<getter>(LoopingSelector_get_ItemWidth), reinterpret_cast<setter>(LoopingSelector_put_ItemWidth), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplate), reinterpret_cast<setter>(LoopingSelector_put_ItemTemplate), nullptr, nullptr },
        { "item_height", reinterpret_cast<getter>(LoopingSelector_get_ItemHeight), reinterpret_cast<setter>(LoopingSelector_put_ItemHeight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelector) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelector = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LoopingSelector",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelector};

    static PyGetSetDef getset_LoopingSelector_Static[] = {
        { "item_height_property", reinterpret_cast<getter>(LoopingSelector_get_ItemHeightProperty), nullptr, nullptr, nullptr },
        { "item_template_property", reinterpret_cast<getter>(LoopingSelector_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "item_width_property", reinterpret_cast<getter>(LoopingSelector_get_ItemWidthProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(LoopingSelector_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(LoopingSelector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "should_loop_property", reinterpret_cast<getter>(LoopingSelector_get_ShouldLoopProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LoopingSelector_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LoopingSelector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LoopingSelector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LoopingSelector_Static) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelector_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LoopingSelector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LoopingSelector_Static
    };

    // ----- LoopingSelectorItem class --------------------

    static PyObject* _new_LoopingSelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItem(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItem[] = {
        { "_assign_array_", _assign_array_LoopingSelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItem[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItem) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItem = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LoopingSelectorItem",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItem};

    // ----- LoopingSelectorPanel class --------------------

    static PyObject* _new_LoopingSelectorPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorPanel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorPanel_GetIrregularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_GetRegularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_add_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorPanel_remove_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.LoopingSelectorPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(LoopingSelectorPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(LoopingSelectorPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorPanel) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.LoopingSelectorPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::LoopingSelectorPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorPanel};

    // ----- MenuFlyoutItemTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutItemTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutItemTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.MenuFlyoutItemTemplateSettings", L"KeyboardAcceleratorTextMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorTextMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutItemTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemTemplateSettings[] = {
        { "keyboard_accelerator_text_min_width", reinterpret_cast<getter>(MenuFlyoutItemTemplateSettings_get_KeyboardAcceleratorTextMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.MenuFlyoutItemTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutItemTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemTemplateSettings};

    // ----- MenuFlyoutPresenterTemplateSettings class --------------------

    static PyObject* _new_MenuFlyoutPresenterTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_MenuFlyoutPresenterTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.MenuFlyoutPresenterTemplateSettings", L"FlyoutContentMinWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlyoutContentMinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterTemplateSettings[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterTemplateSettings[] = {
        { "flyout_content_min_width", reinterpret_cast<getter>(MenuFlyoutPresenterTemplateSettings_get_FlyoutContentMinWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.MenuFlyoutPresenterTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::MenuFlyoutPresenterTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterTemplateSettings};

    // ----- NavigationViewItemPresenter class --------------------

    struct PyWinrtNavigationViewItemPresenter;
    using BasePyWinrtNavigationViewItemPresenter = winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenterT<PyWinrtNavigationViewItemPresenter, py::IPywinrtObject>;

    struct PyWinrtNavigationViewItemPresenter : py::py_obj_ref, BasePyWinrtNavigationViewItemPresenter
    {
        PyWinrtNavigationViewItemPresenter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtNavigationViewItemPresenter() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtNavigationViewItemPresenter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_NavigationViewItemPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtNavigationViewItemPresenter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtNavigationViewItemPresenter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemPresenter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemPresenter_get_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NavigationViewItemPresenter_put_Icon(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::IconElement>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>().Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NavigationViewItemPresenter_get_IconProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.NavigationViewItemPresenter", L"IconProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter::IconProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::NavigationViewItemPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemPresenter[] = {
        { "_assign_array_", _assign_array_NavigationViewItemPresenter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemPresenter[] = {
        { "icon", reinterpret_cast<getter>(NavigationViewItemPresenter_get_Icon), reinterpret_cast<setter>(NavigationViewItemPresenter_put_Icon), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemPresenter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemPresenter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemPresenter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemPresenter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemPresenter) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.NavigationViewItemPresenter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_NavigationViewItemPresenter};

    static PyGetSetDef getset_NavigationViewItemPresenter_Static[] = {
        { "icon_property", reinterpret_cast<getter>(NavigationViewItemPresenter_get_IconProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_NavigationViewItemPresenter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemPresenter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemPresenter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemPresenter_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemPresenter_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.NavigationViewItemPresenter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_NavigationViewItemPresenter_Static
    };

    // ----- OrientedVirtualizingPanel class --------------------

    static PyObject* _new_OrientedVirtualizingPanel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>::type_name);
        return nullptr;
    }

    static void _dealloc_OrientedVirtualizingPanel(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OrientedVirtualizingPanel_GetInsertionIndexes(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetInsertionIndexes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                int32_t param1{};
                int32_t param2{};

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetInsertionIndexes(param0, param1, param2);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetIrregularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_GetRegularSnapPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_LineUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"LineUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().LineUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MakeVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MakeVisible", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MakeVisible(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_MouseWheelUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"MouseWheelUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().MouseWheelUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageDown(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageDown", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageDown();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageLeft(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageLeft", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageLeft();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageRight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageRight", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageRight();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_PageUp(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"PageUp", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().PageUp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetHorizontalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().SetHorizontalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_SetVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"SetVerticalOffset", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().SetVerticalOffset(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ScrollOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_ScrollOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ScrollOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ScrollOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanVerticallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanVerticallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanVerticallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanVerticallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanHorizontallyScroll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OrientedVirtualizingPanel_put_CanHorizontallyScroll(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"CanHorizontallyScroll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().CanHorizontallyScroll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ExtentHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ExtentWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ExtentWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ExtentWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_HorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_VerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ViewportHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_ViewportWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"ViewportWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().ViewportWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_add_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.OrientedVirtualizingPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>().VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OrientedVirtualizingPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::OrientedVirtualizingPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OrientedVirtualizingPanel[] = {
        { "get_insertion_indexes", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetInsertionIndexes), METH_VARARGS, nullptr },
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "line_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineDown), METH_VARARGS, nullptr },
        { "line_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineLeft), METH_VARARGS, nullptr },
        { "line_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineRight), METH_VARARGS, nullptr },
        { "line_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_LineUp), METH_VARARGS, nullptr },
        { "make_visible", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MakeVisible), METH_VARARGS, nullptr },
        { "mouse_wheel_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelDown), METH_VARARGS, nullptr },
        { "mouse_wheel_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelLeft), METH_VARARGS, nullptr },
        { "mouse_wheel_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelRight), METH_VARARGS, nullptr },
        { "mouse_wheel_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_MouseWheelUp), METH_VARARGS, nullptr },
        { "page_down", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageDown), METH_VARARGS, nullptr },
        { "page_left", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageLeft), METH_VARARGS, nullptr },
        { "page_right", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageRight), METH_VARARGS, nullptr },
        { "page_up", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_PageUp), METH_VARARGS, nullptr },
        { "set_horizontal_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetHorizontalOffset), METH_VARARGS, nullptr },
        { "set_vertical_offset", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_SetVerticalOffset), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(OrientedVirtualizingPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_OrientedVirtualizingPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OrientedVirtualizingPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OrientedVirtualizingPanel[] = {
        { "scroll_owner", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ScrollOwner), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_ScrollOwner), nullptr, nullptr },
        { "can_vertically_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanVerticallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanVerticallyScroll), nullptr, nullptr },
        { "can_horizontally_scroll", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_CanHorizontallyScroll), reinterpret_cast<setter>(OrientedVirtualizingPanel_put_CanHorizontallyScroll), nullptr, nullptr },
        { "extent_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentHeight), nullptr, nullptr, nullptr },
        { "extent_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ExtentWidth), nullptr, nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_HorizontalOffset), nullptr, nullptr, nullptr },
        { "vertical_offset", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_VerticalOffset), nullptr, nullptr, nullptr },
        { "viewport_height", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportHeight), nullptr, nullptr, nullptr },
        { "viewport_width", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_ViewportWidth), nullptr, nullptr, nullptr },
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(OrientedVirtualizingPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OrientedVirtualizingPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_OrientedVirtualizingPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OrientedVirtualizingPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OrientedVirtualizingPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OrientedVirtualizingPanel) },
        { }
    };

    static PyType_Spec type_spec_OrientedVirtualizingPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.OrientedVirtualizingPanel",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_OrientedVirtualizingPanel};

    static PyGetSetDef getset_OrientedVirtualizingPanel_Static[] = {
        { }
    };

    static PyMethodDef methods_OrientedVirtualizingPanel_Static[] = {
        { }
    };

    static PyType_Slot type_slots_OrientedVirtualizingPanel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_OrientedVirtualizingPanel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_OrientedVirtualizingPanel_Static) },
        { }
    };

    static PyType_Spec type_spec_OrientedVirtualizingPanel_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.OrientedVirtualizingPanel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_OrientedVirtualizingPanel_Static
    };

    // ----- PickerFlyoutBase class --------------------

    struct PyWinrtPickerFlyoutBase;
    using BasePyWinrtPickerFlyoutBase = winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBaseT<PyWinrtPickerFlyoutBase, py::IPywinrtObject>;

    struct PyWinrtPickerFlyoutBase : py::py_obj_ref, BasePyWinrtPickerFlyoutBase
    {

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPickerFlyoutBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnConfirmed()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_confirmed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        bool ShouldShowConfirmationButtons()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_should_show_confirmation_buttons")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_PickerFlyoutBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerFlyoutBase_GetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"GetTitle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase::GetTitle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_OnConfirmed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"OnConfirmed", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides>().OnConfirmed();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_SetTitle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"SetTitle", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase::SetTitle(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_ShouldShowConfirmationButtons(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"ShouldShowConfirmationButtons", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IPickerFlyoutBaseOverrides>().ShouldShowConfirmationButtons());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PickerFlyoutBase_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.PickerFlyoutBase", L"TitleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase::TitleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::PickerFlyoutBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutBase[] = {
        { "_on_confirmed", reinterpret_cast<PyCFunction>(PickerFlyoutBase_OnConfirmed), METH_VARARGS, nullptr },
        { "_should_show_confirmation_buttons", reinterpret_cast<PyCFunction>(PickerFlyoutBase_ShouldShowConfirmationButtons), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PickerFlyoutBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutBase[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutBase) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutBase = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PickerFlyoutBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PickerFlyoutBase};

    static PyGetSetDef getset_PickerFlyoutBase_Static[] = {
        { "title_property", reinterpret_cast<getter>(PickerFlyoutBase_get_TitleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PickerFlyoutBase_Static[] = {
        { "get_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_GetTitle), METH_VARARGS, nullptr },
        { "set_title", reinterpret_cast<PyCFunction>(PickerFlyoutBase_SetTitle), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PickerFlyoutBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PickerFlyoutBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PickerFlyoutBase_Static) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PickerFlyoutBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PickerFlyoutBase_Static
    };

    // ----- PivotHeaderItem class --------------------

    struct PyWinrtPivotHeaderItem;
    using BasePyWinrtPivotHeaderItem = winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderItemT<PyWinrtPivotHeaderItem, py::IPywinrtObject>;

    struct PyWinrtPivotHeaderItem : py::py_obj_ref, BasePyWinrtPivotHeaderItem
    {
        PyWinrtPivotHeaderItem(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtPivotHeaderItem() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtPivotHeaderItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_PivotHeaderItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtPivotHeaderItem>(self.get());

                    auto obj = py::make_py_obj<PyWinrtPivotHeaderItem>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderItem[] = {
        { "_assign_array_", _assign_array_PivotHeaderItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderItem[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderItem) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderItem = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PivotHeaderItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PivotHeaderItem};

    static PyGetSetDef getset_PivotHeaderItem_Static[] = {
        { }
    };

    static PyMethodDef methods_PivotHeaderItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PivotHeaderItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PivotHeaderItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PivotHeaderItem_Static) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PivotHeaderItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PivotHeaderItem_Static
    };

    // ----- PivotHeaderPanel class --------------------

    static PyObject* _new_PivotHeaderPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotHeaderPanel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotHeaderPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotHeaderPanel[] = {
        { "_assign_array_", _assign_array_PivotHeaderPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotHeaderPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotHeaderPanel[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotHeaderPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotHeaderPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotHeaderPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotHeaderPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotHeaderPanel) },
        { }
    };

    static PyType_Spec type_spec_PivotHeaderPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PivotHeaderPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotHeaderPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotHeaderPanel};

    // ----- PivotPanel class --------------------

    static PyObject* _new_PivotPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::PivotPanel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotPanel(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotPanel_GetIrregularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_GetRegularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreHorizontalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_get_AreVerticalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_add_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotPanel_remove_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.PivotPanel", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::PivotPanel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::PivotPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotPanel[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(PivotPanel_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(PivotPanel_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PivotPanel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotPanel[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(PivotPanel_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotPanel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotPanel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotPanel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotPanel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotPanel) },
        { }
    };

    static PyType_Spec type_spec_PivotPanel = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.PivotPanel",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::PivotPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotPanel};

    // ----- Popup class --------------------

    static PyObject* _new_Popup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::Popup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Popup(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Popup_get_VerticalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_VerticalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.VerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsOpen(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsOpen(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsOpen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOpen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLightDismissEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_IsLightDismissEnabled(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLightDismissEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_HorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_HorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ChildTransitions(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChildTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ChildTransitions(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.ChildTransitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_Child(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Child());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_Child(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(arg);

            self->obj.Child(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LightDismissOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_LightDismissOverlayMode(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::LightDismissOverlayMode>(arg);

            self->obj.LightDismissOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBounds(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShouldConstrainToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_ShouldConstrainToRootBounds(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldConstrainToRootBounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_IsConstrainedToRootBounds(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsConstrainedToRootBounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsConstrainedToRootBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTarget(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PlacementTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_PlacementTarget(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"PlacementTarget");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(arg);

            self->obj.PlacementTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_DesiredPlacement(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Popup_put_DesiredPlacement(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::PopupPlacementMode>(arg);

            self->obj.DesiredPlacement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Popup_get_ActualPlacement(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualPlacement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ChildProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ChildProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::ChildProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ChildTransitionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ChildTransitionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::ChildTransitionsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_HorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"HorizontalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::HorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsLightDismissEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsLightDismissEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::IsLightDismissEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_IsOpenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"IsOpenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::IsOpenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_VerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"VerticalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::VerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_LightDismissOverlayModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"LightDismissOverlayModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::LightDismissOverlayModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_ShouldConstrainToRootBoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ShouldConstrainToRootBoundsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::ShouldConstrainToRootBoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_DesiredPlacementProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"DesiredPlacementProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::DesiredPlacementProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_get_PlacementTargetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"PlacementTargetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Popup::PlacementTargetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Closed(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Closed(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_Opened(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_Opened(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_add_ActualPlacementChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActualPlacementChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Popup_remove_ActualPlacementChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Popup", L"ActualPlacementChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualPlacementChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::Popup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Popup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::Popup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Popup[] = {
        { "add_closed", reinterpret_cast<PyCFunction>(Popup_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(Popup_remove_Closed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(Popup_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(Popup_remove_Opened), METH_O, nullptr },
        { "add_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_add_ActualPlacementChanged), METH_O, nullptr },
        { "remove_actual_placement_changed", reinterpret_cast<PyCFunction>(Popup_remove_ActualPlacementChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Popup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Popup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Popup[] = {
        { "vertical_offset", reinterpret_cast<getter>(Popup_get_VerticalOffset), reinterpret_cast<setter>(Popup_put_VerticalOffset), nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(Popup_get_IsOpen), reinterpret_cast<setter>(Popup_put_IsOpen), nullptr, nullptr },
        { "is_light_dismiss_enabled", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabled), reinterpret_cast<setter>(Popup_put_IsLightDismissEnabled), nullptr, nullptr },
        { "horizontal_offset", reinterpret_cast<getter>(Popup_get_HorizontalOffset), reinterpret_cast<setter>(Popup_put_HorizontalOffset), nullptr, nullptr },
        { "child_transitions", reinterpret_cast<getter>(Popup_get_ChildTransitions), reinterpret_cast<setter>(Popup_put_ChildTransitions), nullptr, nullptr },
        { "child", reinterpret_cast<getter>(Popup_get_Child), reinterpret_cast<setter>(Popup_put_Child), nullptr, nullptr },
        { "light_dismiss_overlay_mode", reinterpret_cast<getter>(Popup_get_LightDismissOverlayMode), reinterpret_cast<setter>(Popup_put_LightDismissOverlayMode), nullptr, nullptr },
        { "should_constrain_to_root_bounds", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBounds), reinterpret_cast<setter>(Popup_put_ShouldConstrainToRootBounds), nullptr, nullptr },
        { "is_constrained_to_root_bounds", reinterpret_cast<getter>(Popup_get_IsConstrainedToRootBounds), nullptr, nullptr, nullptr },
        { "placement_target", reinterpret_cast<getter>(Popup_get_PlacementTarget), reinterpret_cast<setter>(Popup_put_PlacementTarget), nullptr, nullptr },
        { "desired_placement", reinterpret_cast<getter>(Popup_get_DesiredPlacement), reinterpret_cast<setter>(Popup_put_DesiredPlacement), nullptr, nullptr },
        { "actual_placement", reinterpret_cast<getter>(Popup_get_ActualPlacement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Popup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Popup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Popup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Popup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Popup) },
        { }
    };

    static PyType_Spec type_spec_Popup = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Popup",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Popup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Popup};

    static PyGetSetDef getset_Popup_Static[] = {
        { "child_property", reinterpret_cast<getter>(Popup_get_ChildProperty), nullptr, nullptr, nullptr },
        { "child_transitions_property", reinterpret_cast<getter>(Popup_get_ChildTransitionsProperty), nullptr, nullptr, nullptr },
        { "horizontal_offset_property", reinterpret_cast<getter>(Popup_get_HorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "is_light_dismiss_enabled_property", reinterpret_cast<getter>(Popup_get_IsLightDismissEnabledProperty), nullptr, nullptr, nullptr },
        { "is_open_property", reinterpret_cast<getter>(Popup_get_IsOpenProperty), nullptr, nullptr, nullptr },
        { "vertical_offset_property", reinterpret_cast<getter>(Popup_get_VerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "light_dismiss_overlay_mode_property", reinterpret_cast<getter>(Popup_get_LightDismissOverlayModeProperty), nullptr, nullptr, nullptr },
        { "should_constrain_to_root_bounds_property", reinterpret_cast<getter>(Popup_get_ShouldConstrainToRootBoundsProperty), nullptr, nullptr, nullptr },
        { "desired_placement_property", reinterpret_cast<getter>(Popup_get_DesiredPlacementProperty), nullptr, nullptr, nullptr },
        { "placement_target_property", reinterpret_cast<getter>(Popup_get_PlacementTargetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Popup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Popup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Popup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Popup_Static) },
        { }
    };

    static PyType_Spec type_spec_Popup_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Popup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Popup_Static
    };

    // ----- ProgressBarTemplateSettings class --------------------

    static PyObject* _new_ProgressBarTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ProgressBarTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressBarTemplateSettings_get_ContainerAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"ContainerAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContainerAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_ContainerAnimationStartPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"ContainerAnimationStartPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContainerAnimationStartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseAnimationEndPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"EllipseAnimationEndPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseAnimationEndPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseAnimationWellPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"EllipseAnimationWellPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseAnimationWellPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseDiameter(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"EllipseDiameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseDiameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_EllipseOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"EllipseOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressBarTemplateSettings_get_IndicatorLengthDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings", L"IndicatorLengthDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IndicatorLengthDelta());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarTemplateSettings[] = {
        { "_assign_array_", _assign_array_ProgressBarTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBarTemplateSettings[] = {
        { "container_animation_end_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ContainerAnimationEndPosition), nullptr, nullptr, nullptr },
        { "container_animation_start_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_ContainerAnimationStartPosition), nullptr, nullptr, nullptr },
        { "ellipse_animation_end_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseAnimationEndPosition), nullptr, nullptr, nullptr },
        { "ellipse_animation_well_position", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseAnimationWellPosition), nullptr, nullptr, nullptr },
        { "ellipse_diameter", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseDiameter), nullptr, nullptr, nullptr },
        { "ellipse_offset", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_EllipseOffset), nullptr, nullptr, nullptr },
        { "indicator_length_delta", reinterpret_cast<getter>(ProgressBarTemplateSettings_get_IndicatorLengthDelta), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressBarTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ProgressBarTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressBarTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBarTemplateSettings};

    // ----- ProgressRingTemplateSettings class --------------------

    static PyObject* _new_ProgressRingTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ProgressRingTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressRingTemplateSettings_get_EllipseDiameter(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings", L"EllipseDiameter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseDiameter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingTemplateSettings_get_EllipseOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings", L"EllipseOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EllipseOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingTemplateSettings_get_MaxSideLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings", L"MaxSideLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxSideLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressRingTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingTemplateSettings[] = {
        { "_assign_array_", _assign_array_ProgressRingTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressRingTemplateSettings[] = {
        { "ellipse_diameter", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_EllipseDiameter), nullptr, nullptr, nullptr },
        { "ellipse_offset", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_EllipseOffset), nullptr, nullptr, nullptr },
        { "max_side_length", reinterpret_cast<getter>(ProgressRingTemplateSettings_get_MaxSideLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressRingTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ProgressRingTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ProgressRingTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressRingTemplateSettings};

    // ----- RangeBase class --------------------

    struct PyWinrtRangeBase;
    using BasePyWinrtRangeBase = winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseT<PyWinrtRangeBase, py::IPywinrtObject>;

    struct PyWinrtRangeBase : py::py_obj_ref, BasePyWinrtRangeBase
    {

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtRangeBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnMaximumChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_maximum_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnMinimumChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_minimum_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OnValueChanged(double param0, double param1)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_value_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_RangeBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBase_OnMaximumChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"OnMaximumChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnMaximumChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnMinimumChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"OnMinimumChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnMinimumChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_OnValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"OnValueChanged", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IRangeBaseOverrides>().OnValueChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Value(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_SmallChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().SmallChange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Minimum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Minimum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_Maximum(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().Maximum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RangeBase_put_LargeChange(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().LargeChange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RangeBase_get_LargeChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"LargeChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase::LargeChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MaximumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"MaximumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase::MaximumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_MinimumProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"MinimumProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase::MinimumProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_SmallChangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"SmallChangeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase::SmallChangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_get_ValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"ValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase::ValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_add_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().ValueChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBase_remove_ValueChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBase", L"ValueChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>().ValueChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBase[] = {
        { "_on_maximum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMaximumChanged), METH_VARARGS, nullptr },
        { "_on_minimum_changed", reinterpret_cast<PyCFunction>(RangeBase_OnMinimumChanged), METH_VARARGS, nullptr },
        { "_on_value_changed", reinterpret_cast<PyCFunction>(RangeBase_OnValueChanged), METH_VARARGS, nullptr },
        { "add_value_changed", reinterpret_cast<PyCFunction>(RangeBase_add_ValueChanged), METH_O, nullptr },
        { "remove_value_changed", reinterpret_cast<PyCFunction>(RangeBase_remove_ValueChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_RangeBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBase[] = {
        { "value", reinterpret_cast<getter>(RangeBase_get_Value), reinterpret_cast<setter>(RangeBase_put_Value), nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBase_get_SmallChange), reinterpret_cast<setter>(RangeBase_put_SmallChange), nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBase_get_Minimum), reinterpret_cast<setter>(RangeBase_put_Minimum), nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBase_get_Maximum), reinterpret_cast<setter>(RangeBase_put_Maximum), nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBase_get_LargeChange), reinterpret_cast<setter>(RangeBase_put_LargeChange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBase) },
        { }
    };

    static PyType_Spec type_spec_RangeBase = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.RangeBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RangeBase};

    static PyGetSetDef getset_RangeBase_Static[] = {
        { "large_change_property", reinterpret_cast<getter>(RangeBase_get_LargeChangeProperty), nullptr, nullptr, nullptr },
        { "maximum_property", reinterpret_cast<getter>(RangeBase_get_MaximumProperty), nullptr, nullptr, nullptr },
        { "minimum_property", reinterpret_cast<getter>(RangeBase_get_MinimumProperty), nullptr, nullptr, nullptr },
        { "small_change_property", reinterpret_cast<getter>(RangeBase_get_SmallChangeProperty), nullptr, nullptr, nullptr },
        { "value_property", reinterpret_cast<getter>(RangeBase_get_ValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RangeBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeBase_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.RangeBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RangeBase_Static
    };

    // ----- RangeBaseValueChangedEventArgs class --------------------

    static PyObject* _new_RangeBaseValueChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RangeBaseValueChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_NewValue(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseValueChangedEventArgs_get_OldValue(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventArgs", L"OldValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseValueChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseValueChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RangeBaseValueChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseValueChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseValueChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(RangeBaseValueChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseValueChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseValueChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseValueChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseValueChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseValueChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseValueChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.RangeBaseValueChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RangeBaseValueChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseValueChangedEventArgs};

    // ----- RepeatButton class --------------------

    static PyObject* _new_RepeatButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButton(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButton_get_Interval(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Interval(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"Interval");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_Delay(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RepeatButton_put_Delay(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"Delay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RepeatButton_get_DelayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"DelayProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton::DelayProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RepeatButton_get_IntervalProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.RepeatButton", L"IntervalProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton::IntervalProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButton[] = {
        { "_assign_array_", _assign_array_RepeatButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButton[] = {
        { "interval", reinterpret_cast<getter>(RepeatButton_get_Interval), reinterpret_cast<setter>(RepeatButton_put_Interval), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(RepeatButton_get_Delay), reinterpret_cast<setter>(RepeatButton_put_Delay), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RepeatButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButton) },
        { }
    };

    static PyType_Spec type_spec_RepeatButton = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.RepeatButton",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::RepeatButton),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButton};

    static PyGetSetDef getset_RepeatButton_Static[] = {
        { "delay_property", reinterpret_cast<getter>(RepeatButton_get_DelayProperty), nullptr, nullptr, nullptr },
        { "interval_property", reinterpret_cast<getter>(RepeatButton_get_IntervalProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RepeatButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatButton_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.RepeatButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeatButton_Static
    };

    // ----- ScrollBar class --------------------

    static PyObject* _new_ScrollBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBar(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollBar_get_ViewportSize(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewportSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_ViewportSize(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ViewportSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_Orientation(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorMode(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IndicatorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScrollBar_put_IndicatorMode(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollingIndicatorMode>(arg);

            self->obj.IndicatorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScrollBar_get_IndicatorModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"IndicatorModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar::IndicatorModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_OrientationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"OrientationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar::OrientationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_get_ViewportSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"ViewportSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar::ViewportSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_add_Scroll(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollEventHandler>(arg);

            return py::convert(self->obj.Scroll(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollBar_remove_Scroll(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollBar", L"Scroll");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Scroll(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBar[] = {
        { "add_scroll", reinterpret_cast<PyCFunction>(ScrollBar_add_Scroll), METH_O, nullptr },
        { "remove_scroll", reinterpret_cast<PyCFunction>(ScrollBar_remove_Scroll), METH_O, nullptr },
        { "_assign_array_", _assign_array_ScrollBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBar[] = {
        { "viewport_size", reinterpret_cast<getter>(ScrollBar_get_ViewportSize), reinterpret_cast<setter>(ScrollBar_put_ViewportSize), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ScrollBar_get_Orientation), reinterpret_cast<setter>(ScrollBar_put_Orientation), nullptr, nullptr },
        { "indicator_mode", reinterpret_cast<getter>(ScrollBar_get_IndicatorMode), reinterpret_cast<setter>(ScrollBar_put_IndicatorMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBar) },
        { }
    };

    static PyType_Spec type_spec_ScrollBar = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ScrollBar",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBar};

    static PyGetSetDef getset_ScrollBar_Static[] = {
        { "indicator_mode_property", reinterpret_cast<getter>(ScrollBar_get_IndicatorModeProperty), nullptr, nullptr, nullptr },
        { "orientation_property", reinterpret_cast<getter>(ScrollBar_get_OrientationProperty), nullptr, nullptr, nullptr },
        { "viewport_size_property", reinterpret_cast<getter>(ScrollBar_get_ViewportSizeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScrollBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollBar_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ScrollBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollBar_Static
    };

    // ----- ScrollEventArgs class --------------------

    static PyObject* _new_ScrollEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollEventArgs_get_NewValue(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollEventArgs_get_ScrollEventType(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ScrollEventArgs", L"ScrollEventType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollEventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollEventArgs[] = {
        { "_assign_array_", _assign_array_ScrollEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(ScrollEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "scroll_event_type", reinterpret_cast<getter>(ScrollEventArgs_get_ScrollEventType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ScrollEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ScrollEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ScrollEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollEventArgs};

    // ----- Selector class --------------------

    static PyObject* _new_Selector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>::type_name);
        return nullptr;
    }

    static void _dealloc_Selector(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Selector_GetIsSelectionActive(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"GetIsSelectionActive", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::GetIsSelectionActive(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePath(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedValuePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValuePath(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedValuePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedValue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_SelectedIndex(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().IsSynchronizedWithCurrentItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Selector_put_IsSynchronizedWithCurrentItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().IsSynchronizedWithCurrentItem(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Selector_get_IsSynchronizedWithCurrentItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"IsSynchronizedWithCurrentItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::IsSynchronizedWithCurrentItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::SelectedIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedItemProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedItemProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::SelectedItemProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValuePathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValuePathProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::SelectedValuePathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_get_SelectedValueProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectedValueProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Selector::SelectedValueProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_add_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SelectionChangedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Selector_remove_SelectionChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Selector", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>().SelectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Selector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Selector[] = {
        { "add_selection_changed", reinterpret_cast<PyCFunction>(Selector_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(Selector_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_Selector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Selector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Selector[] = {
        { "selected_value_path", reinterpret_cast<getter>(Selector_get_SelectedValuePath), reinterpret_cast<setter>(Selector_put_SelectedValuePath), nullptr, nullptr },
        { "selected_value", reinterpret_cast<getter>(Selector_get_SelectedValue), reinterpret_cast<setter>(Selector_put_SelectedValue), nullptr, nullptr },
        { "selected_item", reinterpret_cast<getter>(Selector_get_SelectedItem), reinterpret_cast<setter>(Selector_put_SelectedItem), nullptr, nullptr },
        { "selected_index", reinterpret_cast<getter>(Selector_get_SelectedIndex), reinterpret_cast<setter>(Selector_put_SelectedIndex), nullptr, nullptr },
        { "is_synchronized_with_current_item", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItem), reinterpret_cast<setter>(Selector_put_IsSynchronizedWithCurrentItem), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Selector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Selector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Selector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Selector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Selector) },
        { }
    };

    static PyType_Spec type_spec_Selector = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Selector",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Selector};

    static PyGetSetDef getset_Selector_Static[] = {
        { "is_synchronized_with_current_item_property", reinterpret_cast<getter>(Selector_get_IsSynchronizedWithCurrentItemProperty), nullptr, nullptr, nullptr },
        { "selected_index_property", reinterpret_cast<getter>(Selector_get_SelectedIndexProperty), nullptr, nullptr, nullptr },
        { "selected_item_property", reinterpret_cast<getter>(Selector_get_SelectedItemProperty), nullptr, nullptr, nullptr },
        { "selected_value_path_property", reinterpret_cast<getter>(Selector_get_SelectedValuePathProperty), nullptr, nullptr, nullptr },
        { "selected_value_property", reinterpret_cast<getter>(Selector_get_SelectedValueProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Selector_Static[] = {
        { "get_is_selection_active", reinterpret_cast<PyCFunction>(Selector_GetIsSelectionActive), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Selector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Selector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Selector_Static) },
        { }
    };

    static PyType_Spec type_spec_Selector_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Selector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Selector_Static
    };

    // ----- SelectorItem class --------------------

    struct PyWinrtSelectorItem;
    using BasePyWinrtSelectorItem = winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItemT<PyWinrtSelectorItem, py::IPywinrtObject>;

    struct PyWinrtSelectorItem : py::py_obj_ref, BasePyWinrtSelectorItem
    {

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSelectorItem* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }
    };

    static PyObject* _new_SelectorItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>::type_name);
        return nullptr;
    }

    static void _dealloc_SelectorItem(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItem_get_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>().IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SelectorItem_put_IsSelected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>().IsSelected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SelectorItem_get_IsSelectedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SelectorItem", L"IsSelectedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem::IsSelectedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::SelectorItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItem[] = {
        { "_assign_array_", _assign_array_SelectorItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItem[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItem_get_IsSelected), reinterpret_cast<setter>(SelectorItem_put_IsSelected), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItem) },
        { }
    };

    static PyType_Spec type_spec_SelectorItem = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.SelectorItem",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SelectorItem};

    static PyGetSetDef getset_SelectorItem_Static[] = {
        { "is_selected_property", reinterpret_cast<getter>(SelectorItem_get_IsSelectedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SelectorItem_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorItem_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorItem_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.SelectorItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SelectorItem_Static
    };

    // ----- SettingsFlyoutTemplateSettings class --------------------

    static PyObject* _new_SettingsFlyoutTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_SettingsFlyoutTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_BorderBrush(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"BorderBrush");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_BorderThickness(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"BorderThickness");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_ContentTransitions(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"ContentTransitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentTransitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_HeaderBackground(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"HeaderBackground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderBackground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_HeaderForeground(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"HeaderForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HeaderForeground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SettingsFlyoutTemplateSettings_get_IconSource(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SettingsFlyoutTemplateSettings", L"IconSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IconSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SettingsFlyoutTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SettingsFlyoutTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SettingsFlyoutTemplateSettings[] = {
        { "_assign_array_", _assign_array_SettingsFlyoutTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SettingsFlyoutTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SettingsFlyoutTemplateSettings[] = {
        { "border_brush", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_BorderBrush), nullptr, nullptr, nullptr },
        { "border_thickness", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_BorderThickness), nullptr, nullptr, nullptr },
        { "content_transitions", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_ContentTransitions), nullptr, nullptr, nullptr },
        { "header_background", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_HeaderBackground), nullptr, nullptr, nullptr },
        { "header_foreground", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_HeaderForeground), nullptr, nullptr, nullptr },
        { "icon_source", reinterpret_cast<getter>(SettingsFlyoutTemplateSettings_get_IconSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SettingsFlyoutTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SettingsFlyoutTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SettingsFlyoutTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SettingsFlyoutTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SettingsFlyoutTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_SettingsFlyoutTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.SettingsFlyoutTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SettingsFlyoutTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SettingsFlyoutTemplateSettings};

    // ----- SplitViewTemplateSettings class --------------------

    static PyObject* _new_SplitViewTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_SplitViewTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitViewTemplateSettings_get_CompactPaneGridLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"CompactPaneGridLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompactPaneGridLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeOpenPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"NegativeOpenPaneLengthMinusCompactLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NegativeOpenPaneLengthMinusCompactLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneGridLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneGridLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpenPaneGridLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpenPaneLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.SplitViewTemplateSettings", L"OpenPaneLengthMinusCompactLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpenPaneLengthMinusCompactLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitViewTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitViewTemplateSettings[] = {
        { "_assign_array_", _assign_array_SplitViewTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitViewTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitViewTemplateSettings[] = {
        { "compact_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_CompactPaneGridLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLength), nullptr, nullptr, nullptr },
        { "negative_open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_NegativeOpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { "open_pane_grid_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneGridLength), nullptr, nullptr, nullptr },
        { "open_pane_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLength), nullptr, nullptr, nullptr },
        { "open_pane_length_minus_compact_length", reinterpret_cast<getter>(SplitViewTemplateSettings_get_OpenPaneLengthMinusCompactLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitViewTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitViewTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitViewTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitViewTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitViewTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_SplitViewTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.SplitViewTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::SplitViewTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitViewTemplateSettings};

    // ----- Thumb class --------------------

    static PyObject* _new_Thumb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::Thumb instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Thumb(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Thumb_CancelDrag(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"CancelDrag", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CancelDrag();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDragging(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"IsDragging");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDragging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_get_IsDraggingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"IsDraggingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::Thumb::IsDraggingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragCompleted(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::DragCompletedEventHandler>(arg);

            return py::convert(self->obj.DragCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragCompleted(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::DragDeltaEventHandler>(arg);

            return py::convert(self->obj.DragDelta(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragDelta(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragDelta");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragDelta(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_add_DragStarted(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::DragStartedEventHandler>(arg);

            return py::convert(self->obj.DragStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Thumb_remove_DragStarted(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.Thumb", L"DragStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::Thumb>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Thumb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::Thumb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Thumb[] = {
        { "cancel_drag", reinterpret_cast<PyCFunction>(Thumb_CancelDrag), METH_VARARGS, nullptr },
        { "add_drag_completed", reinterpret_cast<PyCFunction>(Thumb_add_DragCompleted), METH_O, nullptr },
        { "remove_drag_completed", reinterpret_cast<PyCFunction>(Thumb_remove_DragCompleted), METH_O, nullptr },
        { "add_drag_delta", reinterpret_cast<PyCFunction>(Thumb_add_DragDelta), METH_O, nullptr },
        { "remove_drag_delta", reinterpret_cast<PyCFunction>(Thumb_remove_DragDelta), METH_O, nullptr },
        { "add_drag_started", reinterpret_cast<PyCFunction>(Thumb_add_DragStarted), METH_O, nullptr },
        { "remove_drag_started", reinterpret_cast<PyCFunction>(Thumb_remove_DragStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_Thumb, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Thumb), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Thumb[] = {
        { "is_dragging", reinterpret_cast<getter>(Thumb_get_IsDragging), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Thumb[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Thumb) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Thumb) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Thumb) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Thumb) },
        { }
    };

    static PyType_Spec type_spec_Thumb = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Thumb",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::Thumb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Thumb};

    static PyGetSetDef getset_Thumb_Static[] = {
        { "is_dragging_property", reinterpret_cast<getter>(Thumb_get_IsDraggingProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Thumb_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Thumb_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Thumb_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Thumb_Static) },
        { }
    };

    static PyType_Spec type_spec_Thumb_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.Thumb_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Thumb_Static
    };

    // ----- TickBar class --------------------

    static PyObject* _new_TickBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Primitives::TickBar instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TickBar(py::wrapper::Windows::UI::Xaml::Controls::Primitives::TickBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TickBar_get_Fill(py::wrapper::Windows::UI::Xaml::Controls::Primitives::TickBar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.TickBar", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Fill());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TickBar_put_Fill(py::wrapper::Windows::UI::Xaml::Controls::Primitives::TickBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.TickBar", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Fill(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TickBar_get_FillProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.TickBar", L"FillProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::TickBar::FillProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::TickBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TickBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::TickBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TickBar[] = {
        { "_assign_array_", _assign_array_TickBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TickBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TickBar[] = {
        { "fill", reinterpret_cast<getter>(TickBar_get_Fill), reinterpret_cast<setter>(TickBar_put_Fill), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TickBar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TickBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TickBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TickBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TickBar) },
        { }
    };

    static PyType_Spec type_spec_TickBar = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.TickBar",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::TickBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TickBar};

    static PyGetSetDef getset_TickBar_Static[] = {
        { "fill_property", reinterpret_cast<getter>(TickBar_get_FillProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TickBar_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TickBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TickBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TickBar_Static) },
        { }
    };

    static PyType_Spec type_spec_TickBar_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.TickBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TickBar_Static
    };

    // ----- ToggleButton class --------------------

    struct PyWinrtToggleButton;
    using BasePyWinrtToggleButton = winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButtonT<PyWinrtToggleButton, py::IPywinrtObject>;

    struct PyWinrtToggleButton : py::py_obj_ref, BasePyWinrtToggleButton
    {
        PyWinrtToggleButton(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtToggleButton() {}

        int32_t GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtToggleButton* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        void OnToggle()
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_toggle")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_ToggleButton(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtToggleButton>(self.get());

                    auto obj = py::make_py_obj<PyWinrtToggleButton>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButton(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButton_OnToggle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"OnToggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                py::get_inner_or_self(self->obj).try_as<winrt::Windows::UI::Xaml::Controls::Primitives::IToggleButtonOverrides>().OnToggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().IsThreeState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsThreeState(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().IsThreeState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToggleButton_put_IsChecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsChecked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToggleButton_get_IsCheckedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsCheckedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton::IsCheckedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_get_IsThreeStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"IsThreeStateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton::IsThreeStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Checked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Checked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Checked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Checked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Indeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Indeterminate(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Indeterminate(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Indeterminate");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Indeterminate(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_add_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Unchecked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleButton_remove_Unchecked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleButton", L"Unchecked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>().Unchecked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButton(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButton[] = {
        { "_on_toggle", reinterpret_cast<PyCFunction>(ToggleButton_OnToggle), METH_VARARGS, nullptr },
        { "add_checked", reinterpret_cast<PyCFunction>(ToggleButton_add_Checked), METH_O, nullptr },
        { "remove_checked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Checked), METH_O, nullptr },
        { "add_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_add_Indeterminate), METH_O, nullptr },
        { "remove_indeterminate", reinterpret_cast<PyCFunction>(ToggleButton_remove_Indeterminate), METH_O, nullptr },
        { "add_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_add_Unchecked), METH_O, nullptr },
        { "remove_unchecked", reinterpret_cast<PyCFunction>(ToggleButton_remove_Unchecked), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToggleButton, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButton), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButton[] = {
        { "is_three_state", reinterpret_cast<getter>(ToggleButton_get_IsThreeState), reinterpret_cast<setter>(ToggleButton_put_IsThreeState), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(ToggleButton_get_IsChecked), reinterpret_cast<setter>(ToggleButton_put_IsChecked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButton[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButton) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButton) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButton) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButton) },
        { }
    };

    static PyType_Spec type_spec_ToggleButton = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ToggleButton",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ToggleButton};

    static PyGetSetDef getset_ToggleButton_Static[] = {
        { "is_checked_property", reinterpret_cast<getter>(ToggleButton_get_IsCheckedProperty), nullptr, nullptr, nullptr },
        { "is_three_state_property", reinterpret_cast<getter>(ToggleButton_get_IsThreeStateProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ToggleButton_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleButton_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleButton_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleButton_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleButton_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ToggleButton_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ToggleButton_Static
    };

    // ----- ToggleSwitchTemplateSettings class --------------------

    static PyObject* _new_ToggleSwitchTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToggleSwitchTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurtainCurrentToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainCurrentToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurtainCurrentToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOffToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurtainOffToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"CurtainOnToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurtainOnToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnobCurrentToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobCurrentToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnobCurrentToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOffToOnOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOffToOnOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnobOffToOnOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchTemplateSettings_get_KnobOnToOffOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings", L"KnobOnToOffOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnobOnToOffOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToggleSwitchTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchTemplateSettings[] = {
        { "curtain_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "curtain_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOffToOnOffset), nullptr, nullptr, nullptr },
        { "curtain_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_CurtainOnToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOffOffset), nullptr, nullptr, nullptr },
        { "knob_current_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobCurrentToOnOffset), nullptr, nullptr, nullptr },
        { "knob_off_to_on_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOffToOnOffset), nullptr, nullptr, nullptr },
        { "knob_on_to_off_offset", reinterpret_cast<getter>(ToggleSwitchTemplateSettings_get_KnobOnToOffOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ToggleSwitchTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToggleSwitchTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchTemplateSettings};

    // ----- ToolTipTemplateSettings class --------------------

    static PyObject* _new_ToolTipTemplateSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_ToolTipTemplateSettings(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToolTipTemplateSettings_get_FromHorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FromHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToolTipTemplateSettings_get_FromVerticalOffset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings", L"FromVerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FromVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToolTipTemplateSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToolTipTemplateSettings[] = {
        { "_assign_array_", _assign_array_ToolTipTemplateSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToolTipTemplateSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToolTipTemplateSettings[] = {
        { "from_horizontal_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromHorizontalOffset), nullptr, nullptr, nullptr },
        { "from_vertical_offset", reinterpret_cast<getter>(ToolTipTemplateSettings_get_FromVerticalOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToolTipTemplateSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToolTipTemplateSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToolTipTemplateSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToolTipTemplateSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToolTipTemplateSettings) },
        { }
    };

    static PyType_Spec type_spec_ToolTipTemplateSettings = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ToolTipTemplateSettings",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::ToolTipTemplateSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToolTipTemplateSettings};

    // ----- IScrollSnapPointsInfo interface --------------------

    static PyObject* _new_IScrollSnapPointsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollSnapPointsInfo(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollSnapPointsInfo_GetIrregularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetIrregularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);

                return py::convert(self->obj.GetIrregularSnapPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_GetRegularSnapPoints(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"GetRegularSnapPoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Orientation>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment>(args, 1);
                float param2{};

                auto return_value = self->obj.GetRegularSnapPoints(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreHorizontalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreHorizontalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"AreVerticalSnapPointsRegular");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreVerticalSnapPointsRegular());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HorizontalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"HorizontalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HorizontalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_add_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VerticalSnapPointsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo", L"VerticalSnapPointsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VerticalSnapPointsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollSnapPointsInfo[] = {
        { "get_irregular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetIrregularSnapPoints), METH_VARARGS, nullptr },
        { "get_regular_snap_points", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_GetRegularSnapPoints), METH_VARARGS, nullptr },
        { "add_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "remove_horizontal_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_HorizontalSnapPointsChanged), METH_O, nullptr },
        { "add_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_add_VerticalSnapPointsChanged), METH_O, nullptr },
        { "remove_vertical_snap_points_changed", reinterpret_cast<PyCFunction>(IScrollSnapPointsInfo_remove_VerticalSnapPointsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IScrollSnapPointsInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollSnapPointsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollSnapPointsInfo[] = {
        { "are_horizontal_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreHorizontalSnapPointsRegular), nullptr, nullptr, nullptr },
        { "are_vertical_snap_points_regular", reinterpret_cast<getter>(IScrollSnapPointsInfo_get_AreVerticalSnapPointsRegular), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollSnapPointsInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollSnapPointsInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollSnapPointsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollSnapPointsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollSnapPointsInfo) },
        { }
    };

    static PyType_Spec type_spec_IScrollSnapPointsInfo = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.IScrollSnapPointsInfo",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollSnapPointsInfo};

    struct ImplementsIScrollSnapPointsInfo : py::ImplementsInterfaceT<ImplementsIScrollSnapPointsInfo, winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>
    {
        ImplementsIScrollSnapPointsInfo() = delete;
        ImplementsIScrollSnapPointsInfo(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIScrollSnapPointsInfo, winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>(py_obj, runtime_class)
        {
        }

        auto GetIrregularSnapPoints(winrt::Windows::UI::Xaml::Controls::Orientation param0, winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_irregular_snap_points")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<float>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetRegularSnapPoints(winrt::Windows::UI::Xaml::Controls::Orientation param0, winrt::Windows::UI::Xaml::Controls::Primitives::SnapPointsAlignment param1, float& param2)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_regular_snap_points")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param2 = py::convert_to<float>(return_value.get(), 1);

                return py::convert_to<float>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AreHorizontalSnapPointsRegular()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "are_horizontal_snap_points_regular")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto AreVerticalSnapPointsRegular()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "are_vertical_snap_points_regular")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalSnapPointsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_horizontal_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto HorizontalSnapPointsChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_horizontal_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalSnapPointsChanged(winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_vertical_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto VerticalSnapPointsChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_vertical_snap_points_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Xaml::Controls::Primitives::IScrollSnapPointsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIScrollSnapPointsInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIScrollSnapPointsInfo>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIScrollSnapPointsInfo[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIScrollSnapPointsInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIScrollSnapPointsInfo), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyType_Slot type_slots_ImplementsIScrollSnapPointsInfo[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIScrollSnapPointsInfo) },
        { }
    };

    static PyType_Spec type_spec_ImplementsIScrollSnapPointsInfo = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.ImplementsIScrollSnapPointsInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIScrollSnapPointsInfo};

    // ----- GeneratorPosition struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition>* _new_GeneratorPosition(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_GeneratorPosition(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Index{};
        int32_t _Offset{};

        static const char* kwlist[] = {"index", "offset", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Index, &_Offset))
        {
            return -1;
        }

        try
        {
            self->obj.Index = _Index;
            self->obj.Offset = _Offset;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_GeneratorPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GeneratorPosition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_GeneratorPosition[] = {
        { "_assign_array_", _assign_array_GeneratorPosition, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* GeneratorPosition_get_Index(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Index(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Index = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeneratorPosition_get_Offset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeneratorPosition_set_Offset(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Offset = py::convert_to<int32_t>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GeneratorPosition[] = {
        { "index", reinterpret_cast<getter>(GeneratorPosition_get_Index), reinterpret_cast<setter>(GeneratorPosition_set_Index), nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(GeneratorPosition_get_Offset), reinterpret_cast<setter>(GeneratorPosition_set_Offset), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_GeneratorPosition(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_GeneratorPosition(PyObject* self) noexcept
    {
        py::pyobj_handle Index{PyObject_GetAttrString(self, "index")};
        if (!Index)
        {
            return nullptr;
        }

        py::pyobj_handle Offset{PyObject_GetAttrString(self, "offset")};
        if (!Offset)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("GeneratorPosition(index=%R, offset=%R)", Index.get(), Offset.get());
    }

    static PyType_Slot _type_slots_GeneratorPosition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneratorPosition) },
        { Py_tp_init, reinterpret_cast<void*>(_init_GeneratorPosition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneratorPosition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneratorPosition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneratorPosition) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_GeneratorPosition) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_GeneratorPosition) },
        { }
    };

    static PyType_Spec type_spec_GeneratorPosition = {
        "winrt._winrt_windows_ui_xaml_controls_primitives.GeneratorPosition",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Primitives::GeneratorPosition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneratorPosition};

    // ----- Windows.UI.Xaml.Controls.Primitives Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Controls.Primitives");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_controls_primitives",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Controls::Primitives

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_primitives(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls::Primitives;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_RoutedEventArgs_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "RoutedEventArgs")};
    if (!windows_ui_xaml_RoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_FrameworkElement_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "FrameworkElement")};
    if (!windows_ui_xaml_FrameworkElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml_controls")};
    if (!windows_ui_xaml_controls_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ContentControl_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "ContentControl")};
    if (!windows_ui_xaml_controls_ContentControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Panel_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Panel")};
    if (!windows_ui_xaml_controls_Panel_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_VirtualizingPanel_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "VirtualizingPanel")};
    if (!windows_ui_xaml_controls_VirtualizingPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Control_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Control")};
    if (!windows_ui_xaml_controls_Control_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_CommandBar_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "CommandBar")};
    if (!windows_ui_xaml_controls_CommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ContentPresenter_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "ContentPresenter")};
    if (!windows_ui_xaml_controls_ContentPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_Canvas_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "Canvas")};
    if (!windows_ui_xaml_controls_Canvas_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_controls_ItemsControl_type{PyObject_GetAttrString(windows_ui_xaml_controls_module.get(), "ItemsControl")};
    if (!windows_ui_xaml_controls_ItemsControl_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarButtonTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!AppBarButtonTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButtonTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarButtonTemplateSettings, AppBarButtonTemplateSettings_bases.get(), nullptr)};
    if (!AppBarButtonTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!AppBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarTemplateSettings, AppBarTemplateSettings_bases.get(), nullptr)};
    if (!AppBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle AppBarToggleButtonTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!AppBarToggleButtonTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButtonTemplateSettings_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButtonTemplateSettings, AppBarToggleButtonTemplateSettings_bases.get(), nullptr)};
    if (!AppBarToggleButtonTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!ButtonBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonBase_Static{PyType_FromSpecWithBases(&type_spec_ButtonBase_Static, ButtonBase_Static_bases.get())};
    if (!type_ButtonBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ButtonBase_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!ButtonBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle ButtonBase_type{py::register_python_type(module.get(), &type_spec_ButtonBase, ButtonBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonBase_Static.get()))};
    if (!ButtonBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Panel_type.get())};
    if (!CalendarPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle CalendarPanel_type{py::register_python_type(module.get(), &type_spec_CalendarPanel, CalendarPanel_bases.get(), nullptr)};
    if (!CalendarPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle CalendarViewTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CalendarViewTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CalendarViewTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CalendarViewTemplateSettings, CalendarViewTemplateSettings_bases.get(), nullptr)};
    if (!CalendarViewTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CarouselPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_VirtualizingPanel_type.get())))};
    if (!CarouselPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CarouselPanel_Static{PyType_FromSpecWithBases(&type_spec_CarouselPanel_Static, CarouselPanel_Static_bases.get())};
    if (!type_CarouselPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CarouselPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_VirtualizingPanel_type.get())};
    if (!CarouselPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle CarouselPanel_type{py::register_python_type(module.get(), &type_spec_CarouselPanel, CarouselPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_CarouselPanel_Static.get()))};
    if (!CarouselPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!RangeBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeBase_Static{PyType_FromSpecWithBases(&type_spec_RangeBase_Static, RangeBase_Static_bases.get())};
    if (!type_RangeBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBase_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!RangeBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle RangeBase_type{py::register_python_type(module.get(), &type_spec_RangeBase, RangeBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeBase_Static.get()))};
    if (!RangeBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!ColorSpectrum_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrum_Static{PyType_FromSpecWithBases(&type_spec_ColorSpectrum_Static, ColorSpectrum_Static_bases.get())};
    if (!type_ColorSpectrum_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ColorSpectrum_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!ColorSpectrum_bases)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrum_type{py::register_python_type(module.get(), &type_spec_ColorSpectrum, ColorSpectrum_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrum_Static.get()))};
    if (!ColorSpectrum_type)
    {
        return nullptr;
    }

    py::pyobj_handle ComboBoxTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ComboBoxTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ComboBoxTemplateSettings, ComboBoxTemplateSettings_bases.get(), nullptr)};
    if (!ComboBoxTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_CommandBar_type.get())))};
    if (!CommandBarFlyoutCommandBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CommandBarFlyoutCommandBar_Static{PyType_FromSpecWithBases(&type_spec_CommandBarFlyoutCommandBar_Static, CommandBarFlyoutCommandBar_Static_bases.get())};
    if (!type_CommandBarFlyoutCommandBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBar_bases{PyTuple_Pack(1, windows_ui_xaml_controls_CommandBar_type.get())};
    if (!CommandBarFlyoutCommandBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBar_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBar, CommandBarFlyoutCommandBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_CommandBarFlyoutCommandBar_Static.get()))};
    if (!CommandBarFlyoutCommandBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarFlyoutCommandBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CommandBarFlyoutCommandBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarFlyoutCommandBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CommandBarFlyoutCommandBarTemplateSettings, CommandBarFlyoutCommandBarTemplateSettings_bases.get(), nullptr)};
    if (!CommandBarFlyoutCommandBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle CommandBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CommandBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle CommandBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_CommandBarTemplateSettings, CommandBarTemplateSettings_bases.get(), nullptr)};
    if (!CommandBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragCompletedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragCompletedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragCompletedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragCompletedEventArgs_Static, DragCompletedEventArgs_Static_bases.get())};
    if (!type_DragCompletedEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragCompletedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragCompletedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_DragCompletedEventArgs, DragCompletedEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragCompletedEventArgs_Static.get()))};
    if (!DragCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragDeltaEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragDeltaEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragDeltaEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragDeltaEventArgs_Static, DragDeltaEventArgs_Static_bases.get())};
    if (!type_DragDeltaEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragDeltaEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragDeltaEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragDeltaEventArgs_type{py::register_python_type(module.get(), &type_spec_DragDeltaEventArgs, DragDeltaEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragDeltaEventArgs_Static.get()))};
    if (!DragDeltaEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle DragStartedEventArgs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_RoutedEventArgs_type.get())))};
    if (!DragStartedEventArgs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DragStartedEventArgs_Static{PyType_FromSpecWithBases(&type_spec_DragStartedEventArgs_Static, DragStartedEventArgs_Static_bases.get())};
    if (!type_DragStartedEventArgs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DragStartedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!DragStartedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle DragStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_DragStartedEventArgs, DragStartedEventArgs_bases.get(), reinterpret_cast<PyTypeObject*>(type_DragStartedEventArgs_Static.get()))};
    if (!DragStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!FlyoutBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutBase_Static{PyType_FromSpecWithBases(&type_spec_FlyoutBase_Static, FlyoutBase_Static_bases.get())};
    if (!type_FlyoutBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle FlyoutBase_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!FlyoutBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutBase_type{py::register_python_type(module.get(), &type_spec_FlyoutBase, FlyoutBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutBase_Static.get()))};
    if (!FlyoutBase_type)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutBaseClosingEventArgs_type{py::register_python_type(module.get(), &type_spec_FlyoutBaseClosingEventArgs, object_bases.get(), nullptr)};
    if (!FlyoutBaseClosingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutShowOptions_Static{PyType_FromSpec(&type_spec_FlyoutShowOptions_Static)};
    if (!type_FlyoutShowOptions_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutShowOptions_type{py::register_python_type(module.get(), &type_spec_FlyoutShowOptions, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutShowOptions_Static.get()))};
    if (!FlyoutShowOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeneratorPositionHelper_Static{PyType_FromSpec(&type_spec_GeneratorPositionHelper_Static)};
    if (!type_GeneratorPositionHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle GeneratorPositionHelper_type{py::register_python_type(module.get(), &type_spec_GeneratorPositionHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeneratorPositionHelper_Static.get()))};
    if (!GeneratorPositionHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentPresenter_type.get())))};
    if (!GridViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_GridViewItemPresenter_Static, GridViewItemPresenter_Static_bases.get())};
    if (!type_GridViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentPresenter_type.get())};
    if (!GridViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_GridViewItemPresenter, GridViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemPresenter_Static.get()))};
    if (!GridViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle GridViewItemTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!GridViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_GridViewItemTemplateSettings, GridViewItemTemplateSettings_bases.get(), nullptr)};
    if (!GridViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle ItemsChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ItemsChangedEventArgs, object_bases.get(), nullptr)};
    if (!ItemsChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemBackgroundConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!JumpListItemBackgroundConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemBackgroundConverter_Static{PyType_FromSpecWithBases(&type_spec_JumpListItemBackgroundConverter_Static, JumpListItemBackgroundConverter_Static_bases.get())};
    if (!type_JumpListItemBackgroundConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemBackgroundConverter_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!JumpListItemBackgroundConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle JumpListItemBackgroundConverter_type{py::register_python_type(module.get(), &type_spec_JumpListItemBackgroundConverter, JumpListItemBackgroundConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemBackgroundConverter_Static.get()))};
    if (!JumpListItemBackgroundConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemForegroundConverter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!JumpListItemForegroundConverter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_JumpListItemForegroundConverter_Static{PyType_FromSpecWithBases(&type_spec_JumpListItemForegroundConverter_Static, JumpListItemForegroundConverter_Static_bases.get())};
    if (!type_JumpListItemForegroundConverter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle JumpListItemForegroundConverter_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!JumpListItemForegroundConverter_bases)
    {
        return nullptr;
    }

    py::pytype_handle JumpListItemForegroundConverter_type{py::register_python_type(module.get(), &type_spec_JumpListItemForegroundConverter, JumpListItemForegroundConverter_bases.get(), reinterpret_cast<PyTypeObject*>(type_JumpListItemForegroundConverter_Static.get()))};
    if (!JumpListItemForegroundConverter_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_LayoutInformation_Static{PyType_FromSpec(&type_spec_LayoutInformation_Static)};
    if (!type_LayoutInformation_Static)
    {
        return nullptr;
    }

    py::pytype_handle LayoutInformation_type{py::register_python_type(module.get(), &type_spec_LayoutInformation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LayoutInformation_Static.get()))};
    if (!LayoutInformation_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentPresenter_type.get())))};
    if (!ListViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_ListViewItemPresenter_Static, ListViewItemPresenter_Static_bases.get())};
    if (!type_ListViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentPresenter_type.get())};
    if (!ListViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_ListViewItemPresenter, ListViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemPresenter_Static.get()))};
    if (!ListViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle ListViewItemTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ListViewItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ListViewItemTemplateSettings, ListViewItemTemplateSettings_bases.get(), nullptr)};
    if (!ListViewItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelector_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!LoopingSelector_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LoopingSelector_Static{PyType_FromSpecWithBases(&type_spec_LoopingSelector_Static, LoopingSelector_Static_bases.get())};
    if (!type_LoopingSelector_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelector_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!LoopingSelector_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelector_type{py::register_python_type(module.get(), &type_spec_LoopingSelector, LoopingSelector_bases.get(), reinterpret_cast<PyTypeObject*>(type_LoopingSelector_Static.get()))};
    if (!LoopingSelector_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!LoopingSelectorItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItem_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItem, LoopingSelectorItem_bases.get(), nullptr)};
    if (!LoopingSelectorItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle LoopingSelectorPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Canvas_type.get())};
    if (!LoopingSelectorPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorPanel_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorPanel, LoopingSelectorPanel_bases.get(), nullptr)};
    if (!LoopingSelectorPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutItemTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!MenuFlyoutItemTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutItemTemplateSettings_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutItemTemplateSettings, MenuFlyoutItemTemplateSettings_bases.get(), nullptr)};
    if (!MenuFlyoutItemTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle MenuFlyoutPresenterTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!MenuFlyoutPresenterTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutPresenterTemplateSettings_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterTemplateSettings, MenuFlyoutPresenterTemplateSettings_bases.get(), nullptr)};
    if (!MenuFlyoutPresenterTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!NavigationViewItemPresenter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemPresenter_Static{PyType_FromSpecWithBases(&type_spec_NavigationViewItemPresenter_Static, NavigationViewItemPresenter_Static_bases.get())};
    if (!type_NavigationViewItemPresenter_Static)
    {
        return nullptr;
    }

    py::pyobj_handle NavigationViewItemPresenter_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!NavigationViewItemPresenter_bases)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemPresenter_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemPresenter, NavigationViewItemPresenter_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemPresenter_Static.get()))};
    if (!NavigationViewItemPresenter_type)
    {
        return nullptr;
    }

    py::pyobj_handle OrientedVirtualizingPanel_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_VirtualizingPanel_type.get())))};
    if (!OrientedVirtualizingPanel_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_OrientedVirtualizingPanel_Static{PyType_FromSpecWithBases(&type_spec_OrientedVirtualizingPanel_Static, OrientedVirtualizingPanel_Static_bases.get())};
    if (!type_OrientedVirtualizingPanel_Static)
    {
        return nullptr;
    }

    py::pyobj_handle OrientedVirtualizingPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_VirtualizingPanel_type.get())};
    if (!OrientedVirtualizingPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle OrientedVirtualizingPanel_type{py::register_python_type(module.get(), &type_spec_OrientedVirtualizingPanel, OrientedVirtualizingPanel_bases.get(), reinterpret_cast<PyTypeObject*>(type_OrientedVirtualizingPanel_Static.get()))};
    if (!OrientedVirtualizingPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(FlyoutBase_type.get())))};
    if (!PickerFlyoutBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PickerFlyoutBase_Static{PyType_FromSpecWithBases(&type_spec_PickerFlyoutBase_Static, PickerFlyoutBase_Static_bases.get())};
    if (!type_PickerFlyoutBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PickerFlyoutBase_bases{PyTuple_Pack(1, FlyoutBase_type.get())};
    if (!PickerFlyoutBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle PickerFlyoutBase_type{py::register_python_type(module.get(), &type_spec_PickerFlyoutBase, PickerFlyoutBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_PickerFlyoutBase_Static.get()))};
    if (!PickerFlyoutBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!PivotHeaderItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PivotHeaderItem_Static{PyType_FromSpecWithBases(&type_spec_PivotHeaderItem_Static, PivotHeaderItem_Static_bases.get())};
    if (!type_PivotHeaderItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!PivotHeaderItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotHeaderItem_type{py::register_python_type(module.get(), &type_spec_PivotHeaderItem, PivotHeaderItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_PivotHeaderItem_Static.get()))};
    if (!PivotHeaderItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotHeaderPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Canvas_type.get())};
    if (!PivotHeaderPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotHeaderPanel_type{py::register_python_type(module.get(), &type_spec_PivotHeaderPanel, PivotHeaderPanel_bases.get(), nullptr)};
    if (!PivotHeaderPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle PivotPanel_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Panel_type.get())};
    if (!PivotPanel_bases)
    {
        return nullptr;
    }

    py::pytype_handle PivotPanel_type{py::register_python_type(module.get(), &type_spec_PivotPanel, PivotPanel_bases.get(), nullptr)};
    if (!PivotPanel_type)
    {
        return nullptr;
    }

    py::pyobj_handle Popup_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_FrameworkElement_type.get())))};
    if (!Popup_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Popup_Static{PyType_FromSpecWithBases(&type_spec_Popup_Static, Popup_Static_bases.get())};
    if (!type_Popup_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Popup_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!Popup_bases)
    {
        return nullptr;
    }

    py::pytype_handle Popup_type{py::register_python_type(module.get(), &type_spec_Popup, Popup_bases.get(), reinterpret_cast<PyTypeObject*>(type_Popup_Static.get()))};
    if (!Popup_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressBarTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ProgressBarTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBarTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ProgressBarTemplateSettings, ProgressBarTemplateSettings_bases.get(), nullptr)};
    if (!ProgressBarTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ProgressRingTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ProgressRingTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRingTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ProgressRingTemplateSettings, ProgressRingTemplateSettings_bases.get(), nullptr)};
    if (!ProgressRingTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle RangeBaseValueChangedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!RangeBaseValueChangedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle RangeBaseValueChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RangeBaseValueChangedEventArgs, RangeBaseValueChangedEventArgs_bases.get(), nullptr)};
    if (!RangeBaseValueChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBase_type.get())))};
    if (!RepeatButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatButton_Static{PyType_FromSpecWithBases(&type_spec_RepeatButton_Static, RepeatButton_Static_bases.get())};
    if (!type_RepeatButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RepeatButton_bases{PyTuple_Pack(1, ButtonBase_type.get())};
    if (!RepeatButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle RepeatButton_type{py::register_python_type(module.get(), &type_spec_RepeatButton, RepeatButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatButton_Static.get()))};
    if (!RepeatButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RangeBase_type.get())))};
    if (!ScrollBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollBar_Static{PyType_FromSpecWithBases(&type_spec_ScrollBar_Static, ScrollBar_Static_bases.get())};
    if (!type_ScrollBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollBar_bases{PyTuple_Pack(1, RangeBase_type.get())};
    if (!ScrollBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollBar_type{py::register_python_type(module.get(), &type_spec_ScrollBar, ScrollBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollBar_Static.get()))};
    if (!ScrollBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScrollEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!ScrollEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScrollEventArgs_type{py::register_python_type(module.get(), &type_spec_ScrollEventArgs, ScrollEventArgs_bases.get(), nullptr)};
    if (!ScrollEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle Selector_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ItemsControl_type.get())))};
    if (!Selector_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Selector_Static{PyType_FromSpecWithBases(&type_spec_Selector_Static, Selector_Static_bases.get())};
    if (!type_Selector_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Selector_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ItemsControl_type.get())};
    if (!Selector_bases)
    {
        return nullptr;
    }

    py::pytype_handle Selector_type{py::register_python_type(module.get(), &type_spec_Selector, Selector_bases.get(), reinterpret_cast<PyTypeObject*>(type_Selector_Static.get()))};
    if (!Selector_type)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_ContentControl_type.get())))};
    if (!SelectorItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorItem_Static{PyType_FromSpecWithBases(&type_spec_SelectorItem_Static, SelectorItem_Static_bases.get())};
    if (!type_SelectorItem_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SelectorItem_bases{PyTuple_Pack(1, windows_ui_xaml_controls_ContentControl_type.get())};
    if (!SelectorItem_bases)
    {
        return nullptr;
    }

    py::pytype_handle SelectorItem_type{py::register_python_type(module.get(), &type_spec_SelectorItem, SelectorItem_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorItem_Static.get()))};
    if (!SelectorItem_type)
    {
        return nullptr;
    }

    py::pyobj_handle SettingsFlyoutTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!SettingsFlyoutTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle SettingsFlyoutTemplateSettings_type{py::register_python_type(module.get(), &type_spec_SettingsFlyoutTemplateSettings, SettingsFlyoutTemplateSettings_bases.get(), nullptr)};
    if (!SettingsFlyoutTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle SplitViewTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!SplitViewTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle SplitViewTemplateSettings_type{py::register_python_type(module.get(), &type_spec_SplitViewTemplateSettings, SplitViewTemplateSettings_bases.get(), nullptr)};
    if (!SplitViewTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle Thumb_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_controls_Control_type.get())))};
    if (!Thumb_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Thumb_Static{PyType_FromSpecWithBases(&type_spec_Thumb_Static, Thumb_Static_bases.get())};
    if (!type_Thumb_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Thumb_bases{PyTuple_Pack(1, windows_ui_xaml_controls_Control_type.get())};
    if (!Thumb_bases)
    {
        return nullptr;
    }

    py::pytype_handle Thumb_type{py::register_python_type(module.get(), &type_spec_Thumb, Thumb_bases.get(), reinterpret_cast<PyTypeObject*>(type_Thumb_Static.get()))};
    if (!Thumb_type)
    {
        return nullptr;
    }

    py::pyobj_handle TickBar_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_FrameworkElement_type.get())))};
    if (!TickBar_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TickBar_Static{PyType_FromSpecWithBases(&type_spec_TickBar_Static, TickBar_Static_bases.get())};
    if (!type_TickBar_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TickBar_bases{PyTuple_Pack(1, windows_ui_xaml_FrameworkElement_type.get())};
    if (!TickBar_bases)
    {
        return nullptr;
    }

    py::pytype_handle TickBar_type{py::register_python_type(module.get(), &type_spec_TickBar, TickBar_bases.get(), reinterpret_cast<PyTypeObject*>(type_TickBar_Static.get()))};
    if (!TickBar_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButton_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(ButtonBase_type.get())))};
    if (!ToggleButton_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleButton_Static{PyType_FromSpecWithBases(&type_spec_ToggleButton_Static, ToggleButton_Static_bases.get())};
    if (!type_ToggleButton_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleButton_bases{PyTuple_Pack(1, ButtonBase_type.get())};
    if (!ToggleButton_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleButton_type{py::register_python_type(module.get(), &type_spec_ToggleButton, ToggleButton_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleButton_Static.get()))};
    if (!ToggleButton_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToggleSwitchTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ToggleSwitchTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSwitchTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ToggleSwitchTemplateSettings, ToggleSwitchTemplateSettings_bases.get(), nullptr)};
    if (!ToggleSwitchTemplateSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle ToolTipTemplateSettings_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ToolTipTemplateSettings_bases)
    {
        return nullptr;
    }

    py::pytype_handle ToolTipTemplateSettings_type{py::register_python_type(module.get(), &type_spec_ToolTipTemplateSettings, ToolTipTemplateSettings_bases.get(), nullptr)};
    if (!ToolTipTemplateSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle IScrollSnapPointsInfo_type{py::register_python_type(module.get(), &type_spec_IScrollSnapPointsInfo, object_bases.get(), nullptr)};
    if (!IScrollSnapPointsInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIScrollSnapPointsInfo_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIScrollSnapPointsInfo, nullptr))};
    if (!ImplementsIScrollSnapPointsInfo_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIScrollSnapPointsInfo_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle GeneratorPosition_type{py::register_python_type(module.get(), &type_spec_GeneratorPosition, nullptr, nullptr)};
    if (!GeneratorPosition_type)
    {
        return nullptr;
    }


    return module.detach();
}
