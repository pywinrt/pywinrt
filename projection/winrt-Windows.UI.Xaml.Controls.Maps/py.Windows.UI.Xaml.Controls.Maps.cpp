// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Controls.Maps.h"

namespace py::cpp::Windows::UI::Xaml::Controls::Maps
{
    // ----- CustomMapTileDataSource class --------------------

    static PyObject* _new_CustomMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CustomMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CustomMapTileDataSource_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_add_BitmapRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.CustomMapTileDataSource", L"BitmapRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>>(arg);

            return py::convert(self->obj.BitmapRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_remove_BitmapRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.CustomMapTileDataSource", L"BitmapRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BitmapRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CustomMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CustomMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CustomMapTileDataSource[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_bitmap_requested", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_add_BitmapRequested), METH_O, nullptr },
        { "remove_bitmap_requested", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_remove_BitmapRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CustomMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CustomMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CustomMapTileDataSource[] = {
        { "dispatcher", reinterpret_cast<getter>(CustomMapTileDataSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CustomMapTileDataSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CustomMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CustomMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CustomMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CustomMapTileDataSource) },
        { }
    };

    static PyType_Spec type_spec_CustomMapTileDataSource = {
        "winrt._winrt_windows_ui_xaml_controls_maps.CustomMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CustomMapTileDataSource};

    // ----- HttpMapTileDataSource class --------------------

    static PyObject* _new_HttpMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMapTileDataSource_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_get_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriFormatString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UriFormatString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMapTileDataSource_put_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriFormatString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UriFormatString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMapTileDataSource_get_AllowCaching(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AllowCaching"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowCaching());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMapTileDataSource_put_AllowCaching(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AllowCaching"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCaching(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMapTileDataSource_get_AdditionalRequestHeaders(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AdditionalRequestHeaders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalRequestHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_add_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>(arg);

            return py::convert(self->obj.UriRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_remove_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UriRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMapTileDataSource[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_uri_requested", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_add_UriRequested), METH_O, nullptr },
        { "remove_uri_requested", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_remove_UriRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_HttpMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMapTileDataSource[] = {
        { "uri_format_string", reinterpret_cast<getter>(HttpMapTileDataSource_get_UriFormatString), reinterpret_cast<setter>(HttpMapTileDataSource_put_UriFormatString), nullptr, nullptr },
        { "allow_caching", reinterpret_cast<getter>(HttpMapTileDataSource_get_AllowCaching), reinterpret_cast<setter>(HttpMapTileDataSource_put_AllowCaching), nullptr, nullptr },
        { "additional_request_headers", reinterpret_cast<getter>(HttpMapTileDataSource_get_AdditionalRequestHeaders), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(HttpMapTileDataSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMapTileDataSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMapTileDataSource) },
        { }
    };

    static PyType_Spec type_spec_HttpMapTileDataSource = {
        "winrt._winrt_windows_ui_xaml_controls_maps.HttpMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMapTileDataSource};

    // ----- LocalMapTileDataSource class --------------------

    static PyObject* _new_LocalMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocalMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocalMapTileDataSource_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_get_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriFormatString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UriFormatString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalMapTileDataSource_put_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriFormatString"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UriFormatString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalMapTileDataSource_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_add_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>(arg);

            return py::convert(self->obj.UriRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_remove_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UriRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocalMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocalMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocalMapTileDataSource[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_uri_requested", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_add_UriRequested), METH_O, nullptr },
        { "remove_uri_requested", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_remove_UriRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LocalMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocalMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocalMapTileDataSource[] = {
        { "uri_format_string", reinterpret_cast<getter>(LocalMapTileDataSource_get_UriFormatString), reinterpret_cast<setter>(LocalMapTileDataSource_put_UriFormatString), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(LocalMapTileDataSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocalMapTileDataSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocalMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocalMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocalMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocalMapTileDataSource) },
        { }
    };

    static PyType_Spec type_spec_LocalMapTileDataSource = {
        "winrt._winrt_windows_ui_xaml_controls_maps.LocalMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocalMapTileDataSource};

    // ----- MapActualCameraChangedEventArgs class --------------------

    static PyObject* _new_MapActualCameraChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapActualCameraChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapActualCameraChangedEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangedEventArgs", L"Camera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapActualCameraChangedEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangedEventArgs", L"ChangeReason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapActualCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapActualCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapActualCameraChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapActualCameraChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapActualCameraChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapActualCameraChangedEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapActualCameraChangedEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapActualCameraChangedEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapActualCameraChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapActualCameraChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapActualCameraChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapActualCameraChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapActualCameraChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapActualCameraChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapActualCameraChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapActualCameraChangedEventArgs};

    // ----- MapActualCameraChangingEventArgs class --------------------

    static PyObject* _new_MapActualCameraChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapActualCameraChangingEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapActualCameraChangingEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangingEventArgs", L"Camera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapActualCameraChangingEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangingEventArgs", L"ChangeReason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapActualCameraChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapActualCameraChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapActualCameraChangingEventArgs[] = {
        { "_assign_array_", _assign_array_MapActualCameraChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapActualCameraChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapActualCameraChangingEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapActualCameraChangingEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapActualCameraChangingEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapActualCameraChangingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapActualCameraChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapActualCameraChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapActualCameraChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapActualCameraChangingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapActualCameraChangingEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapActualCameraChangingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapActualCameraChangingEventArgs};

    // ----- MapBillboard class --------------------

    static PyObject* _new_MapBillboard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapBillboard(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapBillboard_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NormalizedAnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.NormalizedAnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Image"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Image"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Image(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CollisionBehaviorDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapElementCollisionBehavior>(arg);

            self->obj.CollisionBehaviorDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_ReferenceCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"ReferenceCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReferenceCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_CollisionBehaviorDesiredProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesiredProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::CollisionBehaviorDesiredProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"LocationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPointProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapBillboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapBillboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapBillboard[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapBillboard_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapBillboard_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapBillboard_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapBillboard_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapBillboard_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapBillboard_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapBillboard_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapBillboard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapBillboard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapBillboard[] = {
        { "normalized_anchor_point", reinterpret_cast<getter>(MapBillboard_get_NormalizedAnchorPoint), reinterpret_cast<setter>(MapBillboard_put_NormalizedAnchorPoint), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapBillboard_get_Location), reinterpret_cast<setter>(MapBillboard_put_Location), nullptr, nullptr },
        { "image", reinterpret_cast<getter>(MapBillboard_get_Image), reinterpret_cast<setter>(MapBillboard_put_Image), nullptr, nullptr },
        { "collision_behavior_desired", reinterpret_cast<getter>(MapBillboard_get_CollisionBehaviorDesired), reinterpret_cast<setter>(MapBillboard_put_CollisionBehaviorDesired), nullptr, nullptr },
        { "reference_camera", reinterpret_cast<getter>(MapBillboard_get_ReferenceCamera), nullptr, nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapBillboard_get_ZIndex), reinterpret_cast<setter>(MapBillboard_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapBillboard_get_Visible), reinterpret_cast<setter>(MapBillboard_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapBillboard_get_MapTabIndex), reinterpret_cast<setter>(MapBillboard_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapBillboard_get_Tag), reinterpret_cast<setter>(MapBillboard_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapBillboard_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapBillboard_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapBillboard_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapBillboard_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapBillboard_get_IsEnabled), reinterpret_cast<setter>(MapBillboard_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapBillboard_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapBillboard[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapBillboard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapBillboard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapBillboard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapBillboard) },
        { }
    };

    static PyType_Spec type_spec_MapBillboard = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapBillboard",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapBillboard};

    static PyGetSetDef getset_MapBillboard_Static[] = {
        { "collision_behavior_desired_property", reinterpret_cast<getter>(MapBillboard_get_CollisionBehaviorDesiredProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapBillboard_get_LocationProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapBillboard_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapBillboard_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapBillboard_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapBillboard_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapBillboard_Static) },
        { }
    };

    static PyType_Spec type_spec_MapBillboard_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapBillboard_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapBillboard_Static
    };

    // ----- MapCamera class --------------------

    static PyObject* _new_MapCamera(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapCamera_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCamera_get_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Roll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Roll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Roll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Pitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Pitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Pitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_FieldOfView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"FieldOfView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FieldOfView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_FieldOfView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"FieldOfView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.FieldOfView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapCamera(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCamera(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCamera[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapCamera_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapCamera_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapCamera_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapCamera_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapCamera_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapCamera_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapCamera_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapCamera, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCamera), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCamera[] = {
        { "roll", reinterpret_cast<getter>(MapCamera_get_Roll), reinterpret_cast<setter>(MapCamera_put_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapCamera_get_Pitch), reinterpret_cast<setter>(MapCamera_put_Pitch), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapCamera_get_Location), reinterpret_cast<setter>(MapCamera_put_Location), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapCamera_get_Heading), reinterpret_cast<setter>(MapCamera_put_Heading), nullptr, nullptr },
        { "field_of_view", reinterpret_cast<getter>(MapCamera_get_FieldOfView), reinterpret_cast<setter>(MapCamera_put_FieldOfView), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapCamera_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapCamera[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCamera) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCamera) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCamera) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCamera) },
        { }
    };

    static PyType_Spec type_spec_MapCamera = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapCamera",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCamera};

    // ----- MapContextRequestedEventArgs class --------------------

    static PyObject* _new_MapContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapContextRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapContextRequestedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapContextRequestedEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapContextRequestedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapContextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapContextRequestedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapContextRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapContextRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapContextRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapContextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapContextRequestedEventArgs};

    // ----- MapControl class --------------------

    static PyObject* _new_MapControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControl instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControl(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControl_AddHandler(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"AddHandler", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.AddHandler(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_ApplyTemplate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Control", L"ApplyTemplate", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ApplyTemplate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_Arrange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"Arrange", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.Arrange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_CancelDirectManipulations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"CancelDirectManipulations", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CancelDirectManipulations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_CapturePointer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"CapturePointer", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::Pointer>(args, 0);

                return py::convert(self->obj.CapturePointer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_FindMapElementsAtOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"FindMapElementsAtOffset", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.FindMapElementsAtOffset(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"FindMapElementsAtOffset", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.FindMapElementsAtOffset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_FindName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"FindName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_Focus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Control", L"Focus", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FocusState>(args, 0);

                return py::convert(self->obj.Focus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetBindingExpression(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"GetBindingExpression", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetBindingExpression(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::GetLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetLocationFromOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocationFromOffset", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Devices::Geolocation::Geopoint param1{nullptr};

                self->obj.GetLocationFromOffset(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocationFromOffset", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                winrt::Windows::Devices::Geolocation::Geopoint param2{nullptr};

                self->obj.GetLocationFromOffset(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetNormalizedAnchorPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetNormalizedAnchorPoint", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::GetNormalizedAnchorPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetOffsetFromLocation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetOffsetFromLocation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                winrt::Windows::Foundation::Point param1{};

                self->obj.GetOffsetFromLocation(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetVisibleRegion(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetVisibleRegion", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapVisibleRegionKind>(args, 0);

                return py::convert(self->obj.GetVisibleRegion(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_InvalidateArrange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"InvalidateArrange", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InvalidateArrange();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_InvalidateMeasure(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"InvalidateMeasure", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InvalidateMeasure();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_IsLocationInView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsLocationInView", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                bool param1{};

                self->obj.IsLocationInView(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_Measure(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"Measure", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.Measure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_PopulatePropertyInfo(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"PopulatePropertyInfo", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_ReleasePointerCapture(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"ReleasePointerCapture", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::Pointer>(args, 0);

                self->obj.ReleasePointerCapture(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_ReleasePointerCaptures(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"ReleasePointerCaptures", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ReleasePointerCaptures();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_RemoveFocusEngagement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Control", L"RemoveFocusEngagement", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFocusEngagement();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_RemoveHandler(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"RemoveHandler", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEvent>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.RemoveHandler(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetBinding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.FrameworkElement", L"SetBinding", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Data::BindingBase>(args, 1);

                self->obj.SetBinding(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SetLocation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SetLocation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetNormalizedAnchorPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SetNormalizedAnchorPoint", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SetNormalizedAnchorPoint(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartAnimation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartAnimation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.StartAnimation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartBringIntoView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartBringIntoView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StartBringIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartBringIntoView", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::BringIntoViewOptions>(args, 0);

                self->obj.StartBringIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousPan(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousPan", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.StartContinuousPan(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousRotate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousRotate", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousRotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousTilt(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousTilt", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousTilt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousZoom(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousZoom", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousZoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartDragAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StartDragAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.StartDragAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopAnimation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"StopAnimation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Composition::ICompositionAnimationBase>(args, 0);

                self->obj.StopAnimation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousPan(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousPan", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopContinuousPan();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousRotate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousRotate", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopContinuousRotate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousTilt(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousTilt", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopContinuousTilt();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousZoom(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousZoom", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StopContinuousZoom();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TransformToVisual(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"TransformToVisual", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(self->obj.TransformToVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryGetLocationFromOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryGetLocationFromOffset", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Devices::Geolocation::Geopoint param1{nullptr};

                auto return_value = self->obj.TryGetLocationFromOffset(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryGetLocationFromOffset", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                winrt::Windows::Devices::Geolocation::Geopoint param2{nullptr};

                auto return_value = self->obj.TryGetLocationFromOffset(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryInvokeKeyboardAccelerator(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"TryInvokeKeyboardAccelerator", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>(args, 0);

                self->obj.TryInvokeKeyboardAccelerator(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryPanAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryPanAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.TryPanAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryPanToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryPanToAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(self->obj.TryPanToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryRotateAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryRotateAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryRotateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryRotateToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryRotateToAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryRotateToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetSceneAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetSceneAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(args, 0);

                return py::convert(self->obj.TrySetSceneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetSceneAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 1);

                return py::convert(self->obj.TrySetSceneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetViewAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(self->obj.TrySetViewAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);

                return py::convert(self->obj.TrySetViewAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 3);

                return py::convert(self->obj.TrySetViewAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 4);

                return py::convert(self->obj.TrySetViewAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetViewBoundsAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewBoundsAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Xaml::Thickness>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 2);

                return py::convert(self->obj.TrySetViewBoundsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryTiltAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryTiltAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryTiltAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryTiltToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryTiltToAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryTiltToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomInAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomInAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryZoomInAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomOutAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomOutAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryZoomOutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomToAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryZoomToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_UpdateLayout(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.UIElement", L"UpdateLayout", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.UpdateLayout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ZoomLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_WatermarkMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WatermarkMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_WatermarkMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapWatermarkMode>(arg);

            self->obj.WatermarkMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOrigin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransformOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOrigin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.TransformOrigin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TrafficFlowVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TrafficFlowVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TrafficFlowVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TrafficFlowVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Style(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Style"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(static_cast<winrt::Windows::UI::Xaml::Controls::Maps::IMapControl>(self->obj).Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Style(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Style"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapStyle>(arg);

            self->obj.Style(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_PedestrianFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PedestrianFeaturesVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_PedestrianFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.PedestrianFeaturesVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MapServiceToken(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceToken"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapServiceToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MapServiceToken(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceToken"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapServiceToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Center(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Center"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Center(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Center"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_DesiredPitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredPitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_DesiredPitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredPitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ColorScheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorScheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ColorScheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorScheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapColorScheme>(arg);

            self->obj.ColorScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_LandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LandmarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_LandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.LandmarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Children(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Children"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LoadingStatus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LoadingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MaxZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MaxZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MinZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MinZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Pitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Routes(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Routes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TileSources(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TileSources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RotateInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotateInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RotateInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.RotateInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ZoomInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ZoomInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.ZoomInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitFeaturesVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransitFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransitFeaturesVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TiltInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TiltInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TiltInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.TiltInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Scene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Scene"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scene());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Scene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Scene"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(arg);

            self->obj.Scene(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BusinessLandmarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BusinessLandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.BusinessLandmarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_PanInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PanInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_PanInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapPanInteractionMode>(arg);

            self->obj.PanInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperience"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomExperience());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperience"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>(arg);

            self->obj.CustomExperience(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ActualCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Is3DSupported(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Is3DSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Is3DSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsStreetsideSupported(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsStreetsideSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStreetsideSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TargetCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitFeaturesEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransitFeaturesEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransitFeaturesEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BusinessLandmarksEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BusinessLandmarksEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.BusinessLandmarksEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ViewPadding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPadding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ViewPadding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPadding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.ViewPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_StyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StyleSheet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_StyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>(arg);

            self->obj.StyleSheet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MapProjection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MapProjection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapProjection>(arg);

            self->obj.MapProjection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Layers(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Layers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Layers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Layers(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Layers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>>(arg);

            self->obj.Layers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Region(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Region"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Region(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Region"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CanTiltDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanTiltDown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanTiltUp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomIn(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomIn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanZoomIn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomOut(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomOut"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanZoomOut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomLevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ZoomLevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ChildrenProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ColorSchemeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorSchemeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ColorSchemeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_DesiredPitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitchProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::DesiredPitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_HeadingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::HeadingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LandmarksVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LandmarksVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LoadingStatusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LoadingStatusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LocationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapElementsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapElementsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapServiceTokenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceTokenProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapServiceTokenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"NormalizedAnchorPointProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PedestrianFeaturesVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PedestrianFeaturesVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RoutesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RoutesProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RoutesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_StyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::StyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TileSourcesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TileSourcesProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TileSourcesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TrafficFlowVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TrafficFlowVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransformOriginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransformOriginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_WatermarkModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::WatermarkModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::BusinessLandmarksVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Is3DSupportedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Is3DSupportedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::Is3DSupportedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsStreetsideSupportedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsStreetsideSupportedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::IsStreetsideSupportedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PanInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PanInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RotateInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RotateInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_SceneProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SceneProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SceneProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TiltInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TiltInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransitFeaturesVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionModeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ZoomInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::BusinessLandmarksEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransitFeaturesEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapProjectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjectionProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapProjectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_StyleSheetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheetProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::StyleSheetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ViewPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPaddingProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ViewPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LayersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LayersProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LayersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RegionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RegionProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RegionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltUpProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltUpProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanTiltUpProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomInProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomInProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanZoomInProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomOutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomOutProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanZoomOutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltDownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltDownProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanTiltDownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Padding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Padding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Padding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Padding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsTabStop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsTabStop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsTabStop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsTabStop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_HorizontalContentAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"HorizontalContentAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_HorizontalContentAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"HorizontalContentAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Foreground(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Foreground"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Foreground(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Foreground"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FontWeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontWeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FontWeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontWeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FontStyle(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FontStyle(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontStyle"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FontStretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontStretch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FontStretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontStretch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStretch>(arg);

            self->obj.FontStretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FontSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FontSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FontFamily(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontFamily"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FontFamily(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FontFamily"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::FontFamily>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"TabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"TabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CharacterSpacing(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"CharacterSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CharacterSpacing(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"CharacterSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BorderThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BorderThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BorderThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BorderThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BorderThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.BorderThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BorderBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BorderBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BorderBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BorderBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BorderBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.BorderBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TabNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"TabNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TabNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TabNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"TabNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardNavigationMode>(arg);

            self->obj.TabNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Background(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Background"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Background(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Background"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_VerticalContentAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"VerticalContentAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalContentAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_VerticalContentAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"VerticalContentAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalContentAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Template(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Template"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Template(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"Template"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ControlTemplate>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"FocusState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsTextScaleFactorEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsTextScaleFactorEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTextScaleFactorEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsTextScaleFactorEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsTextScaleFactorEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextScaleFactorEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_UseSystemFocusVisuals(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"UseSystemFocusVisuals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseSystemFocusVisuals());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_UseSystemFocusVisuals(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"UseSystemFocusVisuals"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseSystemFocusVisuals(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusUp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusUp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusRight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusRight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusRight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusRight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusLeft(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusLeft"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusLeft(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusLeft"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusDown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"XYFocusDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusDown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_RequiresPointer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"RequiresPointer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiresPointer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RequiresPointer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"RequiresPointer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RequiresPointer>(arg);

            self->obj.RequiresPointer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsFocusEngagementEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsFocusEngagementEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFocusEngagementEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsFocusEngagementEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsFocusEngagementEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFocusEngagementEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsFocusEngaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsFocusEngaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFocusEngaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsFocusEngaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"IsFocusEngaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFocusEngaged(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ElementSoundMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"ElementSoundMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ElementSoundMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ElementSoundMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"ElementSoundMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementSoundMode>(arg);

            self->obj.ElementSoundMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_DefaultStyleResourceUri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"DefaultStyleResourceUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultStyleResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_DefaultStyleResourceUri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"DefaultStyleResourceUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.DefaultStyleResourceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CornerRadius(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"CornerRadius"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CornerRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CornerRadius(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"CornerRadius"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::CornerRadius>(arg);

            self->obj.CornerRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BackgroundSizing(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BackgroundSizing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundSizing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BackgroundSizing(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Control", L"BackgroundSizing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::BackgroundSizing>(arg);

            self->obj.BackgroundSizing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Width(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Width(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Width"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_VerticalAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"VerticalAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_VerticalAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"VerticalAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::VerticalAlignment>(arg);

            self->obj.VerticalAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Resources(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Resources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Resources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Resources(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Resources"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ResourceDictionary>(arg);

            self->obj.Resources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Name(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Name(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MinWidth(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MinWidth(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MinWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MinHeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MinHeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MinHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MinHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MaxWidth(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MaxWidth(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MaxHeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MaxHeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"MaxHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Margin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Margin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Margin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Margin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Margin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.Margin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Language(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Language"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Language(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Language"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_HorizontalAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HorizontalAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_HorizontalAlignment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"HorizontalAlignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::HorizontalAlignment>(arg);

            self->obj.HorizontalAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Height(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Height(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FlowDirection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FlowDirection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FlowDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_DataContext(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_DataContext(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.DataContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ActualHeight(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ActualWidth(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_BaseUri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"BaseUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BaseUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Parent(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Parent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Triggers(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"Triggers"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Triggers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RequestedTheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"RequestedTheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestedTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RequestedTheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"RequestedTheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementTheme>(arg);

            self->obj.RequestedTheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusVisualSecondaryThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusVisualSecondaryThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FocusVisualSecondaryThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualSecondaryThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusVisualSecondaryBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusVisualSecondaryBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FocusVisualSecondaryBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualSecondaryBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusVisualSecondaryBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusVisualPrimaryThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusVisualPrimaryThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FocusVisualPrimaryThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualPrimaryThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusVisualPrimaryBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusVisualPrimaryBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FocusVisualPrimaryBrush(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualPrimaryBrush"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(arg);

            self->obj.FocusVisualPrimaryBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_FocusVisualMargin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualMargin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FocusVisualMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_FocusVisualMargin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"FocusVisualMargin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.FocusVisualMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_AllowFocusWhenDisabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusWhenDisabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowFocusWhenDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_AllowFocusWhenDisabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusWhenDisabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusWhenDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_AllowFocusOnInteraction(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusOnInteraction"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowFocusOnInteraction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_AllowFocusOnInteraction(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"AllowFocusOnInteraction"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusOnInteraction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ActualTheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualTheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsLoaded(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.FrameworkElement", L"IsLoaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLoaded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Transitions(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Transitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Transitions(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Animation::TransitionCollection>(arg);

            self->obj.Transitions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Projection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Projection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Projection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Projection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Projection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Projection>(arg);

            self->obj.Projection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_RenderTransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformOrigin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RenderTransformOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RenderTransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransformOrigin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.RenderTransformOrigin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Opacity(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Opacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Opacity(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Opacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ManipulationMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ManipulationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ManipulationMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationModes>(arg);

            self->obj.ManipulationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsRightTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsRightTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRightTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsRightTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsRightTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRightTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsHoldingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHoldingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHoldingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsHoldingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHoldingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHoldingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsHitTestVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHitTestVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHitTestVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsHitTestVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsHitTestVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHitTestVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsDoubleTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsDoubleTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleTapEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsDoubleTapEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsDoubleTapEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDoubleTapEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_AllowDrop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AllowDrop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowDrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_AllowDrop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AllowDrop"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowDrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Clip(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Clip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Clip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Clip(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Clip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::RectangleGeometry>(arg);

            self->obj.Clip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CacheMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CacheMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CacheMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CacheMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CacheMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::CacheMode>(arg);

            self->obj.CacheMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_UseLayoutRounding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UseLayoutRounding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UseLayoutRounding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_UseLayoutRounding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UseLayoutRounding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseLayoutRounding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_RenderTransform(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RenderTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RenderTransform(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderTransform"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(arg);

            self->obj.RenderTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Visibility(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Visibility"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visibility());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Visibility(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Visibility"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Visibility>(arg);

            self->obj.Visibility(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_DesiredSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"DesiredSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PointerCaptures(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PointerCaptures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RenderSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RenderSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RenderSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_XamlRoot(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XamlRoot"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XamlRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XamlRoot(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XamlRoot"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::XamlRoot>(arg);

            self->obj.XamlRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Shadow(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Shadow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Shadow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Shadow(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Shadow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Shadow>(arg);

            self->obj.Shadow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ActualOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ActualOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ActualSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ActualSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActualSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_UIContext(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"UIContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CompositeMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CompositeMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompositeMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CompositeMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CompositeMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ElementCompositeMode>(arg);

            self->obj.CompositeMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Transform3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transform3D"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Transform3D());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Transform3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Transform3D"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Media3D::Transform3D>(arg);

            self->obj.Transform3D(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CanDrag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanDrag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDrag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CanDrag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanDrag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDrag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_IsAccessKeyScope(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsAccessKeyScope"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAccessKeyScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_IsAccessKeyScope(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"IsAccessKeyScope"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAccessKeyScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ExitDisplayModeOnAccessKeyInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExitDisplayModeOnAccessKeyInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ExitDisplayModeOnAccessKeyInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExitDisplayModeOnAccessKeyInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ContextFlyout(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextFlyout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContextFlyout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ContextFlyout(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ContextFlyout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::FlyoutBase>(arg);

            self->obj.ContextFlyout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_AccessKeyScopeOwner(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyScopeOwner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccessKeyScopeOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_AccessKeyScopeOwner(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyScopeOwner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.AccessKeyScopeOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_AccessKey(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccessKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_AccessKey(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"AccessKey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_KeyTipHorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipHorizontalOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyTipHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyTipHorizontalOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipHorizontalOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HighContrastAdjustment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_HighContrastAdjustment(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"HighContrastAdjustment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ElementHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusRightNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusRightNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusRightNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusRightNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusRightNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusRightNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusKeyboardNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusKeyboardNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusKeyboardNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusKeyboardNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusKeyboardNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusKeyboardNavigationMode>(arg);

            self->obj.XYFocusKeyboardNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusDownNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusDownNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusDownNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusDownNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusDownNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusDownNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TabFocusNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TabFocusNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TabFocusNavigation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TabFocusNavigation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TabFocusNavigation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardNavigationMode>(arg);

            self->obj.TabFocusNavigation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_KeyTipVerticalOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipVerticalOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyTipVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyTipVerticalOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipVerticalOffset"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusUpNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusUpNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusUpNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusUpNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusUpNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusUpNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_KeyTipPlacementMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipPlacementMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyTipPlacementMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyTipPlacementMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipPlacementMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyTipPlacementMode>(arg);

            self->obj.KeyTipPlacementMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_XYFocusLeftNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusLeftNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.XYFocusLeftNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_XYFocusLeftNavigationStrategy(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"XYFocusLeftNavigationStrategy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusLeftNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Lights(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Lights"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Lights());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_KeyboardAccelerators(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAccelerators"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAccelerators());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_KeyboardAcceleratorPlacementTarget(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorPlacementTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyboardAcceleratorPlacementTarget(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.KeyboardAcceleratorPlacementTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_KeyboardAcceleratorPlacementMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyboardAcceleratorPlacementMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyboardAcceleratorPlacementMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyboardAcceleratorPlacementMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyboardAcceleratorPlacementMode>(arg);

            self->obj.KeyboardAcceleratorPlacementMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_KeyTipTarget(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KeyTipTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_KeyTipTarget(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"KeyTipTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(arg);

            self->obj.KeyTipTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TranslationTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TranslationTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TranslationTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TranslationTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TranslationTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Vector3Transition>(arg);

            self->obj.TranslationTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_OpacityTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"OpacityTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OpacityTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_OpacityTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"OpacityTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ScalarTransition>(arg);

            self->obj.OpacityTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TransformMatrix(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TransformMatrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransformMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransformMatrix(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"TransformMatrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);

            self->obj.TransformMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ScaleTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ScaleTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScaleTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ScaleTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"ScaleTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Vector3Transition>(arg);

            self->obj.ScaleTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Scale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Scale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_RotationTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationTransition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RotationTransition(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationTransition"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ScalarTransition>(arg);

            self->obj.RotationTransition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_RotationAxis(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationAxis"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationAxis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RotationAxis(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"RotationAxis"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.RotationAxis(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Rotation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Rotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Rotation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Rotation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Translation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Translation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Translation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Translation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"Translation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Translation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CenterPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CenterPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CenterPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CenterPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.CenterPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CanBeScrollAnchor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanBeScrollAnchor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanBeScrollAnchor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CanBeScrollAnchor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.UIElement", L"CanBeScrollAnchor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanBeScrollAnchor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_CenterChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CenterChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_CenterChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CenterChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_HeadingChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HeadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_HeadingChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_LoadingStatusChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoadingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_LoadingStatusChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoadingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapDoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapDoubleTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapDoubleTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapDoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapDoubleTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapDoubleTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapHolding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapHolding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapHolding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapHolding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapHolding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapHolding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PitchChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PitchChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PitchChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PitchChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_TransformOriginChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TransformOriginChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_TransformOriginChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransformOriginChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ZoomLevelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ZoomLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ZoomLevelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ZoomLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ActualCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.ActualCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ActualCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ActualCameraChanging(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>>(arg);

            return py::convert(self->obj.ActualCameraChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ActualCameraChanging(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanging"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualCameraChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_CustomExperienceChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperienceChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>>(arg);

            return py::convert(self->obj.CustomExperienceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_CustomExperienceChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperienceChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CustomExperienceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>>(arg);

            return py::convert(self->obj.MapElementClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.TargetCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>>(arg);

            return py::convert(self->obj.MapRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.MapContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_IsEnabledChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"IsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedEventHandler>(arg);

            return py::convert(self->obj.IsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_IsEnabledChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"IsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_FocusDisengaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"FocusDisengaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::Controls::FocusDisengagedEventArgs>>(arg);

            return py::convert(self->obj.FocusDisengaged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_FocusDisengaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"FocusDisengaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusDisengaged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_FocusEngaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"FocusEngaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Control, winrt::Windows::UI::Xaml::Controls::FocusEngagedEventArgs>>(arg);

            return py::convert(self->obj.FocusEngaged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_FocusEngaged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Control", L"FocusEngaged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusEngaged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_LayoutUpdated(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"LayoutUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LayoutUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_LayoutUpdated(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"LayoutUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LayoutUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Loaded(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Loaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Loaded(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Loaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_SizeChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::SizeChangedEventHandler>(arg);

            return py::convert(self->obj.SizeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_SizeChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"SizeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SizeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Unloaded(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Unloaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.Unloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Unloaded(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Unloaded"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Unloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DataContextChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContextChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::DataContextChangedEventArgs>>(arg);

            return py::convert(self->obj.DataContextChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DataContextChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"DataContextChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataContextChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Loading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loading"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Loading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Loading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"Loading"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Loading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ActualThemeChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualThemeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActualThemeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ActualThemeChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"ActualThemeChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualThemeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_EffectiveViewportChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"EffectiveViewportChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::FrameworkElement, winrt::Windows::UI::Xaml::EffectiveViewportChangedEventArgs>>(arg);

            return py::convert(self->obj.EffectiveViewportChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_EffectiveViewportChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.FrameworkElement", L"EffectiveViewportChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EffectiveViewportChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DoubleTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::DoubleTappedEventHandler>(arg);

            return py::convert(self->obj.DoubleTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DoubleTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DoubleTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DragEnter(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragEnter"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragEnter(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DragEnter(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragEnter"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragEnter(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DragLeave(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragLeave"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragLeave(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DragLeave(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragLeave"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragLeave(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DragOver(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragOver"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.DragOver(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DragOver(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragOver"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragOver(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Drop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Drop"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DragEventHandler>(arg);

            return py::convert(self->obj.Drop(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Drop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Drop"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Drop(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_GotFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GotFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_GotFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GotFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Holding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Holding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::HoldingEventHandler>(arg);

            return py::convert(self->obj.Holding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Holding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Holding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Holding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_KeyDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.KeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_KeyDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_KeyUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.KeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_KeyUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"KeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_LostFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LostFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_LostFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LostFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ManipulationCompleted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationCompletedEventHandler>(arg);

            return py::convert(self->obj.ManipulationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ManipulationCompleted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ManipulationDelta(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationDelta"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationDeltaEventHandler>(arg);

            return py::convert(self->obj.ManipulationDelta(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ManipulationDelta(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationDelta"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationDelta(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ManipulationInertiaStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationInertiaStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationInertiaStartingEventHandler>(arg);

            return py::convert(self->obj.ManipulationInertiaStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ManipulationInertiaStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationInertiaStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationInertiaStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ManipulationStarted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationStartedEventHandler>(arg);

            return py::convert(self->obj.ManipulationStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ManipulationStarted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ManipulationStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::ManipulationStartingEventHandler>(arg);

            return py::convert(self->obj.ManipulationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ManipulationStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ManipulationStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ManipulationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerCanceled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerCanceled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerCaptureLost(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerCaptureLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerCaptureLost(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerCaptureLost"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerCaptureLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerMoved(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerMoved(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerMoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerPressed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerPressed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerReleased(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerReleased(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PointerWheelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::PointerEventHandler>(arg);

            return py::convert(self->obj.PointerWheelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PointerWheelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PointerWheelChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerWheelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_RightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"RightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::RightTappedEventHandler>(arg);

            return py::convert(self->obj.RightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_RightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"RightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_Tapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Tapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::TappedEventHandler>(arg);

            return py::convert(self->obj.Tapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_Tapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"Tapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Tapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DragStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DragStartingEventArgs>>(arg);

            return py::convert(self->obj.DragStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DragStarting(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DragStarting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DragStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_DropCompleted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DropCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::DropCompletedEventArgs>>(arg);

            return py::convert(self->obj.DropCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_DropCompleted(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"DropCompleted"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DropCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_AccessKeyDisplayDismissed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayDismissed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_AccessKeyDisplayDismissed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayDismissed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_AccessKeyDisplayRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_AccessKeyDisplayRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyDisplayRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_AccessKeyInvoked(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::AccessKeyInvokedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_AccessKeyInvoked(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"AccessKeyInvoked"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ContextCanceled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::RoutedEventArgs>>(arg);

            return py::convert(self->obj.ContextCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ContextCanceled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextCanceled"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContextCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::ContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.ContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_GettingFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GettingFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::GettingFocusEventArgs>>(arg);

            return py::convert(self->obj.GettingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_GettingFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"GettingFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GettingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_LosingFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LosingFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::LosingFocusEventArgs>>(arg);

            return py::convert(self->obj.LosingFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_LosingFocus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"LosingFocus"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LosingFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_NoFocusCandidateFound(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"NoFocusCandidateFound"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::NoFocusCandidateFoundEventArgs>>(arg);

            return py::convert(self->obj.NoFocusCandidateFound(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_NoFocusCandidateFound(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"NoFocusCandidateFound"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NoFocusCandidateFound(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_CharacterReceived(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::CharacterReceivedRoutedEventArgs>>(arg);

            return py::convert(self->obj.CharacterReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_CharacterReceived(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"CharacterReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CharacterReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PreviewKeyDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.PreviewKeyDown(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PreviewKeyDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyDown"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewKeyDown(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PreviewKeyUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Input::KeyEventHandler>(arg);

            return py::convert(self->obj.PreviewKeyUp(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PreviewKeyUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"PreviewKeyUp"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PreviewKeyUp(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ProcessKeyboardAccelerators(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ProcessKeyboardAccelerators"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::Input::ProcessKeyboardAcceleratorEventArgs>>(arg);

            return py::convert(self->obj.ProcessKeyboardAccelerators(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ProcessKeyboardAccelerators(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"ProcessKeyboardAccelerators"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProcessKeyboardAccelerators(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_BringIntoViewRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"BringIntoViewRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::UIElement, winrt::Windows::UI::Xaml::BringIntoViewRequestedEventArgs>>(arg);

            return py::convert(self->obj.BringIntoViewRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_BringIntoViewRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.UIElement", L"BringIntoViewRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BringIntoViewRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControl[] = {
        { "add_handler", reinterpret_cast<PyCFunction>(MapControl_AddHandler), METH_VARARGS, nullptr },
        { "apply_template", reinterpret_cast<PyCFunction>(MapControl_ApplyTemplate), METH_VARARGS, nullptr },
        { "arrange", reinterpret_cast<PyCFunction>(MapControl_Arrange), METH_VARARGS, nullptr },
        { "cancel_direct_manipulations", reinterpret_cast<PyCFunction>(MapControl_CancelDirectManipulations), METH_VARARGS, nullptr },
        { "capture_pointer", reinterpret_cast<PyCFunction>(MapControl_CapturePointer), METH_VARARGS, nullptr },
        { "clear_value", reinterpret_cast<PyCFunction>(MapControl_ClearValue), METH_VARARGS, nullptr },
        { "find_map_elements_at_offset", reinterpret_cast<PyCFunction>(MapControl_FindMapElementsAtOffset), METH_VARARGS, nullptr },
        { "find_name", reinterpret_cast<PyCFunction>(MapControl_FindName), METH_VARARGS, nullptr },
        { "focus", reinterpret_cast<PyCFunction>(MapControl_Focus), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapControl_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_binding_expression", reinterpret_cast<PyCFunction>(MapControl_GetBindingExpression), METH_VARARGS, nullptr },
        { "get_location_from_offset", reinterpret_cast<PyCFunction>(MapControl_GetLocationFromOffset), METH_VARARGS, nullptr },
        { "get_offset_from_location", reinterpret_cast<PyCFunction>(MapControl_GetOffsetFromLocation), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapControl_GetValue), METH_VARARGS, nullptr },
        { "get_visible_region", reinterpret_cast<PyCFunction>(MapControl_GetVisibleRegion), METH_VARARGS, nullptr },
        { "invalidate_arrange", reinterpret_cast<PyCFunction>(MapControl_InvalidateArrange), METH_VARARGS, nullptr },
        { "invalidate_measure", reinterpret_cast<PyCFunction>(MapControl_InvalidateMeasure), METH_VARARGS, nullptr },
        { "is_location_in_view", reinterpret_cast<PyCFunction>(MapControl_IsLocationInView), METH_VARARGS, nullptr },
        { "measure", reinterpret_cast<PyCFunction>(MapControl_Measure), METH_VARARGS, nullptr },
        { "populate_property_info", reinterpret_cast<PyCFunction>(MapControl_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapControl_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapControl_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "release_pointer_capture", reinterpret_cast<PyCFunction>(MapControl_ReleasePointerCapture), METH_VARARGS, nullptr },
        { "release_pointer_captures", reinterpret_cast<PyCFunction>(MapControl_ReleasePointerCaptures), METH_VARARGS, nullptr },
        { "remove_focus_engagement", reinterpret_cast<PyCFunction>(MapControl_RemoveFocusEngagement), METH_VARARGS, nullptr },
        { "remove_handler", reinterpret_cast<PyCFunction>(MapControl_RemoveHandler), METH_VARARGS, nullptr },
        { "set_binding", reinterpret_cast<PyCFunction>(MapControl_SetBinding), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapControl_SetValue), METH_VARARGS, nullptr },
        { "start_animation", reinterpret_cast<PyCFunction>(MapControl_StartAnimation), METH_VARARGS, nullptr },
        { "start_bring_into_view", reinterpret_cast<PyCFunction>(MapControl_StartBringIntoView), METH_VARARGS, nullptr },
        { "start_continuous_pan", reinterpret_cast<PyCFunction>(MapControl_StartContinuousPan), METH_VARARGS, nullptr },
        { "start_continuous_rotate", reinterpret_cast<PyCFunction>(MapControl_StartContinuousRotate), METH_VARARGS, nullptr },
        { "start_continuous_tilt", reinterpret_cast<PyCFunction>(MapControl_StartContinuousTilt), METH_VARARGS, nullptr },
        { "start_continuous_zoom", reinterpret_cast<PyCFunction>(MapControl_StartContinuousZoom), METH_VARARGS, nullptr },
        { "start_drag_async", reinterpret_cast<PyCFunction>(MapControl_StartDragAsync), METH_VARARGS, nullptr },
        { "stop_animation", reinterpret_cast<PyCFunction>(MapControl_StopAnimation), METH_VARARGS, nullptr },
        { "stop_continuous_pan", reinterpret_cast<PyCFunction>(MapControl_StopContinuousPan), METH_VARARGS, nullptr },
        { "stop_continuous_rotate", reinterpret_cast<PyCFunction>(MapControl_StopContinuousRotate), METH_VARARGS, nullptr },
        { "stop_continuous_tilt", reinterpret_cast<PyCFunction>(MapControl_StopContinuousTilt), METH_VARARGS, nullptr },
        { "stop_continuous_zoom", reinterpret_cast<PyCFunction>(MapControl_StopContinuousZoom), METH_VARARGS, nullptr },
        { "transform_to_visual", reinterpret_cast<PyCFunction>(MapControl_TransformToVisual), METH_VARARGS, nullptr },
        { "try_get_location_from_offset", reinterpret_cast<PyCFunction>(MapControl_TryGetLocationFromOffset), METH_VARARGS, nullptr },
        { "try_invoke_keyboard_accelerator", reinterpret_cast<PyCFunction>(MapControl_TryInvokeKeyboardAccelerator), METH_VARARGS, nullptr },
        { "try_pan_async", reinterpret_cast<PyCFunction>(MapControl_TryPanAsync), METH_VARARGS, nullptr },
        { "try_pan_to_async", reinterpret_cast<PyCFunction>(MapControl_TryPanToAsync), METH_VARARGS, nullptr },
        { "try_rotate_async", reinterpret_cast<PyCFunction>(MapControl_TryRotateAsync), METH_VARARGS, nullptr },
        { "try_rotate_to_async", reinterpret_cast<PyCFunction>(MapControl_TryRotateToAsync), METH_VARARGS, nullptr },
        { "try_set_scene_async", reinterpret_cast<PyCFunction>(MapControl_TrySetSceneAsync), METH_VARARGS, nullptr },
        { "try_set_view_async", reinterpret_cast<PyCFunction>(MapControl_TrySetViewAsync), METH_VARARGS, nullptr },
        { "try_set_view_bounds_async", reinterpret_cast<PyCFunction>(MapControl_TrySetViewBoundsAsync), METH_VARARGS, nullptr },
        { "try_tilt_async", reinterpret_cast<PyCFunction>(MapControl_TryTiltAsync), METH_VARARGS, nullptr },
        { "try_tilt_to_async", reinterpret_cast<PyCFunction>(MapControl_TryTiltToAsync), METH_VARARGS, nullptr },
        { "try_zoom_in_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomInAsync), METH_VARARGS, nullptr },
        { "try_zoom_out_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomOutAsync), METH_VARARGS, nullptr },
        { "try_zoom_to_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomToAsync), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapControl_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "update_layout", reinterpret_cast<PyCFunction>(MapControl_UpdateLayout), METH_VARARGS, nullptr },
        { "add_center_changed", reinterpret_cast<PyCFunction>(MapControl_add_CenterChanged), METH_O, nullptr },
        { "remove_center_changed", reinterpret_cast<PyCFunction>(MapControl_remove_CenterChanged), METH_O, nullptr },
        { "add_heading_changed", reinterpret_cast<PyCFunction>(MapControl_add_HeadingChanged), METH_O, nullptr },
        { "remove_heading_changed", reinterpret_cast<PyCFunction>(MapControl_remove_HeadingChanged), METH_O, nullptr },
        { "add_loading_status_changed", reinterpret_cast<PyCFunction>(MapControl_add_LoadingStatusChanged), METH_O, nullptr },
        { "remove_loading_status_changed", reinterpret_cast<PyCFunction>(MapControl_remove_LoadingStatusChanged), METH_O, nullptr },
        { "add_map_double_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapDoubleTapped), METH_O, nullptr },
        { "remove_map_double_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapDoubleTapped), METH_O, nullptr },
        { "add_map_holding", reinterpret_cast<PyCFunction>(MapControl_add_MapHolding), METH_O, nullptr },
        { "remove_map_holding", reinterpret_cast<PyCFunction>(MapControl_remove_MapHolding), METH_O, nullptr },
        { "add_map_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapTapped), METH_O, nullptr },
        { "remove_map_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapTapped), METH_O, nullptr },
        { "add_pitch_changed", reinterpret_cast<PyCFunction>(MapControl_add_PitchChanged), METH_O, nullptr },
        { "remove_pitch_changed", reinterpret_cast<PyCFunction>(MapControl_remove_PitchChanged), METH_O, nullptr },
        { "add_transform_origin_changed", reinterpret_cast<PyCFunction>(MapControl_add_TransformOriginChanged), METH_O, nullptr },
        { "remove_transform_origin_changed", reinterpret_cast<PyCFunction>(MapControl_remove_TransformOriginChanged), METH_O, nullptr },
        { "add_zoom_level_changed", reinterpret_cast<PyCFunction>(MapControl_add_ZoomLevelChanged), METH_O, nullptr },
        { "remove_zoom_level_changed", reinterpret_cast<PyCFunction>(MapControl_remove_ZoomLevelChanged), METH_O, nullptr },
        { "add_actual_camera_changed", reinterpret_cast<PyCFunction>(MapControl_add_ActualCameraChanged), METH_O, nullptr },
        { "remove_actual_camera_changed", reinterpret_cast<PyCFunction>(MapControl_remove_ActualCameraChanged), METH_O, nullptr },
        { "add_actual_camera_changing", reinterpret_cast<PyCFunction>(MapControl_add_ActualCameraChanging), METH_O, nullptr },
        { "remove_actual_camera_changing", reinterpret_cast<PyCFunction>(MapControl_remove_ActualCameraChanging), METH_O, nullptr },
        { "add_custom_experience_changed", reinterpret_cast<PyCFunction>(MapControl_add_CustomExperienceChanged), METH_O, nullptr },
        { "remove_custom_experience_changed", reinterpret_cast<PyCFunction>(MapControl_remove_CustomExperienceChanged), METH_O, nullptr },
        { "add_map_element_click", reinterpret_cast<PyCFunction>(MapControl_add_MapElementClick), METH_O, nullptr },
        { "remove_map_element_click", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementClick), METH_O, nullptr },
        { "add_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_add_MapElementPointerEntered), METH_O, nullptr },
        { "remove_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementPointerEntered), METH_O, nullptr },
        { "add_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_add_MapElementPointerExited), METH_O, nullptr },
        { "remove_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementPointerExited), METH_O, nullptr },
        { "add_target_camera_changed", reinterpret_cast<PyCFunction>(MapControl_add_TargetCameraChanged), METH_O, nullptr },
        { "remove_target_camera_changed", reinterpret_cast<PyCFunction>(MapControl_remove_TargetCameraChanged), METH_O, nullptr },
        { "add_map_right_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapRightTapped), METH_O, nullptr },
        { "remove_map_right_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapRightTapped), METH_O, nullptr },
        { "add_map_context_requested", reinterpret_cast<PyCFunction>(MapControl_add_MapContextRequested), METH_O, nullptr },
        { "remove_map_context_requested", reinterpret_cast<PyCFunction>(MapControl_remove_MapContextRequested), METH_O, nullptr },
        { "add_is_enabled_changed", reinterpret_cast<PyCFunction>(MapControl_add_IsEnabledChanged), METH_O, nullptr },
        { "remove_is_enabled_changed", reinterpret_cast<PyCFunction>(MapControl_remove_IsEnabledChanged), METH_O, nullptr },
        { "add_focus_disengaged", reinterpret_cast<PyCFunction>(MapControl_add_FocusDisengaged), METH_O, nullptr },
        { "remove_focus_disengaged", reinterpret_cast<PyCFunction>(MapControl_remove_FocusDisengaged), METH_O, nullptr },
        { "add_focus_engaged", reinterpret_cast<PyCFunction>(MapControl_add_FocusEngaged), METH_O, nullptr },
        { "remove_focus_engaged", reinterpret_cast<PyCFunction>(MapControl_remove_FocusEngaged), METH_O, nullptr },
        { "add_layout_updated", reinterpret_cast<PyCFunction>(MapControl_add_LayoutUpdated), METH_O, nullptr },
        { "remove_layout_updated", reinterpret_cast<PyCFunction>(MapControl_remove_LayoutUpdated), METH_O, nullptr },
        { "add_loaded", reinterpret_cast<PyCFunction>(MapControl_add_Loaded), METH_O, nullptr },
        { "remove_loaded", reinterpret_cast<PyCFunction>(MapControl_remove_Loaded), METH_O, nullptr },
        { "add_size_changed", reinterpret_cast<PyCFunction>(MapControl_add_SizeChanged), METH_O, nullptr },
        { "remove_size_changed", reinterpret_cast<PyCFunction>(MapControl_remove_SizeChanged), METH_O, nullptr },
        { "add_unloaded", reinterpret_cast<PyCFunction>(MapControl_add_Unloaded), METH_O, nullptr },
        { "remove_unloaded", reinterpret_cast<PyCFunction>(MapControl_remove_Unloaded), METH_O, nullptr },
        { "add_data_context_changed", reinterpret_cast<PyCFunction>(MapControl_add_DataContextChanged), METH_O, nullptr },
        { "remove_data_context_changed", reinterpret_cast<PyCFunction>(MapControl_remove_DataContextChanged), METH_O, nullptr },
        { "add_loading", reinterpret_cast<PyCFunction>(MapControl_add_Loading), METH_O, nullptr },
        { "remove_loading", reinterpret_cast<PyCFunction>(MapControl_remove_Loading), METH_O, nullptr },
        { "add_actual_theme_changed", reinterpret_cast<PyCFunction>(MapControl_add_ActualThemeChanged), METH_O, nullptr },
        { "remove_actual_theme_changed", reinterpret_cast<PyCFunction>(MapControl_remove_ActualThemeChanged), METH_O, nullptr },
        { "add_effective_viewport_changed", reinterpret_cast<PyCFunction>(MapControl_add_EffectiveViewportChanged), METH_O, nullptr },
        { "remove_effective_viewport_changed", reinterpret_cast<PyCFunction>(MapControl_remove_EffectiveViewportChanged), METH_O, nullptr },
        { "add_double_tapped", reinterpret_cast<PyCFunction>(MapControl_add_DoubleTapped), METH_O, nullptr },
        { "remove_double_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_DoubleTapped), METH_O, nullptr },
        { "add_drag_enter", reinterpret_cast<PyCFunction>(MapControl_add_DragEnter), METH_O, nullptr },
        { "remove_drag_enter", reinterpret_cast<PyCFunction>(MapControl_remove_DragEnter), METH_O, nullptr },
        { "add_drag_leave", reinterpret_cast<PyCFunction>(MapControl_add_DragLeave), METH_O, nullptr },
        { "remove_drag_leave", reinterpret_cast<PyCFunction>(MapControl_remove_DragLeave), METH_O, nullptr },
        { "add_drag_over", reinterpret_cast<PyCFunction>(MapControl_add_DragOver), METH_O, nullptr },
        { "remove_drag_over", reinterpret_cast<PyCFunction>(MapControl_remove_DragOver), METH_O, nullptr },
        { "add_drop", reinterpret_cast<PyCFunction>(MapControl_add_Drop), METH_O, nullptr },
        { "remove_drop", reinterpret_cast<PyCFunction>(MapControl_remove_Drop), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(MapControl_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(MapControl_remove_GotFocus), METH_O, nullptr },
        { "add_holding", reinterpret_cast<PyCFunction>(MapControl_add_Holding), METH_O, nullptr },
        { "remove_holding", reinterpret_cast<PyCFunction>(MapControl_remove_Holding), METH_O, nullptr },
        { "add_key_down", reinterpret_cast<PyCFunction>(MapControl_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(MapControl_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(MapControl_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(MapControl_remove_KeyUp), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(MapControl_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(MapControl_remove_LostFocus), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(MapControl_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(MapControl_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_delta", reinterpret_cast<PyCFunction>(MapControl_add_ManipulationDelta), METH_O, nullptr },
        { "remove_manipulation_delta", reinterpret_cast<PyCFunction>(MapControl_remove_ManipulationDelta), METH_O, nullptr },
        { "add_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(MapControl_add_ManipulationInertiaStarting), METH_O, nullptr },
        { "remove_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(MapControl_remove_ManipulationInertiaStarting), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(MapControl_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(MapControl_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_starting", reinterpret_cast<PyCFunction>(MapControl_add_ManipulationStarting), METH_O, nullptr },
        { "remove_manipulation_starting", reinterpret_cast<PyCFunction>(MapControl_remove_ManipulationStarting), METH_O, nullptr },
        { "add_pointer_canceled", reinterpret_cast<PyCFunction>(MapControl_add_PointerCanceled), METH_O, nullptr },
        { "remove_pointer_canceled", reinterpret_cast<PyCFunction>(MapControl_remove_PointerCanceled), METH_O, nullptr },
        { "add_pointer_capture_lost", reinterpret_cast<PyCFunction>(MapControl_add_PointerCaptureLost), METH_O, nullptr },
        { "remove_pointer_capture_lost", reinterpret_cast<PyCFunction>(MapControl_remove_PointerCaptureLost), METH_O, nullptr },
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(MapControl_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(MapControl_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(MapControl_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(MapControl_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(MapControl_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(MapControl_remove_PointerReleased), METH_O, nullptr },
        { "add_pointer_wheel_changed", reinterpret_cast<PyCFunction>(MapControl_add_PointerWheelChanged), METH_O, nullptr },
        { "remove_pointer_wheel_changed", reinterpret_cast<PyCFunction>(MapControl_remove_PointerWheelChanged), METH_O, nullptr },
        { "add_right_tapped", reinterpret_cast<PyCFunction>(MapControl_add_RightTapped), METH_O, nullptr },
        { "remove_right_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_RightTapped), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(MapControl_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_Tapped), METH_O, nullptr },
        { "add_drag_starting", reinterpret_cast<PyCFunction>(MapControl_add_DragStarting), METH_O, nullptr },
        { "remove_drag_starting", reinterpret_cast<PyCFunction>(MapControl_remove_DragStarting), METH_O, nullptr },
        { "add_drop_completed", reinterpret_cast<PyCFunction>(MapControl_add_DropCompleted), METH_O, nullptr },
        { "remove_drop_completed", reinterpret_cast<PyCFunction>(MapControl_remove_DropCompleted), METH_O, nullptr },
        { "add_access_key_display_dismissed", reinterpret_cast<PyCFunction>(MapControl_add_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "remove_access_key_display_dismissed", reinterpret_cast<PyCFunction>(MapControl_remove_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "add_access_key_display_requested", reinterpret_cast<PyCFunction>(MapControl_add_AccessKeyDisplayRequested), METH_O, nullptr },
        { "remove_access_key_display_requested", reinterpret_cast<PyCFunction>(MapControl_remove_AccessKeyDisplayRequested), METH_O, nullptr },
        { "add_access_key_invoked", reinterpret_cast<PyCFunction>(MapControl_add_AccessKeyInvoked), METH_O, nullptr },
        { "remove_access_key_invoked", reinterpret_cast<PyCFunction>(MapControl_remove_AccessKeyInvoked), METH_O, nullptr },
        { "add_context_canceled", reinterpret_cast<PyCFunction>(MapControl_add_ContextCanceled), METH_O, nullptr },
        { "remove_context_canceled", reinterpret_cast<PyCFunction>(MapControl_remove_ContextCanceled), METH_O, nullptr },
        { "add_context_requested", reinterpret_cast<PyCFunction>(MapControl_add_ContextRequested), METH_O, nullptr },
        { "remove_context_requested", reinterpret_cast<PyCFunction>(MapControl_remove_ContextRequested), METH_O, nullptr },
        { "add_getting_focus", reinterpret_cast<PyCFunction>(MapControl_add_GettingFocus), METH_O, nullptr },
        { "remove_getting_focus", reinterpret_cast<PyCFunction>(MapControl_remove_GettingFocus), METH_O, nullptr },
        { "add_losing_focus", reinterpret_cast<PyCFunction>(MapControl_add_LosingFocus), METH_O, nullptr },
        { "remove_losing_focus", reinterpret_cast<PyCFunction>(MapControl_remove_LosingFocus), METH_O, nullptr },
        { "add_no_focus_candidate_found", reinterpret_cast<PyCFunction>(MapControl_add_NoFocusCandidateFound), METH_O, nullptr },
        { "remove_no_focus_candidate_found", reinterpret_cast<PyCFunction>(MapControl_remove_NoFocusCandidateFound), METH_O, nullptr },
        { "add_character_received", reinterpret_cast<PyCFunction>(MapControl_add_CharacterReceived), METH_O, nullptr },
        { "remove_character_received", reinterpret_cast<PyCFunction>(MapControl_remove_CharacterReceived), METH_O, nullptr },
        { "add_preview_key_down", reinterpret_cast<PyCFunction>(MapControl_add_PreviewKeyDown), METH_O, nullptr },
        { "remove_preview_key_down", reinterpret_cast<PyCFunction>(MapControl_remove_PreviewKeyDown), METH_O, nullptr },
        { "add_preview_key_up", reinterpret_cast<PyCFunction>(MapControl_add_PreviewKeyUp), METH_O, nullptr },
        { "remove_preview_key_up", reinterpret_cast<PyCFunction>(MapControl_remove_PreviewKeyUp), METH_O, nullptr },
        { "add_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(MapControl_add_ProcessKeyboardAccelerators), METH_O, nullptr },
        { "remove_process_keyboard_accelerators", reinterpret_cast<PyCFunction>(MapControl_remove_ProcessKeyboardAccelerators), METH_O, nullptr },
        { "add_bring_into_view_requested", reinterpret_cast<PyCFunction>(MapControl_add_BringIntoViewRequested), METH_O, nullptr },
        { "remove_bring_into_view_requested", reinterpret_cast<PyCFunction>(MapControl_remove_BringIntoViewRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControl[] = {
        { "zoom_level", reinterpret_cast<getter>(MapControl_get_ZoomLevel), reinterpret_cast<setter>(MapControl_put_ZoomLevel), nullptr, nullptr },
        { "watermark_mode", reinterpret_cast<getter>(MapControl_get_WatermarkMode), reinterpret_cast<setter>(MapControl_put_WatermarkMode), nullptr, nullptr },
        { "transform_origin", reinterpret_cast<getter>(MapControl_get_TransformOrigin), reinterpret_cast<setter>(MapControl_put_TransformOrigin), nullptr, nullptr },
        { "traffic_flow_visible", reinterpret_cast<getter>(MapControl_get_TrafficFlowVisible), reinterpret_cast<setter>(MapControl_put_TrafficFlowVisible), nullptr, nullptr },
        { "style", reinterpret_cast<getter>(MapControl_get_Style), reinterpret_cast<setter>(MapControl_put_Style), nullptr, nullptr },
        { "pedestrian_features_visible", reinterpret_cast<getter>(MapControl_get_PedestrianFeaturesVisible), reinterpret_cast<setter>(MapControl_put_PedestrianFeaturesVisible), nullptr, nullptr },
        { "map_service_token", reinterpret_cast<getter>(MapControl_get_MapServiceToken), reinterpret_cast<setter>(MapControl_put_MapServiceToken), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(MapControl_get_Center), reinterpret_cast<setter>(MapControl_put_Center), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapControl_get_Heading), reinterpret_cast<setter>(MapControl_put_Heading), nullptr, nullptr },
        { "desired_pitch", reinterpret_cast<getter>(MapControl_get_DesiredPitch), reinterpret_cast<setter>(MapControl_put_DesiredPitch), nullptr, nullptr },
        { "color_scheme", reinterpret_cast<getter>(MapControl_get_ColorScheme), reinterpret_cast<setter>(MapControl_put_ColorScheme), nullptr, nullptr },
        { "landmarks_visible", reinterpret_cast<getter>(MapControl_get_LandmarksVisible), reinterpret_cast<setter>(MapControl_put_LandmarksVisible), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(MapControl_get_Children), nullptr, nullptr, nullptr },
        { "loading_status", reinterpret_cast<getter>(MapControl_get_LoadingStatus), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapControl_get_MapElements), nullptr, nullptr, nullptr },
        { "max_zoom_level", reinterpret_cast<getter>(MapControl_get_MaxZoomLevel), nullptr, nullptr, nullptr },
        { "min_zoom_level", reinterpret_cast<getter>(MapControl_get_MinZoomLevel), nullptr, nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapControl_get_Pitch), nullptr, nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(MapControl_get_Routes), nullptr, nullptr, nullptr },
        { "tile_sources", reinterpret_cast<getter>(MapControl_get_TileSources), nullptr, nullptr, nullptr },
        { "rotate_interaction_mode", reinterpret_cast<getter>(MapControl_get_RotateInteractionMode), reinterpret_cast<setter>(MapControl_put_RotateInteractionMode), nullptr, nullptr },
        { "zoom_interaction_mode", reinterpret_cast<getter>(MapControl_get_ZoomInteractionMode), reinterpret_cast<setter>(MapControl_put_ZoomInteractionMode), nullptr, nullptr },
        { "transit_features_visible", reinterpret_cast<getter>(MapControl_get_TransitFeaturesVisible), reinterpret_cast<setter>(MapControl_put_TransitFeaturesVisible), nullptr, nullptr },
        { "tilt_interaction_mode", reinterpret_cast<getter>(MapControl_get_TiltInteractionMode), reinterpret_cast<setter>(MapControl_put_TiltInteractionMode), nullptr, nullptr },
        { "scene", reinterpret_cast<getter>(MapControl_get_Scene), reinterpret_cast<setter>(MapControl_put_Scene), nullptr, nullptr },
        { "business_landmarks_visible", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksVisible), reinterpret_cast<setter>(MapControl_put_BusinessLandmarksVisible), nullptr, nullptr },
        { "pan_interaction_mode", reinterpret_cast<getter>(MapControl_get_PanInteractionMode), reinterpret_cast<setter>(MapControl_put_PanInteractionMode), nullptr, nullptr },
        { "custom_experience", reinterpret_cast<getter>(MapControl_get_CustomExperience), reinterpret_cast<setter>(MapControl_put_CustomExperience), nullptr, nullptr },
        { "actual_camera", reinterpret_cast<getter>(MapControl_get_ActualCamera), nullptr, nullptr, nullptr },
        { "is3_d_supported", reinterpret_cast<getter>(MapControl_get_Is3DSupported), nullptr, nullptr, nullptr },
        { "is_streetside_supported", reinterpret_cast<getter>(MapControl_get_IsStreetsideSupported), nullptr, nullptr, nullptr },
        { "target_camera", reinterpret_cast<getter>(MapControl_get_TargetCamera), nullptr, nullptr, nullptr },
        { "transit_features_enabled", reinterpret_cast<getter>(MapControl_get_TransitFeaturesEnabled), reinterpret_cast<setter>(MapControl_put_TransitFeaturesEnabled), nullptr, nullptr },
        { "business_landmarks_enabled", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksEnabled), reinterpret_cast<setter>(MapControl_put_BusinessLandmarksEnabled), nullptr, nullptr },
        { "view_padding", reinterpret_cast<getter>(MapControl_get_ViewPadding), reinterpret_cast<setter>(MapControl_put_ViewPadding), nullptr, nullptr },
        { "style_sheet", reinterpret_cast<getter>(MapControl_get_StyleSheet), reinterpret_cast<setter>(MapControl_put_StyleSheet), nullptr, nullptr },
        { "map_projection", reinterpret_cast<getter>(MapControl_get_MapProjection), reinterpret_cast<setter>(MapControl_put_MapProjection), nullptr, nullptr },
        { "layers", reinterpret_cast<getter>(MapControl_get_Layers), reinterpret_cast<setter>(MapControl_put_Layers), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(MapControl_get_Region), reinterpret_cast<setter>(MapControl_put_Region), nullptr, nullptr },
        { "can_tilt_down", reinterpret_cast<getter>(MapControl_get_CanTiltDown), nullptr, nullptr, nullptr },
        { "can_tilt_up", reinterpret_cast<getter>(MapControl_get_CanTiltUp), nullptr, nullptr, nullptr },
        { "can_zoom_in", reinterpret_cast<getter>(MapControl_get_CanZoomIn), nullptr, nullptr, nullptr },
        { "can_zoom_out", reinterpret_cast<getter>(MapControl_get_CanZoomOut), nullptr, nullptr, nullptr },
        { "padding", reinterpret_cast<getter>(MapControl_get_Padding), reinterpret_cast<setter>(MapControl_put_Padding), nullptr, nullptr },
        { "is_tab_stop", reinterpret_cast<getter>(MapControl_get_IsTabStop), reinterpret_cast<setter>(MapControl_put_IsTabStop), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapControl_get_IsEnabled), reinterpret_cast<setter>(MapControl_put_IsEnabled), nullptr, nullptr },
        { "horizontal_content_alignment", reinterpret_cast<getter>(MapControl_get_HorizontalContentAlignment), reinterpret_cast<setter>(MapControl_put_HorizontalContentAlignment), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(MapControl_get_Foreground), reinterpret_cast<setter>(MapControl_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(MapControl_get_FontWeight), reinterpret_cast<setter>(MapControl_put_FontWeight), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(MapControl_get_FontStyle), reinterpret_cast<setter>(MapControl_put_FontStyle), nullptr, nullptr },
        { "font_stretch", reinterpret_cast<getter>(MapControl_get_FontStretch), reinterpret_cast<setter>(MapControl_put_FontStretch), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(MapControl_get_FontSize), reinterpret_cast<setter>(MapControl_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(MapControl_get_FontFamily), reinterpret_cast<setter>(MapControl_put_FontFamily), nullptr, nullptr },
        { "tab_index", reinterpret_cast<getter>(MapControl_get_TabIndex), reinterpret_cast<setter>(MapControl_put_TabIndex), nullptr, nullptr },
        { "character_spacing", reinterpret_cast<getter>(MapControl_get_CharacterSpacing), reinterpret_cast<setter>(MapControl_put_CharacterSpacing), nullptr, nullptr },
        { "border_thickness", reinterpret_cast<getter>(MapControl_get_BorderThickness), reinterpret_cast<setter>(MapControl_put_BorderThickness), nullptr, nullptr },
        { "border_brush", reinterpret_cast<getter>(MapControl_get_BorderBrush), reinterpret_cast<setter>(MapControl_put_BorderBrush), nullptr, nullptr },
        { "tab_navigation", reinterpret_cast<getter>(MapControl_get_TabNavigation), reinterpret_cast<setter>(MapControl_put_TabNavigation), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(MapControl_get_Background), reinterpret_cast<setter>(MapControl_put_Background), nullptr, nullptr },
        { "vertical_content_alignment", reinterpret_cast<getter>(MapControl_get_VerticalContentAlignment), reinterpret_cast<setter>(MapControl_put_VerticalContentAlignment), nullptr, nullptr },
        { "template", reinterpret_cast<getter>(MapControl_get_Template), reinterpret_cast<setter>(MapControl_put_Template), nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(MapControl_get_FocusState), nullptr, nullptr, nullptr },
        { "is_text_scale_factor_enabled", reinterpret_cast<getter>(MapControl_get_IsTextScaleFactorEnabled), reinterpret_cast<setter>(MapControl_put_IsTextScaleFactorEnabled), nullptr, nullptr },
        { "use_system_focus_visuals", reinterpret_cast<getter>(MapControl_get_UseSystemFocusVisuals), reinterpret_cast<setter>(MapControl_put_UseSystemFocusVisuals), nullptr, nullptr },
        { "x_y_focus_up", reinterpret_cast<getter>(MapControl_get_XYFocusUp), reinterpret_cast<setter>(MapControl_put_XYFocusUp), nullptr, nullptr },
        { "x_y_focus_right", reinterpret_cast<getter>(MapControl_get_XYFocusRight), reinterpret_cast<setter>(MapControl_put_XYFocusRight), nullptr, nullptr },
        { "x_y_focus_left", reinterpret_cast<getter>(MapControl_get_XYFocusLeft), reinterpret_cast<setter>(MapControl_put_XYFocusLeft), nullptr, nullptr },
        { "x_y_focus_down", reinterpret_cast<getter>(MapControl_get_XYFocusDown), reinterpret_cast<setter>(MapControl_put_XYFocusDown), nullptr, nullptr },
        { "requires_pointer", reinterpret_cast<getter>(MapControl_get_RequiresPointer), reinterpret_cast<setter>(MapControl_put_RequiresPointer), nullptr, nullptr },
        { "is_focus_engagement_enabled", reinterpret_cast<getter>(MapControl_get_IsFocusEngagementEnabled), reinterpret_cast<setter>(MapControl_put_IsFocusEngagementEnabled), nullptr, nullptr },
        { "is_focus_engaged", reinterpret_cast<getter>(MapControl_get_IsFocusEngaged), reinterpret_cast<setter>(MapControl_put_IsFocusEngaged), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(MapControl_get_ElementSoundMode), reinterpret_cast<setter>(MapControl_put_ElementSoundMode), nullptr, nullptr },
        { "default_style_resource_uri", reinterpret_cast<getter>(MapControl_get_DefaultStyleResourceUri), reinterpret_cast<setter>(MapControl_put_DefaultStyleResourceUri), nullptr, nullptr },
        { "corner_radius", reinterpret_cast<getter>(MapControl_get_CornerRadius), reinterpret_cast<setter>(MapControl_put_CornerRadius), nullptr, nullptr },
        { "background_sizing", reinterpret_cast<getter>(MapControl_get_BackgroundSizing), reinterpret_cast<setter>(MapControl_put_BackgroundSizing), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(MapControl_get_Width), reinterpret_cast<setter>(MapControl_put_Width), nullptr, nullptr },
        { "vertical_alignment", reinterpret_cast<getter>(MapControl_get_VerticalAlignment), reinterpret_cast<setter>(MapControl_put_VerticalAlignment), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapControl_get_Tag), reinterpret_cast<setter>(MapControl_put_Tag), nullptr, nullptr },
        { "resources", reinterpret_cast<getter>(MapControl_get_Resources), reinterpret_cast<setter>(MapControl_put_Resources), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(MapControl_get_Name), reinterpret_cast<setter>(MapControl_put_Name), nullptr, nullptr },
        { "min_width", reinterpret_cast<getter>(MapControl_get_MinWidth), reinterpret_cast<setter>(MapControl_put_MinWidth), nullptr, nullptr },
        { "min_height", reinterpret_cast<getter>(MapControl_get_MinHeight), reinterpret_cast<setter>(MapControl_put_MinHeight), nullptr, nullptr },
        { "max_width", reinterpret_cast<getter>(MapControl_get_MaxWidth), reinterpret_cast<setter>(MapControl_put_MaxWidth), nullptr, nullptr },
        { "max_height", reinterpret_cast<getter>(MapControl_get_MaxHeight), reinterpret_cast<setter>(MapControl_put_MaxHeight), nullptr, nullptr },
        { "margin", reinterpret_cast<getter>(MapControl_get_Margin), reinterpret_cast<setter>(MapControl_put_Margin), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(MapControl_get_Language), reinterpret_cast<setter>(MapControl_put_Language), nullptr, nullptr },
        { "horizontal_alignment", reinterpret_cast<getter>(MapControl_get_HorizontalAlignment), reinterpret_cast<setter>(MapControl_put_HorizontalAlignment), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MapControl_get_Height), reinterpret_cast<setter>(MapControl_put_Height), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(MapControl_get_FlowDirection), reinterpret_cast<setter>(MapControl_put_FlowDirection), nullptr, nullptr },
        { "data_context", reinterpret_cast<getter>(MapControl_get_DataContext), reinterpret_cast<setter>(MapControl_put_DataContext), nullptr, nullptr },
        { "actual_height", reinterpret_cast<getter>(MapControl_get_ActualHeight), nullptr, nullptr, nullptr },
        { "actual_width", reinterpret_cast<getter>(MapControl_get_ActualWidth), nullptr, nullptr, nullptr },
        { "base_uri", reinterpret_cast<getter>(MapControl_get_BaseUri), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(MapControl_get_Parent), nullptr, nullptr, nullptr },
        { "triggers", reinterpret_cast<getter>(MapControl_get_Triggers), nullptr, nullptr, nullptr },
        { "requested_theme", reinterpret_cast<getter>(MapControl_get_RequestedTheme), reinterpret_cast<setter>(MapControl_put_RequestedTheme), nullptr, nullptr },
        { "focus_visual_secondary_thickness", reinterpret_cast<getter>(MapControl_get_FocusVisualSecondaryThickness), reinterpret_cast<setter>(MapControl_put_FocusVisualSecondaryThickness), nullptr, nullptr },
        { "focus_visual_secondary_brush", reinterpret_cast<getter>(MapControl_get_FocusVisualSecondaryBrush), reinterpret_cast<setter>(MapControl_put_FocusVisualSecondaryBrush), nullptr, nullptr },
        { "focus_visual_primary_thickness", reinterpret_cast<getter>(MapControl_get_FocusVisualPrimaryThickness), reinterpret_cast<setter>(MapControl_put_FocusVisualPrimaryThickness), nullptr, nullptr },
        { "focus_visual_primary_brush", reinterpret_cast<getter>(MapControl_get_FocusVisualPrimaryBrush), reinterpret_cast<setter>(MapControl_put_FocusVisualPrimaryBrush), nullptr, nullptr },
        { "focus_visual_margin", reinterpret_cast<getter>(MapControl_get_FocusVisualMargin), reinterpret_cast<setter>(MapControl_put_FocusVisualMargin), nullptr, nullptr },
        { "allow_focus_when_disabled", reinterpret_cast<getter>(MapControl_get_AllowFocusWhenDisabled), reinterpret_cast<setter>(MapControl_put_AllowFocusWhenDisabled), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(MapControl_get_AllowFocusOnInteraction), reinterpret_cast<setter>(MapControl_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "actual_theme", reinterpret_cast<getter>(MapControl_get_ActualTheme), nullptr, nullptr, nullptr },
        { "is_loaded", reinterpret_cast<getter>(MapControl_get_IsLoaded), nullptr, nullptr, nullptr },
        { "transitions", reinterpret_cast<getter>(MapControl_get_Transitions), reinterpret_cast<setter>(MapControl_put_Transitions), nullptr, nullptr },
        { "projection", reinterpret_cast<getter>(MapControl_get_Projection), reinterpret_cast<setter>(MapControl_put_Projection), nullptr, nullptr },
        { "render_transform_origin", reinterpret_cast<getter>(MapControl_get_RenderTransformOrigin), reinterpret_cast<setter>(MapControl_put_RenderTransformOrigin), nullptr, nullptr },
        { "opacity", reinterpret_cast<getter>(MapControl_get_Opacity), reinterpret_cast<setter>(MapControl_put_Opacity), nullptr, nullptr },
        { "manipulation_mode", reinterpret_cast<getter>(MapControl_get_ManipulationMode), reinterpret_cast<setter>(MapControl_put_ManipulationMode), nullptr, nullptr },
        { "is_tap_enabled", reinterpret_cast<getter>(MapControl_get_IsTapEnabled), reinterpret_cast<setter>(MapControl_put_IsTapEnabled), nullptr, nullptr },
        { "is_right_tap_enabled", reinterpret_cast<getter>(MapControl_get_IsRightTapEnabled), reinterpret_cast<setter>(MapControl_put_IsRightTapEnabled), nullptr, nullptr },
        { "is_holding_enabled", reinterpret_cast<getter>(MapControl_get_IsHoldingEnabled), reinterpret_cast<setter>(MapControl_put_IsHoldingEnabled), nullptr, nullptr },
        { "is_hit_test_visible", reinterpret_cast<getter>(MapControl_get_IsHitTestVisible), reinterpret_cast<setter>(MapControl_put_IsHitTestVisible), nullptr, nullptr },
        { "is_double_tap_enabled", reinterpret_cast<getter>(MapControl_get_IsDoubleTapEnabled), reinterpret_cast<setter>(MapControl_put_IsDoubleTapEnabled), nullptr, nullptr },
        { "allow_drop", reinterpret_cast<getter>(MapControl_get_AllowDrop), reinterpret_cast<setter>(MapControl_put_AllowDrop), nullptr, nullptr },
        { "clip", reinterpret_cast<getter>(MapControl_get_Clip), reinterpret_cast<setter>(MapControl_put_Clip), nullptr, nullptr },
        { "cache_mode", reinterpret_cast<getter>(MapControl_get_CacheMode), reinterpret_cast<setter>(MapControl_put_CacheMode), nullptr, nullptr },
        { "use_layout_rounding", reinterpret_cast<getter>(MapControl_get_UseLayoutRounding), reinterpret_cast<setter>(MapControl_put_UseLayoutRounding), nullptr, nullptr },
        { "render_transform", reinterpret_cast<getter>(MapControl_get_RenderTransform), reinterpret_cast<setter>(MapControl_put_RenderTransform), nullptr, nullptr },
        { "visibility", reinterpret_cast<getter>(MapControl_get_Visibility), reinterpret_cast<setter>(MapControl_put_Visibility), nullptr, nullptr },
        { "desired_size", reinterpret_cast<getter>(MapControl_get_DesiredSize), nullptr, nullptr, nullptr },
        { "pointer_captures", reinterpret_cast<getter>(MapControl_get_PointerCaptures), nullptr, nullptr, nullptr },
        { "render_size", reinterpret_cast<getter>(MapControl_get_RenderSize), nullptr, nullptr, nullptr },
        { "xaml_root", reinterpret_cast<getter>(MapControl_get_XamlRoot), reinterpret_cast<setter>(MapControl_put_XamlRoot), nullptr, nullptr },
        { "shadow", reinterpret_cast<getter>(MapControl_get_Shadow), reinterpret_cast<setter>(MapControl_put_Shadow), nullptr, nullptr },
        { "actual_offset", reinterpret_cast<getter>(MapControl_get_ActualOffset), nullptr, nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(MapControl_get_ActualSize), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(MapControl_get_UIContext), nullptr, nullptr, nullptr },
        { "composite_mode", reinterpret_cast<getter>(MapControl_get_CompositeMode), reinterpret_cast<setter>(MapControl_put_CompositeMode), nullptr, nullptr },
        { "transform3_d", reinterpret_cast<getter>(MapControl_get_Transform3D), reinterpret_cast<setter>(MapControl_put_Transform3D), nullptr, nullptr },
        { "can_drag", reinterpret_cast<getter>(MapControl_get_CanDrag), reinterpret_cast<setter>(MapControl_put_CanDrag), nullptr, nullptr },
        { "is_access_key_scope", reinterpret_cast<getter>(MapControl_get_IsAccessKeyScope), reinterpret_cast<setter>(MapControl_put_IsAccessKeyScope), nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked", reinterpret_cast<getter>(MapControl_get_ExitDisplayModeOnAccessKeyInvoked), reinterpret_cast<setter>(MapControl_put_ExitDisplayModeOnAccessKeyInvoked), nullptr, nullptr },
        { "context_flyout", reinterpret_cast<getter>(MapControl_get_ContextFlyout), reinterpret_cast<setter>(MapControl_put_ContextFlyout), nullptr, nullptr },
        { "access_key_scope_owner", reinterpret_cast<getter>(MapControl_get_AccessKeyScopeOwner), reinterpret_cast<setter>(MapControl_put_AccessKeyScopeOwner), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(MapControl_get_AccessKey), reinterpret_cast<setter>(MapControl_put_AccessKey), nullptr, nullptr },
        { "key_tip_horizontal_offset", reinterpret_cast<getter>(MapControl_get_KeyTipHorizontalOffset), reinterpret_cast<setter>(MapControl_put_KeyTipHorizontalOffset), nullptr, nullptr },
        { "high_contrast_adjustment", reinterpret_cast<getter>(MapControl_get_HighContrastAdjustment), reinterpret_cast<setter>(MapControl_put_HighContrastAdjustment), nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy", reinterpret_cast<getter>(MapControl_get_XYFocusRightNavigationStrategy), reinterpret_cast<setter>(MapControl_put_XYFocusRightNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_keyboard_navigation", reinterpret_cast<getter>(MapControl_get_XYFocusKeyboardNavigation), reinterpret_cast<setter>(MapControl_put_XYFocusKeyboardNavigation), nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy", reinterpret_cast<getter>(MapControl_get_XYFocusDownNavigationStrategy), reinterpret_cast<setter>(MapControl_put_XYFocusDownNavigationStrategy), nullptr, nullptr },
        { "tab_focus_navigation", reinterpret_cast<getter>(MapControl_get_TabFocusNavigation), reinterpret_cast<setter>(MapControl_put_TabFocusNavigation), nullptr, nullptr },
        { "key_tip_vertical_offset", reinterpret_cast<getter>(MapControl_get_KeyTipVerticalOffset), reinterpret_cast<setter>(MapControl_put_KeyTipVerticalOffset), nullptr, nullptr },
        { "x_y_focus_up_navigation_strategy", reinterpret_cast<getter>(MapControl_get_XYFocusUpNavigationStrategy), reinterpret_cast<setter>(MapControl_put_XYFocusUpNavigationStrategy), nullptr, nullptr },
        { "key_tip_placement_mode", reinterpret_cast<getter>(MapControl_get_KeyTipPlacementMode), reinterpret_cast<setter>(MapControl_put_KeyTipPlacementMode), nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy", reinterpret_cast<getter>(MapControl_get_XYFocusLeftNavigationStrategy), reinterpret_cast<setter>(MapControl_put_XYFocusLeftNavigationStrategy), nullptr, nullptr },
        { "lights", reinterpret_cast<getter>(MapControl_get_Lights), nullptr, nullptr, nullptr },
        { "keyboard_accelerators", reinterpret_cast<getter>(MapControl_get_KeyboardAccelerators), nullptr, nullptr, nullptr },
        { "keyboard_accelerator_placement_target", reinterpret_cast<getter>(MapControl_get_KeyboardAcceleratorPlacementTarget), reinterpret_cast<setter>(MapControl_put_KeyboardAcceleratorPlacementTarget), nullptr, nullptr },
        { "keyboard_accelerator_placement_mode", reinterpret_cast<getter>(MapControl_get_KeyboardAcceleratorPlacementMode), reinterpret_cast<setter>(MapControl_put_KeyboardAcceleratorPlacementMode), nullptr, nullptr },
        { "key_tip_target", reinterpret_cast<getter>(MapControl_get_KeyTipTarget), reinterpret_cast<setter>(MapControl_put_KeyTipTarget), nullptr, nullptr },
        { "translation_transition", reinterpret_cast<getter>(MapControl_get_TranslationTransition), reinterpret_cast<setter>(MapControl_put_TranslationTransition), nullptr, nullptr },
        { "opacity_transition", reinterpret_cast<getter>(MapControl_get_OpacityTransition), reinterpret_cast<setter>(MapControl_put_OpacityTransition), nullptr, nullptr },
        { "transform_matrix", reinterpret_cast<getter>(MapControl_get_TransformMatrix), reinterpret_cast<setter>(MapControl_put_TransformMatrix), nullptr, nullptr },
        { "scale_transition", reinterpret_cast<getter>(MapControl_get_ScaleTransition), reinterpret_cast<setter>(MapControl_put_ScaleTransition), nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(MapControl_get_Scale), reinterpret_cast<setter>(MapControl_put_Scale), nullptr, nullptr },
        { "rotation_transition", reinterpret_cast<getter>(MapControl_get_RotationTransition), reinterpret_cast<setter>(MapControl_put_RotationTransition), nullptr, nullptr },
        { "rotation_axis", reinterpret_cast<getter>(MapControl_get_RotationAxis), reinterpret_cast<setter>(MapControl_put_RotationAxis), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(MapControl_get_Rotation), reinterpret_cast<setter>(MapControl_put_Rotation), nullptr, nullptr },
        { "translation", reinterpret_cast<getter>(MapControl_get_Translation), reinterpret_cast<setter>(MapControl_put_Translation), nullptr, nullptr },
        { "center_point", reinterpret_cast<getter>(MapControl_get_CenterPoint), reinterpret_cast<setter>(MapControl_put_CenterPoint), nullptr, nullptr },
        { "can_be_scroll_anchor", reinterpret_cast<getter>(MapControl_get_CanBeScrollAnchor), reinterpret_cast<setter>(MapControl_put_CanBeScrollAnchor), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapControl_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControl) },
        { }
    };

    static PyType_Spec type_spec_MapControl = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControl",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControl};

    static PyGetSetDef getset_MapControl_Static[] = {
        { "center_property", reinterpret_cast<getter>(MapControl_get_CenterProperty), nullptr, nullptr, nullptr },
        { "zoom_level_property", reinterpret_cast<getter>(MapControl_get_ZoomLevelProperty), nullptr, nullptr, nullptr },
        { "children_property", reinterpret_cast<getter>(MapControl_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { "color_scheme_property", reinterpret_cast<getter>(MapControl_get_ColorSchemeProperty), nullptr, nullptr, nullptr },
        { "desired_pitch_property", reinterpret_cast<getter>(MapControl_get_DesiredPitchProperty), nullptr, nullptr, nullptr },
        { "heading_property", reinterpret_cast<getter>(MapControl_get_HeadingProperty), nullptr, nullptr, nullptr },
        { "landmarks_visible_property", reinterpret_cast<getter>(MapControl_get_LandmarksVisibleProperty), nullptr, nullptr, nullptr },
        { "loading_status_property", reinterpret_cast<getter>(MapControl_get_LoadingStatusProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapControl_get_LocationProperty), nullptr, nullptr, nullptr },
        { "map_elements_property", reinterpret_cast<getter>(MapControl_get_MapElementsProperty), nullptr, nullptr, nullptr },
        { "map_service_token_property", reinterpret_cast<getter>(MapControl_get_MapServiceTokenProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapControl_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { "pedestrian_features_visible_property", reinterpret_cast<getter>(MapControl_get_PedestrianFeaturesVisibleProperty), nullptr, nullptr, nullptr },
        { "pitch_property", reinterpret_cast<getter>(MapControl_get_PitchProperty), nullptr, nullptr, nullptr },
        { "routes_property", reinterpret_cast<getter>(MapControl_get_RoutesProperty), nullptr, nullptr, nullptr },
        { "style_property", reinterpret_cast<getter>(MapControl_get_StyleProperty), nullptr, nullptr, nullptr },
        { "tile_sources_property", reinterpret_cast<getter>(MapControl_get_TileSourcesProperty), nullptr, nullptr, nullptr },
        { "traffic_flow_visible_property", reinterpret_cast<getter>(MapControl_get_TrafficFlowVisibleProperty), nullptr, nullptr, nullptr },
        { "transform_origin_property", reinterpret_cast<getter>(MapControl_get_TransformOriginProperty), nullptr, nullptr, nullptr },
        { "watermark_mode_property", reinterpret_cast<getter>(MapControl_get_WatermarkModeProperty), nullptr, nullptr, nullptr },
        { "business_landmarks_visible_property", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksVisibleProperty), nullptr, nullptr, nullptr },
        { "is3_d_supported_property", reinterpret_cast<getter>(MapControl_get_Is3DSupportedProperty), nullptr, nullptr, nullptr },
        { "is_streetside_supported_property", reinterpret_cast<getter>(MapControl_get_IsStreetsideSupportedProperty), nullptr, nullptr, nullptr },
        { "pan_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_PanInteractionModeProperty), nullptr, nullptr, nullptr },
        { "rotate_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_RotateInteractionModeProperty), nullptr, nullptr, nullptr },
        { "scene_property", reinterpret_cast<getter>(MapControl_get_SceneProperty), nullptr, nullptr, nullptr },
        { "tilt_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_TiltInteractionModeProperty), nullptr, nullptr, nullptr },
        { "transit_features_visible_property", reinterpret_cast<getter>(MapControl_get_TransitFeaturesVisibleProperty), nullptr, nullptr, nullptr },
        { "zoom_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_ZoomInteractionModeProperty), nullptr, nullptr, nullptr },
        { "business_landmarks_enabled_property", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksEnabledProperty), nullptr, nullptr, nullptr },
        { "transit_features_enabled_property", reinterpret_cast<getter>(MapControl_get_TransitFeaturesEnabledProperty), nullptr, nullptr, nullptr },
        { "map_projection_property", reinterpret_cast<getter>(MapControl_get_MapProjectionProperty), nullptr, nullptr, nullptr },
        { "style_sheet_property", reinterpret_cast<getter>(MapControl_get_StyleSheetProperty), nullptr, nullptr, nullptr },
        { "view_padding_property", reinterpret_cast<getter>(MapControl_get_ViewPaddingProperty), nullptr, nullptr, nullptr },
        { "layers_property", reinterpret_cast<getter>(MapControl_get_LayersProperty), nullptr, nullptr, nullptr },
        { "region_property", reinterpret_cast<getter>(MapControl_get_RegionProperty), nullptr, nullptr, nullptr },
        { "can_tilt_up_property", reinterpret_cast<getter>(MapControl_get_CanTiltUpProperty), nullptr, nullptr, nullptr },
        { "can_zoom_in_property", reinterpret_cast<getter>(MapControl_get_CanZoomInProperty), nullptr, nullptr, nullptr },
        { "can_zoom_out_property", reinterpret_cast<getter>(MapControl_get_CanZoomOutProperty), nullptr, nullptr, nullptr },
        { "can_tilt_down_property", reinterpret_cast<getter>(MapControl_get_CanTiltDownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapControl_Static[] = {
        { "get_location", reinterpret_cast<PyCFunction>(MapControl_GetLocation), METH_VARARGS, nullptr },
        { "get_normalized_anchor_point", reinterpret_cast<PyCFunction>(MapControl_GetNormalizedAnchorPoint), METH_VARARGS, nullptr },
        { "set_location", reinterpret_cast<PyCFunction>(MapControl_SetLocation), METH_VARARGS, nullptr },
        { "set_normalized_anchor_point", reinterpret_cast<PyCFunction>(MapControl_SetNormalizedAnchorPoint), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapControl_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapControl_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapControl_Static) },
        { }
    };

    static PyType_Spec type_spec_MapControl_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControl_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapControl_Static
    };

    // ----- MapControlBusinessLandmarkClickEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkClickEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkClickEventArgs", L"LocalLocations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkClickEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkClickEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkClickEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkClickEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkClickEventArgs};

    // ----- MapControlBusinessLandmarkPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkPointerEnteredEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerEnteredEventArgs", L"LocalLocations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkPointerEnteredEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkPointerEnteredEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkPointerEnteredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkPointerEnteredEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkPointerEnteredEventArgs};

    // ----- MapControlBusinessLandmarkPointerExitedEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkPointerExitedEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerExitedEventArgs", L"LocalLocations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkPointerExitedEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkPointerExitedEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkPointerExitedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkPointerExitedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkPointerExitedEventArgs};

    // ----- MapControlBusinessLandmarkRightTappedEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkRightTappedEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkRightTappedEventArgs", L"LocalLocations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkRightTappedEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkRightTappedEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkRightTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkRightTappedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkRightTappedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkRightTappedEventArgs};

    // ----- MapControlDataHelper class --------------------

    static PyObject* _new_MapControlDataHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlDataHelper(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlDataHelper_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_CreateMapControl(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"CreateMapControl", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper::CreateMapControl(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeatureClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>>(arg);

            return py::convert(self->obj.TransitFeatureClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeatureClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeatureClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeatureRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>>(arg);

            return py::convert(self->obj.TransitFeatureRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeatureRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureRightTapped"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeatureRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeaturePointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.TransitFeaturePointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeaturePointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeaturePointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeaturePointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>>(arg);

            return py::convert(self->obj.TransitFeaturePointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeaturePointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeaturePointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlDataHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlDataHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlDataHelper[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapControlDataHelper_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapControlDataHelper_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapControlDataHelper_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapControlDataHelper_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapControlDataHelper_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapControlDataHelper_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapControlDataHelper_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_business_landmark_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkClick), METH_O, nullptr },
        { "remove_business_landmark_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkClick), METH_O, nullptr },
        { "add_business_landmark_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkRightTapped), METH_O, nullptr },
        { "remove_business_landmark_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkRightTapped), METH_O, nullptr },
        { "add_transit_feature_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeatureClick), METH_O, nullptr },
        { "remove_transit_feature_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeatureClick), METH_O, nullptr },
        { "add_transit_feature_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeatureRightTapped), METH_O, nullptr },
        { "remove_transit_feature_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeatureRightTapped), METH_O, nullptr },
        { "add_business_landmark_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkPointerEntered), METH_O, nullptr },
        { "remove_business_landmark_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkPointerEntered), METH_O, nullptr },
        { "add_business_landmark_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkPointerExited), METH_O, nullptr },
        { "remove_business_landmark_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkPointerExited), METH_O, nullptr },
        { "add_transit_feature_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeaturePointerEntered), METH_O, nullptr },
        { "remove_transit_feature_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeaturePointerEntered), METH_O, nullptr },
        { "add_transit_feature_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeaturePointerExited), METH_O, nullptr },
        { "remove_transit_feature_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeaturePointerExited), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapControlDataHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlDataHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlDataHelper[] = {
        { "dispatcher", reinterpret_cast<getter>(MapControlDataHelper_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlDataHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlDataHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlDataHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlDataHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlDataHelper) },
        { }
    };

    static PyType_Spec type_spec_MapControlDataHelper = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlDataHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlDataHelper};

    static PyGetSetDef getset_MapControlDataHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_MapControlDataHelper_Static[] = {
        { "create_map_control", reinterpret_cast<PyCFunction>(MapControlDataHelper_CreateMapControl), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapControlDataHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapControlDataHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapControlDataHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_MapControlDataHelper_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlDataHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapControlDataHelper_Static
    };

    // ----- MapControlTransitFeatureClickEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeatureClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeatureClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"TransitProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeatureClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeatureClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeatureClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeatureClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeatureClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeatureClickEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeatureClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeatureClickEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlTransitFeatureClickEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlTransitFeatureClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeatureClickEventArgs};

    // ----- MapControlTransitFeaturePointerEnteredEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeaturePointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeaturePointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"TransitProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeaturePointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeaturePointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeaturePointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeaturePointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeaturePointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeaturePointerEnteredEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeaturePointerEnteredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeaturePointerEnteredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlTransitFeaturePointerEnteredEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlTransitFeaturePointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeaturePointerEnteredEventArgs};

    // ----- MapControlTransitFeaturePointerExitedEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeaturePointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeaturePointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"TransitProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeaturePointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeaturePointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeaturePointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeaturePointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeaturePointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeaturePointerExitedEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeaturePointerExitedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeaturePointerExitedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlTransitFeaturePointerExitedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlTransitFeaturePointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeaturePointerExitedEventArgs};

    // ----- MapControlTransitFeatureRightTappedEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeatureRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeatureRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"TransitProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeatureRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeatureRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeatureRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeatureRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeatureRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeatureRightTappedEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeatureRightTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeatureRightTappedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapControlTransitFeatureRightTappedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapControlTransitFeatureRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeatureRightTappedEventArgs};

    // ----- MapCustomExperience class --------------------

    static PyObject* _new_MapCustomExperience(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapCustomExperience_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapCustomExperience_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapCustomExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCustomExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCustomExperience[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapCustomExperience_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapCustomExperience_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapCustomExperience_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapCustomExperience_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapCustomExperience_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapCustomExperience_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapCustomExperience_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapCustomExperience, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCustomExperience), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCustomExperience[] = {
        { "dispatcher", reinterpret_cast<getter>(MapCustomExperience_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapCustomExperience[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCustomExperience) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCustomExperience) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCustomExperience) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCustomExperience) },
        { }
    };

    static PyType_Spec type_spec_MapCustomExperience = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapCustomExperience",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCustomExperience};

    // ----- MapCustomExperienceChangedEventArgs class --------------------

    static PyObject* _new_MapCustomExperienceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCustomExperienceChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapCustomExperienceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCustomExperienceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCustomExperienceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapCustomExperienceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCustomExperienceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCustomExperienceChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_MapCustomExperienceChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCustomExperienceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCustomExperienceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCustomExperienceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCustomExperienceChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapCustomExperienceChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapCustomExperienceChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCustomExperienceChangedEventArgs};

    // ----- MapElement class --------------------

    static PyObject* _new_MapElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElement instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElement_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"VisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapTabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapTabIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapStyleSheetEntryProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryStateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapStyleSheetEntryStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_TagProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"TagProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::TagProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_IsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::IsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElement[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapElement_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapElement_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapElement_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapElement_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapElement_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapElement_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapElement_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElement[] = {
        { "z_index", reinterpret_cast<getter>(MapElement_get_ZIndex), reinterpret_cast<setter>(MapElement_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapElement_get_Visible), reinterpret_cast<setter>(MapElement_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapElement_get_MapTabIndex), reinterpret_cast<setter>(MapElement_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapElement_get_Tag), reinterpret_cast<setter>(MapElement_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapElement_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapElement_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapElement_get_IsEnabled), reinterpret_cast<setter>(MapElement_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapElement_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElement) },
        { }
    };

    static PyType_Spec type_spec_MapElement = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElement",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElement};

    static PyGetSetDef getset_MapElement_Static[] = {
        { "visible_property", reinterpret_cast<getter>(MapElement_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapElement_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { "map_tab_index_property", reinterpret_cast<getter>(MapElement_get_MapTabIndexProperty), nullptr, nullptr, nullptr },
        { "map_style_sheet_entry_property", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryProperty), nullptr, nullptr, nullptr },
        { "map_style_sheet_entry_state_property", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryStateProperty), nullptr, nullptr, nullptr },
        { "tag_property", reinterpret_cast<getter>(MapElement_get_TagProperty), nullptr, nullptr, nullptr },
        { "is_enabled_property", reinterpret_cast<getter>(MapElement_get_IsEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapElement_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapElement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapElement_Static) },
        { }
    };

    static PyType_Spec type_spec_MapElement_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElement_Static
    };

    // ----- MapElement3D class --------------------

    static PyObject* _new_MapElement3D(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElement3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElement3D_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Scale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Scale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Roll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Roll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Roll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Pitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Pitch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Pitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Model(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Model"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Model(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Model"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>(arg);

            self->obj.Model(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Heading"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_HeadingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"HeadingProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::HeadingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"LocationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_PitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"PitchProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::PitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_RollProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"RollProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::RollProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_ScaleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"ScaleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::ScaleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElement3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElement3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElement3D[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapElement3D_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapElement3D_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapElement3D_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapElement3D_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapElement3D_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapElement3D_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapElement3D_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapElement3D, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElement3D), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElement3D[] = {
        { "scale", reinterpret_cast<getter>(MapElement3D_get_Scale), reinterpret_cast<setter>(MapElement3D_put_Scale), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(MapElement3D_get_Roll), reinterpret_cast<setter>(MapElement3D_put_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapElement3D_get_Pitch), reinterpret_cast<setter>(MapElement3D_put_Pitch), nullptr, nullptr },
        { "model", reinterpret_cast<getter>(MapElement3D_get_Model), reinterpret_cast<setter>(MapElement3D_put_Model), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapElement3D_get_Location), reinterpret_cast<setter>(MapElement3D_put_Location), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapElement3D_get_Heading), reinterpret_cast<setter>(MapElement3D_put_Heading), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapElement3D_get_ZIndex), reinterpret_cast<setter>(MapElement3D_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapElement3D_get_Visible), reinterpret_cast<setter>(MapElement3D_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapElement3D_get_MapTabIndex), reinterpret_cast<setter>(MapElement3D_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapElement3D_get_Tag), reinterpret_cast<setter>(MapElement3D_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapElement3D_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapElement3D_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapElement3D_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapElement3D_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapElement3D_get_IsEnabled), reinterpret_cast<setter>(MapElement3D_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapElement3D_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElement3D[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElement3D) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElement3D) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElement3D) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElement3D) },
        { }
    };

    static PyType_Spec type_spec_MapElement3D = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElement3D",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElement3D};

    static PyGetSetDef getset_MapElement3D_Static[] = {
        { "heading_property", reinterpret_cast<getter>(MapElement3D_get_HeadingProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapElement3D_get_LocationProperty), nullptr, nullptr, nullptr },
        { "pitch_property", reinterpret_cast<getter>(MapElement3D_get_PitchProperty), nullptr, nullptr, nullptr },
        { "roll_property", reinterpret_cast<getter>(MapElement3D_get_RollProperty), nullptr, nullptr, nullptr },
        { "scale_property", reinterpret_cast<getter>(MapElement3D_get_ScaleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapElement3D_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapElement3D_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElement3D_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapElement3D_Static) },
        { }
    };

    static PyType_Spec type_spec_MapElement3D_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElement3D_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElement3D_Static
    };

    // ----- MapElementClickEventArgs class --------------------

    static PyObject* _new_MapElementClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementClickEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementClickEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementClickEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementClickEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementClickEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementClickEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementClickEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementClickEventArgs};

    // ----- MapElementPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapElementPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"MapElement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementPointerEnteredEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementPointerEnteredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementPointerEnteredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementPointerEnteredEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementPointerEnteredEventArgs};

    // ----- MapElementPointerExitedEventArgs class --------------------

    static PyObject* _new_MapElementPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementPointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerExitedEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"MapElement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerExitedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementPointerExitedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementPointerExitedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementPointerExitedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementPointerExitedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementPointerExitedEventArgs};

    // ----- MapElementsLayer class --------------------

    static PyObject* _new_MapElementsLayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayer_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElementsLayer_put_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>>(arg);

            self->obj.MapElements(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElementsLayer_get_MapElementsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer::MapElementsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElementsLayer_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElementsLayer_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElementsLayer_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElementsLayer_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElementsLayer_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElementsLayer_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.MapContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapContextRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>>(arg);

            return py::convert(self->obj.MapElementClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementClick"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerEntered"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerExited"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayer[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapElementsLayer_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapElementsLayer_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapElementsLayer_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapElementsLayer_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapElementsLayer_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapElementsLayer_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapElementsLayer_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_map_context_requested", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapContextRequested), METH_O, nullptr },
        { "remove_map_context_requested", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapContextRequested), METH_O, nullptr },
        { "add_map_element_click", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementClick), METH_O, nullptr },
        { "remove_map_element_click", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementClick), METH_O, nullptr },
        { "add_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementPointerEntered), METH_O, nullptr },
        { "remove_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementPointerEntered), METH_O, nullptr },
        { "add_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementPointerExited), METH_O, nullptr },
        { "remove_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementPointerExited), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapElementsLayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayer[] = {
        { "map_elements", reinterpret_cast<getter>(MapElementsLayer_get_MapElements), reinterpret_cast<setter>(MapElementsLayer_put_MapElements), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapElementsLayer_get_ZIndex), reinterpret_cast<setter>(MapElementsLayer_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapElementsLayer_get_Visible), reinterpret_cast<setter>(MapElementsLayer_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapElementsLayer_get_MapTabIndex), reinterpret_cast<setter>(MapElementsLayer_put_MapTabIndex), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapElementsLayer_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayer) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayer = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayer",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayer};

    static PyGetSetDef getset_MapElementsLayer_Static[] = {
        { "map_elements_property", reinterpret_cast<getter>(MapElementsLayer_get_MapElementsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapElementsLayer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapElementsLayer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElementsLayer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapElementsLayer_Static) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayer_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElementsLayer_Static
    };

    // ----- MapElementsLayerClickEventArgs class --------------------

    static PyObject* _new_MapElementsLayerClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerClickEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerClickEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerClickEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerClickEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayerClickEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayerClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerClickEventArgs};

    // ----- MapElementsLayerContextRequestedEventArgs class --------------------

    static PyObject* _new_MapElementsLayerContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerContextRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"MapElements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerContextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerContextRequestedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerContextRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerContextRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayerContextRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayerContextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerContextRequestedEventArgs};

    // ----- MapElementsLayerPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapElementsLayerPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"MapElement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerPointerEnteredEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerPointerEnteredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerPointerEnteredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayerPointerEnteredEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayerPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerPointerEnteredEventArgs};

    // ----- MapElementsLayerPointerExitedEventArgs class --------------------

    static PyObject* _new_MapElementsLayerPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"MapElement"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerPointerExitedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerPointerExitedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerPointerExitedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayerPointerExitedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapElementsLayerPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerPointerExitedEventArgs};

    // ----- MapIcon class --------------------

    static PyObject* _new_MapIcon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapIcon instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapIcon(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapIcon_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_Title(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Title(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NormalizedAnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.NormalizedAnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Image"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Image"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Image(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CollisionBehaviorDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesired"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapElementCollisionBehavior>(arg);

            self->obj.CollisionBehaviorDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"LocationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPointProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"TitleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::TitleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_CollisionBehaviorDesiredProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesiredProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::CollisionBehaviorDesiredProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapIcon[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapIcon_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapIcon_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapIcon_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapIcon_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapIcon_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapIcon_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapIcon_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapIcon), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapIcon[] = {
        { "title", reinterpret_cast<getter>(MapIcon_get_Title), reinterpret_cast<setter>(MapIcon_put_Title), nullptr, nullptr },
        { "normalized_anchor_point", reinterpret_cast<getter>(MapIcon_get_NormalizedAnchorPoint), reinterpret_cast<setter>(MapIcon_put_NormalizedAnchorPoint), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapIcon_get_Location), reinterpret_cast<setter>(MapIcon_put_Location), nullptr, nullptr },
        { "image", reinterpret_cast<getter>(MapIcon_get_Image), reinterpret_cast<setter>(MapIcon_put_Image), nullptr, nullptr },
        { "collision_behavior_desired", reinterpret_cast<getter>(MapIcon_get_CollisionBehaviorDesired), reinterpret_cast<setter>(MapIcon_put_CollisionBehaviorDesired), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapIcon_get_ZIndex), reinterpret_cast<setter>(MapIcon_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapIcon_get_Visible), reinterpret_cast<setter>(MapIcon_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapIcon_get_MapTabIndex), reinterpret_cast<setter>(MapIcon_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapIcon_get_Tag), reinterpret_cast<setter>(MapIcon_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapIcon_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapIcon_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapIcon_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapIcon_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapIcon_get_IsEnabled), reinterpret_cast<setter>(MapIcon_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapIcon_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapIcon[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapIcon) },
        { }
    };

    static PyType_Spec type_spec_MapIcon = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapIcon",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapIcon};

    static PyGetSetDef getset_MapIcon_Static[] = {
        { "location_property", reinterpret_cast<getter>(MapIcon_get_LocationProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapIcon_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { "title_property", reinterpret_cast<getter>(MapIcon_get_TitleProperty), nullptr, nullptr, nullptr },
        { "collision_behavior_desired_property", reinterpret_cast<getter>(MapIcon_get_CollisionBehaviorDesiredProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapIcon_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapIcon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapIcon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapIcon_Static) },
        { }
    };

    static PyType_Spec type_spec_MapIcon_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapIcon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapIcon_Static
    };

    // ----- MapInputEventArgs class --------------------

    static PyObject* _new_MapInputEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapInputEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapInputEventArgs_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapInputEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapInputEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapInputEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapInputEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapInputEventArgs[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapInputEventArgs_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapInputEventArgs_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapInputEventArgs_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapInputEventArgs_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapInputEventArgs_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapInputEventArgs_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapInputEventArgs_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapInputEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapInputEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapInputEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapInputEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapInputEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapInputEventArgs_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapInputEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapInputEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapInputEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapInputEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapInputEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapInputEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapInputEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapInputEventArgs};

    // ----- MapItemsControl class --------------------

    static PyObject* _new_MapItemsControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapItemsControl(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapItemsControl_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapItemsControl_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapItemsControl_get_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapItemsControl_put_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapItemsControl_get_Items(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"Items"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSourceProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapItemsControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapItemsControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapItemsControl[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapItemsControl_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapItemsControl_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapItemsControl_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapItemsControl_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapItemsControl_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapItemsControl_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapItemsControl_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapItemsControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapItemsControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapItemsControl[] = {
        { "items_source", reinterpret_cast<getter>(MapItemsControl_get_ItemsSource), reinterpret_cast<setter>(MapItemsControl_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(MapItemsControl_get_ItemTemplate), reinterpret_cast<setter>(MapItemsControl_put_ItemTemplate), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MapItemsControl_get_Items), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapItemsControl_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapItemsControl[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapItemsControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapItemsControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapItemsControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapItemsControl) },
        { }
    };

    static PyType_Spec type_spec_MapItemsControl = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapItemsControl",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapItemsControl};

    static PyGetSetDef getset_MapItemsControl_Static[] = {
        { "item_template_property", reinterpret_cast<getter>(MapItemsControl_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(MapItemsControl_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(MapItemsControl_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapItemsControl_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapItemsControl_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapItemsControl_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapItemsControl_Static) },
        { }
    };

    static PyType_Spec type_spec_MapItemsControl_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapItemsControl_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapItemsControl_Static
    };

    // ----- MapLayer class --------------------

    static PyObject* _new_MapLayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapLayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapLayer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapLayer_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_MapTabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::MapTabIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"VisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapLayer[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapLayer_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapLayer_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapLayer_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapLayer_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapLayer_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapLayer_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapLayer_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapLayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapLayer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapLayer[] = {
        { "z_index", reinterpret_cast<getter>(MapLayer_get_ZIndex), reinterpret_cast<setter>(MapLayer_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapLayer_get_Visible), reinterpret_cast<setter>(MapLayer_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapLayer_get_MapTabIndex), reinterpret_cast<setter>(MapLayer_put_MapTabIndex), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapLayer_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapLayer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapLayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapLayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapLayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapLayer) },
        { }
    };

    static PyType_Spec type_spec_MapLayer = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapLayer",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapLayer};

    static PyGetSetDef getset_MapLayer_Static[] = {
        { "map_tab_index_property", reinterpret_cast<getter>(MapLayer_get_MapTabIndexProperty), nullptr, nullptr, nullptr },
        { "visible_property", reinterpret_cast<getter>(MapLayer_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapLayer_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapLayer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapLayer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapLayer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapLayer_Static) },
        { }
    };

    static PyType_Spec type_spec_MapLayer_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapLayer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapLayer_Static
    };

    // ----- MapModel3D class --------------------

    static PyObject* _new_MapModel3D(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapModel3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapModel3D_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_CreateFrom3MFAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapModel3D", L"CreateFrom3MFAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D::CreateFrom3MFAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapModel3D", L"CreateFrom3MFAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3DShadingOption>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D::CreateFrom3MFAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapModel3D_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapModel3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapModel3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapModel3D[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapModel3D_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapModel3D_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapModel3D_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapModel3D_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapModel3D_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapModel3D_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapModel3D_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapModel3D, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapModel3D), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapModel3D[] = {
        { "dispatcher", reinterpret_cast<getter>(MapModel3D_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapModel3D[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapModel3D) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapModel3D) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapModel3D) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapModel3D) },
        { }
    };

    static PyType_Spec type_spec_MapModel3D = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapModel3D",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapModel3D};

    static PyGetSetDef getset_MapModel3D_Static[] = {
        { }
    };

    static PyMethodDef methods_MapModel3D_Static[] = {
        { "create_from3_m_f_async", reinterpret_cast<PyCFunction>(MapModel3D_CreateFrom3MFAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapModel3D_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapModel3D_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapModel3D_Static) },
        { }
    };

    static PyType_Spec type_spec_MapModel3D_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapModel3D_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapModel3D_Static
    };

    // ----- MapPolygon class --------------------

    static PyObject* _new_MapPolygon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapPolygon(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapPolygon_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.StrokeThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StrokeDashed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.StrokeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_FillColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"FillColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FillColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_FillColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"FillColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.FillColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Paths(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Paths"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_PathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"PathProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::PathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_StrokeDashedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::StrokeDashedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_StrokeThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThicknessProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::StrokeThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapPolygon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapPolygon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapPolygon[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapPolygon_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapPolygon_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapPolygon_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapPolygon_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapPolygon_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapPolygon_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapPolygon_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapPolygon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapPolygon), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapPolygon[] = {
        { "stroke_thickness", reinterpret_cast<getter>(MapPolygon_get_StrokeThickness), reinterpret_cast<setter>(MapPolygon_put_StrokeThickness), nullptr, nullptr },
        { "stroke_dashed", reinterpret_cast<getter>(MapPolygon_get_StrokeDashed), reinterpret_cast<setter>(MapPolygon_put_StrokeDashed), nullptr, nullptr },
        { "stroke_color", reinterpret_cast<getter>(MapPolygon_get_StrokeColor), reinterpret_cast<setter>(MapPolygon_put_StrokeColor), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(MapPolygon_get_Path), reinterpret_cast<setter>(MapPolygon_put_Path), nullptr, nullptr },
        { "fill_color", reinterpret_cast<getter>(MapPolygon_get_FillColor), reinterpret_cast<setter>(MapPolygon_put_FillColor), nullptr, nullptr },
        { "paths", reinterpret_cast<getter>(MapPolygon_get_Paths), nullptr, nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapPolygon_get_ZIndex), reinterpret_cast<setter>(MapPolygon_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapPolygon_get_Visible), reinterpret_cast<setter>(MapPolygon_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapPolygon_get_MapTabIndex), reinterpret_cast<setter>(MapPolygon_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapPolygon_get_Tag), reinterpret_cast<setter>(MapPolygon_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapPolygon_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapPolygon_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapPolygon_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapPolygon_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapPolygon_get_IsEnabled), reinterpret_cast<setter>(MapPolygon_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapPolygon_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapPolygon[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapPolygon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapPolygon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapPolygon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapPolygon) },
        { }
    };

    static PyType_Spec type_spec_MapPolygon = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapPolygon",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapPolygon};

    static PyGetSetDef getset_MapPolygon_Static[] = {
        { "path_property", reinterpret_cast<getter>(MapPolygon_get_PathProperty), nullptr, nullptr, nullptr },
        { "stroke_dashed_property", reinterpret_cast<getter>(MapPolygon_get_StrokeDashedProperty), nullptr, nullptr, nullptr },
        { "stroke_thickness_property", reinterpret_cast<getter>(MapPolygon_get_StrokeThicknessProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapPolygon_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapPolygon_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapPolygon_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapPolygon_Static) },
        { }
    };

    static PyType_Spec type_spec_MapPolygon_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapPolygon_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapPolygon_Static
    };

    // ----- MapPolyline class --------------------

    static PyObject* _new_MapPolyline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapPolyline(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapPolyline_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapPolyline_get_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeThickness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.StrokeThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeDashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StrokeDashed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StrokeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.StrokeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_PathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"PathProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline::PathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolyline_get_StrokeDashedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashedProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline::StrokeDashedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolyline_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapPolyline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapPolyline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapPolyline[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapPolyline_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapPolyline_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapPolyline_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapPolyline_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapPolyline_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapPolyline_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapPolyline_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapPolyline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapPolyline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapPolyline[] = {
        { "stroke_thickness", reinterpret_cast<getter>(MapPolyline_get_StrokeThickness), reinterpret_cast<setter>(MapPolyline_put_StrokeThickness), nullptr, nullptr },
        { "stroke_dashed", reinterpret_cast<getter>(MapPolyline_get_StrokeDashed), reinterpret_cast<setter>(MapPolyline_put_StrokeDashed), nullptr, nullptr },
        { "stroke_color", reinterpret_cast<getter>(MapPolyline_get_StrokeColor), reinterpret_cast<setter>(MapPolyline_put_StrokeColor), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(MapPolyline_get_Path), reinterpret_cast<setter>(MapPolyline_put_Path), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapPolyline_get_ZIndex), reinterpret_cast<setter>(MapPolyline_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapPolyline_get_Visible), reinterpret_cast<setter>(MapPolyline_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapPolyline_get_MapTabIndex), reinterpret_cast<setter>(MapPolyline_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapPolyline_get_Tag), reinterpret_cast<setter>(MapPolyline_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapPolyline_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapPolyline_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapPolyline_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapPolyline_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapPolyline_get_IsEnabled), reinterpret_cast<setter>(MapPolyline_put_IsEnabled), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapPolyline_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapPolyline[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapPolyline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapPolyline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapPolyline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapPolyline) },
        { }
    };

    static PyType_Spec type_spec_MapPolyline = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapPolyline",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapPolyline};

    static PyGetSetDef getset_MapPolyline_Static[] = {
        { "path_property", reinterpret_cast<getter>(MapPolyline_get_PathProperty), nullptr, nullptr, nullptr },
        { "stroke_dashed_property", reinterpret_cast<getter>(MapPolyline_get_StrokeDashedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapPolyline_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapPolyline_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapPolyline_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapPolyline_Static) },
        { }
    };

    static PyType_Spec type_spec_MapPolyline_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapPolyline_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapPolyline_Static
    };

    // ----- MapRightTappedEventArgs class --------------------

    static PyObject* _new_MapRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapRightTappedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRightTappedEventArgs", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapRightTappedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRightTappedEventArgs", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapRightTappedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapRightTappedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapRightTappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapRightTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapRightTappedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapRightTappedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapRightTappedEventArgs};

    // ----- MapRouteView class --------------------

    static PyObject* _new_MapRouteView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::MapRoute>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapRouteView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapRouteView_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapRouteView_get_RouteColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"RouteColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RouteColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapRouteView_put_RouteColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"RouteColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.RouteColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapRouteView_get_OutlineColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"OutlineColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapRouteView_put_OutlineColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"OutlineColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapRouteView_get_Route(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"Route"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Route());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapRouteView_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapRouteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapRouteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapRouteView[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapRouteView_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapRouteView_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapRouteView_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapRouteView_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapRouteView_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapRouteView_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapRouteView_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapRouteView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapRouteView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapRouteView[] = {
        { "route_color", reinterpret_cast<getter>(MapRouteView_get_RouteColor), reinterpret_cast<setter>(MapRouteView_put_RouteColor), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(MapRouteView_get_OutlineColor), reinterpret_cast<setter>(MapRouteView_put_OutlineColor), nullptr, nullptr },
        { "route", reinterpret_cast<getter>(MapRouteView_get_Route), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapRouteView_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapRouteView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapRouteView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapRouteView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapRouteView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapRouteView) },
        { }
    };

    static PyType_Spec type_spec_MapRouteView = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapRouteView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapRouteView};

    // ----- MapScene class --------------------

    static PyObject* _new_MapScene(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>::type_name);
        return nullptr;
    }

    static void _dealloc_MapScene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapScene_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromBoundingBox(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromBoundingBox", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromBoundingBox(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromBoundingBox", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromBoundingBox(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromCamera(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromCamera", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromCamera(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocation", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocationAndRadius(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocationAndRadius", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocationAndRadius(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocationAndRadius", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocationAndRadius(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocations(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocations", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::Geopoint>>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocations(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocations", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::Geopoint>>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocations(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_get_TargetCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCamera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapScene_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapScene_add_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapScene, winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.TargetCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapScene_remove_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCameraChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapScene(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapScene(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapScene[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapScene_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapScene_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapScene_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapScene_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapScene_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapScene_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapScene_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "add_target_camera_changed", reinterpret_cast<PyCFunction>(MapScene_add_TargetCameraChanged), METH_O, nullptr },
        { "remove_target_camera_changed", reinterpret_cast<PyCFunction>(MapScene_remove_TargetCameraChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapScene, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapScene), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapScene[] = {
        { "target_camera", reinterpret_cast<getter>(MapScene_get_TargetCamera), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapScene_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapScene[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapScene) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapScene) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapScene) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapScene) },
        { }
    };

    static PyType_Spec type_spec_MapScene = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapScene",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapScene};

    static PyGetSetDef getset_MapScene_Static[] = {
        { }
    };

    static PyMethodDef methods_MapScene_Static[] = {
        { "create_from_bounding_box", reinterpret_cast<PyCFunction>(MapScene_CreateFromBoundingBox), METH_VARARGS, nullptr },
        { "create_from_camera", reinterpret_cast<PyCFunction>(MapScene_CreateFromCamera), METH_VARARGS, nullptr },
        { "create_from_location", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocation), METH_VARARGS, nullptr },
        { "create_from_location_and_radius", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocationAndRadius), METH_VARARGS, nullptr },
        { "create_from_locations", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocations), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapScene_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapScene_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapScene_Static) },
        { }
    };

    static PyType_Spec type_spec_MapScene_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapScene_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapScene_Static
    };

    // ----- MapStyleSheet class --------------------

    static PyObject* _new_MapStyleSheet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>::type_name);
        return nullptr;
    }

    static void _dealloc_MapStyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapStyleSheet_Aerial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"Aerial", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::Aerial());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_AerialWithOverlay(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"AerialWithOverlay", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::AerialWithOverlay());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_Combine(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"Combine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::Combine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_ParseFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"ParseFromJson", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::ParseFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadDark(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadDark", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadDark());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadHighContrastDark(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadHighContrastDark", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadHighContrastDark());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadHighContrastLight(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadHighContrastLight", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadHighContrastLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadLight(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadLight", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_TryParseFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"TryParseFromJson", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet param1{nullptr};

                auto return_value = winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::TryParseFromJson(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapStyleSheet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapStyleSheet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheet[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapStyleSheet_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapStyleSheet_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapStyleSheet_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapStyleSheet_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapStyleSheet_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapStyleSheet_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapStyleSheet_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapStyleSheet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapStyleSheet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapStyleSheet[] = {
        { "dispatcher", reinterpret_cast<getter>(MapStyleSheet_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheet[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapStyleSheet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheet) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheet = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheet",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheet};

    static PyGetSetDef getset_MapStyleSheet_Static[] = {
        { }
    };

    static PyMethodDef methods_MapStyleSheet_Static[] = {
        { "aerial", reinterpret_cast<PyCFunction>(MapStyleSheet_Aerial), METH_VARARGS, nullptr },
        { "aerial_with_overlay", reinterpret_cast<PyCFunction>(MapStyleSheet_AerialWithOverlay), METH_VARARGS, nullptr },
        { "combine", reinterpret_cast<PyCFunction>(MapStyleSheet_Combine), METH_VARARGS, nullptr },
        { "parse_from_json", reinterpret_cast<PyCFunction>(MapStyleSheet_ParseFromJson), METH_VARARGS, nullptr },
        { "road_dark", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadDark), METH_VARARGS, nullptr },
        { "road_high_contrast_dark", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadHighContrastDark), METH_VARARGS, nullptr },
        { "road_high_contrast_light", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadHighContrastLight), METH_VARARGS, nullptr },
        { "road_light", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadLight), METH_VARARGS, nullptr },
        { "try_parse_from_json", reinterpret_cast<PyCFunction>(MapStyleSheet_TryParseFromJson), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapStyleSheet_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapStyleSheet_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapStyleSheet_Static) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheet_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheet_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapStyleSheet_Static
    };

    // ----- MapStyleSheetEntries class --------------------

    static PyObject* _new_MapStyleSheetEntries(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries>::type_name);
        return nullptr;
    }

    static PyObject* MapStyleSheetEntries_get_AdminDistrict(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"AdminDistrict"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::AdminDistrict());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_AdminDistrictCapital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"AdminDistrictCapital"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::AdminDistrictCapital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Airport(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Airport"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Airport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Area(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Area"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Area());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ArterialRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ArterialRoad"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ArterialRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Building(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Building"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Building());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Business(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Business"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Business());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Capital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Capital"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Capital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Cemetery(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Cemetery"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Cemetery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Continent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Continent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Continent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ControlledAccessHighway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ControlledAccessHighway"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ControlledAccessHighway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_CountryRegion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"CountryRegion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::CountryRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_CountryRegionCapital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"CountryRegionCapital"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::CountryRegionCapital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_District(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"District"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::District());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_DrivingRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"DrivingRoute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::DrivingRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Education(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Education"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Education());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_EducationBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"EducationBuilding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::EducationBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_FoodPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"FoodPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::FoodPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Forest(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Forest"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Forest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_GolfCourse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"GolfCourse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::GolfCourse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_HighSpeedRamp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"HighSpeedRamp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::HighSpeedRamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Highway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Highway"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Highway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_IndigenousPeoplesReserve(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"IndigenousPeoplesReserve"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::IndigenousPeoplesReserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Island(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Island"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Island());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_MajorRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"MajorRoad"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::MajorRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Medical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Medical"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Medical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_MedicalBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"MedicalBuilding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::MedicalBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Military(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Military"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Military());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_NaturalPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"NaturalPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::NaturalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Nautical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Nautical"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Nautical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Neighborhood(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Neighborhood"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Neighborhood());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Park(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Park"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Park());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Peak(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Peak"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Peak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PlayingField(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PlayingField"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PlayingField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Point(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Point"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PointOfInterest(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PointOfInterest"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PointOfInterest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Political(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Political"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Political());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PopulatedPlace(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PopulatedPlace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PopulatedPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Railway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Railway"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Railway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Ramp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Ramp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Ramp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Reserve(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Reserve"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_River(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"River"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::River());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Road(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Road"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Road());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RoadExit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RoadExit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RoadExit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RoadShield(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RoadShield"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RoadShield());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RouteLine(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RouteLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RouteLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Runway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Runway"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Runway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Sand(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Sand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Sand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ShoppingCenter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ShoppingCenter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ShoppingCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Stadium(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Stadium"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Stadium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Street(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Street"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Street());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Structure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Structure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Structure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_TollRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"TollRoad"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::TollRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Trail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Trail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Trail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Transit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Transit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Transit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_TransitBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"TransitBuilding"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::TransitBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Transportation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Transportation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Transportation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_UnpavedStreet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"UnpavedStreet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::UnpavedStreet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Vegetation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Vegetation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Vegetation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_VolcanicPeak(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"VolcanicPeak"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::VolcanicPeak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WalkingRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WalkingRoute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WalkingRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Water(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Water"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Water());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WaterPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WaterPoint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WaterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WaterRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WaterRoute"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WaterRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheetEntries[] = {
        { }
    };

    static PyGetSetDef _getset_MapStyleSheetEntries[] = {
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheetEntries[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheetEntries) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheetEntries) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheetEntries) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntries = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntries",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheetEntries};

    static PyGetSetDef getset_MapStyleSheetEntries_Static[] = {
        { "admin_district", reinterpret_cast<getter>(MapStyleSheetEntries_get_AdminDistrict), nullptr, nullptr, nullptr },
        { "admin_district_capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_AdminDistrictCapital), nullptr, nullptr, nullptr },
        { "airport", reinterpret_cast<getter>(MapStyleSheetEntries_get_Airport), nullptr, nullptr, nullptr },
        { "area", reinterpret_cast<getter>(MapStyleSheetEntries_get_Area), nullptr, nullptr, nullptr },
        { "arterial_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_ArterialRoad), nullptr, nullptr, nullptr },
        { "building", reinterpret_cast<getter>(MapStyleSheetEntries_get_Building), nullptr, nullptr, nullptr },
        { "business", reinterpret_cast<getter>(MapStyleSheetEntries_get_Business), nullptr, nullptr, nullptr },
        { "capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_Capital), nullptr, nullptr, nullptr },
        { "cemetery", reinterpret_cast<getter>(MapStyleSheetEntries_get_Cemetery), nullptr, nullptr, nullptr },
        { "continent", reinterpret_cast<getter>(MapStyleSheetEntries_get_Continent), nullptr, nullptr, nullptr },
        { "controlled_access_highway", reinterpret_cast<getter>(MapStyleSheetEntries_get_ControlledAccessHighway), nullptr, nullptr, nullptr },
        { "country_region", reinterpret_cast<getter>(MapStyleSheetEntries_get_CountryRegion), nullptr, nullptr, nullptr },
        { "country_region_capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_CountryRegionCapital), nullptr, nullptr, nullptr },
        { "district", reinterpret_cast<getter>(MapStyleSheetEntries_get_District), nullptr, nullptr, nullptr },
        { "driving_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_DrivingRoute), nullptr, nullptr, nullptr },
        { "education", reinterpret_cast<getter>(MapStyleSheetEntries_get_Education), nullptr, nullptr, nullptr },
        { "education_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_EducationBuilding), nullptr, nullptr, nullptr },
        { "food_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_FoodPoint), nullptr, nullptr, nullptr },
        { "forest", reinterpret_cast<getter>(MapStyleSheetEntries_get_Forest), nullptr, nullptr, nullptr },
        { "golf_course", reinterpret_cast<getter>(MapStyleSheetEntries_get_GolfCourse), nullptr, nullptr, nullptr },
        { "high_speed_ramp", reinterpret_cast<getter>(MapStyleSheetEntries_get_HighSpeedRamp), nullptr, nullptr, nullptr },
        { "highway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Highway), nullptr, nullptr, nullptr },
        { "indigenous_peoples_reserve", reinterpret_cast<getter>(MapStyleSheetEntries_get_IndigenousPeoplesReserve), nullptr, nullptr, nullptr },
        { "island", reinterpret_cast<getter>(MapStyleSheetEntries_get_Island), nullptr, nullptr, nullptr },
        { "major_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_MajorRoad), nullptr, nullptr, nullptr },
        { "medical", reinterpret_cast<getter>(MapStyleSheetEntries_get_Medical), nullptr, nullptr, nullptr },
        { "medical_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_MedicalBuilding), nullptr, nullptr, nullptr },
        { "military", reinterpret_cast<getter>(MapStyleSheetEntries_get_Military), nullptr, nullptr, nullptr },
        { "natural_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_NaturalPoint), nullptr, nullptr, nullptr },
        { "nautical", reinterpret_cast<getter>(MapStyleSheetEntries_get_Nautical), nullptr, nullptr, nullptr },
        { "neighborhood", reinterpret_cast<getter>(MapStyleSheetEntries_get_Neighborhood), nullptr, nullptr, nullptr },
        { "park", reinterpret_cast<getter>(MapStyleSheetEntries_get_Park), nullptr, nullptr, nullptr },
        { "peak", reinterpret_cast<getter>(MapStyleSheetEntries_get_Peak), nullptr, nullptr, nullptr },
        { "playing_field", reinterpret_cast<getter>(MapStyleSheetEntries_get_PlayingField), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(MapStyleSheetEntries_get_Point), nullptr, nullptr, nullptr },
        { "point_of_interest", reinterpret_cast<getter>(MapStyleSheetEntries_get_PointOfInterest), nullptr, nullptr, nullptr },
        { "political", reinterpret_cast<getter>(MapStyleSheetEntries_get_Political), nullptr, nullptr, nullptr },
        { "populated_place", reinterpret_cast<getter>(MapStyleSheetEntries_get_PopulatedPlace), nullptr, nullptr, nullptr },
        { "railway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Railway), nullptr, nullptr, nullptr },
        { "ramp", reinterpret_cast<getter>(MapStyleSheetEntries_get_Ramp), nullptr, nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(MapStyleSheetEntries_get_Reserve), nullptr, nullptr, nullptr },
        { "river", reinterpret_cast<getter>(MapStyleSheetEntries_get_River), nullptr, nullptr, nullptr },
        { "road", reinterpret_cast<getter>(MapStyleSheetEntries_get_Road), nullptr, nullptr, nullptr },
        { "road_exit", reinterpret_cast<getter>(MapStyleSheetEntries_get_RoadExit), nullptr, nullptr, nullptr },
        { "road_shield", reinterpret_cast<getter>(MapStyleSheetEntries_get_RoadShield), nullptr, nullptr, nullptr },
        { "route_line", reinterpret_cast<getter>(MapStyleSheetEntries_get_RouteLine), nullptr, nullptr, nullptr },
        { "runway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Runway), nullptr, nullptr, nullptr },
        { "sand", reinterpret_cast<getter>(MapStyleSheetEntries_get_Sand), nullptr, nullptr, nullptr },
        { "shopping_center", reinterpret_cast<getter>(MapStyleSheetEntries_get_ShoppingCenter), nullptr, nullptr, nullptr },
        { "stadium", reinterpret_cast<getter>(MapStyleSheetEntries_get_Stadium), nullptr, nullptr, nullptr },
        { "street", reinterpret_cast<getter>(MapStyleSheetEntries_get_Street), nullptr, nullptr, nullptr },
        { "structure", reinterpret_cast<getter>(MapStyleSheetEntries_get_Structure), nullptr, nullptr, nullptr },
        { "toll_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_TollRoad), nullptr, nullptr, nullptr },
        { "trail", reinterpret_cast<getter>(MapStyleSheetEntries_get_Trail), nullptr, nullptr, nullptr },
        { "transit", reinterpret_cast<getter>(MapStyleSheetEntries_get_Transit), nullptr, nullptr, nullptr },
        { "transit_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_TransitBuilding), nullptr, nullptr, nullptr },
        { "transportation", reinterpret_cast<getter>(MapStyleSheetEntries_get_Transportation), nullptr, nullptr, nullptr },
        { "unpaved_street", reinterpret_cast<getter>(MapStyleSheetEntries_get_UnpavedStreet), nullptr, nullptr, nullptr },
        { "vegetation", reinterpret_cast<getter>(MapStyleSheetEntries_get_Vegetation), nullptr, nullptr, nullptr },
        { "volcanic_peak", reinterpret_cast<getter>(MapStyleSheetEntries_get_VolcanicPeak), nullptr, nullptr, nullptr },
        { "walking_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_WalkingRoute), nullptr, nullptr, nullptr },
        { "water", reinterpret_cast<getter>(MapStyleSheetEntries_get_Water), nullptr, nullptr, nullptr },
        { "water_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_WaterPoint), nullptr, nullptr, nullptr },
        { "water_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_WaterRoute), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapStyleSheetEntries_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapStyleSheetEntries_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapStyleSheetEntries_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapStyleSheetEntries_Static) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntries_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntries_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapStyleSheetEntries_Static
    };

    // ----- MapStyleSheetEntryStates class --------------------

    static PyObject* _new_MapStyleSheetEntryStates(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates>::type_name);
        return nullptr;
    }

    static PyObject* MapStyleSheetEntryStates_get_Disabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Disabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntryStates_get_Hover(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Hover"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Hover());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntryStates_get_Selected(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Selected"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheetEntryStates[] = {
        { }
    };

    static PyGetSetDef _getset_MapStyleSheetEntryStates[] = {
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheetEntryStates[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheetEntryStates) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheetEntryStates) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheetEntryStates) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntryStates = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntryStates",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheetEntryStates};

    static PyGetSetDef getset_MapStyleSheetEntryStates_Static[] = {
        { "disabled", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Disabled), nullptr, nullptr, nullptr },
        { "hover", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Hover), nullptr, nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Selected), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapStyleSheetEntryStates_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapStyleSheetEntryStates_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapStyleSheetEntryStates_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapStyleSheetEntryStates_Static) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntryStates_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntryStates_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapStyleSheetEntryStates_Static
    };

    // ----- MapTargetCameraChangedEventArgs class --------------------

    static PyObject* _new_MapTargetCameraChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTargetCameraChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTargetCameraChangedEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTargetCameraChangedEventArgs", L"Camera"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTargetCameraChangedEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTargetCameraChangedEventArgs", L"ChangeReason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTargetCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTargetCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTargetCameraChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTargetCameraChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTargetCameraChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTargetCameraChangedEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapTargetCameraChangedEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapTargetCameraChangedEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTargetCameraChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTargetCameraChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTargetCameraChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTargetCameraChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTargetCameraChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapTargetCameraChangedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTargetCameraChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTargetCameraChangedEventArgs};

    // ----- MapTileBitmapRequest class --------------------

    static PyObject* _new_MapTileBitmapRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequest(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequest_GetDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequest_get_PixelData(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"PixelData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PixelData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileBitmapRequest_put_PixelData(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"PixelData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.PixelData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MapTileBitmapRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileBitmapRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequest[] = {
        { "pixel_data", reinterpret_cast<getter>(MapTileBitmapRequest_get_PixelData), reinterpret_cast<setter>(MapTileBitmapRequest_put_PixelData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequest) },
        { }
    };

    static PyType_Spec type_spec_MapTileBitmapRequest = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequest",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequest};

    // ----- MapTileBitmapRequestDeferral class --------------------

    static PyObject* _new_MapTileBitmapRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequestDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequestDeferral_Complete(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MapTileBitmapRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileBitmapRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_MapTileBitmapRequestDeferral = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequestDeferral",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequestDeferral};

    // ----- MapTileBitmapRequestedEventArgs class --------------------

    static PyObject* _new_MapTileBitmapRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"Request"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_X(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"X"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_Y(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"Y"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"ZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_FrameIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"FrameIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTileBitmapRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_Y), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "frame_index", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_FrameIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapTileBitmapRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequestedEventArgs};

    // ----- MapTileDataSource class --------------------

    static PyObject* _new_MapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileDataSource_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileDataSource_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileDataSource[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapTileDataSource_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapTileDataSource_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapTileDataSource_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapTileDataSource_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapTileDataSource_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapTileDataSource_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapTileDataSource_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileDataSource[] = {
        { "dispatcher", reinterpret_cast<getter>(MapTileDataSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileDataSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileDataSource) },
        { }
    };

    static PyType_Spec type_spec_MapTileDataSource = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileDataSource};

    // ----- MapTileSource class --------------------

    static PyObject* _new_MapTileSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 2);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileSource_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_Pause(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Pause", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_Play(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Play", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Play();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_Stop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Stop", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_ZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRange"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(arg);

            self->obj.ZoomLevelRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_TilePixelSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TilePixelSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_TilePixelSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TilePixelSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Layer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Layer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Layer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Layer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Layer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileLayer>(arg);

            self->obj.Layer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsTransparencyEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTransparencyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsTransparencyEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransparencyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsRetryEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRetryEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsRetryEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRetryEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsFadingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFadingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsFadingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFadingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_DataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_DataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(arg);

            self->obj.DataSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Bounds(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Bounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Bounds(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Bounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AllowOverstretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowOverstretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_AllowOverstretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowOverstretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_FrameDuration(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_FrameDuration(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.FrameDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_FrameCount(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_FrameCount(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FrameCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AutoPlay(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutoPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_AutoPlay(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoPlay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AnimationState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AnimationState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AnimationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AllowOverstretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretchProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AllowOverstretchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_BoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"BoundsProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::BoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_DataSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSourceProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::DataSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsFadingEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsFadingEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsRetryEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsRetryEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsTransparencyEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabledProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsTransparencyEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_LayerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"LayerProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::LayerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_TilePixelSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSizeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::TilePixelSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"VisibleProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndexProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZoomLevelRangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRangeProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::ZoomLevelRangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AnimationStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AnimationStateProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AnimationStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AutoPlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlayProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AutoPlayProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_FrameCountProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCountProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::FrameCountProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_FrameDurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDurationProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::FrameDurationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileSource[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(MapTileSource_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(MapTileSource_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(MapTileSource_GetValue), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(MapTileSource_Pause), METH_VARARGS, nullptr },
        { "play", reinterpret_cast<PyCFunction>(MapTileSource_Play), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(MapTileSource_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(MapTileSource_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(MapTileSource_SetValue), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MapTileSource_Stop), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(MapTileSource_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileSource[] = {
        { "zoom_level_range", reinterpret_cast<getter>(MapTileSource_get_ZoomLevelRange), reinterpret_cast<setter>(MapTileSource_put_ZoomLevelRange), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapTileSource_get_ZIndex), reinterpret_cast<setter>(MapTileSource_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapTileSource_get_Visible), reinterpret_cast<setter>(MapTileSource_put_Visible), nullptr, nullptr },
        { "tile_pixel_size", reinterpret_cast<getter>(MapTileSource_get_TilePixelSize), reinterpret_cast<setter>(MapTileSource_put_TilePixelSize), nullptr, nullptr },
        { "layer", reinterpret_cast<getter>(MapTileSource_get_Layer), reinterpret_cast<setter>(MapTileSource_put_Layer), nullptr, nullptr },
        { "is_transparency_enabled", reinterpret_cast<getter>(MapTileSource_get_IsTransparencyEnabled), reinterpret_cast<setter>(MapTileSource_put_IsTransparencyEnabled), nullptr, nullptr },
        { "is_retry_enabled", reinterpret_cast<getter>(MapTileSource_get_IsRetryEnabled), reinterpret_cast<setter>(MapTileSource_put_IsRetryEnabled), nullptr, nullptr },
        { "is_fading_enabled", reinterpret_cast<getter>(MapTileSource_get_IsFadingEnabled), reinterpret_cast<setter>(MapTileSource_put_IsFadingEnabled), nullptr, nullptr },
        { "data_source", reinterpret_cast<getter>(MapTileSource_get_DataSource), reinterpret_cast<setter>(MapTileSource_put_DataSource), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(MapTileSource_get_Bounds), reinterpret_cast<setter>(MapTileSource_put_Bounds), nullptr, nullptr },
        { "allow_overstretch", reinterpret_cast<getter>(MapTileSource_get_AllowOverstretch), reinterpret_cast<setter>(MapTileSource_put_AllowOverstretch), nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(MapTileSource_get_FrameDuration), reinterpret_cast<setter>(MapTileSource_put_FrameDuration), nullptr, nullptr },
        { "frame_count", reinterpret_cast<getter>(MapTileSource_get_FrameCount), reinterpret_cast<setter>(MapTileSource_put_FrameCount), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(MapTileSource_get_AutoPlay), reinterpret_cast<setter>(MapTileSource_put_AutoPlay), nullptr, nullptr },
        { "animation_state", reinterpret_cast<getter>(MapTileSource_get_AnimationState), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(MapTileSource_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileSource) },
        { }
    };

    static PyType_Spec type_spec_MapTileSource = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileSource};

    static PyGetSetDef getset_MapTileSource_Static[] = {
        { "allow_overstretch_property", reinterpret_cast<getter>(MapTileSource_get_AllowOverstretchProperty), nullptr, nullptr, nullptr },
        { "bounds_property", reinterpret_cast<getter>(MapTileSource_get_BoundsProperty), nullptr, nullptr, nullptr },
        { "data_source_property", reinterpret_cast<getter>(MapTileSource_get_DataSourceProperty), nullptr, nullptr, nullptr },
        { "is_fading_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsFadingEnabledProperty), nullptr, nullptr, nullptr },
        { "is_retry_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsRetryEnabledProperty), nullptr, nullptr, nullptr },
        { "is_transparency_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsTransparencyEnabledProperty), nullptr, nullptr, nullptr },
        { "layer_property", reinterpret_cast<getter>(MapTileSource_get_LayerProperty), nullptr, nullptr, nullptr },
        { "tile_pixel_size_property", reinterpret_cast<getter>(MapTileSource_get_TilePixelSizeProperty), nullptr, nullptr, nullptr },
        { "visible_property", reinterpret_cast<getter>(MapTileSource_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapTileSource_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { "zoom_level_range_property", reinterpret_cast<getter>(MapTileSource_get_ZoomLevelRangeProperty), nullptr, nullptr, nullptr },
        { "animation_state_property", reinterpret_cast<getter>(MapTileSource_get_AnimationStateProperty), nullptr, nullptr, nullptr },
        { "auto_play_property", reinterpret_cast<getter>(MapTileSource_get_AutoPlayProperty), nullptr, nullptr, nullptr },
        { "frame_count_property", reinterpret_cast<getter>(MapTileSource_get_FrameCountProperty), nullptr, nullptr, nullptr },
        { "frame_duration_property", reinterpret_cast<getter>(MapTileSource_get_FrameDurationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MapTileSource_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MapTileSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapTileSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MapTileSource_Static) },
        { }
    };

    static PyType_Spec type_spec_MapTileSource_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapTileSource_Static
    };

    // ----- MapTileUriRequest class --------------------

    static PyObject* _new_MapTileUriRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequest(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequest_GetDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequest_get_Uri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileUriRequest_put_Uri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"Uri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MapTileUriRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MapTileUriRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileUriRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequest[] = {
        { "uri", reinterpret_cast<getter>(MapTileUriRequest_get_Uri), reinterpret_cast<setter>(MapTileUriRequest_put_Uri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequest) },
        { }
    };

    static PyType_Spec type_spec_MapTileUriRequest = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileUriRequest",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequest};

    // ----- MapTileUriRequestDeferral class --------------------

    static PyObject* _new_MapTileUriRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequestDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequestDeferral_Complete(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileUriRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MapTileUriRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileUriRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_MapTileUriRequestDeferral = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileUriRequestDeferral",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequestDeferral};

    // ----- MapTileUriRequestedEventArgs class --------------------

    static PyObject* _new_MapTileUriRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"Request"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_X(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"X"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_Y(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"Y"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"ZoomLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_FrameIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"FrameIndex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileUriRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTileUriRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_Y), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "frame_index", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_FrameIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MapTileUriRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapTileUriRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequestedEventArgs};

    // ----- StreetsideExperience class --------------------

    static PyObject* _new_StreetsideExperience(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreetsideExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreetsideExperience_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsideExperience_get_ZoomButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ZoomButtonsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ZoomButtonsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_ZoomButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ZoomButtonsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ZoomButtonsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_StreetLabelsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"StreetLabelsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreetLabelsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_StreetLabelsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"StreetLabelsVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StreetLabelsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_OverviewMapVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"OverviewMapVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OverviewMapVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_OverviewMapVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"OverviewMapVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.OverviewMapVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_ExitButtonVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ExitButtonVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExitButtonVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_ExitButtonVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ExitButtonVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExitButtonVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_CursorVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"CursorVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CursorVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_CursorVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"CursorVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CursorVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_AddressTextVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"AddressTextVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddressTextVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_AddressTextVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"AddressTextVisible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AddressTextVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreetsideExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreetsideExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreetsideExperience[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(StreetsideExperience_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(StreetsideExperience_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(StreetsideExperience_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(StreetsideExperience_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(StreetsideExperience_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(StreetsideExperience_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(StreetsideExperience_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreetsideExperience, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreetsideExperience), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreetsideExperience[] = {
        { "zoom_buttons_visible", reinterpret_cast<getter>(StreetsideExperience_get_ZoomButtonsVisible), reinterpret_cast<setter>(StreetsideExperience_put_ZoomButtonsVisible), nullptr, nullptr },
        { "street_labels_visible", reinterpret_cast<getter>(StreetsideExperience_get_StreetLabelsVisible), reinterpret_cast<setter>(StreetsideExperience_put_StreetLabelsVisible), nullptr, nullptr },
        { "overview_map_visible", reinterpret_cast<getter>(StreetsideExperience_get_OverviewMapVisible), reinterpret_cast<setter>(StreetsideExperience_put_OverviewMapVisible), nullptr, nullptr },
        { "exit_button_visible", reinterpret_cast<getter>(StreetsideExperience_get_ExitButtonVisible), reinterpret_cast<setter>(StreetsideExperience_put_ExitButtonVisible), nullptr, nullptr },
        { "cursor_visible", reinterpret_cast<getter>(StreetsideExperience_get_CursorVisible), reinterpret_cast<setter>(StreetsideExperience_put_CursorVisible), nullptr, nullptr },
        { "address_text_visible", reinterpret_cast<getter>(StreetsideExperience_get_AddressTextVisible), reinterpret_cast<setter>(StreetsideExperience_put_AddressTextVisible), nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(StreetsideExperience_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreetsideExperience[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreetsideExperience) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreetsideExperience) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreetsideExperience) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreetsideExperience) },
        { }
    };

    static PyType_Spec type_spec_StreetsideExperience = {
        "winrt._winrt_windows_ui_xaml_controls_maps.StreetsideExperience",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreetsideExperience};

    // ----- StreetsidePanorama class --------------------

    static PyObject* _new_StreetsidePanorama(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>::type_name);
        return nullptr;
    }

    static void _dealloc_StreetsidePanorama(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreetsidePanorama_ClearValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ClearValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                self->obj.ClearValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_FindNearbyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"FindNearbyAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama::FindNearbyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"FindNearbyAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama::FindNearbyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_GetAnimationBaseValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetAnimationBaseValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetAnimationBaseValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_GetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"GetValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.GetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_ReadLocalValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"ReadLocalValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);

                return py::convert(self->obj.ReadLocalValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_RegisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"RegisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::DependencyPropertyChangedCallback>(args, 1);

                return py::convert(self->obj.RegisterPropertyChangedCallback(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_SetValue(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"SetValue", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetValue(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_UnregisterPropertyChangedCallback(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.DependencyObject", L"UnregisterPropertyChangedCallback", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyProperty>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.UnregisterPropertyChangedCallback(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_get_Dispatcher(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.DependencyObject", L"Dispatcher"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Dispatcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreetsidePanorama(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreetsidePanorama(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreetsidePanorama[] = {
        { "clear_value", reinterpret_cast<PyCFunction>(StreetsidePanorama_ClearValue), METH_VARARGS, nullptr },
        { "get_animation_base_value", reinterpret_cast<PyCFunction>(StreetsidePanorama_GetAnimationBaseValue), METH_VARARGS, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(StreetsidePanorama_GetValue), METH_VARARGS, nullptr },
        { "read_local_value", reinterpret_cast<PyCFunction>(StreetsidePanorama_ReadLocalValue), METH_VARARGS, nullptr },
        { "register_property_changed_callback", reinterpret_cast<PyCFunction>(StreetsidePanorama_RegisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(StreetsidePanorama_SetValue), METH_VARARGS, nullptr },
        { "unregister_property_changed_callback", reinterpret_cast<PyCFunction>(StreetsidePanorama_UnregisterPropertyChangedCallback), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StreetsidePanorama, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreetsidePanorama), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreetsidePanorama[] = {
        { "location", reinterpret_cast<getter>(StreetsidePanorama_get_Location), nullptr, nullptr, nullptr },
        { "dispatcher", reinterpret_cast<getter>(StreetsidePanorama_get_Dispatcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreetsidePanorama[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreetsidePanorama) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreetsidePanorama) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreetsidePanorama) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreetsidePanorama) },
        { }
    };

    static PyType_Spec type_spec_StreetsidePanorama = {
        "winrt._winrt_windows_ui_xaml_controls_maps.StreetsidePanorama",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreetsidePanorama};

    static PyGetSetDef getset_StreetsidePanorama_Static[] = {
        { }
    };

    static PyMethodDef methods_StreetsidePanorama_Static[] = {
        { "find_nearby_async", reinterpret_cast<PyCFunction>(StreetsidePanorama_FindNearbyAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StreetsidePanorama_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StreetsidePanorama_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StreetsidePanorama_Static) },
        { }
    };

    static PyType_Spec type_spec_StreetsidePanorama_Static =
    {
        "winrt._winrt_windows_ui_xaml_controls_maps.StreetsidePanorama_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StreetsidePanorama_Static
    };

    // ----- MapZoomLevelRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>* _new_MapZoomLevelRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_MapZoomLevelRange(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _Min{};
        double _Max{};

        static const char* kwlist[] = {"min", "max", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dd", const_cast<char**>(kwlist), &_Min, &_Max))
        {
            return -1;
        }

        try
        {
            self->obj.Min = _Min;
            self->obj.Max = _Max;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_MapZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapZoomLevelRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_MapZoomLevelRange[] = {
        { "_assign_array_", _assign_array_MapZoomLevelRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* MapZoomLevelRange_get_Min(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapZoomLevelRange_set_Min(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapZoomLevelRange_get_Max(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapZoomLevelRange_set_Max(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MapZoomLevelRange[] = {
        { "min", reinterpret_cast<getter>(MapZoomLevelRange_get_Min), reinterpret_cast<setter>(MapZoomLevelRange_set_Min), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(MapZoomLevelRange_get_Max), reinterpret_cast<setter>(MapZoomLevelRange_set_Max), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_MapZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_MapZoomLevelRange(PyObject* self) noexcept
    {
        py::pyobj_handle Min{PyObject_GetAttrString(self, "min")};
        if (!Min)
        {
            return nullptr;
        }

        py::pyobj_handle Max{PyObject_GetAttrString(self, "max")};
        if (!Max)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("MapZoomLevelRange(min=%R, max=%R)", Min.get(), Max.get());
    }

    static PyType_Slot _type_slots_MapZoomLevelRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapZoomLevelRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_MapZoomLevelRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapZoomLevelRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapZoomLevelRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapZoomLevelRange) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_MapZoomLevelRange) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_MapZoomLevelRange) },
        { }
    };

    static PyType_Spec type_spec_MapZoomLevelRange = {
        "winrt._winrt_windows_ui_xaml_controls_maps.MapZoomLevelRange",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapZoomLevelRange};

    // ----- Windows.UI.Xaml.Controls.Maps Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Controls.Maps");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_controls_maps",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Controls::Maps

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_maps(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls::Maps;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CustomMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LocalMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapActualCameraChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapActualCameraChangingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapBillboard_Static{PyType_FromSpec(&type_spec_MapBillboard_Static)};
    if (!type_MapBillboard_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapBillboard, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapBillboard_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCamera, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapContextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapControl_Static{PyType_FromSpec(&type_spec_MapControl_Static)};
    if (!type_MapControl_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControl, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapControl_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapControlDataHelper_Static{PyType_FromSpec(&type_spec_MapControlDataHelper_Static)};
    if (!type_MapControlDataHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlDataHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapControlDataHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeatureClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeaturePointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeaturePointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeatureRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCustomExperience, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCustomExperienceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElement_Static{PyType_FromSpec(&type_spec_MapElement_Static)};
    if (!type_MapElement_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElement_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElement3D_Static{PyType_FromSpec(&type_spec_MapElement3D_Static)};
    if (!type_MapElement3D_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElement3D, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElement3D_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElementsLayer_Static{PyType_FromSpec(&type_spec_MapElementsLayer_Static)};
    if (!type_MapElementsLayer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElementsLayer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerContextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapIcon_Static{PyType_FromSpec(&type_spec_MapIcon_Static)};
    if (!type_MapIcon_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapIcon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapIcon_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapInputEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapItemsControl_Static{PyType_FromSpec(&type_spec_MapItemsControl_Static)};
    if (!type_MapItemsControl_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapItemsControl, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapItemsControl_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapLayer_Static{PyType_FromSpec(&type_spec_MapLayer_Static)};
    if (!type_MapLayer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapLayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapLayer_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapModel3D_Static{PyType_FromSpec(&type_spec_MapModel3D_Static)};
    if (!type_MapModel3D_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapModel3D, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapModel3D_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapPolygon_Static{PyType_FromSpec(&type_spec_MapPolygon_Static)};
    if (!type_MapPolygon_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapPolygon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapPolygon_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapPolyline_Static{PyType_FromSpec(&type_spec_MapPolyline_Static)};
    if (!type_MapPolyline_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapPolyline, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapPolyline_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapRouteView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapScene_Static{PyType_FromSpec(&type_spec_MapScene_Static)};
    if (!type_MapScene_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapScene, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapScene_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapStyleSheet_Static{PyType_FromSpec(&type_spec_MapStyleSheet_Static)};
    if (!type_MapStyleSheet_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheet, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapStyleSheet_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapStyleSheetEntries_Static{PyType_FromSpec(&type_spec_MapStyleSheetEntries_Static)};
    if (!type_MapStyleSheetEntries_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheetEntries, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapStyleSheetEntries_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapStyleSheetEntryStates_Static{PyType_FromSpec(&type_spec_MapStyleSheetEntryStates_Static)};
    if (!type_MapStyleSheetEntryStates_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheetEntryStates, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapStyleSheetEntryStates_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTargetCameraChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapTileSource_Static{PyType_FromSpec(&type_spec_MapTileSource_Static)};
    if (!type_MapTileSource_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapTileSource_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StreetsideExperience, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StreetsidePanorama_Static{PyType_FromSpec(&type_spec_StreetsidePanorama_Static)};
    if (!type_StreetsidePanorama_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StreetsidePanorama, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StreetsidePanorama_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapZoomLevelRange, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
