// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Xaml.Controls.Maps.h"


namespace py::cpp::Windows::UI::Xaml::Controls::Maps
{
    // ----- CustomMapTileDataSource class --------------------

    static PyObject* _new_CustomMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CustomMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CustomMapTileDataSource_add_BitmapRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.CustomMapTileDataSource", L"BitmapRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>>(arg);

            return py::convert(self->obj.BitmapRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CustomMapTileDataSource_remove_BitmapRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.CustomMapTileDataSource", L"BitmapRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BitmapRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CustomMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CustomMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CustomMapTileDataSource[] = {
        { "add_bitmap_requested", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_add_BitmapRequested), METH_O, nullptr },
        { "remove_bitmap_requested", reinterpret_cast<PyCFunction>(CustomMapTileDataSource_remove_BitmapRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CustomMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CustomMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CustomMapTileDataSource[] = {
        { }
    };

    static PyType_Slot _type_slots_CustomMapTileDataSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CustomMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CustomMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CustomMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CustomMapTileDataSource) },
        { },
    };

    static PyType_Spec type_spec_CustomMapTileDataSource =
    {
        "_winrt_windows_ui_xaml_controls_maps.CustomMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::CustomMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CustomMapTileDataSource
    };

    // ----- HttpMapTileDataSource class --------------------

    static PyObject* _new_HttpMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HttpMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpMapTileDataSource_get_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriFormatString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UriFormatString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMapTileDataSource_put_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriFormatString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UriFormatString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMapTileDataSource_get_AllowCaching(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AllowCaching"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowCaching());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HttpMapTileDataSource_put_AllowCaching(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AllowCaching"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCaching(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HttpMapTileDataSource_get_AdditionalRequestHeaders(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"AdditionalRequestHeaders"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalRequestHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_add_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>(arg);

            return py::convert(self->obj.UriRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpMapTileDataSource_remove_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.HttpMapTileDataSource", L"UriRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UriRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpMapTileDataSource[] = {
        { "add_uri_requested", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_add_UriRequested), METH_O, nullptr },
        { "remove_uri_requested", reinterpret_cast<PyCFunction>(HttpMapTileDataSource_remove_UriRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_HttpMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpMapTileDataSource[] = {
        { "uri_format_string", reinterpret_cast<getter>(HttpMapTileDataSource_get_UriFormatString), reinterpret_cast<setter>(HttpMapTileDataSource_put_UriFormatString), nullptr, nullptr },
        { "allow_caching", reinterpret_cast<getter>(HttpMapTileDataSource_get_AllowCaching), reinterpret_cast<setter>(HttpMapTileDataSource_put_AllowCaching), nullptr, nullptr },
        { "additional_request_headers", reinterpret_cast<getter>(HttpMapTileDataSource_get_AdditionalRequestHeaders), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpMapTileDataSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpMapTileDataSource) },
        { },
    };

    static PyType_Spec type_spec_HttpMapTileDataSource =
    {
        "_winrt_windows_ui_xaml_controls_maps.HttpMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::HttpMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpMapTileDataSource
    };

    // ----- LocalMapTileDataSource class --------------------

    static PyObject* _new_LocalMapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LocalMapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LocalMapTileDataSource_get_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriFormatString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UriFormatString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LocalMapTileDataSource_put_UriFormatString(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriFormatString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UriFormatString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LocalMapTileDataSource_add_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource, winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>(arg);

            return py::convert(self->obj.UriRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LocalMapTileDataSource_remove_UriRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.LocalMapTileDataSource", L"UriRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UriRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LocalMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LocalMapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LocalMapTileDataSource[] = {
        { "add_uri_requested", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_add_UriRequested), METH_O, nullptr },
        { "remove_uri_requested", reinterpret_cast<PyCFunction>(LocalMapTileDataSource_remove_UriRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_LocalMapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LocalMapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LocalMapTileDataSource[] = {
        { "uri_format_string", reinterpret_cast<getter>(LocalMapTileDataSource_get_UriFormatString), reinterpret_cast<setter>(LocalMapTileDataSource_put_UriFormatString), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LocalMapTileDataSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LocalMapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LocalMapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LocalMapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LocalMapTileDataSource) },
        { },
    };

    static PyType_Spec type_spec_LocalMapTileDataSource =
    {
        "_winrt_windows_ui_xaml_controls_maps.LocalMapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::LocalMapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LocalMapTileDataSource
    };

    // ----- MapActualCameraChangedEventArgs class --------------------

    static PyObject* _new_MapActualCameraChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapActualCameraChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapActualCameraChangedEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangedEventArgs", L"Camera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapActualCameraChangedEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangedEventArgs", L"ChangeReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapActualCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapActualCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapActualCameraChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapActualCameraChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapActualCameraChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapActualCameraChangedEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapActualCameraChangedEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapActualCameraChangedEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapActualCameraChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapActualCameraChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapActualCameraChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapActualCameraChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapActualCameraChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapActualCameraChangedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapActualCameraChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapActualCameraChangedEventArgs
    };

    // ----- MapActualCameraChangingEventArgs class --------------------

    static PyObject* _new_MapActualCameraChangingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapActualCameraChangingEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapActualCameraChangingEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangingEventArgs", L"Camera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapActualCameraChangingEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapActualCameraChangingEventArgs", L"ChangeReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapActualCameraChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapActualCameraChangingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapActualCameraChangingEventArgs[] = {
        { "_assign_array_", _assign_array_MapActualCameraChangingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapActualCameraChangingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapActualCameraChangingEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapActualCameraChangingEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapActualCameraChangingEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapActualCameraChangingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapActualCameraChangingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapActualCameraChangingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapActualCameraChangingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapActualCameraChangingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapActualCameraChangingEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapActualCameraChangingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapActualCameraChangingEventArgs
    };

    // ----- MapBillboard class --------------------

    static PyObject* _new_MapBillboard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapBillboard(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapBillboard_get_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedAnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.NormalizedAnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Image(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollisionBehaviorDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapBillboard_put_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapElementCollisionBehavior>(arg);

            self->obj.CollisionBehaviorDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapBillboard_get_ReferenceCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"ReferenceCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReferenceCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_CollisionBehaviorDesiredProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"CollisionBehaviorDesiredProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::CollisionBehaviorDesiredProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"LocationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapBillboard_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapBillboard", L"NormalizedAnchorPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapBillboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapBillboard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapBillboard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapBillboard[] = {
        { "_assign_array_", _assign_array_MapBillboard, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapBillboard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapBillboard[] = {
        { "normalized_anchor_point", reinterpret_cast<getter>(MapBillboard_get_NormalizedAnchorPoint), reinterpret_cast<setter>(MapBillboard_put_NormalizedAnchorPoint), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapBillboard_get_Location), reinterpret_cast<setter>(MapBillboard_put_Location), nullptr, nullptr },
        { "image", reinterpret_cast<getter>(MapBillboard_get_Image), reinterpret_cast<setter>(MapBillboard_put_Image), nullptr, nullptr },
        { "collision_behavior_desired", reinterpret_cast<getter>(MapBillboard_get_CollisionBehaviorDesired), reinterpret_cast<setter>(MapBillboard_put_CollisionBehaviorDesired), nullptr, nullptr },
        { "reference_camera", reinterpret_cast<getter>(MapBillboard_get_ReferenceCamera), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapBillboard[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapBillboard) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapBillboard) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapBillboard) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapBillboard) },
        { },
    };

    static PyType_Spec type_spec_MapBillboard =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapBillboard",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapBillboard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapBillboard
    };

    static PyGetSetDef getset_MapBillboard_Meta[] = {
        { "collision_behavior_desired_property", reinterpret_cast<getter>(MapBillboard_get_CollisionBehaviorDesiredProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapBillboard_get_LocationProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapBillboard_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapBillboard_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapBillboard_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapBillboard_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapBillboard_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapBillboard_Meta
    };

    // ----- MapCamera class --------------------

    static PyObject* _new_MapCamera(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);

                winrt::Windows::UI::Xaml::Controls::Maps::MapCamera instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapCamera_get_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Roll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Roll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Roll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Pitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Pitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapCamera_get_FieldOfView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"FieldOfView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FieldOfView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapCamera_put_FieldOfView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapCamera", L"FieldOfView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FieldOfView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MapCamera(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCamera(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCamera[] = {
        { "_assign_array_", _assign_array_MapCamera, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCamera), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCamera[] = {
        { "roll", reinterpret_cast<getter>(MapCamera_get_Roll), reinterpret_cast<setter>(MapCamera_put_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapCamera_get_Pitch), reinterpret_cast<setter>(MapCamera_put_Pitch), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapCamera_get_Location), reinterpret_cast<setter>(MapCamera_put_Location), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapCamera_get_Heading), reinterpret_cast<setter>(MapCamera_put_Heading), nullptr, nullptr },
        { "field_of_view", reinterpret_cast<getter>(MapCamera_get_FieldOfView), reinterpret_cast<setter>(MapCamera_put_FieldOfView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapCamera[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCamera) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCamera) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCamera) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCamera) },
        { },
    };

    static PyType_Spec type_spec_MapCamera =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapCamera",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCamera),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCamera
    };

    // ----- MapContextRequestedEventArgs class --------------------

    static PyObject* _new_MapContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapContextRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapContextRequestedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapContextRequestedEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapContextRequestedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapContextRequestedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapContextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapContextRequestedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapContextRequestedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapContextRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapContextRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapContextRequestedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapContextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapContextRequestedEventArgs
    };

    // ----- MapControl class --------------------

    static PyObject* _new_MapControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControl instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControl(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControl_FindMapElementsAtOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"FindMapElementsAtOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.FindMapElementsAtOffset(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"FindMapElementsAtOffset", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.FindMapElementsAtOffset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::GetLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetLocationFromOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocationFromOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Devices::Geolocation::Geopoint param1 { nullptr };

                self->obj.GetLocationFromOffset(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetLocationFromOffset", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                winrt::Windows::Devices::Geolocation::Geopoint param2 { nullptr };

                self->obj.GetLocationFromOffset(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetNormalizedAnchorPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetNormalizedAnchorPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::GetNormalizedAnchorPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetOffsetFromLocation(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetOffsetFromLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                winrt::Windows::Foundation::Point param1 {  };

                self->obj.GetOffsetFromLocation(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_GetVisibleRegion(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"GetVisibleRegion", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapVisibleRegionKind>(args, 0);

                return py::convert(self->obj.GetVisibleRegion(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_IsLocationInView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsLocationInView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                bool param1 {  };

                self->obj.IsLocationInView(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SetLocation", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SetLocation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_SetNormalizedAnchorPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SetNormalizedAnchorPoint", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SetNormalizedAnchorPoint(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousPan(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousPan", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.StartContinuousPan(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousRotate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousRotate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousRotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousTilt(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousTilt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousTilt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StartContinuousZoom(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StartContinuousZoom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.StartContinuousZoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousPan(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousPan", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopContinuousPan();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousRotate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousRotate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopContinuousRotate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousTilt(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousTilt", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopContinuousTilt();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_StopContinuousZoom(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StopContinuousZoom", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopContinuousZoom();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryGetLocationFromOffset(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryGetLocationFromOffset", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Devices::Geolocation::Geopoint param1 { nullptr };

                auto return_value = self->obj.TryGetLocationFromOffset(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryGetLocationFromOffset", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                winrt::Windows::Devices::Geolocation::Geopoint param2 { nullptr };

                auto return_value = self->obj.TryGetLocationFromOffset(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryPanAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryPanAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(self->obj.TryPanAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryPanToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryPanToAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(self->obj.TryPanToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryRotateAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryRotateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryRotateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryRotateToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryRotateToAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryRotateToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetSceneAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetSceneAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(args, 0);

                return py::convert(self->obj.TrySetSceneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetSceneAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 1);

                return py::convert(self->obj.TrySetSceneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetViewAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(self->obj.TrySetViewAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);

                return py::convert(self->obj.TrySetViewAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 3);

                return py::convert(self->obj.TrySetViewAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 4);

                return py::convert(self->obj.TrySetViewAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TrySetViewBoundsAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrySetViewBoundsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Xaml::Thickness>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapAnimationKind>(args, 2);

                return py::convert(self->obj.TrySetViewBoundsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryTiltAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryTiltAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryTiltAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryTiltToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryTiltToAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryTiltToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomInAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomInAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryZoomInAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomOutAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomOutAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryZoomOutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_TryZoomToAsync(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TryZoomToAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TryZoomToAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZoomLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_WatermarkMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WatermarkMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_WatermarkMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapWatermarkMode>(arg);

            self->obj.WatermarkMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransformOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransformOrigin(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.TransformOrigin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TrafficFlowVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrafficFlowVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TrafficFlowVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TrafficFlowVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Style(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Style"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(static_cast<winrt::Windows::UI::Xaml::Controls::Maps::IMapControl>(self->obj).Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Style(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Style"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapStyle>(arg);

            self->obj.Style(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_PedestrianFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PedestrianFeaturesVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_PedestrianFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.PedestrianFeaturesVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MapServiceToken(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapServiceToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MapServiceToken(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceToken"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapServiceToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Center(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Center(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_DesiredPitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredPitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_DesiredPitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DesiredPitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ColorScheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ColorScheme(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapColorScheme>(arg);

            self->obj.ColorScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_LandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LandmarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_LandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.LandmarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Children(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LoadingStatus(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LoadingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MaxZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MaxZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MinZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MinZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Pitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Routes(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Routes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Routes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TileSources(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TileSources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RotateInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotateInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_RotateInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.RotateInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ZoomInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ZoomInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.ZoomInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitFeaturesVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransitFeaturesVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransitFeaturesVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_TiltInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TiltInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TiltInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapInteractionMode>(arg);

            self->obj.TiltInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Scene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Scene"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scene());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Scene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Scene"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>(arg);

            self->obj.Scene(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BusinessLandmarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BusinessLandmarksVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.BusinessLandmarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_PanInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PanInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_PanInteractionMode(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapPanInteractionMode>(arg);

            self->obj.PanInteractionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperience"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomExperience());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_CustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperience"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>(arg);

            self->obj.CustomExperience(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ActualCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Is3DSupported(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Is3DSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Is3DSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsStreetsideSupported(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsStreetsideSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStreetsideSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TargetCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitFeaturesEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_TransitFeaturesEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TransitFeaturesEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BusinessLandmarksEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_BusinessLandmarksEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.BusinessLandmarksEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_ViewPadding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ViewPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_ViewPadding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPadding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Thickness>(arg);

            self->obj.ViewPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_StyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StyleSheet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_StyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>(arg);

            self->obj.StyleSheet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_MapProjection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_MapProjection(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapProjection>(arg);

            self->obj.MapProjection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Layers(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Layers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Layers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Layers(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Layers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>>(arg);

            self->obj.Layers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_Region(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapControl_put_Region(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Region"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapControl_get_CanTiltDown(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanTiltDown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltUp(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanTiltUp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomIn(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomIn"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanZoomIn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomOut(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomOut"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanZoomOut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomLevelProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ZoomLevelProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ChildrenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ColorSchemeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ColorSchemeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ColorSchemeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_DesiredPitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"DesiredPitchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::DesiredPitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_HeadingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::HeadingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LandmarksVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LandmarksVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LandmarksVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LoadingStatusProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LoadingStatusProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LocationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapElementsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapElementsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapServiceTokenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapServiceTokenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapServiceTokenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"NormalizedAnchorPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PedestrianFeaturesVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PedestrianFeaturesVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PedestrianFeaturesVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RoutesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RoutesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RoutesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_StyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::StyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TileSourcesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TileSourcesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TileSourcesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TrafficFlowVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TrafficFlowVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TrafficFlowVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransformOriginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransformOriginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_WatermarkModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"WatermarkModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::WatermarkModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::BusinessLandmarksVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_Is3DSupportedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"Is3DSupportedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::Is3DSupportedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_IsStreetsideSupportedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"IsStreetsideSupportedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::IsStreetsideSupportedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_PanInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PanInteractionModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::PanInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RotateInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RotateInteractionModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RotateInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_SceneProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"SceneProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::SceneProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TiltInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TiltInteractionModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TiltInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesVisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesVisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransitFeaturesVisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ZoomInteractionModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomInteractionModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ZoomInteractionModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_BusinessLandmarksEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"BusinessLandmarksEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::BusinessLandmarksEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_TransitFeaturesEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransitFeaturesEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::TransitFeaturesEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_MapProjectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapProjectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::MapProjectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_StyleSheetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"StyleSheetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::StyleSheetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_ViewPaddingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ViewPaddingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::ViewPaddingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_LayersProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LayersProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::LayersProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_RegionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"RegionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::RegionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltUpProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltUpProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanTiltUpProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomInProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomInProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanZoomInProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanZoomOutProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanZoomOutProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanZoomOutProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_get_CanTiltDownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CanTiltDownProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControl::CanTiltDownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_CenterChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CenterChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_CenterChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CenterChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CenterChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_HeadingChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HeadingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_HeadingChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"HeadingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_LoadingStatusChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoadingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_LoadingStatusChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"LoadingStatusChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoadingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapDoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapDoubleTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapDoubleTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapDoubleTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapDoubleTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapDoubleTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapHolding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapHolding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapHolding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapHolding(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapHolding"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapHolding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>(arg);

            return py::convert(self->obj.MapTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_PitchChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PitchChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_PitchChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"PitchChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PitchChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_TransformOriginChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TransformOriginChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_TransformOriginChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TransformOriginChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransformOriginChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ZoomLevelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ZoomLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ZoomLevelChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ZoomLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ZoomLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ActualCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.ActualCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ActualCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_ActualCameraChanging(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapActualCameraChangingEventArgs>>(arg);

            return py::convert(self->obj.ActualCameraChanging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_ActualCameraChanging(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"ActualCameraChanging"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActualCameraChanging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_CustomExperienceChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperienceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>>(arg);

            return py::convert(self->obj.CustomExperienceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_CustomExperienceChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"CustomExperienceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CustomExperienceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>>(arg);

            return py::convert(self->obj.MapElementClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapElementPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.TargetCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"TargetCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>>(arg);

            return py::convert(self->obj.MapRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_add_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.MapContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControl_remove_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControl", L"MapContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControl[] = {
        { "find_map_elements_at_offset", reinterpret_cast<PyCFunction>(MapControl_FindMapElementsAtOffset), METH_VARARGS, nullptr },
        { "get_location", reinterpret_cast<PyCFunction>(MapControl_GetLocation), METH_VARARGS | METH_STATIC, nullptr },
        { "get_location_from_offset", reinterpret_cast<PyCFunction>(MapControl_GetLocationFromOffset), METH_VARARGS, nullptr },
        { "get_normalized_anchor_point", reinterpret_cast<PyCFunction>(MapControl_GetNormalizedAnchorPoint), METH_VARARGS | METH_STATIC, nullptr },
        { "get_offset_from_location", reinterpret_cast<PyCFunction>(MapControl_GetOffsetFromLocation), METH_VARARGS, nullptr },
        { "get_visible_region", reinterpret_cast<PyCFunction>(MapControl_GetVisibleRegion), METH_VARARGS, nullptr },
        { "is_location_in_view", reinterpret_cast<PyCFunction>(MapControl_IsLocationInView), METH_VARARGS, nullptr },
        { "set_location", reinterpret_cast<PyCFunction>(MapControl_SetLocation), METH_VARARGS | METH_STATIC, nullptr },
        { "set_normalized_anchor_point", reinterpret_cast<PyCFunction>(MapControl_SetNormalizedAnchorPoint), METH_VARARGS | METH_STATIC, nullptr },
        { "start_continuous_pan", reinterpret_cast<PyCFunction>(MapControl_StartContinuousPan), METH_VARARGS, nullptr },
        { "start_continuous_rotate", reinterpret_cast<PyCFunction>(MapControl_StartContinuousRotate), METH_VARARGS, nullptr },
        { "start_continuous_tilt", reinterpret_cast<PyCFunction>(MapControl_StartContinuousTilt), METH_VARARGS, nullptr },
        { "start_continuous_zoom", reinterpret_cast<PyCFunction>(MapControl_StartContinuousZoom), METH_VARARGS, nullptr },
        { "stop_continuous_pan", reinterpret_cast<PyCFunction>(MapControl_StopContinuousPan), METH_VARARGS, nullptr },
        { "stop_continuous_rotate", reinterpret_cast<PyCFunction>(MapControl_StopContinuousRotate), METH_VARARGS, nullptr },
        { "stop_continuous_tilt", reinterpret_cast<PyCFunction>(MapControl_StopContinuousTilt), METH_VARARGS, nullptr },
        { "stop_continuous_zoom", reinterpret_cast<PyCFunction>(MapControl_StopContinuousZoom), METH_VARARGS, nullptr },
        { "try_get_location_from_offset", reinterpret_cast<PyCFunction>(MapControl_TryGetLocationFromOffset), METH_VARARGS, nullptr },
        { "try_pan_async", reinterpret_cast<PyCFunction>(MapControl_TryPanAsync), METH_VARARGS, nullptr },
        { "try_pan_to_async", reinterpret_cast<PyCFunction>(MapControl_TryPanToAsync), METH_VARARGS, nullptr },
        { "try_rotate_async", reinterpret_cast<PyCFunction>(MapControl_TryRotateAsync), METH_VARARGS, nullptr },
        { "try_rotate_to_async", reinterpret_cast<PyCFunction>(MapControl_TryRotateToAsync), METH_VARARGS, nullptr },
        { "try_set_scene_async", reinterpret_cast<PyCFunction>(MapControl_TrySetSceneAsync), METH_VARARGS, nullptr },
        { "try_set_view_async", reinterpret_cast<PyCFunction>(MapControl_TrySetViewAsync), METH_VARARGS, nullptr },
        { "try_set_view_bounds_async", reinterpret_cast<PyCFunction>(MapControl_TrySetViewBoundsAsync), METH_VARARGS, nullptr },
        { "try_tilt_async", reinterpret_cast<PyCFunction>(MapControl_TryTiltAsync), METH_VARARGS, nullptr },
        { "try_tilt_to_async", reinterpret_cast<PyCFunction>(MapControl_TryTiltToAsync), METH_VARARGS, nullptr },
        { "try_zoom_in_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomInAsync), METH_VARARGS, nullptr },
        { "try_zoom_out_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomOutAsync), METH_VARARGS, nullptr },
        { "try_zoom_to_async", reinterpret_cast<PyCFunction>(MapControl_TryZoomToAsync), METH_VARARGS, nullptr },
        { "add_center_changed", reinterpret_cast<PyCFunction>(MapControl_add_CenterChanged), METH_O, nullptr },
        { "remove_center_changed", reinterpret_cast<PyCFunction>(MapControl_remove_CenterChanged), METH_O, nullptr },
        { "add_heading_changed", reinterpret_cast<PyCFunction>(MapControl_add_HeadingChanged), METH_O, nullptr },
        { "remove_heading_changed", reinterpret_cast<PyCFunction>(MapControl_remove_HeadingChanged), METH_O, nullptr },
        { "add_loading_status_changed", reinterpret_cast<PyCFunction>(MapControl_add_LoadingStatusChanged), METH_O, nullptr },
        { "remove_loading_status_changed", reinterpret_cast<PyCFunction>(MapControl_remove_LoadingStatusChanged), METH_O, nullptr },
        { "add_map_double_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapDoubleTapped), METH_O, nullptr },
        { "remove_map_double_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapDoubleTapped), METH_O, nullptr },
        { "add_map_holding", reinterpret_cast<PyCFunction>(MapControl_add_MapHolding), METH_O, nullptr },
        { "remove_map_holding", reinterpret_cast<PyCFunction>(MapControl_remove_MapHolding), METH_O, nullptr },
        { "add_map_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapTapped), METH_O, nullptr },
        { "remove_map_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapTapped), METH_O, nullptr },
        { "add_pitch_changed", reinterpret_cast<PyCFunction>(MapControl_add_PitchChanged), METH_O, nullptr },
        { "remove_pitch_changed", reinterpret_cast<PyCFunction>(MapControl_remove_PitchChanged), METH_O, nullptr },
        { "add_transform_origin_changed", reinterpret_cast<PyCFunction>(MapControl_add_TransformOriginChanged), METH_O, nullptr },
        { "remove_transform_origin_changed", reinterpret_cast<PyCFunction>(MapControl_remove_TransformOriginChanged), METH_O, nullptr },
        { "add_zoom_level_changed", reinterpret_cast<PyCFunction>(MapControl_add_ZoomLevelChanged), METH_O, nullptr },
        { "remove_zoom_level_changed", reinterpret_cast<PyCFunction>(MapControl_remove_ZoomLevelChanged), METH_O, nullptr },
        { "add_actual_camera_changed", reinterpret_cast<PyCFunction>(MapControl_add_ActualCameraChanged), METH_O, nullptr },
        { "remove_actual_camera_changed", reinterpret_cast<PyCFunction>(MapControl_remove_ActualCameraChanged), METH_O, nullptr },
        { "add_actual_camera_changing", reinterpret_cast<PyCFunction>(MapControl_add_ActualCameraChanging), METH_O, nullptr },
        { "remove_actual_camera_changing", reinterpret_cast<PyCFunction>(MapControl_remove_ActualCameraChanging), METH_O, nullptr },
        { "add_custom_experience_changed", reinterpret_cast<PyCFunction>(MapControl_add_CustomExperienceChanged), METH_O, nullptr },
        { "remove_custom_experience_changed", reinterpret_cast<PyCFunction>(MapControl_remove_CustomExperienceChanged), METH_O, nullptr },
        { "add_map_element_click", reinterpret_cast<PyCFunction>(MapControl_add_MapElementClick), METH_O, nullptr },
        { "remove_map_element_click", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementClick), METH_O, nullptr },
        { "add_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_add_MapElementPointerEntered), METH_O, nullptr },
        { "remove_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementPointerEntered), METH_O, nullptr },
        { "add_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_add_MapElementPointerExited), METH_O, nullptr },
        { "remove_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapControl_remove_MapElementPointerExited), METH_O, nullptr },
        { "add_target_camera_changed", reinterpret_cast<PyCFunction>(MapControl_add_TargetCameraChanged), METH_O, nullptr },
        { "remove_target_camera_changed", reinterpret_cast<PyCFunction>(MapControl_remove_TargetCameraChanged), METH_O, nullptr },
        { "add_map_right_tapped", reinterpret_cast<PyCFunction>(MapControl_add_MapRightTapped), METH_O, nullptr },
        { "remove_map_right_tapped", reinterpret_cast<PyCFunction>(MapControl_remove_MapRightTapped), METH_O, nullptr },
        { "add_map_context_requested", reinterpret_cast<PyCFunction>(MapControl_add_MapContextRequested), METH_O, nullptr },
        { "remove_map_context_requested", reinterpret_cast<PyCFunction>(MapControl_remove_MapContextRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControl[] = {
        { "zoom_level", reinterpret_cast<getter>(MapControl_get_ZoomLevel), reinterpret_cast<setter>(MapControl_put_ZoomLevel), nullptr, nullptr },
        { "watermark_mode", reinterpret_cast<getter>(MapControl_get_WatermarkMode), reinterpret_cast<setter>(MapControl_put_WatermarkMode), nullptr, nullptr },
        { "transform_origin", reinterpret_cast<getter>(MapControl_get_TransformOrigin), reinterpret_cast<setter>(MapControl_put_TransformOrigin), nullptr, nullptr },
        { "traffic_flow_visible", reinterpret_cast<getter>(MapControl_get_TrafficFlowVisible), reinterpret_cast<setter>(MapControl_put_TrafficFlowVisible), nullptr, nullptr },
        { "style", reinterpret_cast<getter>(MapControl_get_Style), reinterpret_cast<setter>(MapControl_put_Style), nullptr, nullptr },
        { "pedestrian_features_visible", reinterpret_cast<getter>(MapControl_get_PedestrianFeaturesVisible), reinterpret_cast<setter>(MapControl_put_PedestrianFeaturesVisible), nullptr, nullptr },
        { "map_service_token", reinterpret_cast<getter>(MapControl_get_MapServiceToken), reinterpret_cast<setter>(MapControl_put_MapServiceToken), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(MapControl_get_Center), reinterpret_cast<setter>(MapControl_put_Center), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapControl_get_Heading), reinterpret_cast<setter>(MapControl_put_Heading), nullptr, nullptr },
        { "desired_pitch", reinterpret_cast<getter>(MapControl_get_DesiredPitch), reinterpret_cast<setter>(MapControl_put_DesiredPitch), nullptr, nullptr },
        { "color_scheme", reinterpret_cast<getter>(MapControl_get_ColorScheme), reinterpret_cast<setter>(MapControl_put_ColorScheme), nullptr, nullptr },
        { "landmarks_visible", reinterpret_cast<getter>(MapControl_get_LandmarksVisible), reinterpret_cast<setter>(MapControl_put_LandmarksVisible), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(MapControl_get_Children), nullptr, nullptr, nullptr },
        { "loading_status", reinterpret_cast<getter>(MapControl_get_LoadingStatus), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapControl_get_MapElements), nullptr, nullptr, nullptr },
        { "max_zoom_level", reinterpret_cast<getter>(MapControl_get_MaxZoomLevel), nullptr, nullptr, nullptr },
        { "min_zoom_level", reinterpret_cast<getter>(MapControl_get_MinZoomLevel), nullptr, nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapControl_get_Pitch), nullptr, nullptr, nullptr },
        { "routes", reinterpret_cast<getter>(MapControl_get_Routes), nullptr, nullptr, nullptr },
        { "tile_sources", reinterpret_cast<getter>(MapControl_get_TileSources), nullptr, nullptr, nullptr },
        { "rotate_interaction_mode", reinterpret_cast<getter>(MapControl_get_RotateInteractionMode), reinterpret_cast<setter>(MapControl_put_RotateInteractionMode), nullptr, nullptr },
        { "zoom_interaction_mode", reinterpret_cast<getter>(MapControl_get_ZoomInteractionMode), reinterpret_cast<setter>(MapControl_put_ZoomInteractionMode), nullptr, nullptr },
        { "transit_features_visible", reinterpret_cast<getter>(MapControl_get_TransitFeaturesVisible), reinterpret_cast<setter>(MapControl_put_TransitFeaturesVisible), nullptr, nullptr },
        { "tilt_interaction_mode", reinterpret_cast<getter>(MapControl_get_TiltInteractionMode), reinterpret_cast<setter>(MapControl_put_TiltInteractionMode), nullptr, nullptr },
        { "scene", reinterpret_cast<getter>(MapControl_get_Scene), reinterpret_cast<setter>(MapControl_put_Scene), nullptr, nullptr },
        { "business_landmarks_visible", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksVisible), reinterpret_cast<setter>(MapControl_put_BusinessLandmarksVisible), nullptr, nullptr },
        { "pan_interaction_mode", reinterpret_cast<getter>(MapControl_get_PanInteractionMode), reinterpret_cast<setter>(MapControl_put_PanInteractionMode), nullptr, nullptr },
        { "custom_experience", reinterpret_cast<getter>(MapControl_get_CustomExperience), reinterpret_cast<setter>(MapControl_put_CustomExperience), nullptr, nullptr },
        { "actual_camera", reinterpret_cast<getter>(MapControl_get_ActualCamera), nullptr, nullptr, nullptr },
        { "is3_d_supported", reinterpret_cast<getter>(MapControl_get_Is3DSupported), nullptr, nullptr, nullptr },
        { "is_streetside_supported", reinterpret_cast<getter>(MapControl_get_IsStreetsideSupported), nullptr, nullptr, nullptr },
        { "target_camera", reinterpret_cast<getter>(MapControl_get_TargetCamera), nullptr, nullptr, nullptr },
        { "transit_features_enabled", reinterpret_cast<getter>(MapControl_get_TransitFeaturesEnabled), reinterpret_cast<setter>(MapControl_put_TransitFeaturesEnabled), nullptr, nullptr },
        { "business_landmarks_enabled", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksEnabled), reinterpret_cast<setter>(MapControl_put_BusinessLandmarksEnabled), nullptr, nullptr },
        { "view_padding", reinterpret_cast<getter>(MapControl_get_ViewPadding), reinterpret_cast<setter>(MapControl_put_ViewPadding), nullptr, nullptr },
        { "style_sheet", reinterpret_cast<getter>(MapControl_get_StyleSheet), reinterpret_cast<setter>(MapControl_put_StyleSheet), nullptr, nullptr },
        { "map_projection", reinterpret_cast<getter>(MapControl_get_MapProjection), reinterpret_cast<setter>(MapControl_put_MapProjection), nullptr, nullptr },
        { "layers", reinterpret_cast<getter>(MapControl_get_Layers), reinterpret_cast<setter>(MapControl_put_Layers), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(MapControl_get_Region), reinterpret_cast<setter>(MapControl_put_Region), nullptr, nullptr },
        { "can_tilt_down", reinterpret_cast<getter>(MapControl_get_CanTiltDown), nullptr, nullptr, nullptr },
        { "can_tilt_up", reinterpret_cast<getter>(MapControl_get_CanTiltUp), nullptr, nullptr, nullptr },
        { "can_zoom_in", reinterpret_cast<getter>(MapControl_get_CanZoomIn), nullptr, nullptr, nullptr },
        { "can_zoom_out", reinterpret_cast<getter>(MapControl_get_CanZoomOut), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControl) },
        { },
    };

    static PyType_Spec type_spec_MapControl =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControl",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControl
    };

    static PyGetSetDef getset_MapControl_Meta[] = {
        { "center_property", reinterpret_cast<getter>(MapControl_get_CenterProperty), nullptr, nullptr, nullptr },
        { "zoom_level_property", reinterpret_cast<getter>(MapControl_get_ZoomLevelProperty), nullptr, nullptr, nullptr },
        { "children_property", reinterpret_cast<getter>(MapControl_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { "color_scheme_property", reinterpret_cast<getter>(MapControl_get_ColorSchemeProperty), nullptr, nullptr, nullptr },
        { "desired_pitch_property", reinterpret_cast<getter>(MapControl_get_DesiredPitchProperty), nullptr, nullptr, nullptr },
        { "heading_property", reinterpret_cast<getter>(MapControl_get_HeadingProperty), nullptr, nullptr, nullptr },
        { "landmarks_visible_property", reinterpret_cast<getter>(MapControl_get_LandmarksVisibleProperty), nullptr, nullptr, nullptr },
        { "loading_status_property", reinterpret_cast<getter>(MapControl_get_LoadingStatusProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapControl_get_LocationProperty), nullptr, nullptr, nullptr },
        { "map_elements_property", reinterpret_cast<getter>(MapControl_get_MapElementsProperty), nullptr, nullptr, nullptr },
        { "map_service_token_property", reinterpret_cast<getter>(MapControl_get_MapServiceTokenProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapControl_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { "pedestrian_features_visible_property", reinterpret_cast<getter>(MapControl_get_PedestrianFeaturesVisibleProperty), nullptr, nullptr, nullptr },
        { "pitch_property", reinterpret_cast<getter>(MapControl_get_PitchProperty), nullptr, nullptr, nullptr },
        { "routes_property", reinterpret_cast<getter>(MapControl_get_RoutesProperty), nullptr, nullptr, nullptr },
        { "style_property", reinterpret_cast<getter>(MapControl_get_StyleProperty), nullptr, nullptr, nullptr },
        { "tile_sources_property", reinterpret_cast<getter>(MapControl_get_TileSourcesProperty), nullptr, nullptr, nullptr },
        { "traffic_flow_visible_property", reinterpret_cast<getter>(MapControl_get_TrafficFlowVisibleProperty), nullptr, nullptr, nullptr },
        { "transform_origin_property", reinterpret_cast<getter>(MapControl_get_TransformOriginProperty), nullptr, nullptr, nullptr },
        { "watermark_mode_property", reinterpret_cast<getter>(MapControl_get_WatermarkModeProperty), nullptr, nullptr, nullptr },
        { "business_landmarks_visible_property", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksVisibleProperty), nullptr, nullptr, nullptr },
        { "is3_d_supported_property", reinterpret_cast<getter>(MapControl_get_Is3DSupportedProperty), nullptr, nullptr, nullptr },
        { "is_streetside_supported_property", reinterpret_cast<getter>(MapControl_get_IsStreetsideSupportedProperty), nullptr, nullptr, nullptr },
        { "pan_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_PanInteractionModeProperty), nullptr, nullptr, nullptr },
        { "rotate_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_RotateInteractionModeProperty), nullptr, nullptr, nullptr },
        { "scene_property", reinterpret_cast<getter>(MapControl_get_SceneProperty), nullptr, nullptr, nullptr },
        { "tilt_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_TiltInteractionModeProperty), nullptr, nullptr, nullptr },
        { "transit_features_visible_property", reinterpret_cast<getter>(MapControl_get_TransitFeaturesVisibleProperty), nullptr, nullptr, nullptr },
        { "zoom_interaction_mode_property", reinterpret_cast<getter>(MapControl_get_ZoomInteractionModeProperty), nullptr, nullptr, nullptr },
        { "business_landmarks_enabled_property", reinterpret_cast<getter>(MapControl_get_BusinessLandmarksEnabledProperty), nullptr, nullptr, nullptr },
        { "transit_features_enabled_property", reinterpret_cast<getter>(MapControl_get_TransitFeaturesEnabledProperty), nullptr, nullptr, nullptr },
        { "map_projection_property", reinterpret_cast<getter>(MapControl_get_MapProjectionProperty), nullptr, nullptr, nullptr },
        { "style_sheet_property", reinterpret_cast<getter>(MapControl_get_StyleSheetProperty), nullptr, nullptr, nullptr },
        { "view_padding_property", reinterpret_cast<getter>(MapControl_get_ViewPaddingProperty), nullptr, nullptr, nullptr },
        { "layers_property", reinterpret_cast<getter>(MapControl_get_LayersProperty), nullptr, nullptr, nullptr },
        { "region_property", reinterpret_cast<getter>(MapControl_get_RegionProperty), nullptr, nullptr, nullptr },
        { "can_tilt_up_property", reinterpret_cast<getter>(MapControl_get_CanTiltUpProperty), nullptr, nullptr, nullptr },
        { "can_zoom_in_property", reinterpret_cast<getter>(MapControl_get_CanZoomInProperty), nullptr, nullptr, nullptr },
        { "can_zoom_out_property", reinterpret_cast<getter>(MapControl_get_CanZoomOutProperty), nullptr, nullptr, nullptr },
        { "can_tilt_down_property", reinterpret_cast<getter>(MapControl_get_CanTiltDownProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapControl_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapControl_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapControl_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControl_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapControl_Meta
    };

    // ----- MapControlBusinessLandmarkClickEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkClickEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkClickEventArgs", L"LocalLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkClickEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkClickEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkClickEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkClickEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkClickEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkClickEventArgs
    };

    // ----- MapControlBusinessLandmarkPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkPointerEnteredEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerEnteredEventArgs", L"LocalLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkPointerEnteredEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkPointerEnteredEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkPointerEnteredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkPointerEnteredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkPointerEnteredEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkPointerEnteredEventArgs
    };

    // ----- MapControlBusinessLandmarkPointerExitedEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkPointerExitedEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkPointerExitedEventArgs", L"LocalLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkPointerExitedEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkPointerExitedEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkPointerExitedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkPointerExitedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkPointerExitedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkPointerExitedEventArgs
    };

    // ----- MapControlBusinessLandmarkRightTappedEventArgs class --------------------

    static PyObject* _new_MapControlBusinessLandmarkRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlBusinessLandmarkRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlBusinessLandmarkRightTappedEventArgs_get_LocalLocations(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlBusinessLandmarkRightTappedEventArgs", L"LocalLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlBusinessLandmarkRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlBusinessLandmarkRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlBusinessLandmarkRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlBusinessLandmarkRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlBusinessLandmarkRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlBusinessLandmarkRightTappedEventArgs[] = {
        { "local_locations", reinterpret_cast<getter>(MapControlBusinessLandmarkRightTappedEventArgs_get_LocalLocations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlBusinessLandmarkRightTappedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlBusinessLandmarkRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlBusinessLandmarkRightTappedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlBusinessLandmarkRightTappedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlBusinessLandmarkRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlBusinessLandmarkRightTappedEventArgs
    };

    // ----- MapControlDataHelper class --------------------

    static PyObject* _new_MapControlDataHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapControl>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlDataHelper(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlDataHelper_CreateMapControl(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"CreateMapControl", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper::CreateMapControl(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkClickEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkRightTappedEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeatureClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>>(arg);

            return py::convert(self->obj.TransitFeatureClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeatureClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeatureClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeatureRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>>(arg);

            return py::convert(self->obj.TransitFeatureRightTapped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeatureRightTapped(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeatureRightTapped"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeatureRightTapped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_BusinessLandmarkPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlBusinessLandmarkPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.BusinessLandmarkPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_BusinessLandmarkPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"BusinessLandmarkPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BusinessLandmarkPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeaturePointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.TransitFeaturePointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeaturePointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeaturePointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_add_TransitFeaturePointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapControl, winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>>(arg);

            return py::convert(self->obj.TransitFeaturePointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlDataHelper_remove_TransitFeaturePointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlDataHelper", L"TransitFeaturePointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransitFeaturePointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlDataHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlDataHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlDataHelper[] = {
        { "create_map_control", reinterpret_cast<PyCFunction>(MapControlDataHelper_CreateMapControl), METH_VARARGS | METH_STATIC, nullptr },
        { "add_business_landmark_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkClick), METH_O, nullptr },
        { "remove_business_landmark_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkClick), METH_O, nullptr },
        { "add_business_landmark_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkRightTapped), METH_O, nullptr },
        { "remove_business_landmark_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkRightTapped), METH_O, nullptr },
        { "add_transit_feature_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeatureClick), METH_O, nullptr },
        { "remove_transit_feature_click", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeatureClick), METH_O, nullptr },
        { "add_transit_feature_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeatureRightTapped), METH_O, nullptr },
        { "remove_transit_feature_right_tapped", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeatureRightTapped), METH_O, nullptr },
        { "add_business_landmark_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkPointerEntered), METH_O, nullptr },
        { "remove_business_landmark_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkPointerEntered), METH_O, nullptr },
        { "add_business_landmark_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_BusinessLandmarkPointerExited), METH_O, nullptr },
        { "remove_business_landmark_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_BusinessLandmarkPointerExited), METH_O, nullptr },
        { "add_transit_feature_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeaturePointerEntered), METH_O, nullptr },
        { "remove_transit_feature_pointer_entered", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeaturePointerEntered), METH_O, nullptr },
        { "add_transit_feature_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_add_TransitFeaturePointerExited), METH_O, nullptr },
        { "remove_transit_feature_pointer_exited", reinterpret_cast<PyCFunction>(MapControlDataHelper_remove_TransitFeaturePointerExited), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapControlDataHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlDataHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlDataHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_MapControlDataHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlDataHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlDataHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlDataHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlDataHelper) },
        { },
    };

    static PyType_Spec type_spec_MapControlDataHelper =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlDataHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlDataHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlDataHelper
    };

    // ----- MapControlTransitFeatureClickEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeatureClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeatureClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureClickEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureClickEventArgs", L"TransitProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeatureClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeatureClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeatureClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeatureClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeatureClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeatureClickEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeatureClickEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeatureClickEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeatureClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeatureClickEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlTransitFeatureClickEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlTransitFeatureClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeatureClickEventArgs
    };

    // ----- MapControlTransitFeaturePointerEnteredEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeaturePointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeaturePointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerEnteredEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerEnteredEventArgs", L"TransitProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeaturePointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeaturePointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeaturePointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeaturePointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeaturePointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeaturePointerEnteredEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeaturePointerEnteredEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeaturePointerEnteredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeaturePointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeaturePointerEnteredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlTransitFeaturePointerEnteredEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlTransitFeaturePointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeaturePointerEnteredEventArgs
    };

    // ----- MapControlTransitFeaturePointerExitedEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeaturePointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeaturePointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeaturePointerExitedEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeaturePointerExitedEventArgs", L"TransitProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeaturePointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeaturePointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeaturePointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeaturePointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeaturePointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeaturePointerExitedEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeaturePointerExitedEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeaturePointerExitedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeaturePointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeaturePointerExitedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlTransitFeaturePointerExitedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlTransitFeaturePointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeaturePointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeaturePointerExitedEventArgs
    };

    // ----- MapControlTransitFeatureRightTappedEventArgs class --------------------

    static PyObject* _new_MapControlTransitFeatureRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapControlTransitFeatureRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_DisplayName(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlTransitFeatureRightTappedEventArgs_get_TransitProperties(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapControlTransitFeatureRightTappedEventArgs", L"TransitProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TransitProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlTransitFeatureRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlTransitFeatureRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlTransitFeatureRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapControlTransitFeatureRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlTransitFeatureRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlTransitFeatureRightTappedEventArgs[] = {
        { "display_name", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_DisplayName), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "transit_properties", reinterpret_cast<getter>(MapControlTransitFeatureRightTappedEventArgs_get_TransitProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlTransitFeatureRightTappedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlTransitFeatureRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlTransitFeatureRightTappedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapControlTransitFeatureRightTappedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapControlTransitFeatureRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapControlTransitFeatureRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlTransitFeatureRightTappedEventArgs
    };

    // ----- MapCustomExperience class --------------------

    static PyObject* _new_MapCustomExperience(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCustomExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapCustomExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCustomExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperience>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCustomExperience[] = {
        { "_assign_array_", _assign_array_MapCustomExperience, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCustomExperience), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCustomExperience[] = {
        { }
    };

    static PyType_Slot _type_slots_MapCustomExperience[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCustomExperience) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCustomExperience) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCustomExperience) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCustomExperience) },
        { },
    };

    static PyType_Spec type_spec_MapCustomExperience =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapCustomExperience",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperience),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCustomExperience
    };

    // ----- MapCustomExperienceChangedEventArgs class --------------------

    static PyObject* _new_MapCustomExperienceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapCustomExperienceChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapCustomExperienceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapCustomExperienceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapCustomExperienceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapCustomExperienceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapCustomExperienceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapCustomExperienceChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_MapCustomExperienceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapCustomExperienceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapCustomExperienceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapCustomExperienceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapCustomExperienceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapCustomExperienceChangedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapCustomExperienceChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapCustomExperienceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapCustomExperienceChangedEventArgs
    };

    // ----- MapElement class --------------------

    static PyObject* _new_MapElement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElement instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElement_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_Tag(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapStyleSheetEntryState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapStyleSheetEntryState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntryState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapStyleSheetEntry());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_MapStyleSheetEntry(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntry"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MapStyleSheetEntry(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement_put_IsEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"VisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"ZIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapTabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapTabIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapTabIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapStyleSheetEntryProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_MapStyleSheetEntryStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"MapStyleSheetEntryStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::MapStyleSheetEntryStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_TagProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"TagProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::TagProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement_get_IsEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement", L"IsEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement::IsEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElement[] = {
        { "_assign_array_", _assign_array_MapElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElement[] = {
        { "z_index", reinterpret_cast<getter>(MapElement_get_ZIndex), reinterpret_cast<setter>(MapElement_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapElement_get_Visible), reinterpret_cast<setter>(MapElement_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapElement_get_MapTabIndex), reinterpret_cast<setter>(MapElement_put_MapTabIndex), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(MapElement_get_Tag), reinterpret_cast<setter>(MapElement_put_Tag), nullptr, nullptr },
        { "map_style_sheet_entry_state", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryState), reinterpret_cast<setter>(MapElement_put_MapStyleSheetEntryState), nullptr, nullptr },
        { "map_style_sheet_entry", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntry), reinterpret_cast<setter>(MapElement_put_MapStyleSheetEntry), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(MapElement_get_IsEnabled), reinterpret_cast<setter>(MapElement_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElement) },
        { },
    };

    static PyType_Spec type_spec_MapElement =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElement",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElement
    };

    static PyGetSetDef getset_MapElement_Meta[] = {
        { "visible_property", reinterpret_cast<getter>(MapElement_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapElement_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { "map_tab_index_property", reinterpret_cast<getter>(MapElement_get_MapTabIndexProperty), nullptr, nullptr, nullptr },
        { "map_style_sheet_entry_property", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryProperty), nullptr, nullptr, nullptr },
        { "map_style_sheet_entry_state_property", reinterpret_cast<getter>(MapElement_get_MapStyleSheetEntryStateProperty), nullptr, nullptr, nullptr },
        { "tag_property", reinterpret_cast<getter>(MapElement_get_TagProperty), nullptr, nullptr, nullptr },
        { "is_enabled_property", reinterpret_cast<getter>(MapElement_get_IsEnabledProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapElement_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElement_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapElement_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElement_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElement_Meta
    };

    // ----- MapElement3D class --------------------

    static PyObject* _new_MapElement3D(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElement3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElement3D_get_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Scale(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Scale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Roll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Roll(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Roll"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Roll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Pitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pitch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Pitch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Pitch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pitch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Model(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Model"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Model(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Model"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>(arg);

            self->obj.Model(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElement3D_put_Heading(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"Heading"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Heading(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElement3D_get_HeadingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"HeadingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::HeadingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"LocationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_PitchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"PitchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::PitchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_RollProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"RollProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::RollProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElement3D_get_ScaleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElement3D", L"ScaleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D::ScaleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElement3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElement3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElement3D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElement3D[] = {
        { "_assign_array_", _assign_array_MapElement3D, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElement3D), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElement3D[] = {
        { "scale", reinterpret_cast<getter>(MapElement3D_get_Scale), reinterpret_cast<setter>(MapElement3D_put_Scale), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(MapElement3D_get_Roll), reinterpret_cast<setter>(MapElement3D_put_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(MapElement3D_get_Pitch), reinterpret_cast<setter>(MapElement3D_put_Pitch), nullptr, nullptr },
        { "model", reinterpret_cast<getter>(MapElement3D_get_Model), reinterpret_cast<setter>(MapElement3D_put_Model), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapElement3D_get_Location), reinterpret_cast<setter>(MapElement3D_put_Location), nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(MapElement3D_get_Heading), reinterpret_cast<setter>(MapElement3D_put_Heading), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElement3D[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElement3D) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElement3D) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElement3D) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElement3D) },
        { },
    };

    static PyType_Spec type_spec_MapElement3D =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElement3D",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElement3D),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElement3D
    };

    static PyGetSetDef getset_MapElement3D_Meta[] = {
        { "heading_property", reinterpret_cast<getter>(MapElement3D_get_HeadingProperty), nullptr, nullptr, nullptr },
        { "location_property", reinterpret_cast<getter>(MapElement3D_get_LocationProperty), nullptr, nullptr, nullptr },
        { "pitch_property", reinterpret_cast<getter>(MapElement3D_get_PitchProperty), nullptr, nullptr, nullptr },
        { "roll_property", reinterpret_cast<getter>(MapElement3D_get_RollProperty), nullptr, nullptr, nullptr },
        { "scale_property", reinterpret_cast<getter>(MapElement3D_get_ScaleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapElement3D_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElement3D_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapElement3D_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElement3D_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElement3D_Meta
    };

    // ----- MapElementClickEventArgs class --------------------

    static PyObject* _new_MapElementClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementClickEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementClickEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementClickEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementClickEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementClickEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementClickEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementClickEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementClickEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementClickEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementClickEventArgs
    };

    // ----- MapElementPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapElementPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"MapElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerEnteredEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerEnteredEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementPointerEnteredEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementPointerEnteredEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementPointerEnteredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementPointerEnteredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementPointerEnteredEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementPointerEnteredEventArgs
    };

    // ----- MapElementPointerExitedEventArgs class --------------------

    static PyObject* _new_MapElementPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementPointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerExitedEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"MapElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementPointerExitedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementPointerExitedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementPointerExitedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementPointerExitedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementPointerExitedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementPointerExitedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementPointerExitedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementPointerExitedEventArgs
    };

    // ----- MapElementsLayer class --------------------

    static PyObject* _new_MapElementsLayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayer_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapElementsLayer_put_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Xaml::Controls::Maps::MapElement>>(arg);

            self->obj.MapElements(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapElementsLayer_get_MapElementsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer::MapElementsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>>(arg);

            return py::convert(self->obj.MapContextRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapContextRequested(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapContextRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapContextRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>>(arg);

            return py::convert(self->obj.MapElementClick(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementClick(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementClick"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementClick(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementPointerEntered(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerEntered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_add_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer, winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>>(arg);

            return py::convert(self->obj.MapElementPointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayer_remove_MapElementPointerExited(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayer", L"MapElementPointerExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapElementPointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayer[] = {
        { "add_map_context_requested", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapContextRequested), METH_O, nullptr },
        { "remove_map_context_requested", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapContextRequested), METH_O, nullptr },
        { "add_map_element_click", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementClick), METH_O, nullptr },
        { "remove_map_element_click", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementClick), METH_O, nullptr },
        { "add_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementPointerEntered), METH_O, nullptr },
        { "remove_map_element_pointer_entered", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementPointerEntered), METH_O, nullptr },
        { "add_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapElementsLayer_add_MapElementPointerExited), METH_O, nullptr },
        { "remove_map_element_pointer_exited", reinterpret_cast<PyCFunction>(MapElementsLayer_remove_MapElementPointerExited), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapElementsLayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayer[] = {
        { "map_elements", reinterpret_cast<getter>(MapElementsLayer_get_MapElements), reinterpret_cast<setter>(MapElementsLayer_put_MapElements), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayer) },
        { },
    };

    static PyType_Spec type_spec_MapElementsLayer =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayer",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayer
    };

    static PyGetSetDef getset_MapElementsLayer_Meta[] = {
        { "map_elements_property", reinterpret_cast<getter>(MapElementsLayer_get_MapElementsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapElementsLayer_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapElementsLayer_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapElementsLayer_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayer_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapElementsLayer_Meta
    };

    // ----- MapElementsLayerClickEventArgs class --------------------

    static PyObject* _new_MapElementsLayerClickEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerClickEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerClickEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerClickEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerClickEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerClickEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerClickEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerClickEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerClickEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerClickEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerClickEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementsLayerClickEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayerClickEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerClickEventArgs
    };

    // ----- MapElementsLayerContextRequestedEventArgs class --------------------

    static PyObject* _new_MapElementsLayerContextRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerContextRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_MapElements(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"MapElements"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerContextRequestedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerContextRequestedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerContextRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerContextRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerContextRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerContextRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerContextRequestedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_elements", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_MapElements), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerContextRequestedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerContextRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerContextRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerContextRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementsLayerContextRequestedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayerContextRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerContextRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerContextRequestedEventArgs
    };

    // ----- MapElementsLayerPointerEnteredEventArgs class --------------------

    static PyObject* _new_MapElementsLayerPointerEnteredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerPointerEnteredEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"MapElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerEnteredEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerEnteredEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerPointerEnteredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerPointerEnteredEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerPointerEnteredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerPointerEnteredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerPointerEnteredEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerPointerEnteredEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerPointerEnteredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerPointerEnteredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerPointerEnteredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementsLayerPointerEnteredEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayerPointerEnteredEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerEnteredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerPointerEnteredEventArgs
    };

    // ----- MapElementsLayerPointerExitedEventArgs class --------------------

    static PyObject* _new_MapElementsLayerPointerExitedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapElementsLayerPointerExitedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_MapElement(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"MapElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapElementsLayerPointerExitedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapElementsLayerPointerExitedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapElementsLayerPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapElementsLayerPointerExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapElementsLayerPointerExitedEventArgs[] = {
        { "_assign_array_", _assign_array_MapElementsLayerPointerExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapElementsLayerPointerExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapElementsLayerPointerExitedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "map_element", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_MapElement), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapElementsLayerPointerExitedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapElementsLayerPointerExitedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapElementsLayerPointerExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapElementsLayerPointerExitedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapElementsLayerPointerExitedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapElementsLayerPointerExitedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapElementsLayerPointerExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapElementsLayerPointerExitedEventArgs
    };

    // ----- MapIcon class --------------------

    static PyObject* _new_MapIcon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapIcon instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapIcon(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapIcon_get_Title(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Title(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NormalizedAnchorPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_NormalizedAnchorPoint(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.NormalizedAnchorPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_Image(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"Image"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Image(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollisionBehaviorDesired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapIcon_put_CollisionBehaviorDesired(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapElementCollisionBehavior>(arg);

            self->obj.CollisionBehaviorDesired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapIcon_get_LocationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"LocationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::LocationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_NormalizedAnchorPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"NormalizedAnchorPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::NormalizedAnchorPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_TitleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"TitleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::TitleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapIcon_get_CollisionBehaviorDesiredProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapIcon", L"CollisionBehaviorDesiredProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapIcon::CollisionBehaviorDesiredProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapIcon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapIcon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapIcon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapIcon[] = {
        { "_assign_array_", _assign_array_MapIcon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapIcon), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapIcon[] = {
        { "title", reinterpret_cast<getter>(MapIcon_get_Title), reinterpret_cast<setter>(MapIcon_put_Title), nullptr, nullptr },
        { "normalized_anchor_point", reinterpret_cast<getter>(MapIcon_get_NormalizedAnchorPoint), reinterpret_cast<setter>(MapIcon_put_NormalizedAnchorPoint), nullptr, nullptr },
        { "location", reinterpret_cast<getter>(MapIcon_get_Location), reinterpret_cast<setter>(MapIcon_put_Location), nullptr, nullptr },
        { "image", reinterpret_cast<getter>(MapIcon_get_Image), reinterpret_cast<setter>(MapIcon_put_Image), nullptr, nullptr },
        { "collision_behavior_desired", reinterpret_cast<getter>(MapIcon_get_CollisionBehaviorDesired), reinterpret_cast<setter>(MapIcon_put_CollisionBehaviorDesired), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapIcon[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapIcon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapIcon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapIcon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapIcon) },
        { },
    };

    static PyType_Spec type_spec_MapIcon =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapIcon",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapIcon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapIcon
    };

    static PyGetSetDef getset_MapIcon_Meta[] = {
        { "location_property", reinterpret_cast<getter>(MapIcon_get_LocationProperty), nullptr, nullptr, nullptr },
        { "normalized_anchor_point_property", reinterpret_cast<getter>(MapIcon_get_NormalizedAnchorPointProperty), nullptr, nullptr, nullptr },
        { "title_property", reinterpret_cast<getter>(MapIcon_get_TitleProperty), nullptr, nullptr, nullptr },
        { "collision_behavior_desired_property", reinterpret_cast<getter>(MapIcon_get_CollisionBehaviorDesiredProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapIcon_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapIcon_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapIcon_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapIcon_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapIcon_Meta
    };

    // ----- MapInputEventArgs class --------------------

    static PyObject* _new_MapInputEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapInputEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapInputEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapInputEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapInputEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapInputEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapInputEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapInputEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapInputEventArgs[] = {
        { "_assign_array_", _assign_array_MapInputEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapInputEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapInputEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapInputEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapInputEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapInputEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapInputEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapInputEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapInputEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapInputEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapInputEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapInputEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapInputEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapInputEventArgs
    };

    // ----- MapItemsControl class --------------------

    static PyObject* _new_MapItemsControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapItemsControl(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapItemsControl_get_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapItemsControl_put_ItemsSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.ItemsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapItemsControl_get_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemTemplate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapItemsControl_put_ItemTemplate(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DataTemplate>(arg);

            self->obj.ItemTemplate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapItemsControl_get_Items(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"Items"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemTemplateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemTemplateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemTemplateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapItemsControl_get_ItemsSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapItemsControl", L"ItemsSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl::ItemsSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapItemsControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapItemsControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapItemsControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapItemsControl[] = {
        { "_assign_array_", _assign_array_MapItemsControl, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapItemsControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapItemsControl[] = {
        { "items_source", reinterpret_cast<getter>(MapItemsControl_get_ItemsSource), reinterpret_cast<setter>(MapItemsControl_put_ItemsSource), nullptr, nullptr },
        { "item_template", reinterpret_cast<getter>(MapItemsControl_get_ItemTemplate), reinterpret_cast<setter>(MapItemsControl_put_ItemTemplate), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(MapItemsControl_get_Items), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapItemsControl[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapItemsControl) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapItemsControl) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapItemsControl) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapItemsControl) },
        { },
    };

    static PyType_Spec type_spec_MapItemsControl =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapItemsControl",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapItemsControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapItemsControl
    };

    static PyGetSetDef getset_MapItemsControl_Meta[] = {
        { "item_template_property", reinterpret_cast<getter>(MapItemsControl_get_ItemTemplateProperty), nullptr, nullptr, nullptr },
        { "items_property", reinterpret_cast<getter>(MapItemsControl_get_ItemsProperty), nullptr, nullptr, nullptr },
        { "items_source_property", reinterpret_cast<getter>(MapItemsControl_get_ItemsSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapItemsControl_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapItemsControl_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapItemsControl_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapItemsControl_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapItemsControl_Meta
    };

    // ----- MapLayer class --------------------

    static PyObject* _new_MapLayer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapLayer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapLayer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapLayer_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MapTabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapLayer_put_MapTabIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.MapTabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapLayer_get_MapTabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"MapTabIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::MapTabIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"VisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapLayer_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapLayer", L"ZIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapLayer::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapLayer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapLayer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapLayer[] = {
        { "_assign_array_", _assign_array_MapLayer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapLayer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapLayer[] = {
        { "z_index", reinterpret_cast<getter>(MapLayer_get_ZIndex), reinterpret_cast<setter>(MapLayer_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapLayer_get_Visible), reinterpret_cast<setter>(MapLayer_put_Visible), nullptr, nullptr },
        { "map_tab_index", reinterpret_cast<getter>(MapLayer_get_MapTabIndex), reinterpret_cast<setter>(MapLayer_put_MapTabIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapLayer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapLayer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapLayer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapLayer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapLayer) },
        { },
    };

    static PyType_Spec type_spec_MapLayer =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapLayer",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapLayer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapLayer
    };

    static PyGetSetDef getset_MapLayer_Meta[] = {
        { "map_tab_index_property", reinterpret_cast<getter>(MapLayer_get_MapTabIndexProperty), nullptr, nullptr, nullptr },
        { "visible_property", reinterpret_cast<getter>(MapLayer_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapLayer_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapLayer_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapLayer_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapLayer_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapLayer_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapLayer_Meta
    };

    // ----- MapModel3D class --------------------

    static PyObject* _new_MapModel3D(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapModel3D(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapModel3D_CreateFrom3MFAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapModel3D", L"CreateFrom3MFAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D::CreateFrom3MFAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapModel3D", L"CreateFrom3MFAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3DShadingOption>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D::CreateFrom3MFAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapModel3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapModel3D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapModel3D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapModel3D[] = {
        { "create_from3_m_f_async", reinterpret_cast<PyCFunction>(MapModel3D_CreateFrom3MFAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_MapModel3D, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapModel3D), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapModel3D[] = {
        { }
    };

    static PyType_Slot _type_slots_MapModel3D[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapModel3D) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapModel3D) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapModel3D) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapModel3D) },
        { },
    };

    static PyType_Spec type_spec_MapModel3D =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapModel3D",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapModel3D),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapModel3D
    };

    // ----- MapPolygon class --------------------

    static PyObject* _new_MapPolygon(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapPolygon(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapPolygon_get_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.StrokeThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeDashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StrokeDashed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.StrokeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_FillColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"FillColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolygon_put_FillColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"FillColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.FillColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolygon_get_Paths(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"Paths"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_PathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"PathProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::PathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_StrokeDashedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeDashedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::StrokeDashedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolygon_get_StrokeThicknessProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolygon", L"StrokeThicknessProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon::StrokeThicknessProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapPolygon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapPolygon(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapPolygon>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapPolygon[] = {
        { "_assign_array_", _assign_array_MapPolygon, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapPolygon), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapPolygon[] = {
        { "stroke_thickness", reinterpret_cast<getter>(MapPolygon_get_StrokeThickness), reinterpret_cast<setter>(MapPolygon_put_StrokeThickness), nullptr, nullptr },
        { "stroke_dashed", reinterpret_cast<getter>(MapPolygon_get_StrokeDashed), reinterpret_cast<setter>(MapPolygon_put_StrokeDashed), nullptr, nullptr },
        { "stroke_color", reinterpret_cast<getter>(MapPolygon_get_StrokeColor), reinterpret_cast<setter>(MapPolygon_put_StrokeColor), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(MapPolygon_get_Path), reinterpret_cast<setter>(MapPolygon_put_Path), nullptr, nullptr },
        { "fill_color", reinterpret_cast<getter>(MapPolygon_get_FillColor), reinterpret_cast<setter>(MapPolygon_put_FillColor), nullptr, nullptr },
        { "paths", reinterpret_cast<getter>(MapPolygon_get_Paths), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapPolygon[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapPolygon) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapPolygon) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapPolygon) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapPolygon) },
        { },
    };

    static PyType_Spec type_spec_MapPolygon =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapPolygon",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolygon),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapPolygon
    };

    static PyGetSetDef getset_MapPolygon_Meta[] = {
        { "path_property", reinterpret_cast<getter>(MapPolygon_get_PathProperty), nullptr, nullptr, nullptr },
        { "stroke_dashed_property", reinterpret_cast<getter>(MapPolygon_get_StrokeDashedProperty), nullptr, nullptr, nullptr },
        { "stroke_thickness_property", reinterpret_cast<getter>(MapPolygon_get_StrokeThicknessProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapPolygon_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapPolygon_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapPolygon_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapPolygon_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapPolygon_Meta
    };

    // ----- MapPolyline class --------------------

    static PyObject* _new_MapPolyline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapPolyline(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapPolyline_get_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeThickness(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeThickness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.StrokeThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeDashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeDashed(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StrokeDashed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StrokeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_StrokeColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.StrokeColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapPolyline_put_Path(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopath>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapPolyline_get_PathProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"PathProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline::PathProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapPolyline_get_StrokeDashedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapPolyline", L"StrokeDashedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline::StrokeDashedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapPolyline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapPolyline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapPolyline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapPolyline[] = {
        { "_assign_array_", _assign_array_MapPolyline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapPolyline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapPolyline[] = {
        { "stroke_thickness", reinterpret_cast<getter>(MapPolyline_get_StrokeThickness), reinterpret_cast<setter>(MapPolyline_put_StrokeThickness), nullptr, nullptr },
        { "stroke_dashed", reinterpret_cast<getter>(MapPolyline_get_StrokeDashed), reinterpret_cast<setter>(MapPolyline_put_StrokeDashed), nullptr, nullptr },
        { "stroke_color", reinterpret_cast<getter>(MapPolyline_get_StrokeColor), reinterpret_cast<setter>(MapPolyline_put_StrokeColor), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(MapPolyline_get_Path), reinterpret_cast<setter>(MapPolyline_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapPolyline[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapPolyline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapPolyline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapPolyline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapPolyline) },
        { },
    };

    static PyType_Spec type_spec_MapPolyline =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapPolyline",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapPolyline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapPolyline
    };

    static PyGetSetDef getset_MapPolyline_Meta[] = {
        { "path_property", reinterpret_cast<getter>(MapPolyline_get_PathProperty), nullptr, nullptr, nullptr },
        { "stroke_dashed_property", reinterpret_cast<getter>(MapPolyline_get_StrokeDashedProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapPolyline_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapPolyline_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapPolyline_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapPolyline_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapPolyline_Meta
    };

    // ----- MapRightTappedEventArgs class --------------------

    static PyObject* _new_MapRightTappedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapRightTappedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapRightTappedEventArgs_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRightTappedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapRightTappedEventArgs_get_Position(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRightTappedEventArgs", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapRightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapRightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_MapRightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapRightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapRightTappedEventArgs[] = {
        { "location", reinterpret_cast<getter>(MapRightTappedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MapRightTappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapRightTappedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapRightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapRightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapRightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapRightTappedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapRightTappedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapRightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapRightTappedEventArgs
    };

    // ----- MapRouteView class --------------------

    static PyObject* _new_MapRouteView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Maps::MapRoute>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapRouteView(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapRouteView_get_RouteColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"RouteColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RouteColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapRouteView_put_RouteColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"RouteColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.RouteColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapRouteView_get_OutlineColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"OutlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapRouteView_put_OutlineColor(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"OutlineColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapRouteView_get_Route(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapRouteView", L"Route"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Route());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapRouteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapRouteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapRouteView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapRouteView[] = {
        { "_assign_array_", _assign_array_MapRouteView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapRouteView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapRouteView[] = {
        { "route_color", reinterpret_cast<getter>(MapRouteView_get_RouteColor), reinterpret_cast<setter>(MapRouteView_put_RouteColor), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(MapRouteView_get_OutlineColor), reinterpret_cast<setter>(MapRouteView_put_OutlineColor), nullptr, nullptr },
        { "route", reinterpret_cast<getter>(MapRouteView_get_Route), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapRouteView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapRouteView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapRouteView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapRouteView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapRouteView) },
        { },
    };

    static PyType_Spec type_spec_MapRouteView =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapRouteView",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapRouteView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapRouteView
    };

    // ----- MapScene class --------------------

    static PyObject* _new_MapScene(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>::type_name);
        return nullptr;
    }

    static void _dealloc_MapScene(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapScene_CreateFromBoundingBox(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromBoundingBox", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromBoundingBox(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromBoundingBox", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromBoundingBox(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromCamera(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromCamera", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapCamera>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromCamera(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocation", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocation(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocationAndRadius(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocationAndRadius", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocationAndRadius(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocationAndRadius", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocationAndRadius(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_CreateFromLocations(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocations", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::Geopoint>>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocations(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"CreateFromLocations", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::Geopoint>>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapScene::CreateFromLocations(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapScene_get_TargetCamera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCamera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetCamera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapScene_add_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Controls::Maps::MapScene, winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>(arg);

            return py::convert(self->obj.TargetCameraChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapScene_remove_TargetCameraChanged(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Controls.Maps.MapScene", L"TargetCameraChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetCameraChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapScene(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapScene(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapScene>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapScene[] = {
        { "create_from_bounding_box", reinterpret_cast<PyCFunction>(MapScene_CreateFromBoundingBox), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_camera", reinterpret_cast<PyCFunction>(MapScene_CreateFromCamera), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_location", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocation), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_location_and_radius", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocationAndRadius), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_locations", reinterpret_cast<PyCFunction>(MapScene_CreateFromLocations), METH_VARARGS | METH_STATIC, nullptr },
        { "add_target_camera_changed", reinterpret_cast<PyCFunction>(MapScene_add_TargetCameraChanged), METH_O, nullptr },
        { "remove_target_camera_changed", reinterpret_cast<PyCFunction>(MapScene_remove_TargetCameraChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_MapScene, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapScene), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapScene[] = {
        { "target_camera", reinterpret_cast<getter>(MapScene_get_TargetCamera), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapScene[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapScene) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapScene) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapScene) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapScene) },
        { },
    };

    static PyType_Spec type_spec_MapScene =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapScene",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapScene),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapScene
    };

    // ----- MapStyleSheet class --------------------

    static PyObject* _new_MapStyleSheet(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>::type_name);
        return nullptr;
    }

    static void _dealloc_MapStyleSheet(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapStyleSheet_Aerial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"Aerial", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::Aerial());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_AerialWithOverlay(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"AerialWithOverlay", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::AerialWithOverlay());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_Combine(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"Combine", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::Combine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_ParseFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"ParseFromJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::ParseFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadDark(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadDark", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadDark());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadHighContrastDark(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadHighContrastDark", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadHighContrastDark());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadHighContrastLight(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadHighContrastLight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadHighContrastLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_RoadLight(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"RoadLight", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::RoadLight());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapStyleSheet_TryParseFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheet", L"TryParseFromJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet param1 { nullptr };

                auto return_value = winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet::TryParseFromJson(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapStyleSheet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapStyleSheet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheet[] = {
        { "aerial", reinterpret_cast<PyCFunction>(MapStyleSheet_Aerial), METH_VARARGS | METH_STATIC, nullptr },
        { "aerial_with_overlay", reinterpret_cast<PyCFunction>(MapStyleSheet_AerialWithOverlay), METH_VARARGS | METH_STATIC, nullptr },
        { "combine", reinterpret_cast<PyCFunction>(MapStyleSheet_Combine), METH_VARARGS | METH_STATIC, nullptr },
        { "parse_from_json", reinterpret_cast<PyCFunction>(MapStyleSheet_ParseFromJson), METH_VARARGS | METH_STATIC, nullptr },
        { "road_dark", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadDark), METH_VARARGS | METH_STATIC, nullptr },
        { "road_high_contrast_dark", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadHighContrastDark), METH_VARARGS | METH_STATIC, nullptr },
        { "road_high_contrast_light", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadHighContrastLight), METH_VARARGS | METH_STATIC, nullptr },
        { "road_light", reinterpret_cast<PyCFunction>(MapStyleSheet_RoadLight), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse_from_json", reinterpret_cast<PyCFunction>(MapStyleSheet_TryParseFromJson), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_MapStyleSheet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapStyleSheet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapStyleSheet[] = {
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapStyleSheet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheet) },
        { },
    };

    static PyType_Spec type_spec_MapStyleSheet =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapStyleSheet",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapStyleSheet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheet
    };

    // ----- MapStyleSheetEntries class --------------------

    static PyObject* _new_MapStyleSheetEntries(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries>::type_name);
        return nullptr;
    }

    static PyObject* MapStyleSheetEntries_get_AdminDistrict(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"AdminDistrict"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::AdminDistrict());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_AdminDistrictCapital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"AdminDistrictCapital"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::AdminDistrictCapital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Airport(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Airport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Airport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Area(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Area"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Area());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ArterialRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ArterialRoad"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ArterialRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Building(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Building"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Building());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Business(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Business"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Business());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Capital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Capital"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Capital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Cemetery(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Cemetery"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Cemetery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Continent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Continent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Continent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ControlledAccessHighway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ControlledAccessHighway"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ControlledAccessHighway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_CountryRegion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"CountryRegion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::CountryRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_CountryRegionCapital(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"CountryRegionCapital"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::CountryRegionCapital());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_District(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"District"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::District());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_DrivingRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"DrivingRoute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::DrivingRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Education(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Education"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Education());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_EducationBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"EducationBuilding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::EducationBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_FoodPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"FoodPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::FoodPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Forest(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Forest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Forest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_GolfCourse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"GolfCourse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::GolfCourse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_HighSpeedRamp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"HighSpeedRamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::HighSpeedRamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Highway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Highway"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Highway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_IndigenousPeoplesReserve(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"IndigenousPeoplesReserve"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::IndigenousPeoplesReserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Island(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Island"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Island());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_MajorRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"MajorRoad"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::MajorRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Medical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Medical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Medical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_MedicalBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"MedicalBuilding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::MedicalBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Military(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Military"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Military());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_NaturalPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"NaturalPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::NaturalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Nautical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Nautical"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Nautical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Neighborhood(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Neighborhood"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Neighborhood());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Park(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Park"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Park());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Peak(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Peak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Peak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PlayingField(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PlayingField"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PlayingField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Point(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PointOfInterest(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PointOfInterest"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PointOfInterest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Political(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Political"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Political());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_PopulatedPlace(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"PopulatedPlace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::PopulatedPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Railway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Railway"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Railway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Ramp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Ramp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Ramp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Reserve(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Reserve"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_River(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"River"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::River());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Road(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Road"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Road());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RoadExit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RoadExit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RoadExit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RoadShield(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RoadShield"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RoadShield());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_RouteLine(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"RouteLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::RouteLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Runway(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Runway"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Runway());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Sand(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Sand"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Sand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_ShoppingCenter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"ShoppingCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::ShoppingCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Stadium(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Stadium"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Stadium());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Street(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Street"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Street());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Structure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Structure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Structure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_TollRoad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"TollRoad"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::TollRoad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Trail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Trail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Trail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Transit(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Transit"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Transit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_TransitBuilding(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"TransitBuilding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::TransitBuilding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Transportation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Transportation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Transportation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_UnpavedStreet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"UnpavedStreet"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::UnpavedStreet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Vegetation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Vegetation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Vegetation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_VolcanicPeak(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"VolcanicPeak"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::VolcanicPeak());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WalkingRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WalkingRoute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WalkingRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_Water(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"Water"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::Water());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WaterPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WaterPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WaterPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntries_get_WaterRoute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntries", L"WaterRoute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntries::WaterRoute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheetEntries[] = {
        { }
    };

    static PyGetSetDef _getset_MapStyleSheetEntries[] = {
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheetEntries[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheetEntries) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheetEntries) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheetEntries) },
        { },
    };

    static PyType_Spec type_spec_MapStyleSheetEntries =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntries",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheetEntries
    };

    static PyGetSetDef getset_MapStyleSheetEntries_Meta[] = {
        { "admin_district", reinterpret_cast<getter>(MapStyleSheetEntries_get_AdminDistrict), nullptr, nullptr, nullptr },
        { "admin_district_capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_AdminDistrictCapital), nullptr, nullptr, nullptr },
        { "airport", reinterpret_cast<getter>(MapStyleSheetEntries_get_Airport), nullptr, nullptr, nullptr },
        { "area", reinterpret_cast<getter>(MapStyleSheetEntries_get_Area), nullptr, nullptr, nullptr },
        { "arterial_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_ArterialRoad), nullptr, nullptr, nullptr },
        { "building", reinterpret_cast<getter>(MapStyleSheetEntries_get_Building), nullptr, nullptr, nullptr },
        { "business", reinterpret_cast<getter>(MapStyleSheetEntries_get_Business), nullptr, nullptr, nullptr },
        { "capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_Capital), nullptr, nullptr, nullptr },
        { "cemetery", reinterpret_cast<getter>(MapStyleSheetEntries_get_Cemetery), nullptr, nullptr, nullptr },
        { "continent", reinterpret_cast<getter>(MapStyleSheetEntries_get_Continent), nullptr, nullptr, nullptr },
        { "controlled_access_highway", reinterpret_cast<getter>(MapStyleSheetEntries_get_ControlledAccessHighway), nullptr, nullptr, nullptr },
        { "country_region", reinterpret_cast<getter>(MapStyleSheetEntries_get_CountryRegion), nullptr, nullptr, nullptr },
        { "country_region_capital", reinterpret_cast<getter>(MapStyleSheetEntries_get_CountryRegionCapital), nullptr, nullptr, nullptr },
        { "district", reinterpret_cast<getter>(MapStyleSheetEntries_get_District), nullptr, nullptr, nullptr },
        { "driving_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_DrivingRoute), nullptr, nullptr, nullptr },
        { "education", reinterpret_cast<getter>(MapStyleSheetEntries_get_Education), nullptr, nullptr, nullptr },
        { "education_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_EducationBuilding), nullptr, nullptr, nullptr },
        { "food_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_FoodPoint), nullptr, nullptr, nullptr },
        { "forest", reinterpret_cast<getter>(MapStyleSheetEntries_get_Forest), nullptr, nullptr, nullptr },
        { "golf_course", reinterpret_cast<getter>(MapStyleSheetEntries_get_GolfCourse), nullptr, nullptr, nullptr },
        { "high_speed_ramp", reinterpret_cast<getter>(MapStyleSheetEntries_get_HighSpeedRamp), nullptr, nullptr, nullptr },
        { "highway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Highway), nullptr, nullptr, nullptr },
        { "indigenous_peoples_reserve", reinterpret_cast<getter>(MapStyleSheetEntries_get_IndigenousPeoplesReserve), nullptr, nullptr, nullptr },
        { "island", reinterpret_cast<getter>(MapStyleSheetEntries_get_Island), nullptr, nullptr, nullptr },
        { "major_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_MajorRoad), nullptr, nullptr, nullptr },
        { "medical", reinterpret_cast<getter>(MapStyleSheetEntries_get_Medical), nullptr, nullptr, nullptr },
        { "medical_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_MedicalBuilding), nullptr, nullptr, nullptr },
        { "military", reinterpret_cast<getter>(MapStyleSheetEntries_get_Military), nullptr, nullptr, nullptr },
        { "natural_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_NaturalPoint), nullptr, nullptr, nullptr },
        { "nautical", reinterpret_cast<getter>(MapStyleSheetEntries_get_Nautical), nullptr, nullptr, nullptr },
        { "neighborhood", reinterpret_cast<getter>(MapStyleSheetEntries_get_Neighborhood), nullptr, nullptr, nullptr },
        { "park", reinterpret_cast<getter>(MapStyleSheetEntries_get_Park), nullptr, nullptr, nullptr },
        { "peak", reinterpret_cast<getter>(MapStyleSheetEntries_get_Peak), nullptr, nullptr, nullptr },
        { "playing_field", reinterpret_cast<getter>(MapStyleSheetEntries_get_PlayingField), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(MapStyleSheetEntries_get_Point), nullptr, nullptr, nullptr },
        { "point_of_interest", reinterpret_cast<getter>(MapStyleSheetEntries_get_PointOfInterest), nullptr, nullptr, nullptr },
        { "political", reinterpret_cast<getter>(MapStyleSheetEntries_get_Political), nullptr, nullptr, nullptr },
        { "populated_place", reinterpret_cast<getter>(MapStyleSheetEntries_get_PopulatedPlace), nullptr, nullptr, nullptr },
        { "railway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Railway), nullptr, nullptr, nullptr },
        { "ramp", reinterpret_cast<getter>(MapStyleSheetEntries_get_Ramp), nullptr, nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(MapStyleSheetEntries_get_Reserve), nullptr, nullptr, nullptr },
        { "river", reinterpret_cast<getter>(MapStyleSheetEntries_get_River), nullptr, nullptr, nullptr },
        { "road", reinterpret_cast<getter>(MapStyleSheetEntries_get_Road), nullptr, nullptr, nullptr },
        { "road_exit", reinterpret_cast<getter>(MapStyleSheetEntries_get_RoadExit), nullptr, nullptr, nullptr },
        { "road_shield", reinterpret_cast<getter>(MapStyleSheetEntries_get_RoadShield), nullptr, nullptr, nullptr },
        { "route_line", reinterpret_cast<getter>(MapStyleSheetEntries_get_RouteLine), nullptr, nullptr, nullptr },
        { "runway", reinterpret_cast<getter>(MapStyleSheetEntries_get_Runway), nullptr, nullptr, nullptr },
        { "sand", reinterpret_cast<getter>(MapStyleSheetEntries_get_Sand), nullptr, nullptr, nullptr },
        { "shopping_center", reinterpret_cast<getter>(MapStyleSheetEntries_get_ShoppingCenter), nullptr, nullptr, nullptr },
        { "stadium", reinterpret_cast<getter>(MapStyleSheetEntries_get_Stadium), nullptr, nullptr, nullptr },
        { "street", reinterpret_cast<getter>(MapStyleSheetEntries_get_Street), nullptr, nullptr, nullptr },
        { "structure", reinterpret_cast<getter>(MapStyleSheetEntries_get_Structure), nullptr, nullptr, nullptr },
        { "toll_road", reinterpret_cast<getter>(MapStyleSheetEntries_get_TollRoad), nullptr, nullptr, nullptr },
        { "trail", reinterpret_cast<getter>(MapStyleSheetEntries_get_Trail), nullptr, nullptr, nullptr },
        { "transit", reinterpret_cast<getter>(MapStyleSheetEntries_get_Transit), nullptr, nullptr, nullptr },
        { "transit_building", reinterpret_cast<getter>(MapStyleSheetEntries_get_TransitBuilding), nullptr, nullptr, nullptr },
        { "transportation", reinterpret_cast<getter>(MapStyleSheetEntries_get_Transportation), nullptr, nullptr, nullptr },
        { "unpaved_street", reinterpret_cast<getter>(MapStyleSheetEntries_get_UnpavedStreet), nullptr, nullptr, nullptr },
        { "vegetation", reinterpret_cast<getter>(MapStyleSheetEntries_get_Vegetation), nullptr, nullptr, nullptr },
        { "volcanic_peak", reinterpret_cast<getter>(MapStyleSheetEntries_get_VolcanicPeak), nullptr, nullptr, nullptr },
        { "walking_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_WalkingRoute), nullptr, nullptr, nullptr },
        { "water", reinterpret_cast<getter>(MapStyleSheetEntries_get_Water), nullptr, nullptr, nullptr },
        { "water_point", reinterpret_cast<getter>(MapStyleSheetEntries_get_WaterPoint), nullptr, nullptr, nullptr },
        { "water_route", reinterpret_cast<getter>(MapStyleSheetEntries_get_WaterRoute), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapStyleSheetEntries_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapStyleSheetEntries_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntries_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntries_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapStyleSheetEntries_Meta
    };

    // ----- MapStyleSheetEntryStates class --------------------

    static PyObject* _new_MapStyleSheetEntryStates(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates>::type_name);
        return nullptr;
    }

    static PyObject* MapStyleSheetEntryStates_get_Disabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Disabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntryStates_get_Hover(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Hover"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Hover());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapStyleSheetEntryStates_get_Selected(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapStyleSheetEntryStates", L"Selected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapStyleSheetEntryStates::Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapStyleSheetEntryStates[] = {
        { }
    };

    static PyGetSetDef _getset_MapStyleSheetEntryStates[] = {
        { }
    };

    static PyType_Slot _type_slots_MapStyleSheetEntryStates[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapStyleSheetEntryStates) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapStyleSheetEntryStates) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapStyleSheetEntryStates) },
        { },
    };

    static PyType_Spec type_spec_MapStyleSheetEntryStates =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntryStates",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapStyleSheetEntryStates
    };

    static PyGetSetDef getset_MapStyleSheetEntryStates_Meta[] = {
        { "disabled", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Disabled), nullptr, nullptr, nullptr },
        { "hover", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Hover), nullptr, nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(MapStyleSheetEntryStates_get_Selected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapStyleSheetEntryStates_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapStyleSheetEntryStates_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapStyleSheetEntryStates_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapStyleSheetEntryStates_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapStyleSheetEntryStates_Meta
    };

    // ----- MapTargetCameraChangedEventArgs class --------------------

    static PyObject* _new_MapTargetCameraChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTargetCameraChangedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTargetCameraChangedEventArgs_get_Camera(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTargetCameraChangedEventArgs", L"Camera"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Camera());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTargetCameraChangedEventArgs_get_ChangeReason(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTargetCameraChangedEventArgs", L"ChangeReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTargetCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTargetCameraChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTargetCameraChangedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTargetCameraChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTargetCameraChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTargetCameraChangedEventArgs[] = {
        { "camera", reinterpret_cast<getter>(MapTargetCameraChangedEventArgs_get_Camera), nullptr, nullptr, nullptr },
        { "change_reason", reinterpret_cast<getter>(MapTargetCameraChangedEventArgs_get_ChangeReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTargetCameraChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTargetCameraChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTargetCameraChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTargetCameraChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTargetCameraChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapTargetCameraChangedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTargetCameraChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTargetCameraChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTargetCameraChangedEventArgs
    };

    // ----- MapTileBitmapRequest class --------------------

    static PyObject* _new_MapTileBitmapRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequest(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequest_GetDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequest_get_PixelData(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"PixelData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileBitmapRequest_put_PixelData(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequest", L"PixelData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.PixelData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MapTileBitmapRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileBitmapRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequest[] = {
        { "pixel_data", reinterpret_cast<getter>(MapTileBitmapRequest_get_PixelData), reinterpret_cast<setter>(MapTileBitmapRequest_put_PixelData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequest) },
        { },
    };

    static PyType_Spec type_spec_MapTileBitmapRequest =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequest",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequest
    };

    // ----- MapTileBitmapRequestDeferral class --------------------

    static PyObject* _new_MapTileBitmapRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequestDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequestDeferral_Complete(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MapTileBitmapRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileBitmapRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_MapTileBitmapRequestDeferral =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequestDeferral",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequestDeferral
    };

    // ----- MapTileBitmapRequestedEventArgs class --------------------

    static PyObject* _new_MapTileBitmapRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileBitmapRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_X(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"X"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_Y(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"Y"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileBitmapRequestedEventArgs_get_FrameIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileBitmapRequestedEventArgs", L"FrameIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileBitmapRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTileBitmapRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileBitmapRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileBitmapRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_Y), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "frame_index", reinterpret_cast<getter>(MapTileBitmapRequestedEventArgs_get_FrameIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileBitmapRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileBitmapRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileBitmapRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileBitmapRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileBitmapRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapTileBitmapRequestedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileBitmapRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileBitmapRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileBitmapRequestedEventArgs
    };

    // ----- MapTileDataSource class --------------------

    static PyObject* _new_MapTileDataSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileDataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileDataSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileDataSource[] = {
        { "_assign_array_", _assign_array_MapTileDataSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileDataSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileDataSource[] = {
        { }
    };

    static PyType_Slot _type_slots_MapTileDataSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileDataSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileDataSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileDataSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileDataSource) },
        { },
    };

    static PyType_Spec type_spec_MapTileDataSource =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileDataSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileDataSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileDataSource
    };

    // ----- MapTileSource class --------------------

    static PyObject* _new_MapTileSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 2);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileSource_Pause(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_Play(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Play", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Play();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_Stop(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_ZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>(arg);

            self->obj.ZoomLevelRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_ZIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Visible(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Visible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_TilePixelSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TilePixelSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_TilePixelSize(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TilePixelSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Layer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Layer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Layer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Layer(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Layer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileLayer>(arg);

            self->obj.Layer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsTransparencyEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTransparencyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsTransparencyEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransparencyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsRetryEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRetryEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsRetryEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRetryEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_IsFadingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFadingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_IsFadingEnabled(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFadingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_DataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DataSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_DataSource(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::MapTileDataSource>(arg);

            self->obj.DataSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_Bounds(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_Bounds(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::GeoboundingBox>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AllowOverstretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowOverstretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_AllowOverstretch(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowOverstretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_FrameDuration(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_FrameDuration(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.FrameDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_FrameCount(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_FrameCount(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.FrameCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AutoPlay(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutoPlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileSource_put_AutoPlay(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoPlay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapTileSource_get_AnimationState(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AnimationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnimationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AllowOverstretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AllowOverstretchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AllowOverstretchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_BoundsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"BoundsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::BoundsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_DataSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"DataSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::DataSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsFadingEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsFadingEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsFadingEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsRetryEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsRetryEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsRetryEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_IsTransparencyEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"IsTransparencyEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::IsTransparencyEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_LayerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"LayerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::LayerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_TilePixelSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"TilePixelSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::TilePixelSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_VisibleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"VisibleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::VisibleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::ZIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_ZoomLevelRangeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"ZoomLevelRangeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::ZoomLevelRangeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AnimationStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AnimationStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AnimationStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_AutoPlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"AutoPlayProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::AutoPlayProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_FrameCountProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameCountProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::FrameCountProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileSource_get_FrameDurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileSource", L"FrameDurationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource::FrameDurationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileSource[] = {
        { "pause", reinterpret_cast<PyCFunction>(MapTileSource_Pause), METH_VARARGS, nullptr },
        { "play", reinterpret_cast<PyCFunction>(MapTileSource_Play), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MapTileSource_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileSource[] = {
        { "zoom_level_range", reinterpret_cast<getter>(MapTileSource_get_ZoomLevelRange), reinterpret_cast<setter>(MapTileSource_put_ZoomLevelRange), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(MapTileSource_get_ZIndex), reinterpret_cast<setter>(MapTileSource_put_ZIndex), nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(MapTileSource_get_Visible), reinterpret_cast<setter>(MapTileSource_put_Visible), nullptr, nullptr },
        { "tile_pixel_size", reinterpret_cast<getter>(MapTileSource_get_TilePixelSize), reinterpret_cast<setter>(MapTileSource_put_TilePixelSize), nullptr, nullptr },
        { "layer", reinterpret_cast<getter>(MapTileSource_get_Layer), reinterpret_cast<setter>(MapTileSource_put_Layer), nullptr, nullptr },
        { "is_transparency_enabled", reinterpret_cast<getter>(MapTileSource_get_IsTransparencyEnabled), reinterpret_cast<setter>(MapTileSource_put_IsTransparencyEnabled), nullptr, nullptr },
        { "is_retry_enabled", reinterpret_cast<getter>(MapTileSource_get_IsRetryEnabled), reinterpret_cast<setter>(MapTileSource_put_IsRetryEnabled), nullptr, nullptr },
        { "is_fading_enabled", reinterpret_cast<getter>(MapTileSource_get_IsFadingEnabled), reinterpret_cast<setter>(MapTileSource_put_IsFadingEnabled), nullptr, nullptr },
        { "data_source", reinterpret_cast<getter>(MapTileSource_get_DataSource), reinterpret_cast<setter>(MapTileSource_put_DataSource), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(MapTileSource_get_Bounds), reinterpret_cast<setter>(MapTileSource_put_Bounds), nullptr, nullptr },
        { "allow_overstretch", reinterpret_cast<getter>(MapTileSource_get_AllowOverstretch), reinterpret_cast<setter>(MapTileSource_put_AllowOverstretch), nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(MapTileSource_get_FrameDuration), reinterpret_cast<setter>(MapTileSource_put_FrameDuration), nullptr, nullptr },
        { "frame_count", reinterpret_cast<getter>(MapTileSource_get_FrameCount), reinterpret_cast<setter>(MapTileSource_put_FrameCount), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(MapTileSource_get_AutoPlay), reinterpret_cast<setter>(MapTileSource_put_AutoPlay), nullptr, nullptr },
        { "animation_state", reinterpret_cast<getter>(MapTileSource_get_AnimationState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileSource) },
        { },
    };

    static PyType_Spec type_spec_MapTileSource =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileSource
    };

    static PyGetSetDef getset_MapTileSource_Meta[] = {
        { "allow_overstretch_property", reinterpret_cast<getter>(MapTileSource_get_AllowOverstretchProperty), nullptr, nullptr, nullptr },
        { "bounds_property", reinterpret_cast<getter>(MapTileSource_get_BoundsProperty), nullptr, nullptr, nullptr },
        { "data_source_property", reinterpret_cast<getter>(MapTileSource_get_DataSourceProperty), nullptr, nullptr, nullptr },
        { "is_fading_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsFadingEnabledProperty), nullptr, nullptr, nullptr },
        { "is_retry_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsRetryEnabledProperty), nullptr, nullptr, nullptr },
        { "is_transparency_enabled_property", reinterpret_cast<getter>(MapTileSource_get_IsTransparencyEnabledProperty), nullptr, nullptr, nullptr },
        { "layer_property", reinterpret_cast<getter>(MapTileSource_get_LayerProperty), nullptr, nullptr, nullptr },
        { "tile_pixel_size_property", reinterpret_cast<getter>(MapTileSource_get_TilePixelSizeProperty), nullptr, nullptr, nullptr },
        { "visible_property", reinterpret_cast<getter>(MapTileSource_get_VisibleProperty), nullptr, nullptr, nullptr },
        { "z_index_property", reinterpret_cast<getter>(MapTileSource_get_ZIndexProperty), nullptr, nullptr, nullptr },
        { "zoom_level_range_property", reinterpret_cast<getter>(MapTileSource_get_ZoomLevelRangeProperty), nullptr, nullptr, nullptr },
        { "animation_state_property", reinterpret_cast<getter>(MapTileSource_get_AnimationStateProperty), nullptr, nullptr, nullptr },
        { "auto_play_property", reinterpret_cast<getter>(MapTileSource_get_AutoPlayProperty), nullptr, nullptr, nullptr },
        { "frame_count_property", reinterpret_cast<getter>(MapTileSource_get_FrameCountProperty), nullptr, nullptr, nullptr },
        { "frame_duration_property", reinterpret_cast<getter>(MapTileSource_get_FrameDurationProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_MapTileSource_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MapTileSource_Meta) },
        { }
    };

    static PyType_Spec type_spec_MapTileSource_Meta =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileSource_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MapTileSource_Meta
    };

    // ----- MapTileUriRequest class --------------------

    static PyObject* _new_MapTileUriRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequest(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequest_GetDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequest_get_Uri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapTileUriRequest_put_Uri(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MapTileUriRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MapTileUriRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileUriRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequest[] = {
        { "uri", reinterpret_cast<getter>(MapTileUriRequest_get_Uri), reinterpret_cast<setter>(MapTileUriRequest_put_Uri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequest) },
        { },
    };

    static PyType_Spec type_spec_MapTileUriRequest =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileUriRequest",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequest
    };

    // ----- MapTileUriRequestDeferral class --------------------

    static PyObject* _new_MapTileUriRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequestDeferral(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequestDeferral_Complete(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileUriRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MapTileUriRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapTileUriRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequestDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequestDeferral) },
        { },
    };

    static PyType_Spec type_spec_MapTileUriRequestDeferral =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileUriRequestDeferral",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequestDeferral
    };

    // ----- MapTileUriRequestedEventArgs class --------------------

    static PyObject* _new_MapTileUriRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MapTileUriRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapTileUriRequestedEventArgs_get_Request(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_X(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"X"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_Y(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"Y"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapTileUriRequestedEventArgs_get_FrameIndex(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.MapTileUriRequestedEventArgs", L"FrameIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapTileUriRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapTileUriRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapTileUriRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_MapTileUriRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapTileUriRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapTileUriRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "x", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_X), nullptr, nullptr, nullptr },
        { "y", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_Y), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "frame_index", reinterpret_cast<getter>(MapTileUriRequestedEventArgs_get_FrameIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapTileUriRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapTileUriRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapTileUriRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapTileUriRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapTileUriRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MapTileUriRequestedEventArgs =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapTileUriRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapTileUriRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapTileUriRequestedEventArgs
    };

    // ----- StreetsideExperience class --------------------

    static PyObject* _new_StreetsideExperience(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>(args, 0);

                winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreetsideExperience(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreetsideExperience_get_ZoomButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ZoomButtonsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomButtonsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_ZoomButtonsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ZoomButtonsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ZoomButtonsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_StreetLabelsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"StreetLabelsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StreetLabelsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_StreetLabelsVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"StreetLabelsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StreetLabelsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_OverviewMapVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"OverviewMapVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverviewMapVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_OverviewMapVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"OverviewMapVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OverviewMapVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_ExitButtonVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ExitButtonVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitButtonVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_ExitButtonVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"ExitButtonVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExitButtonVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_CursorVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"CursorVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CursorVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_CursorVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"CursorVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CursorVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreetsideExperience_get_AddressTextVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"AddressTextVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AddressTextVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreetsideExperience_put_AddressTextVisible(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsideExperience", L"AddressTextVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AddressTextVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StreetsideExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreetsideExperience(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::StreetsideExperience>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreetsideExperience[] = {
        { "_assign_array_", _assign_array_StreetsideExperience, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreetsideExperience), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreetsideExperience[] = {
        { "zoom_buttons_visible", reinterpret_cast<getter>(StreetsideExperience_get_ZoomButtonsVisible), reinterpret_cast<setter>(StreetsideExperience_put_ZoomButtonsVisible), nullptr, nullptr },
        { "street_labels_visible", reinterpret_cast<getter>(StreetsideExperience_get_StreetLabelsVisible), reinterpret_cast<setter>(StreetsideExperience_put_StreetLabelsVisible), nullptr, nullptr },
        { "overview_map_visible", reinterpret_cast<getter>(StreetsideExperience_get_OverviewMapVisible), reinterpret_cast<setter>(StreetsideExperience_put_OverviewMapVisible), nullptr, nullptr },
        { "exit_button_visible", reinterpret_cast<getter>(StreetsideExperience_get_ExitButtonVisible), reinterpret_cast<setter>(StreetsideExperience_put_ExitButtonVisible), nullptr, nullptr },
        { "cursor_visible", reinterpret_cast<getter>(StreetsideExperience_get_CursorVisible), reinterpret_cast<setter>(StreetsideExperience_put_CursorVisible), nullptr, nullptr },
        { "address_text_visible", reinterpret_cast<getter>(StreetsideExperience_get_AddressTextVisible), reinterpret_cast<setter>(StreetsideExperience_put_AddressTextVisible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreetsideExperience[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreetsideExperience) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreetsideExperience) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreetsideExperience) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreetsideExperience) },
        { },
    };

    static PyType_Spec type_spec_StreetsideExperience =
    {
        "_winrt_windows_ui_xaml_controls_maps.StreetsideExperience",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsideExperience),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreetsideExperience
    };

    // ----- StreetsidePanorama class --------------------

    static PyObject* _new_StreetsidePanorama(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>::type_name);
        return nullptr;
    }

    static void _dealloc_StreetsidePanorama(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StreetsidePanorama_FindNearbyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"FindNearbyAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama::FindNearbyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"FindNearbyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::Geopoint>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama::FindNearbyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreetsidePanorama_get_Location(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Controls.Maps.StreetsidePanorama", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StreetsidePanorama(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StreetsidePanorama(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreetsidePanorama[] = {
        { "find_nearby_async", reinterpret_cast<PyCFunction>(StreetsidePanorama_FindNearbyAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_StreetsidePanorama, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreetsidePanorama), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreetsidePanorama[] = {
        { "location", reinterpret_cast<getter>(StreetsidePanorama_get_Location), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreetsidePanorama[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StreetsidePanorama) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StreetsidePanorama) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StreetsidePanorama) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StreetsidePanorama) },
        { },
    };

    static PyType_Spec type_spec_StreetsidePanorama =
    {
        "_winrt_windows_ui_xaml_controls_maps.StreetsidePanorama",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::StreetsidePanorama),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreetsidePanorama
    };

    // ----- MapZoomLevelRange struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>* _new_MapZoomLevelRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_MapZoomLevelRange(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _Min{};
        double _Max{};

        static const char* kwlist[] = {"min", "max", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dd", const_cast<char**>(kwlist), &_Min, &_Max))
        {
            return -1;
        }

        try
        {
            self->obj = {_Min, _Max};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_MapZoomLevelRange(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MapZoomLevelRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_MapZoomLevelRange[] = {
        { "_assign_array_", _assign_array_MapZoomLevelRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* MapZoomLevelRange_get_Min(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapZoomLevelRange_set_Min(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MapZoomLevelRange_get_Max(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MapZoomLevelRange_set_Max(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MapZoomLevelRange[] = {
        { "min", reinterpret_cast<getter>(MapZoomLevelRange_get_Min), reinterpret_cast<setter>(MapZoomLevelRange_set_Min), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(MapZoomLevelRange_get_Max), reinterpret_cast<setter>(MapZoomLevelRange_set_Max), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapZoomLevelRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapZoomLevelRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_MapZoomLevelRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapZoomLevelRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapZoomLevelRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapZoomLevelRange) },
        { },
    };

    static PyType_Spec type_spec_MapZoomLevelRange =
    {
        "_winrt_windows_ui_xaml_controls_maps.MapZoomLevelRange",
        sizeof(py::wrapper::Windows::UI::Xaml::Controls::Maps::MapZoomLevelRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapZoomLevelRange
    };

    // ----- Windows.UI.Xaml.Controls.Maps Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Controls::Maps");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_controls_maps",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Controls::Maps

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_controls_maps(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Controls::Maps;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CustomMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LocalMapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapActualCameraChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapActualCameraChangingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapBillboard_Meta{PyType_FromSpec(&type_spec_MapBillboard_Meta)};
    if (!type_MapBillboard_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapBillboard, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapBillboard_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCamera, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapContextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapControl_Meta{PyType_FromSpec(&type_spec_MapControl_Meta)};
    if (!type_MapControl_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControl, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapControl_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlBusinessLandmarkRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlDataHelper, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeatureClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeaturePointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeaturePointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapControlTransitFeatureRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCustomExperience, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapCustomExperienceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElement_Meta{PyType_FromSpec(&type_spec_MapElement_Meta)};
    if (!type_MapElement_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElement_Meta.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElement3D_Meta{PyType_FromSpec(&type_spec_MapElement3D_Meta)};
    if (!type_MapElement3D_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElement3D, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElement3D_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapElementsLayer_Meta{PyType_FromSpec(&type_spec_MapElementsLayer_Meta)};
    if (!type_MapElementsLayer_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapElementsLayer_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerContextRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerPointerEnteredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapElementsLayerPointerExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapIcon_Meta{PyType_FromSpec(&type_spec_MapIcon_Meta)};
    if (!type_MapIcon_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapIcon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapIcon_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapInputEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapItemsControl_Meta{PyType_FromSpec(&type_spec_MapItemsControl_Meta)};
    if (!type_MapItemsControl_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapItemsControl, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapItemsControl_Meta.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapLayer_Meta{PyType_FromSpec(&type_spec_MapLayer_Meta)};
    if (!type_MapLayer_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapLayer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapLayer_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapModel3D, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapPolygon_Meta{PyType_FromSpec(&type_spec_MapPolygon_Meta)};
    if (!type_MapPolygon_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapPolygon, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapPolygon_Meta.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapPolyline_Meta{PyType_FromSpec(&type_spec_MapPolyline_Meta)};
    if (!type_MapPolyline_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapPolyline, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapPolyline_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapRightTappedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapRouteView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapScene, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheet, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapStyleSheetEntries_Meta{PyType_FromSpec(&type_spec_MapStyleSheetEntries_Meta)};
    if (!type_MapStyleSheetEntries_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheetEntries, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapStyleSheetEntries_Meta.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapStyleSheetEntryStates_Meta{PyType_FromSpec(&type_spec_MapStyleSheetEntryStates_Meta)};
    if (!type_MapStyleSheetEntryStates_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapStyleSheetEntryStates, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapStyleSheetEntryStates_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTargetCameraChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileBitmapRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileDataSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MapTileSource_Meta{PyType_FromSpec(&type_spec_MapTileSource_Meta)};
    if (!type_MapTileSource_Meta)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MapTileSource_Meta.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapTileUriRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StreetsideExperience, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StreetsidePanorama, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MapZoomLevelRange, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
