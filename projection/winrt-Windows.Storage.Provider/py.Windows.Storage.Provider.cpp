// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Storage.Provider.h"

namespace py::cpp::Windows::Storage::Provider
{
    // ----- CachedFileUpdater class --------------------

    static PyObject* _new_CachedFileUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::type_name);
        return nullptr;
    }

    static PyObject* CachedFileUpdater_SetUpdateInformation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.CachedFileUpdater", L"SetUpdateInformation", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Provider::ReadActivationMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Provider::WriteActivationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Provider::CachedFileOptions>(args, 4);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(param0, param1, param2, param3, param4);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdater[] = {
        { }};

    static PyGetSetDef _getset_CachedFileUpdater[] = {
        { }};

    static PyType_Slot _type_slots_CachedFileUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdater) },
        { }};

    static PyType_Spec type_spec_CachedFileUpdater = {
        "winrt._winrt_windows_storage_provider.CachedFileUpdater",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdater};

    static PyGetSetDef getset_CachedFileUpdater_Static[] = {
        { }};

    static PyMethodDef methods_CachedFileUpdater_Static[] = {
        { "set_update_information", reinterpret_cast<PyCFunction>(CachedFileUpdater_SetUpdateInformation), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_CachedFileUpdater_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CachedFileUpdater_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CachedFileUpdater_Static) },
        { }
    };

    static PyType_Spec type_spec_CachedFileUpdater_Static = {
        "winrt._winrt_windows_storage_provider.CachedFileUpdater_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CachedFileUpdater_Static};

    // ----- CachedFileUpdaterUI class --------------------

    static PyObject* _new_CachedFileUpdaterUI(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::type_name);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterUI(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterUI_GetDeferral(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Title();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CachedFileUpdaterUI_put_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"Title");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Title(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UIStatus(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UIStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateTarget(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UpdateTarget");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateTarget();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateRequest(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UpdateRequest");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UpdateRequest();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"FileUpdateRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileUpdateRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"FileUpdateRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.FileUpdateRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UIRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.UIRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterUI[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_GetDeferral), METH_VARARGS, nullptr },
        { "add_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_FileUpdateRequested), METH_O, nullptr },
        { "remove_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_FileUpdateRequested), METH_O, nullptr },
        { "add_ui_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_UIRequested), METH_O, nullptr },
        { "remove_ui_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_UIRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CachedFileUpdaterUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterUI), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CachedFileUpdaterUI[] = {
        { "title", reinterpret_cast<getter>(CachedFileUpdaterUI_get_Title), reinterpret_cast<setter>(CachedFileUpdaterUI_put_Title), nullptr, nullptr },
        { "ui_status", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UIStatus), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateTarget), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateRequest), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CachedFileUpdaterUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterUI) },
        { }};

    static PyType_Spec type_spec_CachedFileUpdaterUI = {
        "winrt._winrt_windows_storage_provider.CachedFileUpdaterUI",
        sizeof(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterUI};

    // ----- FileUpdateRequest class --------------------

    static PyObject* _new_FileUpdateRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequest(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequest_GetDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_UpdateLocalFile(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UpdateLocalFile", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdateLocalFile(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::FileUpdateStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileUpdateRequest_get_ContentId(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"ContentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_File(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"File");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.File();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UserInputNeededMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserInputNeededMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UserInputNeededMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.UserInputNeededMessage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(FileUpdateRequest_GetDeferral), METH_VARARGS, nullptr },
        { "update_local_file", reinterpret_cast<PyCFunction>(FileUpdateRequest_UpdateLocalFile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileUpdateRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileUpdateRequest[] = {
        { "status", reinterpret_cast<getter>(FileUpdateRequest_get_Status), reinterpret_cast<setter>(FileUpdateRequest_put_Status), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(FileUpdateRequest_get_ContentId), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileUpdateRequest_get_File), nullptr, nullptr, nullptr },
        { "user_input_needed_message", reinterpret_cast<getter>(FileUpdateRequest_get_UserInputNeededMessage), reinterpret_cast<setter>(FileUpdateRequest_put_UserInputNeededMessage), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileUpdateRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequest) },
        { }};

    static PyType_Spec type_spec_FileUpdateRequest = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequest",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequest};

    // ----- FileUpdateRequestDeferral class --------------------

    static PyObject* _new_FileUpdateRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestDeferral_Complete(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequestDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(FileUpdateRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileUpdateRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileUpdateRequestDeferral[] = {
        { }};

    static PyType_Slot _type_slots_FileUpdateRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequestDeferral) },
        { }};

    static PyType_Spec type_spec_FileUpdateRequestDeferral = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestDeferral};

    // ----- FileUpdateRequestedEventArgs class --------------------

    static PyObject* _new_FileUpdateRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestedEventArgs(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_FileUpdateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_FileUpdateRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(FileUpdateRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_FileUpdateRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_FileUpdateRequestedEventArgs = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestedEventArgs};

    // ----- StorageProviderFileTypeInfo class --------------------

    static PyObject* _new_StorageProviderFileTypeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderFileTypeInfo_get_FileExtension(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderFileTypeInfo", L"FileExtension");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileExtension();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderFileTypeInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderFileTypeInfo", L"IconResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IconResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderFileTypeInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderFileTypeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderFileTypeInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderFileTypeInfo[] = {
        { "file_extension", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_FileExtension), nullptr, nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_IconResource), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderFileTypeInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderFileTypeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderFileTypeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderFileTypeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderFileTypeInfo) },
        { }};

    static PyType_Spec type_spec_StorageProviderFileTypeInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderFileTypeInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderFileTypeInfo};

    // ----- StorageProviderGetContentInfoForPathResult class --------------------

    static PyObject* _new_StorageProviderGetContentInfoForPathResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetContentInfoForPathResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetContentInfoForPathResult[] = {
        { "_assign_array_", _assign_array_StorageProviderGetContentInfoForPathResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetContentInfoForPathResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderGetContentInfoForPathResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_Status), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_Status), nullptr, nullptr },
        { "content_uri", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentUri), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentUri), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentId), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentId), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderGetContentInfoForPathResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderGetContentInfoForPathResult) },
        { }};

    static PyType_Spec type_spec_StorageProviderGetContentInfoForPathResult = {
        "winrt._winrt_windows_storage_provider.StorageProviderGetContentInfoForPathResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetContentInfoForPathResult};

    // ----- StorageProviderGetPathForContentUriResult class --------------------

    static PyObject* _new_StorageProviderGetPathForContentUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetPathForContentUriResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Path(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetPathForContentUriResult[] = {
        { "_assign_array_", _assign_array_StorageProviderGetPathForContentUriResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetPathForContentUriResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderGetPathForContentUriResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Status), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Status), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Path), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Path), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderGetPathForContentUriResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderGetPathForContentUriResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderGetPathForContentUriResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderGetPathForContentUriResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderGetPathForContentUriResult) },
        { }};

    static PyType_Spec type_spec_StorageProviderGetPathForContentUriResult = {
        "winrt._winrt_windows_storage_provider.StorageProviderGetPathForContentUriResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetPathForContentUriResult};

    // ----- StorageProviderItemProperties class --------------------

    static PyObject* _new_StorageProviderItemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::type_name);
        return nullptr;
    }

    static PyObject* StorageProviderItemProperties_SetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderItemProperties", L"SetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::Provider::StorageProviderItemProperties::SetAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperties[] = {
        { }};

    static PyGetSetDef _getset_StorageProviderItemProperties[] = {
        { }};

    static PyType_Slot _type_slots_StorageProviderItemProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemProperties) },
        { }};

    static PyType_Spec type_spec_StorageProviderItemProperties = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperties};

    static PyGetSetDef getset_StorageProviderItemProperties_Static[] = {
        { }};

    static PyMethodDef methods_StorageProviderItemProperties_Static[] = {
        { "set_async", reinterpret_cast<PyCFunction>(StorageProviderItemProperties_SetAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StorageProviderItemProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageProviderItemProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageProviderItemProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderItemProperties_Static = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageProviderItemProperties_Static};

    // ----- StorageProviderItemProperty class --------------------

    static PyObject* _new_StorageProviderItemProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemProperty instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemProperty(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemProperty_get_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"IconResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IconResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"IconResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.IconResource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperty[] = {
        { "_assign_array_", _assign_array_StorageProviderItemProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemProperty), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderItemProperty[] = {
        { "value", reinterpret_cast<getter>(StorageProviderItemProperty_get_Value), reinterpret_cast<setter>(StorageProviderItemProperty_put_Value), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderItemProperty_get_Id), reinterpret_cast<setter>(StorageProviderItemProperty_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderItemProperty_get_IconResource), reinterpret_cast<setter>(StorageProviderItemProperty_put_IconResource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderItemProperty[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderItemProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemProperty) },
        { }};

    static PyType_Spec type_spec_StorageProviderItemProperty = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperty",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperty};

    // ----- StorageProviderItemPropertyDefinition class --------------------

    static PyObject* _new_StorageProviderItemPropertyDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemPropertyDefinition(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"DisplayNameResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayNameResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"DisplayNameResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayNameResource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemPropertyDefinition[] = {
        { "_assign_array_", _assign_array_StorageProviderItemPropertyDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemPropertyDefinition), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderItemPropertyDefinition[] = {
        { "id", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_Id), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_Id), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_DisplayNameResource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderItemPropertyDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemPropertyDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderItemPropertyDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemPropertyDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemPropertyDefinition) },
        { }};

    static PyType_Spec type_spec_StorageProviderItemPropertyDefinition = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemPropertyDefinition",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemPropertyDefinition};

    // ----- StorageProviderKnownFolderEntry class --------------------

    static PyObject* _new_StorageProviderKnownFolderEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderKnownFolderEntry(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderEntry_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderEntry_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderEntry_get_KnownFolderId(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"KnownFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownFolderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderEntry_put_KnownFolderId(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"KnownFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.KnownFolderId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderEntry[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderEntry), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderKnownFolderEntry[] = {
        { "status", reinterpret_cast<getter>(StorageProviderKnownFolderEntry_get_Status), reinterpret_cast<setter>(StorageProviderKnownFolderEntry_put_Status), nullptr, nullptr },
        { "known_folder_id", reinterpret_cast<getter>(StorageProviderKnownFolderEntry_get_KnownFolderId), reinterpret_cast<setter>(StorageProviderKnownFolderEntry_put_KnownFolderId), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderKnownFolderEntry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderEntry) },
        { }};

    static PyType_Spec type_spec_StorageProviderKnownFolderEntry = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderEntry",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderEntry};

    // ----- StorageProviderKnownFolderSyncInfo class --------------------

    static PyObject* _new_StorageProviderKnownFolderSyncInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderKnownFolderSyncInfo(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_SyncRequested(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"SyncRequested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SyncRequested();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderSyncInfo_put_SyncRequested(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"SyncRequested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler>(arg);

            {
                auto _gil = release_gil();
                self->obj.SyncRequested(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_ProviderDisplayName(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"ProviderDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderDisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderSyncInfo_put_ProviderDisplayName(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"ProviderDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderDisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_KnownFolderEntries(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"KnownFolderEntries");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownFolderEntries();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderSyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderSyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderSyncInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderSyncInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderSyncInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderKnownFolderSyncInfo[] = {
        { "sync_requested", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_SyncRequested), reinterpret_cast<setter>(StorageProviderKnownFolderSyncInfo_put_SyncRequested), nullptr, nullptr },
        { "provider_display_name", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_ProviderDisplayName), reinterpret_cast<setter>(StorageProviderKnownFolderSyncInfo_put_ProviderDisplayName), nullptr, nullptr },
        { "known_folder_entries", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_KnownFolderEntries), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderKnownFolderSyncInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderSyncInfo) },
        { }};

    static PyType_Spec type_spec_StorageProviderKnownFolderSyncInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderSyncInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderSyncInfo};

    // ----- StorageProviderKnownFolderSyncRequestArgs class --------------------

    static PyObject* _new_StorageProviderKnownFolderSyncRequestArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageProviderKnownFolderSyncRequestArgs(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderSyncRequestArgs_get_KnownFolders(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncRequestArgs", L"KnownFolders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownFolders();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncRequestArgs_get_Source(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncRequestArgs", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderSyncRequestArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderSyncRequestArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderSyncRequestArgs[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderSyncRequestArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderSyncRequestArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderKnownFolderSyncRequestArgs[] = {
        { "known_folders", reinterpret_cast<getter>(StorageProviderKnownFolderSyncRequestArgs_get_KnownFolders), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(StorageProviderKnownFolderSyncRequestArgs_get_Source), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderKnownFolderSyncRequestArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderSyncRequestArgs) },
        { }};

    static PyType_Spec type_spec_StorageProviderKnownFolderSyncRequestArgs = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderSyncRequestArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderSyncRequestArgs};

    // ----- StorageProviderMoreInfoUI class --------------------

    static PyObject* _new_StorageProviderMoreInfoUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderMoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderMoreInfoUI_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Message(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderMoreInfoUI_get_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Command();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Command");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.Command(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderMoreInfoUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderMoreInfoUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderMoreInfoUI[] = {
        { "_assign_array_", _assign_array_StorageProviderMoreInfoUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderMoreInfoUI), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderMoreInfoUI[] = {
        { "message", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Message), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Message), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Command), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Command), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderMoreInfoUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderMoreInfoUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderMoreInfoUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderMoreInfoUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderMoreInfoUI) },
        { }};

    static PyType_Spec type_spec_StorageProviderMoreInfoUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderMoreInfoUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderMoreInfoUI};

    // ----- StorageProviderQuotaUI class --------------------

    static PyObject* _new_StorageProviderQuotaUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderQuotaUI instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderQuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedLabel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuotaUsedLabel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedLabel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuotaUsedLabel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuotaUsedInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuotaUsedInBytes(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuotaUsedColor();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuotaUsedColor(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaTotalInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuotaTotalInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaTotalInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuotaTotalInBytes(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderQuotaUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderQuotaUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderQuotaUI[] = {
        { "_assign_array_", _assign_array_StorageProviderQuotaUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderQuotaUI), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderQuotaUI[] = {
        { "quota_used_label", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedLabel), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedLabel), nullptr, nullptr },
        { "quota_used_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedInBytes), nullptr, nullptr },
        { "quota_used_color", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedColor), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedColor), nullptr, nullptr },
        { "quota_total_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaTotalInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaTotalInBytes), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderQuotaUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderQuotaUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderQuotaUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderQuotaUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderQuotaUI) },
        { }};

    static PyType_Spec type_spec_StorageProviderQuotaUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderQuotaUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderQuotaUI};

    // ----- StorageProviderStatusUI class --------------------

    static PyObject* _new_StorageProviderStatusUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderStatusUI instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderStatusUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderStatusUI_get_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"SyncStatusCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SyncStatusCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"SyncStatusCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.SyncStatusCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"QuotaUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.QuotaUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"QuotaUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>(arg);

            {
                auto _gil = release_gil();
                self->obj.QuotaUI(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateLabel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderStateLabel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateLabel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderStateLabel(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateIcon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderStateIcon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateIcon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderStateIcon(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderSecondaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderSecondaryCommands();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderSecondaryCommands");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderSecondaryCommands(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderPrimaryCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderPrimaryCommand();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderPrimaryCommand");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderPrimaryCommand(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"MoreInfoUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MoreInfoUI();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"MoreInfoUI");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>(arg);

            {
                auto _gil = release_gil();
                self->obj.MoreInfoUI(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderStatusUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderStatusUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderStatusUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderStatusUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderStatusUI[] = {
        { "_assign_array_", _assign_array_StorageProviderStatusUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderStatusUI), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderStatusUI[] = {
        { "sync_status_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_SyncStatusCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_SyncStatusCommand), nullptr, nullptr },
        { "quota_ui", reinterpret_cast<getter>(StorageProviderStatusUI_get_QuotaUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_QuotaUI), nullptr, nullptr },
        { "provider_state_label", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateLabel), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateLabel), nullptr, nullptr },
        { "provider_state_icon", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateIcon), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateIcon), nullptr, nullptr },
        { "provider_state", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderState), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderState), nullptr, nullptr },
        { "provider_secondary_commands", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderSecondaryCommands), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderSecondaryCommands), nullptr, nullptr },
        { "provider_primary_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderPrimaryCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderPrimaryCommand), nullptr, nullptr },
        { "more_info_ui", reinterpret_cast<getter>(StorageProviderStatusUI_get_MoreInfoUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_MoreInfoUI), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderStatusUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderStatusUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderStatusUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderStatusUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderStatusUI) },
        { }};

    static PyType_Spec type_spec_StorageProviderStatusUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderStatusUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderStatusUI};

    // ----- StorageProviderSyncRootInfo class --------------------

    static PyObject* _new_StorageProviderSyncRootInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderSyncRootInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderSyncRootInfo_get_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Version();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Version(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ShowSiblingsAsGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowSiblingsAsGroup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ShowSiblingsAsGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowSiblingsAsGroup(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"RecycleBinUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecycleBinUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"RecycleBinUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.RecycleBinUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProtectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProtectionMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProtectionMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProtectionMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"PopulationPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PopulationPolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"PopulationPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.PopulationPolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            {
                auto _gil = release_gil();
                self->obj.Path(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"InSyncPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InSyncPolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"InSyncPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.InSyncPolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"IconResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IconResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"IconResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.IconResource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicyModifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HydrationPolicyModifier();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicyModifier");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(arg);

            {
                auto _gil = release_gil();
                self->obj.HydrationPolicyModifier(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HydrationPolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.HydrationPolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HardlinkPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HardlinkPolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HardlinkPolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.HardlinkPolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"DisplayNameResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayNameResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"DisplayNameResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayNameResource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Context");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Context();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Context");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            {
                auto _gil = release_gil();
                self->obj.Context(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"AllowPinning");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowPinning();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"AllowPinning");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowPinning(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"StorageProviderItemPropertyDefinitions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StorageProviderItemPropertyDefinitions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProviderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProviderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProviderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProviderId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_FallbackFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"FallbackFileTypeInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FallbackFileTypeInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderSyncRootInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderSyncRootInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_StorageProviderSyncRootInfo[] = {
        { "version", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Version), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Version), nullptr, nullptr },
        { "show_siblings_as_group", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup), nullptr, nullptr },
        { "recycle_bin_uri", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_RecycleBinUri), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_RecycleBinUri), nullptr, nullptr },
        { "protection_mode", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProtectionMode), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProtectionMode), nullptr, nullptr },
        { "population_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_PopulationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_PopulationPolicy), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Path), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Path), nullptr, nullptr },
        { "in_sync_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_InSyncPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_InSyncPolicy), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Id), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_IconResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_IconResource), nullptr, nullptr },
        { "hydration_policy_modifier", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicyModifier), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicyModifier), nullptr, nullptr },
        { "hydration_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicy), nullptr, nullptr },
        { "hardlink_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HardlinkPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HardlinkPolicy), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_DisplayNameResource), nullptr, nullptr },
        { "context", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Context), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Context), nullptr, nullptr },
        { "allow_pinning", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_AllowPinning), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_AllowPinning), nullptr, nullptr },
        { "storage_provider_item_property_definitions", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProviderId), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProviderId), nullptr, nullptr },
        { "fallback_file_type_info", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_FallbackFileTypeInfo), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_StorageProviderSyncRootInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderSyncRootInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderSyncRootInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderSyncRootInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderSyncRootInfo) },
        { }};

    static PyType_Spec type_spec_StorageProviderSyncRootInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootInfo};

    // ----- StorageProviderSyncRootManager class --------------------

    static PyObject* _new_StorageProviderSyncRootManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::type_name);
        return nullptr;
    }

    static PyObject* StorageProviderSyncRootManager_GetCurrentSyncRoots(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetCurrentSyncRoots", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetCurrentSyncRoots();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetSyncRootInformationForFolder", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForFolder(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetSyncRootInformationForId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"Register", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Register(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"Unregister", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Unregister(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootManager[] = {
        { }};

    static PyGetSetDef _getset_StorageProviderSyncRootManager[] = {
        { }};

    static PyType_Slot _type_slots_StorageProviderSyncRootManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderSyncRootManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderSyncRootManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderSyncRootManager) },
        { }};

    static PyType_Spec type_spec_StorageProviderSyncRootManager = {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootManager};

    static PyGetSetDef getset_StorageProviderSyncRootManager_Static[] = {
        { }};

    static PyMethodDef methods_StorageProviderSyncRootManager_Static[] = {
        { "get_current_sync_roots", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetCurrentSyncRoots), METH_VARARGS, nullptr },
        { "get_sync_root_information_for_folder", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForFolder), METH_VARARGS, nullptr },
        { "get_sync_root_information_for_id", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForId), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_IsSupported), METH_VARARGS, nullptr },
        { "register", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Unregister), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_StorageProviderSyncRootManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageProviderSyncRootManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageProviderSyncRootManager_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderSyncRootManager_Static = {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageProviderSyncRootManager_Static};

    // ----- IStorageProviderItemPropertySource interface --------------------

    static PyObject* _new_IStorageProviderItemPropertySource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderItemPropertySource(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderItemPropertySource_GetItemProperties(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderItemPropertySource", L"GetItemProperties", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetItemProperties(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderItemPropertySource[] = {
        { "get_item_properties", reinterpret_cast<PyCFunction>(IStorageProviderItemPropertySource_GetItemProperties), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderItemPropertySource[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderItemPropertySource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderItemPropertySource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderItemPropertySource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderItemPropertySource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderItemPropertySource) },
        { }};

    static PyType_Spec type_spec_IStorageProviderItemPropertySource = {
        "winrt._winrt_windows_storage_provider._IStorageProviderItemPropertySource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderItemPropertySource};

    struct ImplementsIStorageProviderItemPropertySource : py::ImplementsInterfaceT<ImplementsIStorageProviderItemPropertySource, winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>
    {
        ImplementsIStorageProviderItemPropertySource() = delete;
        ImplementsIStorageProviderItemPropertySource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderItemPropertySource, winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>(py_obj, runtime_class)
        {
        }

        auto GetItemProperties(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_item_properties")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderItemPropertySource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderItemPropertySource[] = {
        { "_assign_array_", _assign_array_IStorageProviderItemPropertySource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderItemPropertySource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderItemPropertySource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderItemPropertySource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderItemPropertySource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderItemPropertySource) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderItemPropertySource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderItemPropertySource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderItemPropertySource};

    // ----- IStorageProviderKnownFolderSyncInfoSource interface --------------------

    static PyObject* _new_IStorageProviderKnownFolderSyncInfoSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderKnownFolderSyncInfoSource(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_GetKnownFolderSyncInfo(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"GetKnownFolderSyncInfo", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetKnownFolderSyncInfo();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_add_KnownFolderSyncInfoChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"KnownFolderSyncInfoChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownFolderSyncInfoChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_remove_KnownFolderSyncInfoChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"KnownFolderSyncInfoChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.KnownFolderSyncInfoChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderKnownFolderSyncInfoSource[] = {
        { "get_known_folder_sync_info", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_GetKnownFolderSyncInfo), METH_VARARGS, nullptr },
        { "add_known_folder_sync_info_changed", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_add_KnownFolderSyncInfoChanged), METH_O, nullptr },
        { "remove_known_folder_sync_info_changed", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_remove_KnownFolderSyncInfoChanged), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderKnownFolderSyncInfoSource[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderKnownFolderSyncInfoSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderKnownFolderSyncInfoSource) },
        { }};

    static PyType_Spec type_spec_IStorageProviderKnownFolderSyncInfoSource = {
        "winrt._winrt_windows_storage_provider._IStorageProviderKnownFolderSyncInfoSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderKnownFolderSyncInfoSource};

    struct ImplementsIStorageProviderKnownFolderSyncInfoSource : py::ImplementsInterfaceT<ImplementsIStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>
    {
        ImplementsIStorageProviderKnownFolderSyncInfoSource() = delete;
        ImplementsIStorageProviderKnownFolderSyncInfoSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>(py_obj, runtime_class)
        {
        }

        auto GetKnownFolderSyncInfo()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_known_folder_sync_info")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto KnownFolderSyncInfoChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_known_folder_sync_info_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto KnownFolderSyncInfoChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_known_folder_sync_info_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderKnownFolderSyncInfoSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderKnownFolderSyncInfoSource[] = {
        { "_assign_array_", _assign_array_IStorageProviderKnownFolderSyncInfoSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderKnownFolderSyncInfoSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderKnownFolderSyncInfoSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderKnownFolderSyncInfoSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderKnownFolderSyncInfoSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderKnownFolderSyncInfoSource) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderKnownFolderSyncInfoSource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderKnownFolderSyncInfoSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderKnownFolderSyncInfoSource};

    // ----- IStorageProviderKnownFolderSyncInfoSourceFactory interface --------------------

    static PyObject* _new_IStorageProviderKnownFolderSyncInfoSourceFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderKnownFolderSyncInfoSourceFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSourceFactory_GetKnownFolderSyncInfoSource(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSourceFactory", L"GetKnownFolderSyncInfoSource", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetKnownFolderSyncInfoSource();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { "get_known_folder_sync_info_source", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSourceFactory_GetKnownFolderSyncInfoSource), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { }};

    static PyType_Spec type_spec_IStorageProviderKnownFolderSyncInfoSourceFactory = {
        "winrt._winrt_windows_storage_provider._IStorageProviderKnownFolderSyncInfoSourceFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderKnownFolderSyncInfoSourceFactory};

    struct ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory : py::ImplementsInterfaceT<ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>
    {
        ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory() = delete;
        ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory, winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>(py_obj, runtime_class)
        {
        }

        auto GetKnownFolderSyncInfoSource()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_known_folder_sync_info_source")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { "_assign_array_", _assign_array_IStorageProviderKnownFolderSyncInfoSourceFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderKnownFolderSyncInfoSourceFactory), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory = {
        "winrt._winrt_windows_storage_provider.IStorageProviderKnownFolderSyncInfoSourceFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory};

    // ----- IStorageProviderPropertyCapabilities interface --------------------

    static PyObject* _new_IStorageProviderPropertyCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderPropertyCapabilities(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderPropertyCapabilities_IsPropertySupported(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderPropertyCapabilities", L"IsPropertySupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IsPropertySupported(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderPropertyCapabilities[] = {
        { "is_property_supported", reinterpret_cast<PyCFunction>(IStorageProviderPropertyCapabilities_IsPropertySupported), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderPropertyCapabilities[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderPropertyCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderPropertyCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderPropertyCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderPropertyCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderPropertyCapabilities) },
        { }};

    static PyType_Spec type_spec_IStorageProviderPropertyCapabilities = {
        "winrt._winrt_windows_storage_provider._IStorageProviderPropertyCapabilities",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderPropertyCapabilities};

    struct ImplementsIStorageProviderPropertyCapabilities : py::ImplementsInterfaceT<ImplementsIStorageProviderPropertyCapabilities, winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>
    {
        ImplementsIStorageProviderPropertyCapabilities() = delete;
        ImplementsIStorageProviderPropertyCapabilities(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderPropertyCapabilities, winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>(py_obj, runtime_class)
        {
        }

        auto IsPropertySupported(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "is_property_supported")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<bool>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderPropertyCapabilities>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderPropertyCapabilities[] = {
        { "_assign_array_", _assign_array_IStorageProviderPropertyCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderPropertyCapabilities), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderPropertyCapabilities), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderPropertyCapabilities), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderPropertyCapabilities[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderPropertyCapabilities) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderPropertyCapabilities = {
        "winrt._winrt_windows_storage_provider.IStorageProviderPropertyCapabilities",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderPropertyCapabilities};

    // ----- IStorageProviderShareLinkSource interface --------------------

    static PyObject* _new_IStorageProviderShareLinkSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderShareLinkSource(py::wrapper::Windows::Storage::Provider::IStorageProviderShareLinkSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderShareLinkSource_CreateLinkAsync(py::wrapper::Windows::Storage::Provider::IStorageProviderShareLinkSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderShareLinkSource", L"CreateLinkAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateLinkAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderShareLinkSource_GetDefaultAccessControlStringAsync(py::wrapper::Windows::Storage::Provider::IStorageProviderShareLinkSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderShareLinkSource", L"GetDefaultAccessControlStringAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDefaultAccessControlStringAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderShareLinkSource_GetState(py::wrapper::Windows::Storage::Provider::IStorageProviderShareLinkSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderShareLinkSource", L"GetState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetState(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderShareLinkSource[] = {
        { "create_link_async", reinterpret_cast<PyCFunction>(IStorageProviderShareLinkSource_CreateLinkAsync), METH_VARARGS, nullptr },
        { "get_default_access_control_string_async", reinterpret_cast<PyCFunction>(IStorageProviderShareLinkSource_GetDefaultAccessControlStringAsync), METH_VARARGS, nullptr },
        { "get_state", reinterpret_cast<PyCFunction>(IStorageProviderShareLinkSource_GetState), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderShareLinkSource[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderShareLinkSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderShareLinkSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderShareLinkSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderShareLinkSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderShareLinkSource) },
        { }};

    static PyType_Spec type_spec_IStorageProviderShareLinkSource = {
        "winrt._winrt_windows_storage_provider._IStorageProviderShareLinkSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderShareLinkSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderShareLinkSource};

    struct ImplementsIStorageProviderShareLinkSource : py::ImplementsInterfaceT<ImplementsIStorageProviderShareLinkSource, winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>
    {
        ImplementsIStorageProviderShareLinkSource() = delete;
        ImplementsIStorageProviderShareLinkSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderShareLinkSource, winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>(py_obj, runtime_class)
        {
        }

        auto CreateLinkAsync(winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_link_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Foundation::Uri>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetDefaultAccessControlStringAsync(winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_default_access_control_string_async")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::hstring>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetState(winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::Storage::IStorageItem> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_state")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IAsyncOperation<winrt::Windows::Storage::Provider::StorageProviderShareLinkState>>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderShareLinkSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderShareLinkSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderShareLinkSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderShareLinkSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderShareLinkSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderShareLinkSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderShareLinkSource[] = {
        { "_assign_array_", _assign_array_IStorageProviderShareLinkSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderShareLinkSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderShareLinkSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderShareLinkSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderShareLinkSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderShareLinkSource) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderShareLinkSource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderShareLinkSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderShareLinkSource};

    // ----- IStorageProviderStatusUISource interface --------------------

    static PyObject* _new_IStorageProviderStatusUISource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISource_GetStatusUI(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"GetStatusUI", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStatusUI();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_add_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"StatusUIChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusUIChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_remove_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"StatusUIChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.StatusUIChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISource[] = {
        { "get_status_ui", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_GetStatusUI), METH_VARARGS, nullptr },
        { "add_status_ui_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_add_StatusUIChanged), METH_O, nullptr },
        { "remove_status_ui_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_remove_StatusUIChanged), METH_O, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderStatusUISource[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderStatusUISource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderStatusUISource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderStatusUISource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderStatusUISource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderStatusUISource) },
        { }};

    static PyType_Spec type_spec_IStorageProviderStatusUISource = {
        "winrt._winrt_windows_storage_provider._IStorageProviderStatusUISource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISource};

    struct ImplementsIStorageProviderStatusUISource : py::ImplementsInterfaceT<ImplementsIStorageProviderStatusUISource, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>
    {
        ImplementsIStorageProviderStatusUISource() = delete;
        ImplementsIStorageProviderStatusUISource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderStatusUISource, winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>(py_obj, runtime_class)
        {
        }

        auto GetStatusUI()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_status_ui")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::StorageProviderStatusUI>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StatusUIChanged(winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "add_status_ui_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::event_token>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto StatusUIChanged(winrt::event_token param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "remove_status_ui_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderStatusUISource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderStatusUISource[] = {
        { "_assign_array_", _assign_array_IStorageProviderStatusUISource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderStatusUISource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderStatusUISource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderStatusUISource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderStatusUISource) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderStatusUISource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderStatusUISource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderStatusUISource};

    // ----- IStorageProviderStatusUISourceFactory interface --------------------

    static PyObject* _new_IStorageProviderStatusUISourceFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISourceFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISourceFactory_GetStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISourceFactory", L"GetStatusUISource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetStatusUISource(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISourceFactory[] = {
        { "get_status_ui_source", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISourceFactory_GetStatusUISource), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderStatusUISourceFactory[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderStatusUISourceFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderStatusUISourceFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderStatusUISourceFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderStatusUISourceFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderStatusUISourceFactory) },
        { }};

    static PyType_Spec type_spec_IStorageProviderStatusUISourceFactory = {
        "winrt._winrt_windows_storage_provider._IStorageProviderStatusUISourceFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISourceFactory};

    struct ImplementsIStorageProviderStatusUISourceFactory : py::ImplementsInterfaceT<ImplementsIStorageProviderStatusUISourceFactory, winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>
    {
        ImplementsIStorageProviderStatusUISourceFactory() = delete;
        ImplementsIStorageProviderStatusUISourceFactory(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderStatusUISourceFactory, winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>(py_obj, runtime_class)
        {
        }

        auto GetStatusUISource(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_status_ui_source")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderStatusUISourceFactory>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderStatusUISourceFactory[] = {
        { "_assign_array_", _assign_array_IStorageProviderStatusUISourceFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISourceFactory), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderStatusUISourceFactory), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderStatusUISourceFactory), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderStatusUISourceFactory[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderStatusUISourceFactory) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderStatusUISourceFactory = {
        "winrt._winrt_windows_storage_provider.IStorageProviderStatusUISourceFactory",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderStatusUISourceFactory};

    // ----- IStorageProviderUICommand interface --------------------

    static PyObject* _new_IStorageProviderUICommand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUICommand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUICommand>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUICommand(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUICommand_Invoke(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Invoke();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Description(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Icon(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Icon");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Icon();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Label(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Label");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Label();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_State(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUICommand[] = {
        { "invoke", reinterpret_cast<PyCFunction>(IStorageProviderUICommand_Invoke), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderUICommand[] = {
        { "description", reinterpret_cast<getter>(IStorageProviderUICommand_get_Description), nullptr, nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(IStorageProviderUICommand_get_Icon), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IStorageProviderUICommand_get_Label), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IStorageProviderUICommand_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IStorageProviderUICommand[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderUICommand) },
        { }};

    static PyType_Spec type_spec_IStorageProviderUICommand = {
        "winrt._winrt_windows_storage_provider._IStorageProviderUICommand",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUICommand};

    struct ImplementsIStorageProviderUICommand : py::ImplementsInterfaceT<ImplementsIStorageProviderUICommand, winrt::Windows::Storage::Provider::IStorageProviderUICommand>
    {
        ImplementsIStorageProviderUICommand() = delete;
        ImplementsIStorageProviderUICommand(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderUICommand, winrt::Windows::Storage::Provider::IStorageProviderUICommand>(py_obj, runtime_class)
        {
        }

        auto Invoke()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "invoke")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Description()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "description")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Icon()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "icon")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Uri>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Label()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "label")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::hstring>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto State()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "state")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUICommandState>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderUICommand(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderUICommand(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderUICommand>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderUICommand[] = {
        { "_assign_array_", _assign_array_IStorageProviderUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUICommand), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderUICommand), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderUICommand), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderUICommand[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderUICommand) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderUICommand = {
        "winrt._winrt_windows_storage_provider.IStorageProviderUICommand",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderUICommand};

    // ----- IStorageProviderUriSource interface --------------------

    static PyObject* _new_IStorageProviderUriSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUriSource(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUriSource_GetContentInfoForPath(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUriSource", L"GetContentInfoForPath", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.GetContentInfoForPath(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUriSource_GetPathForContentUri(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUriSource", L"GetPathForContentUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.GetPathForContentUri(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUriSource[] = {
        { "get_content_info_for_path", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetContentInfoForPath), METH_VARARGS, nullptr },
        { "get_path_for_content_uri", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetPathForContentUri), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IStorageProviderUriSource[] = {
        { }};

    static PyType_Slot _type_slots_IStorageProviderUriSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderUriSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderUriSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderUriSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderUriSource) },
        { }};

    static PyType_Spec type_spec_IStorageProviderUriSource = {
        "winrt._winrt_windows_storage_provider._IStorageProviderUriSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUriSource};

    struct ImplementsIStorageProviderUriSource : py::ImplementsInterfaceT<ImplementsIStorageProviderUriSource, winrt::Windows::Storage::Provider::IStorageProviderUriSource>
    {
        ImplementsIStorageProviderUriSource() = delete;
        ImplementsIStorageProviderUriSource(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIStorageProviderUriSource, winrt::Windows::Storage::Provider::IStorageProviderUriSource>(py_obj, runtime_class)
        {
        }

        auto GetContentInfoForPath(winrt::hstring const& param0, winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_content_info_for_path")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetPathForContentUri(winrt::hstring const& param0, winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_path_for_content_uri")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderUriSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIStorageProviderUriSource(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIStorageProviderUriSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIStorageProviderUriSource>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIStorageProviderUriSource[] = {
        { "_assign_array_", _assign_array_IStorageProviderUriSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUriSource), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIStorageProviderUriSource), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIStorageProviderUriSource), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIStorageProviderUriSource[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIStorageProviderUriSource) },
        { }};

    static PyType_Spec type_spec_ImplementsIStorageProviderUriSource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderUriSource",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIStorageProviderUriSource};

    // ----- Windows.Storage.Provider Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Storage.Provider");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_storage_provider",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Storage::Provider

PyMODINIT_FUNC PyInit__winrt_windows_storage_provider(void) noexcept
{
    using namespace py::cpp::Windows::Storage::Provider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CachedFileUpdater_Static{PyType_FromSpec(&type_spec_CachedFileUpdater_Static)};
    if (!type_CachedFileUpdater_Static)
    {
        return nullptr;
    }

    py::pytype_handle CachedFileUpdater_type{py::register_python_type(module.get(), &type_spec_CachedFileUpdater, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CachedFileUpdater_Static.get()))};
    if (!CachedFileUpdater_type)
    {
        return nullptr;
    }

    py::pytype_handle CachedFileUpdaterUI_type{py::register_python_type(module.get(), &type_spec_CachedFileUpdaterUI, object_bases.get(), nullptr)};
    if (!CachedFileUpdaterUI_type)
    {
        return nullptr;
    }

    py::pytype_handle FileUpdateRequest_type{py::register_python_type(module.get(), &type_spec_FileUpdateRequest, object_bases.get(), nullptr)};
    if (!FileUpdateRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle FileUpdateRequestDeferral_type{py::register_python_type(module.get(), &type_spec_FileUpdateRequestDeferral, object_bases.get(), nullptr)};
    if (!FileUpdateRequestDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle FileUpdateRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_FileUpdateRequestedEventArgs, object_bases.get(), nullptr)};
    if (!FileUpdateRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderFileTypeInfo_type{py::register_python_type(module.get(), &type_spec_StorageProviderFileTypeInfo, object_bases.get(), nullptr)};
    if (!StorageProviderFileTypeInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderGetContentInfoForPathResult_type{py::register_python_type(module.get(), &type_spec_StorageProviderGetContentInfoForPathResult, object_bases.get(), nullptr)};
    if (!StorageProviderGetContentInfoForPathResult_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderGetPathForContentUriResult_type{py::register_python_type(module.get(), &type_spec_StorageProviderGetPathForContentUriResult, object_bases.get(), nullptr)};
    if (!StorageProviderGetPathForContentUriResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageProviderItemProperties_Static{PyType_FromSpec(&type_spec_StorageProviderItemProperties_Static)};
    if (!type_StorageProviderItemProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderItemProperties_type{py::register_python_type(module.get(), &type_spec_StorageProviderItemProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageProviderItemProperties_Static.get()))};
    if (!StorageProviderItemProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderItemProperty_type{py::register_python_type(module.get(), &type_spec_StorageProviderItemProperty, object_bases.get(), nullptr)};
    if (!StorageProviderItemProperty_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderItemPropertyDefinition_type{py::register_python_type(module.get(), &type_spec_StorageProviderItemPropertyDefinition, object_bases.get(), nullptr)};
    if (!StorageProviderItemPropertyDefinition_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderKnownFolderEntry_type{py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderEntry, object_bases.get(), nullptr)};
    if (!StorageProviderKnownFolderEntry_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderKnownFolderSyncInfo_type{py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderSyncInfo, object_bases.get(), nullptr)};
    if (!StorageProviderKnownFolderSyncInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderKnownFolderSyncRequestArgs_type{py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderSyncRequestArgs, object_bases.get(), nullptr)};
    if (!StorageProviderKnownFolderSyncRequestArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderMoreInfoUI_type{py::register_python_type(module.get(), &type_spec_StorageProviderMoreInfoUI, object_bases.get(), nullptr)};
    if (!StorageProviderMoreInfoUI_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderQuotaUI_type{py::register_python_type(module.get(), &type_spec_StorageProviderQuotaUI, object_bases.get(), nullptr)};
    if (!StorageProviderQuotaUI_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderStatusUI_type{py::register_python_type(module.get(), &type_spec_StorageProviderStatusUI, object_bases.get(), nullptr)};
    if (!StorageProviderStatusUI_type)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderSyncRootInfo_type{py::register_python_type(module.get(), &type_spec_StorageProviderSyncRootInfo, object_bases.get(), nullptr)};
    if (!StorageProviderSyncRootInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageProviderSyncRootManager_Static{PyType_FromSpec(&type_spec_StorageProviderSyncRootManager_Static)};
    if (!type_StorageProviderSyncRootManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle StorageProviderSyncRootManager_type{py::register_python_type(module.get(), &type_spec_StorageProviderSyncRootManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageProviderSyncRootManager_Static.get()))};
    if (!StorageProviderSyncRootManager_type)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderItemPropertySource_type{py::register_python_type(module.get(), &type_spec_IStorageProviderItemPropertySource, object_bases.get(), nullptr)};
    if (!IStorageProviderItemPropertySource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderItemPropertySource_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderItemPropertySource, nullptr))};
    if (!ImplementsIStorageProviderItemPropertySource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderItemPropertySource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderKnownFolderSyncInfoSource_type{py::register_python_type(module.get(), &type_spec_IStorageProviderKnownFolderSyncInfoSource, object_bases.get(), nullptr)};
    if (!IStorageProviderKnownFolderSyncInfoSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderKnownFolderSyncInfoSource_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderKnownFolderSyncInfoSource, nullptr))};
    if (!ImplementsIStorageProviderKnownFolderSyncInfoSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderKnownFolderSyncInfoSource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderKnownFolderSyncInfoSourceFactory_type{py::register_python_type(module.get(), &type_spec_IStorageProviderKnownFolderSyncInfoSourceFactory, object_bases.get(), nullptr)};
    if (!IStorageProviderKnownFolderSyncInfoSourceFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory, nullptr))};
    if (!ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderKnownFolderSyncInfoSourceFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderPropertyCapabilities_type{py::register_python_type(module.get(), &type_spec_IStorageProviderPropertyCapabilities, object_bases.get(), nullptr)};
    if (!IStorageProviderPropertyCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderPropertyCapabilities_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderPropertyCapabilities, nullptr))};
    if (!ImplementsIStorageProviderPropertyCapabilities_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderPropertyCapabilities_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderShareLinkSource_type{py::register_python_type(module.get(), &type_spec_IStorageProviderShareLinkSource, object_bases.get(), nullptr)};
    if (!IStorageProviderShareLinkSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderShareLinkSource_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderShareLinkSource, nullptr))};
    if (!ImplementsIStorageProviderShareLinkSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderShareLinkSource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderStatusUISource_type{py::register_python_type(module.get(), &type_spec_IStorageProviderStatusUISource, object_bases.get(), nullptr)};
    if (!IStorageProviderStatusUISource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderStatusUISource_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderStatusUISource, nullptr))};
    if (!ImplementsIStorageProviderStatusUISource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderStatusUISource_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderStatusUISourceFactory_type{py::register_python_type(module.get(), &type_spec_IStorageProviderStatusUISourceFactory, object_bases.get(), nullptr)};
    if (!IStorageProviderStatusUISourceFactory_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderStatusUISourceFactory_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderStatusUISourceFactory, nullptr))};
    if (!ImplementsIStorageProviderStatusUISourceFactory_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderStatusUISourceFactory_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderUICommand_type{py::register_python_type(module.get(), &type_spec_IStorageProviderUICommand, object_bases.get(), nullptr)};
    if (!IStorageProviderUICommand_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderUICommand_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderUICommand, nullptr))};
    if (!ImplementsIStorageProviderUICommand_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderUICommand_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IStorageProviderUriSource_type{py::register_python_type(module.get(), &type_spec_IStorageProviderUriSource, object_bases.get(), nullptr)};
    if (!IStorageProviderUriSource_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIStorageProviderUriSource_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIStorageProviderUriSource, nullptr))};
    if (!ImplementsIStorageProviderUriSource_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIStorageProviderUriSource_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
