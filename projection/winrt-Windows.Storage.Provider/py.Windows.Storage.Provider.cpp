// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Storage.Provider.h"


namespace py::cpp::Windows::Storage::Provider
{
    // ----- CachedFileUpdater class --------------------

    static PyObject* _new_CachedFileUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::type_name);
        return nullptr;
    }

    static PyObject* CachedFileUpdater_SetUpdateInformation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.CachedFileUpdater", L"SetUpdateInformation", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Provider::ReadActivationMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Provider::WriteActivationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Provider::CachedFileOptions>(args, 4);

                winrt::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdater[] = {
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdater[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdater) },
        { }
    };

    static PyType_Spec type_spec_CachedFileUpdater = {
        "winrt._winrt_windows_storage_provider.CachedFileUpdater",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdater};

    static PyGetSetDef getset_CachedFileUpdater_Static[] = {
        { }
    };

    static PyMethodDef methods_CachedFileUpdater_Static[] = {
        { "set_update_information", reinterpret_cast<PyCFunction>(CachedFileUpdater_SetUpdateInformation), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CachedFileUpdater_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CachedFileUpdater_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CachedFileUpdater_Static) },
        { }
    };

    static PyType_Spec type_spec_CachedFileUpdater_Static =
    {
        "winrt._winrt_windows_storage_provider.CachedFileUpdater_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CachedFileUpdater_Static
    };

    // ----- CachedFileUpdaterUI class --------------------

    static PyObject* _new_CachedFileUpdaterUI(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::type_name);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterUI(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterUI_GetDeferral(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CachedFileUpdaterUI_put_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UIStatus(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UIStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateTarget(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UpdateTarget"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateRequest(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UpdateRequest"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"FileUpdateRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.FileUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"FileUpdateRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UIRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.CachedFileUpdaterUI", L"UIRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UIRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterUI[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_GetDeferral), METH_VARARGS, nullptr },
        { "add_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_FileUpdateRequested), METH_O, nullptr },
        { "remove_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_FileUpdateRequested), METH_O, nullptr },
        { "add_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_UIRequested), METH_O, nullptr },
        { "remove_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_UIRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CachedFileUpdaterUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterUI[] = {
        { "title", reinterpret_cast<getter>(CachedFileUpdaterUI_get_Title), reinterpret_cast<setter>(CachedFileUpdaterUI_put_Title), nullptr, nullptr },
        { "u_i_status", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UIStatus), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateTarget), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CachedFileUpdaterUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CachedFileUpdaterUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CachedFileUpdaterUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CachedFileUpdaterUI) },
        { }
    };

    static PyType_Spec type_spec_CachedFileUpdaterUI = {
        "winrt._winrt_windows_storage_provider.CachedFileUpdaterUI",
        sizeof(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterUI};

    // ----- FileUpdateRequest class --------------------

    static PyObject* _new_FileUpdateRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequest(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequest_GetDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_UpdateLocalFile(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UpdateLocalFile", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.UpdateLocalFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::FileUpdateStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileUpdateRequest_get_ContentId(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"ContentId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_File(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"File"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UserInputNeededMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserInputNeededMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequest", L"UserInputNeededMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserInputNeededMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(FileUpdateRequest_GetDeferral), METH_VARARGS, nullptr },
        { "update_local_file", reinterpret_cast<PyCFunction>(FileUpdateRequest_UpdateLocalFile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileUpdateRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequest[] = {
        { "status", reinterpret_cast<getter>(FileUpdateRequest_get_Status), reinterpret_cast<setter>(FileUpdateRequest_put_Status), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(FileUpdateRequest_get_ContentId), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileUpdateRequest_get_File), nullptr, nullptr, nullptr },
        { "user_input_needed_message", reinterpret_cast<getter>(FileUpdateRequest_get_UserInputNeededMessage), reinterpret_cast<setter>(FileUpdateRequest_put_UserInputNeededMessage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequest) },
        { }
    };

    static PyType_Spec type_spec_FileUpdateRequest = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequest",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequest};

    // ----- FileUpdateRequestDeferral class --------------------

    static PyObject* _new_FileUpdateRequestDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestDeferral_Complete(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.FileUpdateRequestDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(FileUpdateRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileUpdateRequestDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequestDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequestDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequestDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequestDeferral) },
        { }
    };

    static PyType_Spec type_spec_FileUpdateRequestDeferral = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestDeferral};

    // ----- FileUpdateRequestedEventArgs class --------------------

    static PyObject* _new_FileUpdateRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestedEventArgs(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.FileUpdateRequestedEventArgs", L"Request"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_FileUpdateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(FileUpdateRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileUpdateRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileUpdateRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileUpdateRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileUpdateRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_FileUpdateRequestedEventArgs = {
        "winrt._winrt_windows_storage_provider.FileUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestedEventArgs};

    // ----- StorageProviderFileTypeInfo class --------------------

    static PyObject* _new_StorageProviderFileTypeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderFileTypeInfo_get_FileExtension(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderFileTypeInfo", L"FileExtension"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderFileTypeInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderFileTypeInfo", L"IconResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderFileTypeInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderFileTypeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderFileTypeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderFileTypeInfo[] = {
        { "file_extension", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_FileExtension), nullptr, nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_IconResource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderFileTypeInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderFileTypeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderFileTypeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderFileTypeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderFileTypeInfo) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderFileTypeInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderFileTypeInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderFileTypeInfo};

    // ----- StorageProviderGetContentInfoForPathResult class --------------------

    static PyObject* _new_StorageProviderGetContentInfoForPathResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetContentInfoForPathResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetContentInfoForPathResult", L"ContentId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetContentInfoForPathResult[] = {
        { "_assign_array_", _assign_array_StorageProviderGetContentInfoForPathResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetContentInfoForPathResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetContentInfoForPathResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_Status), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_Status), nullptr, nullptr },
        { "content_uri", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentUri), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentUri), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentId), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetContentInfoForPathResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderGetContentInfoForPathResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderGetContentInfoForPathResult) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderGetContentInfoForPathResult = {
        "winrt._winrt_windows_storage_provider.StorageProviderGetContentInfoForPathResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetContentInfoForPathResult};

    // ----- StorageProviderGetPathForContentUriResult class --------------------

    static PyObject* _new_StorageProviderGetPathForContentUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetPathForContentUriResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderGetPathForContentUriResult", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetPathForContentUriResult[] = {
        { "_assign_array_", _assign_array_StorageProviderGetPathForContentUriResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetPathForContentUriResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetPathForContentUriResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Status), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Status), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Path), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetPathForContentUriResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderGetPathForContentUriResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderGetPathForContentUriResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderGetPathForContentUriResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderGetPathForContentUriResult) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderGetPathForContentUriResult = {
        "winrt._winrt_windows_storage_provider.StorageProviderGetPathForContentUriResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetPathForContentUriResult};

    // ----- StorageProviderItemProperties class --------------------

    static PyObject* _new_StorageProviderItemProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::type_name);
        return nullptr;
    }

    static PyObject* StorageProviderItemProperties_SetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderItemProperties", L"SetAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(args, 1);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderItemProperties::SetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperties[] = {
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemProperties) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderItemProperties = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperties};

    static PyGetSetDef getset_StorageProviderItemProperties_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageProviderItemProperties_Static[] = {
        { "set_async", reinterpret_cast<PyCFunction>(StorageProviderItemProperties_SetAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageProviderItemProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageProviderItemProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageProviderItemProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderItemProperties_Static =
    {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageProviderItemProperties_Static
    };

    // ----- StorageProviderItemProperty class --------------------

    static PyObject* _new_StorageProviderItemProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemProperty instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemProperty(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemProperty_get_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"IconResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemProperty", L"IconResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperty[] = {
        { "_assign_array_", _assign_array_StorageProviderItemProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperty[] = {
        { "value", reinterpret_cast<getter>(StorageProviderItemProperty_get_Value), reinterpret_cast<setter>(StorageProviderItemProperty_put_Value), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderItemProperty_get_Id), reinterpret_cast<setter>(StorageProviderItemProperty_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderItemProperty_get_IconResource), reinterpret_cast<setter>(StorageProviderItemProperty_put_IconResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperty[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderItemProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemProperty) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderItemProperty = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemProperty",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperty};

    // ----- StorageProviderItemPropertyDefinition class --------------------

    static PyObject* _new_StorageProviderItemPropertyDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemPropertyDefinition(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"DisplayNameResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderItemPropertyDefinition", L"DisplayNameResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemPropertyDefinition[] = {
        { "_assign_array_", _assign_array_StorageProviderItemPropertyDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemPropertyDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemPropertyDefinition[] = {
        { "id", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_Id), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_Id), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_DisplayNameResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemPropertyDefinition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderItemPropertyDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderItemPropertyDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderItemPropertyDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderItemPropertyDefinition) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderItemPropertyDefinition = {
        "winrt._winrt_windows_storage_provider.StorageProviderItemPropertyDefinition",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemPropertyDefinition};

    // ----- StorageProviderKnownFolderEntry class --------------------

    static PyObject* _new_StorageProviderKnownFolderEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderKnownFolderEntry(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderEntry_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderEntry_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderEntry_get_KnownFolderId(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"KnownFolderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnownFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderEntry_put_KnownFolderId(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderEntry", L"KnownFolderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.KnownFolderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderEntry[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderKnownFolderEntry[] = {
        { "status", reinterpret_cast<getter>(StorageProviderKnownFolderEntry_get_Status), reinterpret_cast<setter>(StorageProviderKnownFolderEntry_put_Status), nullptr, nullptr },
        { "known_folder_id", reinterpret_cast<getter>(StorageProviderKnownFolderEntry_get_KnownFolderId), reinterpret_cast<setter>(StorageProviderKnownFolderEntry_put_KnownFolderId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderKnownFolderEntry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderEntry) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderKnownFolderEntry = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderEntry",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderEntry};

    // ----- StorageProviderKnownFolderSyncInfo class --------------------

    static PyObject* _new_StorageProviderKnownFolderSyncInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderKnownFolderSyncInfo(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_SyncRequested(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"SyncRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SyncRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderSyncInfo_put_SyncRequested(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"SyncRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestedHandler>(arg);

            self->obj.SyncRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_ProviderDisplayName(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"ProviderDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderKnownFolderSyncInfo_put_ProviderDisplayName(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"ProviderDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncInfo_get_KnownFolderEntries(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncInfo", L"KnownFolderEntries"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnownFolderEntries());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderSyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderSyncInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderSyncInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderSyncInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderSyncInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderKnownFolderSyncInfo[] = {
        { "sync_requested", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_SyncRequested), reinterpret_cast<setter>(StorageProviderKnownFolderSyncInfo_put_SyncRequested), nullptr, nullptr },
        { "provider_display_name", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_ProviderDisplayName), reinterpret_cast<setter>(StorageProviderKnownFolderSyncInfo_put_ProviderDisplayName), nullptr, nullptr },
        { "known_folder_entries", reinterpret_cast<getter>(StorageProviderKnownFolderSyncInfo_get_KnownFolderEntries), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderKnownFolderSyncInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderSyncInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderSyncInfo) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderKnownFolderSyncInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderSyncInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderSyncInfo};

    // ----- StorageProviderKnownFolderSyncRequestArgs class --------------------

    static PyObject* _new_StorageProviderKnownFolderSyncRequestArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_StorageProviderKnownFolderSyncRequestArgs(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderKnownFolderSyncRequestArgs_get_KnownFolders(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncRequestArgs", L"KnownFolders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnownFolders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderKnownFolderSyncRequestArgs_get_Source(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderKnownFolderSyncRequestArgs", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderKnownFolderSyncRequestArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderKnownFolderSyncRequestArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderKnownFolderSyncRequestArgs[] = {
        { "_assign_array_", _assign_array_StorageProviderKnownFolderSyncRequestArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderKnownFolderSyncRequestArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderKnownFolderSyncRequestArgs[] = {
        { "known_folders", reinterpret_cast<getter>(StorageProviderKnownFolderSyncRequestArgs_get_KnownFolders), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(StorageProviderKnownFolderSyncRequestArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderKnownFolderSyncRequestArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderKnownFolderSyncRequestArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderKnownFolderSyncRequestArgs) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderKnownFolderSyncRequestArgs = {
        "winrt._winrt_windows_storage_provider.StorageProviderKnownFolderSyncRequestArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderKnownFolderSyncRequestArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderKnownFolderSyncRequestArgs};

    // ----- StorageProviderMoreInfoUI class --------------------

    static PyObject* _new_StorageProviderMoreInfoUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderMoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderMoreInfoUI_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Message"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Message"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Message(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderMoreInfoUI_get_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Command"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderMoreInfoUI", L"Command"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderMoreInfoUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderMoreInfoUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderMoreInfoUI[] = {
        { "_assign_array_", _assign_array_StorageProviderMoreInfoUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderMoreInfoUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderMoreInfoUI[] = {
        { "message", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Message), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Message), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Command), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Command), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderMoreInfoUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderMoreInfoUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderMoreInfoUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderMoreInfoUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderMoreInfoUI) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderMoreInfoUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderMoreInfoUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderMoreInfoUI};

    // ----- StorageProviderQuotaUI class --------------------

    static PyObject* _new_StorageProviderQuotaUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderQuotaUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderQuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedLabel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuotaUsedLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedLabel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.QuotaUsedLabel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuotaUsedInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.QuotaUsedInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuotaUsedColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaUsedColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.QuotaUsedColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaTotalInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuotaTotalInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderQuotaUI", L"QuotaTotalInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.QuotaTotalInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderQuotaUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderQuotaUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderQuotaUI[] = {
        { "_assign_array_", _assign_array_StorageProviderQuotaUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderQuotaUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderQuotaUI[] = {
        { "quota_used_label", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedLabel), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedLabel), nullptr, nullptr },
        { "quota_used_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedInBytes), nullptr, nullptr },
        { "quota_used_color", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedColor), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedColor), nullptr, nullptr },
        { "quota_total_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaTotalInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaTotalInBytes), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderQuotaUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderQuotaUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderQuotaUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderQuotaUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderQuotaUI) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderQuotaUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderQuotaUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderQuotaUI};

    // ----- StorageProviderStatusUI class --------------------

    static PyObject* _new_StorageProviderStatusUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderStatusUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderStatusUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderStatusUI_get_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"SyncStatusCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SyncStatusCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"SyncStatusCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.SyncStatusCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"QuotaUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.QuotaUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"QuotaUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>(arg);

            self->obj.QuotaUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateLabel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderStateLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateLabel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderStateLabel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateIcon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderStateIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderStateIcon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProviderStateIcon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(arg);

            self->obj.ProviderState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderSecondaryCommands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderSecondaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderSecondaryCommands"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>(arg);

            self->obj.ProviderSecondaryCommands(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderPrimaryCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderPrimaryCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"ProviderPrimaryCommand"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.ProviderPrimaryCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"MoreInfoUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MoreInfoUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderStatusUI", L"MoreInfoUI"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>(arg);

            self->obj.MoreInfoUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StorageProviderStatusUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderStatusUI>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderStatusUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderStatusUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderStatusUI[] = {
        { "_assign_array_", _assign_array_StorageProviderStatusUI, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderStatusUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderStatusUI[] = {
        { "sync_status_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_SyncStatusCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_SyncStatusCommand), nullptr, nullptr },
        { "quota_u_i", reinterpret_cast<getter>(StorageProviderStatusUI_get_QuotaUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_QuotaUI), nullptr, nullptr },
        { "provider_state_label", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateLabel), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateLabel), nullptr, nullptr },
        { "provider_state_icon", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateIcon), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateIcon), nullptr, nullptr },
        { "provider_state", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderState), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderState), nullptr, nullptr },
        { "provider_secondary_commands", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderSecondaryCommands), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderSecondaryCommands), nullptr, nullptr },
        { "provider_primary_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderPrimaryCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderPrimaryCommand), nullptr, nullptr },
        { "more_info_u_i", reinterpret_cast<getter>(StorageProviderStatusUI_get_MoreInfoUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_MoreInfoUI), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderStatusUI[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderStatusUI) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderStatusUI) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderStatusUI) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderStatusUI) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderStatusUI = {
        "winrt._winrt_windows_storage_provider.StorageProviderStatusUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderStatusUI};

    // ----- StorageProviderSyncRootInfo class --------------------

    static PyObject* _new_StorageProviderSyncRootInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderSyncRootInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderSyncRootInfo_get_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ShowSiblingsAsGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ShowSiblingsAsGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ShowSiblingsAsGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowSiblingsAsGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"RecycleBinUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecycleBinUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"RecycleBinUri"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RecycleBinUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProtectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProtectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProtectionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(arg);

            self->obj.ProtectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"PopulationPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PopulationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"PopulationPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(arg);

            self->obj.PopulationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Path"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"InSyncPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InSyncPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"InSyncPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(arg);

            self->obj.InSyncPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"IconResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"IconResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicyModifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HydrationPolicyModifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicyModifier"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(arg);

            self->obj.HydrationPolicyModifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HydrationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HydrationPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(arg);

            self->obj.HydrationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HardlinkPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HardlinkPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"HardlinkPolicy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(arg);

            self->obj.HardlinkPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"DisplayNameResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"DisplayNameResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Context"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"Context"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Context(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"AllowPinning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowPinning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"AllowPinning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowPinning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"StorageProviderItemPropertyDefinitions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StorageProviderItemPropertyDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProviderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"ProviderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_FallbackFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.StorageProviderSyncRootInfo", L"FallbackFileTypeInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FallbackFileTypeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootInfo[] = {
        { "_assign_array_", _assign_array_StorageProviderSyncRootInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderSyncRootInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootInfo[] = {
        { "version", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Version), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Version), nullptr, nullptr },
        { "show_siblings_as_group", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup), nullptr, nullptr },
        { "recycle_bin_uri", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_RecycleBinUri), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_RecycleBinUri), nullptr, nullptr },
        { "protection_mode", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProtectionMode), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProtectionMode), nullptr, nullptr },
        { "population_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_PopulationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_PopulationPolicy), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Path), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Path), nullptr, nullptr },
        { "in_sync_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_InSyncPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_InSyncPolicy), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Id), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_IconResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_IconResource), nullptr, nullptr },
        { "hydration_policy_modifier", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicyModifier), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicyModifier), nullptr, nullptr },
        { "hydration_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicy), nullptr, nullptr },
        { "hardlink_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HardlinkPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HardlinkPolicy), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_DisplayNameResource), nullptr, nullptr },
        { "context", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Context), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Context), nullptr, nullptr },
        { "allow_pinning", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_AllowPinning), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_AllowPinning), nullptr, nullptr },
        { "storage_provider_item_property_definitions", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProviderId), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProviderId), nullptr, nullptr },
        { "fallback_file_type_info", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_FallbackFileTypeInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderSyncRootInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StorageProviderSyncRootInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderSyncRootInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderSyncRootInfo) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderSyncRootInfo = {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootInfo};

    // ----- StorageProviderSyncRootManager class --------------------

    static PyObject* _new_StorageProviderSyncRootManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::type_name);
        return nullptr;
    }

    static PyObject* StorageProviderSyncRootManager_GetCurrentSyncRoots(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetCurrentSyncRoots", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetCurrentSyncRoots());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetSyncRootInformationForFolder", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"GetSyncRootInformationForId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"IsSupported", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"Register", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Register(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.StorageProviderSyncRootManager", L"Unregister", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootManager[] = {
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootManager[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StorageProviderSyncRootManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StorageProviderSyncRootManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StorageProviderSyncRootManager) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderSyncRootManager = {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootManager};

    static PyGetSetDef getset_StorageProviderSyncRootManager_Static[] = {
        { }
    };

    static PyMethodDef methods_StorageProviderSyncRootManager_Static[] = {
        { "get_current_sync_roots", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetCurrentSyncRoots), METH_VARARGS, nullptr },
        { "get_sync_root_information_for_folder", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForFolder), METH_VARARGS, nullptr },
        { "get_sync_root_information_for_id", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForId), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_IsSupported), METH_VARARGS, nullptr },
        { "register", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Unregister), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StorageProviderSyncRootManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StorageProviderSyncRootManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StorageProviderSyncRootManager_Static) },
        { }
    };

    static PyType_Spec type_spec_StorageProviderSyncRootManager_Static =
    {
        "winrt._winrt_windows_storage_provider.StorageProviderSyncRootManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StorageProviderSyncRootManager_Static
    };

    // ----- IStorageProviderItemPropertySource interface --------------------

    static PyObject* _new_IStorageProviderItemPropertySource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderItemPropertySource(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderItemPropertySource_GetItemProperties(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderItemPropertySource", L"GetItemProperties", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderItemPropertySource[] = {
        { "get_item_properties", reinterpret_cast<PyCFunction>(IStorageProviderItemPropertySource_GetItemProperties), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderItemPropertySource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderItemPropertySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderItemPropertySource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderItemPropertySource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderItemPropertySource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderItemPropertySource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderItemPropertySource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderItemPropertySource) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderItemPropertySource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderItemPropertySource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderItemPropertySource};

    // ----- IStorageProviderKnownFolderSyncInfoSource interface --------------------

    static PyObject* _new_IStorageProviderKnownFolderSyncInfoSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderKnownFolderSyncInfoSource(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_GetKnownFolderSyncInfo(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"GetKnownFolderSyncInfo", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetKnownFolderSyncInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_add_KnownFolderSyncInfoChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"KnownFolderSyncInfoChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.KnownFolderSyncInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSource_remove_KnownFolderSyncInfoChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSource", L"KnownFolderSyncInfoChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.KnownFolderSyncInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderKnownFolderSyncInfoSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderKnownFolderSyncInfoSource[] = {
        { "get_known_folder_sync_info", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_GetKnownFolderSyncInfo), METH_VARARGS, nullptr },
        { "add_known_folder_sync_info_changed", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_add_KnownFolderSyncInfoChanged), METH_O, nullptr },
        { "remove_known_folder_sync_info_changed", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSource_remove_KnownFolderSyncInfoChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderKnownFolderSyncInfoSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderKnownFolderSyncInfoSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderKnownFolderSyncInfoSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderKnownFolderSyncInfoSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderKnownFolderSyncInfoSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderKnownFolderSyncInfoSource) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderKnownFolderSyncInfoSource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderKnownFolderSyncInfoSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderKnownFolderSyncInfoSource};

    // ----- IStorageProviderKnownFolderSyncInfoSourceFactory interface --------------------

    static PyObject* _new_IStorageProviderKnownFolderSyncInfoSourceFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderKnownFolderSyncInfoSourceFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderKnownFolderSyncInfoSourceFactory_GetKnownFolderSyncInfoSource(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderKnownFolderSyncInfoSourceFactory", L"GetKnownFolderSyncInfoSource", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetKnownFolderSyncInfoSource());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderKnownFolderSyncInfoSourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { "get_known_folder_sync_info_source", reinterpret_cast<PyCFunction>(IStorageProviderKnownFolderSyncInfoSourceFactory_GetKnownFolderSyncInfoSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderKnownFolderSyncInfoSourceFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderKnownFolderSyncInfoSourceFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderKnownFolderSyncInfoSourceFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderKnownFolderSyncInfoSourceFactory) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderKnownFolderSyncInfoSourceFactory = {
        "winrt._winrt_windows_storage_provider.IStorageProviderKnownFolderSyncInfoSourceFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderKnownFolderSyncInfoSourceFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderKnownFolderSyncInfoSourceFactory};

    // ----- IStorageProviderPropertyCapabilities interface --------------------

    static PyObject* _new_IStorageProviderPropertyCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderPropertyCapabilities(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderPropertyCapabilities_IsPropertySupported(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderPropertyCapabilities", L"IsPropertySupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderPropertyCapabilities[] = {
        { "is_property_supported", reinterpret_cast<PyCFunction>(IStorageProviderPropertyCapabilities_IsPropertySupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderPropertyCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderPropertyCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderPropertyCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderPropertyCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderPropertyCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderPropertyCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderPropertyCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderPropertyCapabilities) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderPropertyCapabilities = {
        "winrt._winrt_windows_storage_provider.IStorageProviderPropertyCapabilities",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderPropertyCapabilities};

    // ----- IStorageProviderStatusUISource interface --------------------

    static PyObject* _new_IStorageProviderStatusUISource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISource_GetStatusUI(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"GetStatusUI", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetStatusUI());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_add_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"StatusUIChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusUIChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_remove_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISource", L"StatusUIChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUIChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISource[] = {
        { "get_status_u_i", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_GetStatusUI), METH_VARARGS, nullptr },
        { "add_status_u_i_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_add_StatusUIChanged), METH_O, nullptr },
        { "remove_status_u_i_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_remove_StatusUIChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderStatusUISource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderStatusUISource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusUISource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderStatusUISource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderStatusUISource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderStatusUISource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderStatusUISource) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderStatusUISource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderStatusUISource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISource};

    // ----- IStorageProviderStatusUISourceFactory interface --------------------

    static PyObject* _new_IStorageProviderStatusUISourceFactory(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISourceFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISourceFactory_GetStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderStatusUISourceFactory", L"GetStatusUISource", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetStatusUISource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISourceFactory[] = {
        { "get_status_u_i_source", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISourceFactory_GetStatusUISource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderStatusUISourceFactory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISourceFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderStatusUISourceFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusUISourceFactory[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderStatusUISourceFactory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderStatusUISourceFactory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderStatusUISourceFactory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderStatusUISourceFactory) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderStatusUISourceFactory = {
        "winrt._winrt_windows_storage_provider.IStorageProviderStatusUISourceFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISourceFactory};

    // ----- IStorageProviderUICommand interface --------------------

    static PyObject* _new_IStorageProviderUICommand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUICommand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUICommand>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUICommand(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUICommand_Invoke(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Invoke", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Description(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Icon(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Icon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Label(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"Label"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_State(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Provider.IStorageProviderUICommand", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUICommand[] = {
        { "invoke", reinterpret_cast<PyCFunction>(IStorageProviderUICommand_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderUICommand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUICommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderUICommand[] = {
        { "description", reinterpret_cast<getter>(IStorageProviderUICommand_get_Description), nullptr, nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(IStorageProviderUICommand_get_Icon), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IStorageProviderUICommand_get_Label), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IStorageProviderUICommand_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderUICommand[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderUICommand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderUICommand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderUICommand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderUICommand) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderUICommand = {
        "winrt._winrt_windows_storage_provider.IStorageProviderUICommand",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUICommand};

    // ----- IStorageProviderUriSource interface --------------------

    static PyObject* _new_IStorageProviderUriSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::type_name);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUriSource(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUriSource_GetContentInfoForPath(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUriSource", L"GetContentInfoForPath", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>(args, 1);

                self->obj.GetContentInfoForPath(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUriSource_GetPathForContentUri(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Provider.IStorageProviderUriSource", L"GetPathForContentUri", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>(args, 1);

                self->obj.GetPathForContentUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Provider::IStorageProviderUriSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUriSource[] = {
        { "get_content_info_for_path", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetContentInfoForPath), METH_VARARGS, nullptr },
        { "get_path_for_content_uri", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetPathForContentUri), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IStorageProviderUriSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUriSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderUriSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderUriSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStorageProviderUriSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStorageProviderUriSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStorageProviderUriSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStorageProviderUriSource) },
        { }
    };

    static PyType_Spec type_spec_IStorageProviderUriSource = {
        "winrt._winrt_windows_storage_provider.IStorageProviderUriSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUriSource};

    // ----- Windows.Storage.Provider Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Storage.Provider");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_storage_provider",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Storage::Provider

PyMODINIT_FUNC PyInit__winrt_windows_storage_provider(void) noexcept
{
    using namespace py::cpp::Windows::Storage::Provider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CachedFileUpdater_Static{PyType_FromSpec(&type_spec_CachedFileUpdater_Static)};
    if (!type_CachedFileUpdater_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CachedFileUpdater, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CachedFileUpdater_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CachedFileUpdaterUI, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileUpdateRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileUpdateRequestDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileUpdateRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderFileTypeInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderGetContentInfoForPathResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderGetPathForContentUriResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageProviderItemProperties_Static{PyType_FromSpec(&type_spec_StorageProviderItemProperties_Static)};
    if (!type_StorageProviderItemProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderItemProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageProviderItemProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderItemProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderItemPropertyDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderEntry, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderSyncInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderKnownFolderSyncRequestArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderMoreInfoUI, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderQuotaUI, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderStatusUI, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderSyncRootInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StorageProviderSyncRootManager_Static{PyType_FromSpec(&type_spec_StorageProviderSyncRootManager_Static)};
    if (!type_StorageProviderSyncRootManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StorageProviderSyncRootManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StorageProviderSyncRootManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderItemPropertySource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderKnownFolderSyncInfoSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderKnownFolderSyncInfoSourceFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderPropertyCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderStatusUISource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderStatusUISourceFactory, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderUICommand, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStorageProviderUriSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
