// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Input.h"

namespace py::cpp::Windows::UI::Input
{
    // ----- AttachableInputObject class --------------------

    static PyObject* _new_AttachableInputObject(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::AttachableInputObject>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::AttachableInputObject>::type_name);
        return nullptr;
    }

    static void _dealloc_AttachableInputObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AttachableInputObject_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.AttachableInputObject", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Windows::UI::Input::AttachableInputObject>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AttachableInputObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::AttachableInputObject>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AttachableInputObject(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::AttachableInputObject>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AttachableInputObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AttachableInputObject(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Windows::UI::Input::AttachableInputObject>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttachableInputObject[] = {
        { "close", reinterpret_cast<PyCFunction>(AttachableInputObject_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AttachableInputObject, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AttachableInputObject), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AttachableInputObject), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AttachableInputObject), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_AttachableInputObject[] = {
        { }};

    static PyType_Slot _type_slots_AttachableInputObject[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AttachableInputObject) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AttachableInputObject) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AttachableInputObject) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AttachableInputObject) },
        { }};

    static PyType_Spec type_spec_AttachableInputObject = {
        "winrt._winrt_windows_ui_input.AttachableInputObject",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AttachableInputObject};

    static PyGetSetDef getset_AttachableInputObject_Static[] = {
        { }};

    static PyMethodDef methods_AttachableInputObject_Static[] = {
        { }};

    static PyType_Slot type_slots_AttachableInputObject_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AttachableInputObject_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AttachableInputObject_Static) },
        { }
    };

    static PyType_Spec type_spec_AttachableInputObject_Static = {
        "winrt._winrt_windows_ui_input.AttachableInputObject_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AttachableInputObject_Static};

    // ----- CrossSlidingEventArgs class --------------------

    static PyObject* _new_CrossSlidingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::CrossSlidingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::CrossSlidingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CrossSlidingEventArgs(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CrossSlidingEventArgs_get_CrossSlidingState(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.CrossSlidingEventArgs", L"CrossSlidingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlidingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.CrossSlidingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_Position(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.CrossSlidingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlidingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.CrossSlidingEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CrossSlidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::CrossSlidingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CrossSlidingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::CrossSlidingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CrossSlidingEventArgs[] = {
        { "_assign_array_", _assign_array_CrossSlidingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CrossSlidingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CrossSlidingEventArgs[] = {
        { "cross_sliding_state", reinterpret_cast<getter>(CrossSlidingEventArgs_get_CrossSlidingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(CrossSlidingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(CrossSlidingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(CrossSlidingEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CrossSlidingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CrossSlidingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CrossSlidingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CrossSlidingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CrossSlidingEventArgs) },
        { }};

    static PyType_Spec type_spec_CrossSlidingEventArgs = {
        "winrt._winrt_windows_ui_input.CrossSlidingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::CrossSlidingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlidingEventArgs};

    // ----- DraggingEventArgs class --------------------

    static PyObject* _new_DraggingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::DraggingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::DraggingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DraggingEventArgs(py::wrapper::Windows::UI::Input::DraggingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DraggingEventArgs_get_DraggingState(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.DraggingEventArgs", L"DraggingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DraggingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.DraggingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_Position(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.DraggingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DraggingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::DraggingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.DraggingEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DraggingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::DraggingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DraggingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::DraggingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DraggingEventArgs[] = {
        { "_assign_array_", _assign_array_DraggingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DraggingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DraggingEventArgs[] = {
        { "dragging_state", reinterpret_cast<getter>(DraggingEventArgs_get_DraggingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(DraggingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(DraggingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(DraggingEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DraggingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DraggingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DraggingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DraggingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DraggingEventArgs) },
        { }};

    static PyType_Spec type_spec_DraggingEventArgs = {
        "winrt._winrt_windows_ui_input.DraggingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::DraggingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DraggingEventArgs};

    // ----- EdgeGesture class --------------------

    static PyObject* _new_EdgeGesture(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::EdgeGesture>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::EdgeGesture>::type_name);
        return nullptr;
    }

    static void _dealloc_EdgeGesture(py::wrapper::Windows::UI::Input::EdgeGesture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EdgeGesture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.EdgeGesture", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::EdgeGesture::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Canceled(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Canceled(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Canceled(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Canceled");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Canceled(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Completed(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Completed(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_add_Starting(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Starting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::EdgeGesture, winrt::Windows::UI::Input::EdgeGestureEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Starting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EdgeGesture_remove_Starting(py::wrapper::Windows::UI::Input::EdgeGesture* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.EdgeGesture", L"Starting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Starting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EdgeGesture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::EdgeGesture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EdgeGesture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::EdgeGesture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EdgeGesture[] = {
        { "add_canceled", reinterpret_cast<PyCFunction>(EdgeGesture_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(EdgeGesture_remove_Canceled), METH_O, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(EdgeGesture_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(EdgeGesture_remove_Completed), METH_O, nullptr },
        { "add_starting", reinterpret_cast<PyCFunction>(EdgeGesture_add_Starting), METH_O, nullptr },
        { "remove_starting", reinterpret_cast<PyCFunction>(EdgeGesture_remove_Starting), METH_O, nullptr },
        { "_assign_array_", _assign_array_EdgeGesture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EdgeGesture), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EdgeGesture[] = {
        { }};

    static PyType_Slot _type_slots_EdgeGesture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EdgeGesture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EdgeGesture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EdgeGesture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EdgeGesture) },
        { }};

    static PyType_Spec type_spec_EdgeGesture = {
        "winrt._winrt_windows_ui_input.EdgeGesture",
        sizeof(py::wrapper::Windows::UI::Input::EdgeGesture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EdgeGesture};

    static PyGetSetDef getset_EdgeGesture_Static[] = {
        { }};

    static PyMethodDef methods_EdgeGesture_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(EdgeGesture_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_EdgeGesture_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EdgeGesture_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EdgeGesture_Static) },
        { }
    };

    static PyType_Spec type_spec_EdgeGesture_Static = {
        "winrt._winrt_windows_ui_input.EdgeGesture_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EdgeGesture_Static};

    // ----- EdgeGestureEventArgs class --------------------

    static PyObject* _new_EdgeGestureEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::EdgeGestureEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::EdgeGestureEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EdgeGestureEventArgs(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EdgeGestureEventArgs_get_Kind(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.EdgeGestureEventArgs", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EdgeGestureEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::EdgeGestureEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EdgeGestureEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::EdgeGestureEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EdgeGestureEventArgs[] = {
        { "_assign_array_", _assign_array_EdgeGestureEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EdgeGestureEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EdgeGestureEventArgs[] = {
        { "kind", reinterpret_cast<getter>(EdgeGestureEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EdgeGestureEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EdgeGestureEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EdgeGestureEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EdgeGestureEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EdgeGestureEventArgs) },
        { }};

    static PyType_Spec type_spec_EdgeGestureEventArgs = {
        "winrt._winrt_windows_ui_input.EdgeGestureEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::EdgeGestureEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EdgeGestureEventArgs};

    // ----- GestureRecognizer class --------------------

    static PyObject* _new_GestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::GestureRecognizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GestureRecognizer(py::wrapper::Windows::UI::Input::GestureRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GestureRecognizer_CanBeDoubleTap(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"CanBeDoubleTap", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CanBeDoubleTap(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_CompleteGesture(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"CompleteGesture", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.CompleteGesture();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessDownEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"ProcessDownEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessDownEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"ProcessInertia", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ProcessInertia();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMouseWheelEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"ProcessMouseWheelEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessMouseWheelEvent(param0, param1, param2);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessMoveEvents(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"ProcessMoveEvents", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Input::PointerPoint>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessMoveEvents(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_ProcessUpEvent(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.GestureRecognizer", L"ProcessUpEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessUpEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_ShowGestureFeedback(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"ShowGestureFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ShowGestureFeedback();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ShowGestureFeedback(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"ShowGestureFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ShowGestureFeedback(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"PivotRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PivotRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"PivotRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.PivotRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_PivotCenter(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"PivotCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PivotCenter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_PivotCenter(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"PivotCenter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.PivotCenter(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_ManipulationExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationExact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_ManipulationExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationExact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDisplacement(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaTranslationDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaTranslationDisplacement();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDisplacement(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaTranslationDisplacement");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaTranslationDisplacement(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaTranslationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaTranslationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaTranslationDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaTranslationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaTranslationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaTranslationDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaRotationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaRotationDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaRotationDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaRotationDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaRotationAngle(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaRotationAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaRotationAngle(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaRotationAngle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansionDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaExpansionDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaExpansionDeceleration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansionDeceleration(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaExpansionDeceleration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaExpansionDeceleration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_InertiaExpansion(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InertiaExpansion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_InertiaExpansion(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"InertiaExpansion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.InertiaExpansion(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_GestureSettings(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GestureSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_GestureSettings(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::GestureSettings>(arg);

            {
                auto _gil = release_gil();
                self->obj.GestureSettings(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideThresholds(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideThresholds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideThresholds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideThresholds(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideThresholds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::CrossSlideThresholds>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideThresholds(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideHorizontally(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideHorizontally");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideHorizontally();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideHorizontally(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideHorizontally");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideHorizontally(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_CrossSlideExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSlideExact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_CrossSlideExact(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSlideExact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSlideExact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_AutoProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"AutoProcessInertia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoProcessInertia();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_AutoProcessInertia(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"AutoProcessInertia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutoProcessInertia(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_IsActive(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_IsInertial(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"IsInertial");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInertial();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_MouseWheelParameters(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"MouseWheelParameters");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseWheelParameters();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_get_TranslationMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TranslationMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TranslationMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TranslationMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TranslationMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TranslationMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TranslationMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TranslationMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TranslationMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TranslationMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TapMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TapMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TapMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TapMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TapMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_TapMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TapMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_TapMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"TapMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TapMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldStartDelay(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldStartDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldStartDelay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldStartDelay(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldStartDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldStartDelay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldRadius(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldMinContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_get_HoldMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GestureRecognizer_put_HoldMaxContactCount(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.GestureRecognizer", L"HoldMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GestureRecognizer_add_CrossSliding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSliding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::CrossSlidingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CrossSliding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_CrossSliding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"CrossSliding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.CrossSliding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Dragging(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Dragging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::DraggingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Dragging(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Dragging(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Dragging");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Dragging(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Holding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::HoldingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Holding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Holding(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Holding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationCompleted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationCompleted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationInertiaStarting(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationInertiaStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationInertiaStarting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationInertiaStarting(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationInertiaStarting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationInertiaStarting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationStarted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationStarted(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_ManipulationUpdated(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationUpdated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_ManipulationUpdated(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationUpdated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_RightTapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"RightTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::RightTappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RightTapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_RightTapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"RightTapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RightTapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_add_Tapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::GestureRecognizer, winrt::Windows::UI::Input::TappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GestureRecognizer_remove_Tapped(py::wrapper::Windows::UI::Input::GestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.GestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::GestureRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::GestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GestureRecognizer[] = {
        { "can_be_double_tap", reinterpret_cast<PyCFunction>(GestureRecognizer_CanBeDoubleTap), METH_VARARGS, nullptr },
        { "complete_gesture", reinterpret_cast<PyCFunction>(GestureRecognizer_CompleteGesture), METH_VARARGS, nullptr },
        { "process_down_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessDownEvent), METH_VARARGS, nullptr },
        { "process_inertia", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessInertia), METH_VARARGS, nullptr },
        { "process_mouse_wheel_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessMouseWheelEvent), METH_VARARGS, nullptr },
        { "process_move_events", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessMoveEvents), METH_VARARGS, nullptr },
        { "process_up_event", reinterpret_cast<PyCFunction>(GestureRecognizer_ProcessUpEvent), METH_VARARGS, nullptr },
        { "add_cross_sliding", reinterpret_cast<PyCFunction>(GestureRecognizer_add_CrossSliding), METH_O, nullptr },
        { "remove_cross_sliding", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_CrossSliding), METH_O, nullptr },
        { "add_dragging", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Dragging), METH_O, nullptr },
        { "remove_dragging", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Dragging), METH_O, nullptr },
        { "add_holding", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Holding), METH_O, nullptr },
        { "remove_holding", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Holding), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationInertiaStarting), METH_O, nullptr },
        { "remove_manipulation_inertia_starting", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationInertiaStarting), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_updated", reinterpret_cast<PyCFunction>(GestureRecognizer_add_ManipulationUpdated), METH_O, nullptr },
        { "remove_manipulation_updated", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_ManipulationUpdated), METH_O, nullptr },
        { "add_right_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_add_RightTapped), METH_O, nullptr },
        { "remove_right_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_RightTapped), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(GestureRecognizer_remove_Tapped), METH_O, nullptr },
        { "_assign_array_", _assign_array_GestureRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GestureRecognizer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_GestureRecognizer[] = {
        { "show_gesture_feedback", reinterpret_cast<getter>(GestureRecognizer_get_ShowGestureFeedback), reinterpret_cast<setter>(GestureRecognizer_put_ShowGestureFeedback), nullptr, nullptr },
        { "pivot_radius", reinterpret_cast<getter>(GestureRecognizer_get_PivotRadius), reinterpret_cast<setter>(GestureRecognizer_put_PivotRadius), nullptr, nullptr },
        { "pivot_center", reinterpret_cast<getter>(GestureRecognizer_get_PivotCenter), reinterpret_cast<setter>(GestureRecognizer_put_PivotCenter), nullptr, nullptr },
        { "manipulation_exact", reinterpret_cast<getter>(GestureRecognizer_get_ManipulationExact), reinterpret_cast<setter>(GestureRecognizer_put_ManipulationExact), nullptr, nullptr },
        { "inertia_translation_displacement", reinterpret_cast<getter>(GestureRecognizer_get_InertiaTranslationDisplacement), reinterpret_cast<setter>(GestureRecognizer_put_InertiaTranslationDisplacement), nullptr, nullptr },
        { "inertia_translation_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaTranslationDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaTranslationDeceleration), nullptr, nullptr },
        { "inertia_rotation_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaRotationDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaRotationDeceleration), nullptr, nullptr },
        { "inertia_rotation_angle", reinterpret_cast<getter>(GestureRecognizer_get_InertiaRotationAngle), reinterpret_cast<setter>(GestureRecognizer_put_InertiaRotationAngle), nullptr, nullptr },
        { "inertia_expansion_deceleration", reinterpret_cast<getter>(GestureRecognizer_get_InertiaExpansionDeceleration), reinterpret_cast<setter>(GestureRecognizer_put_InertiaExpansionDeceleration), nullptr, nullptr },
        { "inertia_expansion", reinterpret_cast<getter>(GestureRecognizer_get_InertiaExpansion), reinterpret_cast<setter>(GestureRecognizer_put_InertiaExpansion), nullptr, nullptr },
        { "gesture_settings", reinterpret_cast<getter>(GestureRecognizer_get_GestureSettings), reinterpret_cast<setter>(GestureRecognizer_put_GestureSettings), nullptr, nullptr },
        { "cross_slide_thresholds", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideThresholds), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideThresholds), nullptr, nullptr },
        { "cross_slide_horizontally", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideHorizontally), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideHorizontally), nullptr, nullptr },
        { "cross_slide_exact", reinterpret_cast<getter>(GestureRecognizer_get_CrossSlideExact), reinterpret_cast<setter>(GestureRecognizer_put_CrossSlideExact), nullptr, nullptr },
        { "auto_process_inertia", reinterpret_cast<getter>(GestureRecognizer_get_AutoProcessInertia), reinterpret_cast<setter>(GestureRecognizer_put_AutoProcessInertia), nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(GestureRecognizer_get_IsActive), nullptr, nullptr, nullptr },
        { "is_inertial", reinterpret_cast<getter>(GestureRecognizer_get_IsInertial), nullptr, nullptr, nullptr },
        { "mouse_wheel_parameters", reinterpret_cast<getter>(GestureRecognizer_get_MouseWheelParameters), nullptr, nullptr, nullptr },
        { "translation_min_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_TranslationMinContactCount), reinterpret_cast<setter>(GestureRecognizer_put_TranslationMinContactCount), nullptr, nullptr },
        { "translation_max_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_TranslationMaxContactCount), reinterpret_cast<setter>(GestureRecognizer_put_TranslationMaxContactCount), nullptr, nullptr },
        { "tap_min_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_TapMinContactCount), reinterpret_cast<setter>(GestureRecognizer_put_TapMinContactCount), nullptr, nullptr },
        { "tap_max_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_TapMaxContactCount), reinterpret_cast<setter>(GestureRecognizer_put_TapMaxContactCount), nullptr, nullptr },
        { "hold_start_delay", reinterpret_cast<getter>(GestureRecognizer_get_HoldStartDelay), reinterpret_cast<setter>(GestureRecognizer_put_HoldStartDelay), nullptr, nullptr },
        { "hold_radius", reinterpret_cast<getter>(GestureRecognizer_get_HoldRadius), reinterpret_cast<setter>(GestureRecognizer_put_HoldRadius), nullptr, nullptr },
        { "hold_min_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_HoldMinContactCount), reinterpret_cast<setter>(GestureRecognizer_put_HoldMinContactCount), nullptr, nullptr },
        { "hold_max_contact_count", reinterpret_cast<getter>(GestureRecognizer_get_HoldMaxContactCount), reinterpret_cast<setter>(GestureRecognizer_put_HoldMaxContactCount), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_GestureRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GestureRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GestureRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GestureRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GestureRecognizer) },
        { }};

    static PyType_Spec type_spec_GestureRecognizer = {
        "winrt._winrt_windows_ui_input.GestureRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::GestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GestureRecognizer};

    // ----- HoldingEventArgs class --------------------

    static PyObject* _new_HoldingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::HoldingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::HoldingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HoldingEventArgs(py::wrapper::Windows::UI::Input::HoldingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HoldingEventArgs_get_HoldingState(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.HoldingEventArgs", L"HoldingState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldingState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.HoldingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_Position(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.HoldingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.HoldingEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HoldingEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::HoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.HoldingEventArgs", L"CurrentContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::HoldingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::HoldingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HoldingEventArgs[] = {
        { "_assign_array_", _assign_array_HoldingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HoldingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HoldingEventArgs[] = {
        { "holding_state", reinterpret_cast<getter>(HoldingEventArgs_get_HoldingState), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(HoldingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(HoldingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(HoldingEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { "current_contact_count", reinterpret_cast<getter>(HoldingEventArgs_get_CurrentContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_HoldingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HoldingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HoldingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HoldingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HoldingEventArgs) },
        { }};

    static PyType_Spec type_spec_HoldingEventArgs = {
        "winrt._winrt_windows_ui_input.HoldingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::HoldingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HoldingEventArgs};

    // ----- InputActivationListener class --------------------

    static PyObject* _new_InputActivationListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::InputActivationListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::InputActivationListener>::type_name);
        return nullptr;
    }

    static void _dealloc_InputActivationListener(py::wrapper::Windows::UI::Input::InputActivationListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputActivationListener_get_State(py::wrapper::Windows::UI::Input::InputActivationListener* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.InputActivationListener", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_add_InputActivationChanged(py::wrapper::Windows::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.InputActivationListener", L"InputActivationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::InputActivationListener, winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InputActivationChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputActivationListener_remove_InputActivationChanged(py::wrapper::Windows::UI::Input::InputActivationListener* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.InputActivationListener", L"InputActivationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.InputActivationChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputActivationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::InputActivationListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputActivationListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::InputActivationListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListener[] = {
        { "add_input_activation_changed", reinterpret_cast<PyCFunction>(InputActivationListener_add_InputActivationChanged), METH_O, nullptr },
        { "remove_input_activation_changed", reinterpret_cast<PyCFunction>(InputActivationListener_remove_InputActivationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputActivationListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputActivationListener), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputActivationListener[] = {
        { "state", reinterpret_cast<getter>(InputActivationListener_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputActivationListener[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputActivationListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputActivationListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputActivationListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputActivationListener) },
        { }};

    static PyType_Spec type_spec_InputActivationListener = {
        "winrt._winrt_windows_ui_input.InputActivationListener",
        sizeof(py::wrapper::Windows::UI::Input::InputActivationListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListener};

    // ----- InputActivationListenerActivationChangedEventArgs class --------------------

    static PyObject* _new_InputActivationListenerActivationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InputActivationListenerActivationChangedEventArgs(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputActivationListenerActivationChangedEventArgs_get_State(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.InputActivationListenerActivationChangedEventArgs", L"State");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.State();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputActivationListenerActivationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputActivationListenerActivationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputActivationListenerActivationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_InputActivationListenerActivationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputActivationListenerActivationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InputActivationListenerActivationChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(InputActivationListenerActivationChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InputActivationListenerActivationChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputActivationListenerActivationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputActivationListenerActivationChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_InputActivationListenerActivationChangedEventArgs = {
        "winrt._winrt_windows_ui_input.InputActivationListenerActivationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::InputActivationListenerActivationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputActivationListenerActivationChangedEventArgs};

    // ----- KeyboardDeliveryInterceptor class --------------------

    static PyObject* _new_KeyboardDeliveryInterceptor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>::type_name);
        return nullptr;
    }

    static void _dealloc_KeyboardDeliveryInterceptor(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyboardDeliveryInterceptor_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::KeyboardDeliveryInterceptor::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_get_IsInterceptionEnabledWhenInForeground(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"IsInterceptionEnabledWhenInForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInterceptionEnabledWhenInForeground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyboardDeliveryInterceptor_put_IsInterceptionEnabledWhenInForeground(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"IsInterceptionEnabledWhenInForeground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsInterceptionEnabledWhenInForeground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_add_KeyDown(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"KeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyDown(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_remove_KeyDown(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"KeyDown");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.KeyDown(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_add_KeyUp(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"KeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor, winrt::Windows::UI::Core::KeyEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KeyUp(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyboardDeliveryInterceptor_remove_KeyUp(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.KeyboardDeliveryInterceptor", L"KeyUp");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.KeyUp(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_KeyboardDeliveryInterceptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_KeyboardDeliveryInterceptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::KeyboardDeliveryInterceptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyboardDeliveryInterceptor[] = {
        { "add_key_down", reinterpret_cast<PyCFunction>(KeyboardDeliveryInterceptor_add_KeyDown), METH_O, nullptr },
        { "remove_key_down", reinterpret_cast<PyCFunction>(KeyboardDeliveryInterceptor_remove_KeyDown), METH_O, nullptr },
        { "add_key_up", reinterpret_cast<PyCFunction>(KeyboardDeliveryInterceptor_add_KeyUp), METH_O, nullptr },
        { "remove_key_up", reinterpret_cast<PyCFunction>(KeyboardDeliveryInterceptor_remove_KeyUp), METH_O, nullptr },
        { "_assign_array_", _assign_array_KeyboardDeliveryInterceptor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyboardDeliveryInterceptor), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_KeyboardDeliveryInterceptor[] = {
        { "is_interception_enabled_when_in_foreground", reinterpret_cast<getter>(KeyboardDeliveryInterceptor_get_IsInterceptionEnabledWhenInForeground), reinterpret_cast<setter>(KeyboardDeliveryInterceptor_put_IsInterceptionEnabledWhenInForeground), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_KeyboardDeliveryInterceptor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KeyboardDeliveryInterceptor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_KeyboardDeliveryInterceptor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KeyboardDeliveryInterceptor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KeyboardDeliveryInterceptor) },
        { }};

    static PyType_Spec type_spec_KeyboardDeliveryInterceptor = {
        "winrt._winrt_windows_ui_input.KeyboardDeliveryInterceptor",
        sizeof(py::wrapper::Windows::UI::Input::KeyboardDeliveryInterceptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyboardDeliveryInterceptor};

    static PyGetSetDef getset_KeyboardDeliveryInterceptor_Static[] = {
        { }};

    static PyMethodDef methods_KeyboardDeliveryInterceptor_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(KeyboardDeliveryInterceptor_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_KeyboardDeliveryInterceptor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KeyboardDeliveryInterceptor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KeyboardDeliveryInterceptor_Static) },
        { }
    };

    static PyType_Spec type_spec_KeyboardDeliveryInterceptor_Static = {
        "winrt._winrt_windows_ui_input.KeyboardDeliveryInterceptor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KeyboardDeliveryInterceptor_Static};

    // ----- ManipulationCompletedEventArgs class --------------------

    static PyObject* _new_ManipulationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationCompletedEventArgs(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationCompletedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationCompletedEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationCompletedEventArgs", L"CurrentContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationCompletedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { "current_contact_count", reinterpret_cast<getter>(ManipulationCompletedEventArgs_get_CurrentContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationCompletedEventArgs = {
        "winrt._winrt_windows_ui_input.ManipulationCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationCompletedEventArgs};

    // ----- ManipulationInertiaStartingEventArgs class --------------------

    static PyObject* _new_ManipulationInertiaStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationInertiaStartingEventArgs(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Delta(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationInertiaStartingEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationInertiaStartingEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationInertiaStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationInertiaStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationInertiaStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationInertiaStartingEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationInertiaStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationInertiaStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationInertiaStartingEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(ManipulationInertiaStartingEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationInertiaStartingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationInertiaStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationInertiaStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationInertiaStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationInertiaStartingEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationInertiaStartingEventArgs = {
        "winrt._winrt_windows_ui_input.ManipulationInertiaStartingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationInertiaStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationInertiaStartingEventArgs};

    // ----- ManipulationStartedEventArgs class --------------------

    static PyObject* _new_ManipulationStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::ManipulationStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::ManipulationStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationStartedEventArgs(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationStartedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationStartedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationStartedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationStartedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationStartedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationStartedEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationStartedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationStartedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(ManipulationStartedEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationStartedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationStartedEventArgs = {
        "winrt._winrt_windows_ui_input.ManipulationStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationStartedEventArgs};

    // ----- ManipulationUpdatedEventArgs class --------------------

    static PyObject* _new_ManipulationUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ManipulationUpdatedEventArgs(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Cumulative(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"Cumulative");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Cumulative();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Delta(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"Delta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Delta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Position(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_Velocities(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"Velocities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Velocities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationUpdatedEventArgs_get_CurrentContactCount(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.ManipulationUpdatedEventArgs", L"CurrentContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CurrentContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ManipulationUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ManipulationUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_ManipulationUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ManipulationUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ManipulationUpdatedEventArgs[] = {
        { "cumulative", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Cumulative), nullptr, nullptr, nullptr },
        { "delta", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Delta), nullptr, nullptr, nullptr },
        { "pointer_device_type", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "velocities", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_Velocities), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { "current_contact_count", reinterpret_cast<getter>(ManipulationUpdatedEventArgs_get_CurrentContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ManipulationUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationUpdatedEventArgs) },
        { }};

    static PyType_Spec type_spec_ManipulationUpdatedEventArgs = {
        "winrt._winrt_windows_ui_input.ManipulationUpdatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationUpdatedEventArgs};

    // ----- MouseWheelParameters class --------------------

    static PyObject* _new_MouseWheelParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::MouseWheelParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::MouseWheelParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_MouseWheelParameters(py::wrapper::Windows::UI::Input::MouseWheelParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MouseWheelParameters_get_PageTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"PageTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PageTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_PageTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"PageTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.PageTranslation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaScale(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"DeltaScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeltaScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaScale(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"DeltaScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeltaScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_DeltaRotationAngle(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"DeltaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeltaRotationAngle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_DeltaRotationAngle(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"DeltaRotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.DeltaRotationAngle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MouseWheelParameters_get_CharTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"CharTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CharTranslation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MouseWheelParameters_put_CharTranslation(py::wrapper::Windows::UI::Input::MouseWheelParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.MouseWheelParameters", L"CharTranslation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            {
                auto _gil = release_gil();
                self->obj.CharTranslation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_MouseWheelParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::MouseWheelParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MouseWheelParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::MouseWheelParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MouseWheelParameters[] = {
        { "_assign_array_", _assign_array_MouseWheelParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MouseWheelParameters), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_MouseWheelParameters[] = {
        { "page_translation", reinterpret_cast<getter>(MouseWheelParameters_get_PageTranslation), reinterpret_cast<setter>(MouseWheelParameters_put_PageTranslation), nullptr, nullptr },
        { "delta_scale", reinterpret_cast<getter>(MouseWheelParameters_get_DeltaScale), reinterpret_cast<setter>(MouseWheelParameters_put_DeltaScale), nullptr, nullptr },
        { "delta_rotation_angle", reinterpret_cast<getter>(MouseWheelParameters_get_DeltaRotationAngle), reinterpret_cast<setter>(MouseWheelParameters_put_DeltaRotationAngle), nullptr, nullptr },
        { "char_translation", reinterpret_cast<getter>(MouseWheelParameters_get_CharTranslation), reinterpret_cast<setter>(MouseWheelParameters_put_CharTranslation), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_MouseWheelParameters[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MouseWheelParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MouseWheelParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MouseWheelParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MouseWheelParameters) },
        { }};

    static PyType_Spec type_spec_MouseWheelParameters = {
        "winrt._winrt_windows_ui_input.MouseWheelParameters",
        sizeof(py::wrapper::Windows::UI::Input::MouseWheelParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MouseWheelParameters};

    // ----- PhysicalGestureRecognizer class --------------------

    static PyObject* _new_PhysicalGestureRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::PhysicalGestureRecognizer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhysicalGestureRecognizer(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhysicalGestureRecognizer_CompleteGesture(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"CompleteGesture", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.CompleteGesture();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_ProcessDownEvent(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ProcessDownEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessDownEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_ProcessMoveEvents(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ProcessMoveEvents", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::UI::Input::PointerPoint>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessMoveEvents(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_ProcessUpEvent(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ProcessUpEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ProcessUpEvent(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_TranslationMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TranslationMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TranslationMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_TranslationMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TranslationMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TranslationMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TranslationMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TranslationMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_TranslationMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TranslationMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TranslationMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_TapMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TapMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_TapMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TapMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TapMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_TapMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TapMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_TapMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"TapMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TapMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_HoldStartDelay(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldStartDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldStartDelay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_HoldStartDelay(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldStartDelay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldStartDelay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_HoldRadius(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldRadius();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_HoldRadius(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldRadius");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldRadius(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_HoldMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldMinContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_HoldMinContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldMinContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldMinContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_HoldMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HoldMaxContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_HoldMaxContactCount(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"HoldMaxContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.HoldMaxContactCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_get_GestureSettings(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GestureSettings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhysicalGestureRecognizer_put_GestureSettings(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"GestureSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::GestureSettings>(arg);

            {
                auto _gil = release_gil();
                self->obj.GestureSettings(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhysicalGestureRecognizer_add_Holding(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::PhysicalGestureRecognizer, winrt::Windows::UI::Input::HoldingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Holding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_remove_Holding(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"Holding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Holding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_add_ManipulationCompleted(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::PhysicalGestureRecognizer, winrt::Windows::UI::Input::ManipulationCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationCompleted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_remove_ManipulationCompleted(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationCompleted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_add_ManipulationStarted(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::PhysicalGestureRecognizer, winrt::Windows::UI::Input::ManipulationStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_remove_ManipulationStarted(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_add_ManipulationUpdated(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::PhysicalGestureRecognizer, winrt::Windows::UI::Input::ManipulationUpdatedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ManipulationUpdated(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_remove_ManipulationUpdated(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"ManipulationUpdated");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ManipulationUpdated(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_add_Tapped(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::PhysicalGestureRecognizer, winrt::Windows::UI::Input::TappedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tapped(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhysicalGestureRecognizer_remove_Tapped(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.PhysicalGestureRecognizer", L"Tapped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tapped(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhysicalGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::PhysicalGestureRecognizer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhysicalGestureRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PhysicalGestureRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhysicalGestureRecognizer[] = {
        { "complete_gesture", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_CompleteGesture), METH_VARARGS, nullptr },
        { "process_down_event", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_ProcessDownEvent), METH_VARARGS, nullptr },
        { "process_move_events", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_ProcessMoveEvents), METH_VARARGS, nullptr },
        { "process_up_event", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_ProcessUpEvent), METH_VARARGS, nullptr },
        { "add_holding", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_add_Holding), METH_O, nullptr },
        { "remove_holding", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_remove_Holding), METH_O, nullptr },
        { "add_manipulation_completed", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_add_ManipulationCompleted), METH_O, nullptr },
        { "remove_manipulation_completed", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_remove_ManipulationCompleted), METH_O, nullptr },
        { "add_manipulation_started", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_add_ManipulationStarted), METH_O, nullptr },
        { "remove_manipulation_started", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_remove_ManipulationStarted), METH_O, nullptr },
        { "add_manipulation_updated", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_add_ManipulationUpdated), METH_O, nullptr },
        { "remove_manipulation_updated", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_remove_ManipulationUpdated), METH_O, nullptr },
        { "add_tapped", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_add_Tapped), METH_O, nullptr },
        { "remove_tapped", reinterpret_cast<PyCFunction>(PhysicalGestureRecognizer_remove_Tapped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhysicalGestureRecognizer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhysicalGestureRecognizer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhysicalGestureRecognizer[] = {
        { "translation_min_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_TranslationMinContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_TranslationMinContactCount), nullptr, nullptr },
        { "translation_max_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_TranslationMaxContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_TranslationMaxContactCount), nullptr, nullptr },
        { "tap_min_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_TapMinContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_TapMinContactCount), nullptr, nullptr },
        { "tap_max_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_TapMaxContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_TapMaxContactCount), nullptr, nullptr },
        { "hold_start_delay", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_HoldStartDelay), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_HoldStartDelay), nullptr, nullptr },
        { "hold_radius", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_HoldRadius), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_HoldRadius), nullptr, nullptr },
        { "hold_min_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_HoldMinContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_HoldMinContactCount), nullptr, nullptr },
        { "hold_max_contact_count", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_HoldMaxContactCount), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_HoldMaxContactCount), nullptr, nullptr },
        { "gesture_settings", reinterpret_cast<getter>(PhysicalGestureRecognizer_get_GestureSettings), reinterpret_cast<setter>(PhysicalGestureRecognizer_put_GestureSettings), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhysicalGestureRecognizer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhysicalGestureRecognizer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhysicalGestureRecognizer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhysicalGestureRecognizer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhysicalGestureRecognizer) },
        { }};

    static PyType_Spec type_spec_PhysicalGestureRecognizer = {
        "winrt._winrt_windows_ui_input.PhysicalGestureRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::PhysicalGestureRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhysicalGestureRecognizer};

    // ----- PointerPoint class --------------------

    static PyObject* _new_PointerPoint(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::PointerPoint>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::PointerPoint>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerPoint(py::wrapper::Windows::UI::Input::PointerPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerPoint_GetCurrentPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPoint", L"GetCurrentPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::PointerPoint::GetCurrentPoint(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_GetCurrentPointTransformed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPoint", L"GetCurrentPoint", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::IPointerPointTransform>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::PointerPoint::GetCurrentPoint(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_GetIntermediatePoints(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPoint", L"GetIntermediatePoints", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::PointerPoint::GetIntermediatePoints(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_GetIntermediatePointsTransformed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPoint", L"GetIntermediatePoints", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::IPointerPointTransform>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::PointerPoint::GetIntermediatePoints(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_FrameId(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"FrameId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FrameId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_IsInContact(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"IsInContact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInContact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerDevice(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"PointerDevice");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDevice();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PointerId(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"PointerId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Position(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Properties(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Properties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_RawPosition(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"RawPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RawPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_Timestamp(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_IsPhysicalPositionSupported(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"IsPhysicalPositionSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPhysicalPositionSupported();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPoint_get_PhysicalPosition(py::wrapper::Windows::UI::Input::PointerPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPoint", L"PhysicalPosition");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhysicalPosition();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::PointerPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPoint[] = {
        { "_assign_array_", _assign_array_PointerPoint, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerPoint), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerPoint[] = {
        { "frame_id", reinterpret_cast<getter>(PointerPoint_get_FrameId), nullptr, nullptr, nullptr },
        { "is_in_contact", reinterpret_cast<getter>(PointerPoint_get_IsInContact), nullptr, nullptr, nullptr },
        { "pointer_device", reinterpret_cast<getter>(PointerPoint_get_PointerDevice), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(PointerPoint_get_PointerId), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(PointerPoint_get_Position), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PointerPoint_get_Properties), nullptr, nullptr, nullptr },
        { "raw_position", reinterpret_cast<getter>(PointerPoint_get_RawPosition), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(PointerPoint_get_Timestamp), nullptr, nullptr, nullptr },
        { "is_physical_position_supported", reinterpret_cast<getter>(PointerPoint_get_IsPhysicalPositionSupported), nullptr, nullptr, nullptr },
        { "physical_position", reinterpret_cast<getter>(PointerPoint_get_PhysicalPosition), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerPoint[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerPoint) },
        { }};

    static PyType_Spec type_spec_PointerPoint = {
        "winrt._winrt_windows_ui_input.PointerPoint",
        sizeof(py::wrapper::Windows::UI::Input::PointerPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPoint};

    static PyGetSetDef getset_PointerPoint_Static[] = {
        { }};

    static PyMethodDef methods_PointerPoint_Static[] = {
        { "get_current_point", reinterpret_cast<PyCFunction>(PointerPoint_GetCurrentPoint), METH_VARARGS, nullptr },
        { "get_current_point_transformed", reinterpret_cast<PyCFunction>(PointerPoint_GetCurrentPointTransformed), METH_VARARGS, nullptr },
        { "get_intermediate_points", reinterpret_cast<PyCFunction>(PointerPoint_GetIntermediatePoints), METH_VARARGS, nullptr },
        { "get_intermediate_points_transformed", reinterpret_cast<PyCFunction>(PointerPoint_GetIntermediatePointsTransformed), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PointerPoint_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerPoint_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PointerPoint_Static) },
        { }
    };

    static PyType_Spec type_spec_PointerPoint_Static = {
        "winrt._winrt_windows_ui_input.PointerPoint_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerPoint_Static};

    // ----- PointerPointProperties class --------------------

    static PyObject* _new_PointerPointProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::PointerPointProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::PointerPointProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerPointProperties(py::wrapper::Windows::UI::Input::PointerPointProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerPointProperties_GetUsageValue(py::wrapper::Windows::UI::Input::PointerPointProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPointProperties", L"GetUsageValue", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetUsageValue(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_HasUsage(py::wrapper::Windows::UI::Input::PointerPointProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerPointProperties", L"HasUsage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.HasUsage(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ContactRect(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"ContactRect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactRect();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ContactRectRaw(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"ContactRectRaw");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactRectRaw();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsBarrelButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsBarrelButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsBarrelButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsCanceled(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsCanceled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsCanceled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsEraser(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsEraser");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEraser();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsHorizontalMouseWheel(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsHorizontalMouseWheel");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsHorizontalMouseWheel();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInRange(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsInRange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInRange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsInverted(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsInverted");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInverted();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsLeftButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsLeftButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLeftButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsMiddleButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsMiddleButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMiddleButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsPrimary(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsPrimary");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPrimary();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsRightButtonPressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsRightButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRightButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton1Pressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsXButton1Pressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsXButton1Pressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_IsXButton2Pressed(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"IsXButton2Pressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsXButton2Pressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_MouseWheelDelta(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"MouseWheelDelta");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MouseWheelDelta();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Orientation(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"Orientation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Orientation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_PointerUpdateKind(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"PointerUpdateKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerUpdateKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Pressure(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"Pressure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Pressure();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_TouchConfidence(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"TouchConfidence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TouchConfidence();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_Twist(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"Twist");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Twist();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_XTilt(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"XTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XTilt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_YTilt(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"YTilt");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.YTilt();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PointerPointProperties_get_ZDistance(py::wrapper::Windows::UI::Input::PointerPointProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerPointProperties", L"ZDistance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ZDistance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointerPointProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::PointerPointProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerPointProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerPointProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerPointProperties[] = {
        { "get_usage_value", reinterpret_cast<PyCFunction>(PointerPointProperties_GetUsageValue), METH_VARARGS, nullptr },
        { "has_usage", reinterpret_cast<PyCFunction>(PointerPointProperties_HasUsage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointerPointProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerPointProperties), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerPointProperties[] = {
        { "contact_rect", reinterpret_cast<getter>(PointerPointProperties_get_ContactRect), nullptr, nullptr, nullptr },
        { "contact_rect_raw", reinterpret_cast<getter>(PointerPointProperties_get_ContactRectRaw), nullptr, nullptr, nullptr },
        { "is_barrel_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsBarrelButtonPressed), nullptr, nullptr, nullptr },
        { "is_canceled", reinterpret_cast<getter>(PointerPointProperties_get_IsCanceled), nullptr, nullptr, nullptr },
        { "is_eraser", reinterpret_cast<getter>(PointerPointProperties_get_IsEraser), nullptr, nullptr, nullptr },
        { "is_horizontal_mouse_wheel", reinterpret_cast<getter>(PointerPointProperties_get_IsHorizontalMouseWheel), nullptr, nullptr, nullptr },
        { "is_in_range", reinterpret_cast<getter>(PointerPointProperties_get_IsInRange), nullptr, nullptr, nullptr },
        { "is_inverted", reinterpret_cast<getter>(PointerPointProperties_get_IsInverted), nullptr, nullptr, nullptr },
        { "is_left_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsLeftButtonPressed), nullptr, nullptr, nullptr },
        { "is_middle_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsMiddleButtonPressed), nullptr, nullptr, nullptr },
        { "is_primary", reinterpret_cast<getter>(PointerPointProperties_get_IsPrimary), nullptr, nullptr, nullptr },
        { "is_right_button_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsRightButtonPressed), nullptr, nullptr, nullptr },
        { "is_x_button1_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsXButton1Pressed), nullptr, nullptr, nullptr },
        { "is_x_button2_pressed", reinterpret_cast<getter>(PointerPointProperties_get_IsXButton2Pressed), nullptr, nullptr, nullptr },
        { "mouse_wheel_delta", reinterpret_cast<getter>(PointerPointProperties_get_MouseWheelDelta), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(PointerPointProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "pointer_update_kind", reinterpret_cast<getter>(PointerPointProperties_get_PointerUpdateKind), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(PointerPointProperties_get_Pressure), nullptr, nullptr, nullptr },
        { "touch_confidence", reinterpret_cast<getter>(PointerPointProperties_get_TouchConfidence), nullptr, nullptr, nullptr },
        { "twist", reinterpret_cast<getter>(PointerPointProperties_get_Twist), nullptr, nullptr, nullptr },
        { "x_tilt", reinterpret_cast<getter>(PointerPointProperties_get_XTilt), nullptr, nullptr, nullptr },
        { "y_tilt", reinterpret_cast<getter>(PointerPointProperties_get_YTilt), nullptr, nullptr, nullptr },
        { "z_distance", reinterpret_cast<getter>(PointerPointProperties_get_ZDistance), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerPointProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerPointProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerPointProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerPointProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerPointProperties) },
        { }};

    static PyType_Spec type_spec_PointerPointProperties = {
        "winrt._winrt_windows_ui_input.PointerPointProperties",
        sizeof(py::wrapper::Windows::UI::Input::PointerPointProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerPointProperties};

    // ----- PointerVisualizationSettings class --------------------

    static PyObject* _new_PointerVisualizationSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::PointerVisualizationSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::PointerVisualizationSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_PointerVisualizationSettings(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointerVisualizationSettings_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.PointerVisualizationSettings", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::PointerVisualizationSettings::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointerVisualizationSettings_get_IsContactFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerVisualizationSettings", L"IsContactFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsContactFeedbackEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerVisualizationSettings_put_IsContactFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerVisualizationSettings", L"IsContactFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsContactFeedbackEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointerVisualizationSettings_get_IsBarrelButtonFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerVisualizationSettings", L"IsBarrelButtonFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsBarrelButtonFeedbackEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointerVisualizationSettings_put_IsBarrelButtonFeedbackEnabled(py::wrapper::Windows::UI::Input::PointerVisualizationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.PointerVisualizationSettings", L"IsBarrelButtonFeedbackEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsBarrelButtonFeedbackEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PointerVisualizationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::PointerVisualizationSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointerVisualizationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::PointerVisualizationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PointerVisualizationSettings[] = {
        { "_assign_array_", _assign_array_PointerVisualizationSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointerVisualizationSettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PointerVisualizationSettings[] = {
        { "is_contact_feedback_enabled", reinterpret_cast<getter>(PointerVisualizationSettings_get_IsContactFeedbackEnabled), reinterpret_cast<setter>(PointerVisualizationSettings_put_IsContactFeedbackEnabled), nullptr, nullptr },
        { "is_barrel_button_feedback_enabled", reinterpret_cast<getter>(PointerVisualizationSettings_get_IsBarrelButtonFeedbackEnabled), reinterpret_cast<setter>(PointerVisualizationSettings_put_IsBarrelButtonFeedbackEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PointerVisualizationSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointerVisualizationSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointerVisualizationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointerVisualizationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointerVisualizationSettings) },
        { }};

    static PyType_Spec type_spec_PointerVisualizationSettings = {
        "winrt._winrt_windows_ui_input.PointerVisualizationSettings",
        sizeof(py::wrapper::Windows::UI::Input::PointerVisualizationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointerVisualizationSettings};

    static PyGetSetDef getset_PointerVisualizationSettings_Static[] = {
        { }};

    static PyMethodDef methods_PointerVisualizationSettings_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(PointerVisualizationSettings_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PointerVisualizationSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PointerVisualizationSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PointerVisualizationSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_PointerVisualizationSettings_Static = {
        "winrt._winrt_windows_ui_input.PointerVisualizationSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PointerVisualizationSettings_Static};

    // ----- RadialController class --------------------

    static PyObject* _new_RadialController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialController>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialController(py::wrapper::Windows::UI::Input::RadialController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialController_CreateForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialController", L"CreateForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialController::CreateForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialController_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialController", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialController::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialController_get_UseAutomaticHapticFeedback(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialController", L"UseAutomaticHapticFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UseAutomaticHapticFeedback();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialController_put_UseAutomaticHapticFeedback(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialController", L"UseAutomaticHapticFeedback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.UseAutomaticHapticFeedback(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialController_get_RotationResolutionInDegrees(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialController", L"RotationResolutionInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationResolutionInDegrees();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialController_put_RotationResolutionInDegrees(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialController", L"RotationResolutionInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationResolutionInDegrees(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialController_get_Menu(py::wrapper::Windows::UI::Input::RadialController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialController", L"Menu");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Menu();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonClicked(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonClicked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonClicked(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonClicked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ButtonClicked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ControlAcquired(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ControlAcquired");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlAcquired(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ControlAcquired(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ControlAcquired");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ControlAcquired(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ControlLost(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ControlLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ControlLost(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ControlLost(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ControlLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ControlLost(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_RotationChanged(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"RotationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_RotationChanged(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"RotationChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.RotationChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactContinued(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactContinued");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScreenContactContinued(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactContinued(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactContinued");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScreenContactContinued(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactEnded(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScreenContactEnded(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactEnded(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactEnded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScreenContactEnded(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ScreenContactStarted(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ScreenContactStarted(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ScreenContactStarted(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ScreenContactStarted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ScreenContactStarted(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonHolding(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonHolding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonHolding(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonHolding(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonHolding");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ButtonHolding(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonPressed(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonPressed(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ButtonPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_add_ButtonReleased(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialController, winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ButtonReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialController_remove_ButtonReleased(py::wrapper::Windows::UI::Input::RadialController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialController", L"ButtonReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ButtonReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialController[] = {
        { "add_button_clicked", reinterpret_cast<PyCFunction>(RadialController_add_ButtonClicked), METH_O, nullptr },
        { "remove_button_clicked", reinterpret_cast<PyCFunction>(RadialController_remove_ButtonClicked), METH_O, nullptr },
        { "add_control_acquired", reinterpret_cast<PyCFunction>(RadialController_add_ControlAcquired), METH_O, nullptr },
        { "remove_control_acquired", reinterpret_cast<PyCFunction>(RadialController_remove_ControlAcquired), METH_O, nullptr },
        { "add_control_lost", reinterpret_cast<PyCFunction>(RadialController_add_ControlLost), METH_O, nullptr },
        { "remove_control_lost", reinterpret_cast<PyCFunction>(RadialController_remove_ControlLost), METH_O, nullptr },
        { "add_rotation_changed", reinterpret_cast<PyCFunction>(RadialController_add_RotationChanged), METH_O, nullptr },
        { "remove_rotation_changed", reinterpret_cast<PyCFunction>(RadialController_remove_RotationChanged), METH_O, nullptr },
        { "add_screen_contact_continued", reinterpret_cast<PyCFunction>(RadialController_add_ScreenContactContinued), METH_O, nullptr },
        { "remove_screen_contact_continued", reinterpret_cast<PyCFunction>(RadialController_remove_ScreenContactContinued), METH_O, nullptr },
        { "add_screen_contact_ended", reinterpret_cast<PyCFunction>(RadialController_add_ScreenContactEnded), METH_O, nullptr },
        { "remove_screen_contact_ended", reinterpret_cast<PyCFunction>(RadialController_remove_ScreenContactEnded), METH_O, nullptr },
        { "add_screen_contact_started", reinterpret_cast<PyCFunction>(RadialController_add_ScreenContactStarted), METH_O, nullptr },
        { "remove_screen_contact_started", reinterpret_cast<PyCFunction>(RadialController_remove_ScreenContactStarted), METH_O, nullptr },
        { "add_button_holding", reinterpret_cast<PyCFunction>(RadialController_add_ButtonHolding), METH_O, nullptr },
        { "remove_button_holding", reinterpret_cast<PyCFunction>(RadialController_remove_ButtonHolding), METH_O, nullptr },
        { "add_button_pressed", reinterpret_cast<PyCFunction>(RadialController_add_ButtonPressed), METH_O, nullptr },
        { "remove_button_pressed", reinterpret_cast<PyCFunction>(RadialController_remove_ButtonPressed), METH_O, nullptr },
        { "add_button_released", reinterpret_cast<PyCFunction>(RadialController_add_ButtonReleased), METH_O, nullptr },
        { "remove_button_released", reinterpret_cast<PyCFunction>(RadialController_remove_ButtonReleased), METH_O, nullptr },
        { "_assign_array_", _assign_array_RadialController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialController[] = {
        { "use_automatic_haptic_feedback", reinterpret_cast<getter>(RadialController_get_UseAutomaticHapticFeedback), reinterpret_cast<setter>(RadialController_put_UseAutomaticHapticFeedback), nullptr, nullptr },
        { "rotation_resolution_in_degrees", reinterpret_cast<getter>(RadialController_get_RotationResolutionInDegrees), reinterpret_cast<setter>(RadialController_put_RotationResolutionInDegrees), nullptr, nullptr },
        { "menu", reinterpret_cast<getter>(RadialController_get_Menu), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialController) },
        { }};

    static PyType_Spec type_spec_RadialController = {
        "winrt._winrt_windows_ui_input.RadialController",
        sizeof(py::wrapper::Windows::UI::Input::RadialController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialController};

    static PyGetSetDef getset_RadialController_Static[] = {
        { }};

    static PyMethodDef methods_RadialController_Static[] = {
        { "create_for_current_view", reinterpret_cast<PyCFunction>(RadialController_CreateForCurrentView), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(RadialController_IsSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_RadialController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadialController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadialController_Static) },
        { }
    };

    static PyType_Spec type_spec_RadialController_Static = {
        "winrt._winrt_windows_ui_input.RadialController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadialController_Static};

    // ----- RadialControllerButtonClickedEventArgs class --------------------

    static PyObject* _new_RadialControllerButtonClickedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonClickedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerButtonClickedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonClickedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonClickedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonClickedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerButtonClickedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonClickedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonClickedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerButtonClickedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerButtonClickedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerButtonClickedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerButtonClickedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerButtonClickedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerButtonClickedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerButtonClickedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerButtonClickedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerButtonClickedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerButtonClickedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerButtonClickedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerButtonClickedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonClickedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonClickedEventArgs};

    // ----- RadialControllerButtonHoldingEventArgs class --------------------

    static PyObject* _new_RadialControllerButtonHoldingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonHoldingEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerButtonHoldingEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonHoldingEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonHoldingEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonHoldingEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerButtonHoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerButtonHoldingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonHoldingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonHoldingEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerButtonHoldingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerButtonHoldingEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerButtonHoldingEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerButtonHoldingEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerButtonHoldingEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerButtonHoldingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerButtonHoldingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerButtonHoldingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerButtonHoldingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerButtonHoldingEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerButtonHoldingEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerButtonHoldingEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonHoldingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonHoldingEventArgs};

    // ----- RadialControllerButtonPressedEventArgs class --------------------

    static PyObject* _new_RadialControllerButtonPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonPressedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerButtonPressedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonPressedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonPressedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonPressedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerButtonPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonPressedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerButtonPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerButtonPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerButtonPressedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerButtonPressedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerButtonPressedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerButtonPressedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerButtonPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerButtonPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerButtonPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerButtonPressedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerButtonPressedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerButtonPressedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonPressedEventArgs};

    // ----- RadialControllerButtonReleasedEventArgs class --------------------

    static PyObject* _new_RadialControllerButtonReleasedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerButtonReleasedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerButtonReleasedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonReleasedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerButtonReleasedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerButtonReleasedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerButtonReleasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerButtonReleasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerButtonReleasedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerButtonReleasedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerButtonReleasedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerButtonReleasedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerButtonReleasedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerButtonReleasedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerButtonReleasedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerButtonReleasedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerButtonReleasedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerButtonReleasedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerButtonReleasedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerButtonReleasedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerButtonReleasedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerButtonReleasedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerButtonReleasedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerButtonReleasedEventArgs};

    // ----- RadialControllerConfiguration class --------------------

    static PyObject* _new_RadialControllerConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerConfiguration(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerConfiguration_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialControllerConfiguration::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_ResetToDefaultMenuItems(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"ResetToDefaultMenuItems", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.ResetToDefaultMenuItems();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_SetDefaultMenuItems(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"SetDefaultMenuItems", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::RadialControllerSystemMenuItemKind>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetDefaultMenuItems(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_TrySelectDefaultMenuItem(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"TrySelectDefaultMenuItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialControllerSystemMenuItemKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySelectDefaultMenuItem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerConfiguration_get_IsMenuSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"IsMenuSuppressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMenuSuppressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_IsMenuSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"IsMenuSuppressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsMenuSuppressed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerConfiguration_get_ActiveControllerWhenMenuIsSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"ActiveControllerWhenMenuIsSuppressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ActiveControllerWhenMenuIsSuppressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_ActiveControllerWhenMenuIsSuppressed(py::wrapper::Windows::UI::Input::RadialControllerConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"ActiveControllerWhenMenuIsSuppressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialController>(arg);

            {
                auto _gil = release_gil();
                self->obj.ActiveControllerWhenMenuIsSuppressed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerConfiguration_get_IsAppControllerEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"IsAppControllerEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Input::RadialControllerConfiguration::IsAppControllerEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_IsAppControllerEnabled(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"IsAppControllerEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Input::RadialControllerConfiguration::IsAppControllerEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerConfiguration_get_AppController(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"AppController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::UI::Input::RadialControllerConfiguration::AppController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerConfiguration_put_AppController(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerConfiguration", L"AppController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialController>(arg);

            {
                auto _gil = release_gil();
                winrt::Windows::UI::Input::RadialControllerConfiguration::AppController(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RadialControllerConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerConfiguration[] = {
        { "reset_to_default_menu_items", reinterpret_cast<PyCFunction>(RadialControllerConfiguration_ResetToDefaultMenuItems), METH_VARARGS, nullptr },
        { "set_default_menu_items", reinterpret_cast<PyCFunction>(RadialControllerConfiguration_SetDefaultMenuItems), METH_VARARGS, nullptr },
        { "try_select_default_menu_item", reinterpret_cast<PyCFunction>(RadialControllerConfiguration_TrySelectDefaultMenuItem), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadialControllerConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerConfiguration), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerConfiguration[] = {
        { "is_menu_suppressed", reinterpret_cast<getter>(RadialControllerConfiguration_get_IsMenuSuppressed), reinterpret_cast<setter>(RadialControllerConfiguration_put_IsMenuSuppressed), nullptr, nullptr },
        { "active_controller_when_menu_is_suppressed", reinterpret_cast<getter>(RadialControllerConfiguration_get_ActiveControllerWhenMenuIsSuppressed), reinterpret_cast<setter>(RadialControllerConfiguration_put_ActiveControllerWhenMenuIsSuppressed), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerConfiguration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerConfiguration) },
        { }};

    static PyType_Spec type_spec_RadialControllerConfiguration = {
        "winrt._winrt_windows_ui_input.RadialControllerConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerConfiguration};

    static PyGetSetDef getset_RadialControllerConfiguration_Static[] = {
        { "is_app_controller_enabled", reinterpret_cast<getter>(RadialControllerConfiguration_get_IsAppControllerEnabled), reinterpret_cast<setter>(RadialControllerConfiguration_put_IsAppControllerEnabled), nullptr, nullptr },
        { "app_controller", reinterpret_cast<getter>(RadialControllerConfiguration_get_AppController), reinterpret_cast<setter>(RadialControllerConfiguration_put_AppController), nullptr, nullptr },
        { }};

    static PyMethodDef methods_RadialControllerConfiguration_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(RadialControllerConfiguration_GetForCurrentView), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_RadialControllerConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadialControllerConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadialControllerConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_RadialControllerConfiguration_Static = {
        "winrt._winrt_windows_ui_input.RadialControllerConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadialControllerConfiguration_Static};

    // ----- RadialControllerControlAcquiredEventArgs class --------------------

    static PyObject* _new_RadialControllerControlAcquiredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerControlAcquiredEventArgs(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerControlAcquiredEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerControlAcquiredEventArgs", L"IsButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerControlAcquiredEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerControlAcquiredEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerControlAcquiredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerControlAcquiredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerControlAcquiredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerControlAcquiredEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerControlAcquiredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerControlAcquiredEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerControlAcquiredEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerControlAcquiredEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "is_button_pressed", reinterpret_cast<getter>(RadialControllerControlAcquiredEventArgs_get_IsButtonPressed), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerControlAcquiredEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerControlAcquiredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerControlAcquiredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerControlAcquiredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerControlAcquiredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerControlAcquiredEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerControlAcquiredEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerControlAcquiredEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerControlAcquiredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerControlAcquiredEventArgs};

    // ----- RadialControllerMenu class --------------------

    static PyObject* _new_RadialControllerMenu(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerMenu>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerMenu>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerMenu(py::wrapper::Windows::UI::Input::RadialControllerMenu* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerMenu_GetSelectedMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenu", L"GetSelectedMenuItem", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSelectedMenuItem();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_SelectMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenu", L"SelectMenuItem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Input::RadialControllerMenuItem>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SelectMenuItem(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_TrySelectPreviouslySelectedMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenu", L"TrySelectPreviouslySelectedMenuItem", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySelectPreviouslySelectedMenuItem();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenu_get_IsEnabled(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenu", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerMenu_put_IsEnabled(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenu", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerMenu_get_Items(py::wrapper::Windows::UI::Input::RadialControllerMenu* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenu", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Items();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerMenu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerMenu>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerMenu(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerMenu>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerMenu[] = {
        { "get_selected_menu_item", reinterpret_cast<PyCFunction>(RadialControllerMenu_GetSelectedMenuItem), METH_VARARGS, nullptr },
        { "select_menu_item", reinterpret_cast<PyCFunction>(RadialControllerMenu_SelectMenuItem), METH_VARARGS, nullptr },
        { "try_select_previously_selected_menu_item", reinterpret_cast<PyCFunction>(RadialControllerMenu_TrySelectPreviouslySelectedMenuItem), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadialControllerMenu, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerMenu), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerMenu[] = {
        { "is_enabled", reinterpret_cast<getter>(RadialControllerMenu_get_IsEnabled), reinterpret_cast<setter>(RadialControllerMenu_put_IsEnabled), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(RadialControllerMenu_get_Items), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerMenu[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerMenu) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerMenu) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerMenu) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerMenu) },
        { }};

    static PyType_Spec type_spec_RadialControllerMenu = {
        "winrt._winrt_windows_ui_input.RadialControllerMenu",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerMenu),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerMenu};

    // ----- RadialControllerMenuItem class --------------------

    static PyObject* _new_RadialControllerMenuItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerMenuItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerMenuItem>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerMenuItem(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerMenuItem_CreateFromFontGlyph(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"CreateFromFontGlyph", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromFontGlyph(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_CreateFromFontGlyphWithUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"CreateFromFontGlyph", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromFontGlyph(param0, param1, param2, param3);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_CreateFromIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"CreateFromIcon", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromIcon(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_CreateFromKnownIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"CreateFromKnownIcon", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::RadialControllerMenuKnownIcon>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::RadialControllerMenuItem::CreateFromKnownIcon(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_get_Tag(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Tag();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialControllerMenuItem_put_Tag(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"Tag");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.Tag(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialControllerMenuItem_get_DisplayText(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"DisplayText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayText();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_add_Invoked(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::RadialControllerMenuItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Invoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerMenuItem_remove_Invoked(py::wrapper::Windows::UI::Input::RadialControllerMenuItem* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.RadialControllerMenuItem", L"Invoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Invoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerMenuItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerMenuItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerMenuItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerMenuItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerMenuItem[] = {
        { "add_invoked", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_add_Invoked), METH_O, nullptr },
        { "remove_invoked", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_remove_Invoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_RadialControllerMenuItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerMenuItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerMenuItem[] = {
        { "tag", reinterpret_cast<getter>(RadialControllerMenuItem_get_Tag), reinterpret_cast<setter>(RadialControllerMenuItem_put_Tag), nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(RadialControllerMenuItem_get_DisplayText), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerMenuItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerMenuItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerMenuItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerMenuItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerMenuItem) },
        { }};

    static PyType_Spec type_spec_RadialControllerMenuItem = {
        "winrt._winrt_windows_ui_input.RadialControllerMenuItem",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerMenuItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerMenuItem};

    static PyGetSetDef getset_RadialControllerMenuItem_Static[] = {
        { }};

    static PyMethodDef methods_RadialControllerMenuItem_Static[] = {
        { "create_from_font_glyph", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_CreateFromFontGlyph), METH_VARARGS, nullptr },
        { "create_from_font_glyph_with_uri", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_CreateFromFontGlyphWithUri), METH_VARARGS, nullptr },
        { "create_from_icon", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_CreateFromIcon), METH_VARARGS, nullptr },
        { "create_from_known_icon", reinterpret_cast<PyCFunction>(RadialControllerMenuItem_CreateFromKnownIcon), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_RadialControllerMenuItem_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadialControllerMenuItem_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadialControllerMenuItem_Static) },
        { }
    };

    static PyType_Spec type_spec_RadialControllerMenuItem_Static = {
        "winrt._winrt_windows_ui_input.RadialControllerMenuItem_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadialControllerMenuItem_Static};

    // ----- RadialControllerRotationChangedEventArgs class --------------------

    static PyObject* _new_RadialControllerRotationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerRotationChangedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerRotationChangedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_RotationDeltaInDegrees(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerRotationChangedEventArgs", L"RotationDeltaInDegrees");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RotationDeltaInDegrees();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerRotationChangedEventArgs", L"IsButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerRotationChangedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerRotationChangedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerRotationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerRotationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerRotationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerRotationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerRotationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerRotationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerRotationChangedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerRotationChangedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "rotation_delta_in_degrees", reinterpret_cast<getter>(RadialControllerRotationChangedEventArgs_get_RotationDeltaInDegrees), nullptr, nullptr, nullptr },
        { "is_button_pressed", reinterpret_cast<getter>(RadialControllerRotationChangedEventArgs_get_IsButtonPressed), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerRotationChangedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerRotationChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerRotationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerRotationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerRotationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerRotationChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerRotationChangedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerRotationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerRotationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerRotationChangedEventArgs};

    // ----- RadialControllerScreenContact class --------------------

    static PyObject* _new_RadialControllerScreenContact(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContact>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContact>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContact(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerScreenContact_get_Bounds(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContact", L"Bounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bounds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContact_get_Position(py::wrapper::Windows::UI::Input::RadialControllerScreenContact* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContact", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerScreenContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerScreenContact>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerScreenContact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContact[] = {
        { "_assign_array_", _assign_array_RadialControllerScreenContact, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerScreenContact), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerScreenContact[] = {
        { "bounds", reinterpret_cast<getter>(RadialControllerScreenContact_get_Bounds), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(RadialControllerScreenContact_get_Position), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerScreenContact[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerScreenContact) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerScreenContact) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerScreenContact) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerScreenContact) },
        { }};

    static PyType_Spec type_spec_RadialControllerScreenContact = {
        "winrt._winrt_windows_ui_input.RadialControllerScreenContact",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContact};

    // ----- RadialControllerScreenContactContinuedEventArgs class --------------------

    static PyObject* _new_RadialControllerScreenContactContinuedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactContinuedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactContinuedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactContinuedEventArgs", L"IsButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactContinuedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactContinuedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerScreenContactContinuedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerScreenContactContinuedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactContinuedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerScreenContactContinuedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerScreenContactContinuedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerScreenContactContinuedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerScreenContactContinuedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "is_button_pressed", reinterpret_cast<getter>(RadialControllerScreenContactContinuedEventArgs_get_IsButtonPressed), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerScreenContactContinuedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerScreenContactContinuedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerScreenContactContinuedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerScreenContactContinuedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerScreenContactContinuedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerScreenContactContinuedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerScreenContactContinuedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerScreenContactContinuedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactContinuedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactContinuedEventArgs};

    // ----- RadialControllerScreenContactEndedEventArgs class --------------------

    static PyObject* _new_RadialControllerScreenContactEndedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactEndedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerScreenContactEndedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactEndedEventArgs", L"IsButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactEndedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactEndedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerScreenContactEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerScreenContactEndedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactEndedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerScreenContactEndedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerScreenContactEndedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerScreenContactEndedEventArgs[] = {
        { "is_button_pressed", reinterpret_cast<getter>(RadialControllerScreenContactEndedEventArgs_get_IsButtonPressed), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerScreenContactEndedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerScreenContactEndedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerScreenContactEndedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerScreenContactEndedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerScreenContactEndedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerScreenContactEndedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerScreenContactEndedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerScreenContactEndedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactEndedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactEndedEventArgs};

    // ----- RadialControllerScreenContactStartedEventArgs class --------------------

    static PyObject* _new_RadialControllerScreenContactStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RadialControllerScreenContactStartedEventArgs(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_Contact(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactStartedEventArgs", L"Contact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Contact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_IsButtonPressed(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactStartedEventArgs", L"IsButtonPressed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsButtonPressed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialControllerScreenContactStartedEventArgs_get_SimpleHapticsController(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RadialControllerScreenContactStartedEventArgs", L"SimpleHapticsController");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SimpleHapticsController();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialControllerScreenContactStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialControllerScreenContactStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialControllerScreenContactStartedEventArgs[] = {
        { "_assign_array_", _assign_array_RadialControllerScreenContactStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialControllerScreenContactStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RadialControllerScreenContactStartedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(RadialControllerScreenContactStartedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "is_button_pressed", reinterpret_cast<getter>(RadialControllerScreenContactStartedEventArgs_get_IsButtonPressed), nullptr, nullptr, nullptr },
        { "simple_haptics_controller", reinterpret_cast<getter>(RadialControllerScreenContactStartedEventArgs_get_SimpleHapticsController), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RadialControllerScreenContactStartedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialControllerScreenContactStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialControllerScreenContactStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialControllerScreenContactStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialControllerScreenContactStartedEventArgs) },
        { }};

    static PyType_Spec type_spec_RadialControllerScreenContactStartedEventArgs = {
        "winrt._winrt_windows_ui_input.RadialControllerScreenContactStartedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RadialControllerScreenContactStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialControllerScreenContactStartedEventArgs};

    // ----- RightTappedEventArgs class --------------------

    static PyObject* _new_RightTappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::RightTappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::RightTappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RightTappedEventArgs(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RightTappedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RightTappedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RightTappedEventArgs_get_Position(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RightTappedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RightTappedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::RightTappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.RightTappedEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::RightTappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RightTappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::RightTappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RightTappedEventArgs[] = {
        { "_assign_array_", _assign_array_RightTappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RightTappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RightTappedEventArgs[] = {
        { "pointer_device_type", reinterpret_cast<getter>(RightTappedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(RightTappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(RightTappedEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RightTappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RightTappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RightTappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RightTappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RightTappedEventArgs) },
        { }};

    static PyType_Spec type_spec_RightTappedEventArgs = {
        "winrt._winrt_windows_ui_input.RightTappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::RightTappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RightTappedEventArgs};

    // ----- SystemButtonEventController class --------------------

    static PyObject* _new_SystemButtonEventController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::SystemButtonEventController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::SystemButtonEventController>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemButtonEventController(py::wrapper::Windows::UI::Input::SystemButtonEventController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemButtonEventController_CreateForDispatcherQueue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.SystemButtonEventController", L"CreateForDispatcherQueue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::DispatcherQueue>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::SystemButtonEventController::CreateForDispatcherQueue(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionButtonPressed(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionButtonPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemFunctionButtonPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionButtonPressed(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionButtonPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemFunctionButtonPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionButtonReleased(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionButtonReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemFunctionButtonReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionButtonReleased(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionButtonReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemFunctionButtonReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionLockChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionLockChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemFunctionLockChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionLockChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionLockChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemFunctionLockChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_add_SystemFunctionLockIndicatorChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionLockIndicatorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::SystemButtonEventController, winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SystemFunctionLockIndicatorChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemButtonEventController_remove_SystemFunctionLockIndicatorChanged(py::wrapper::Windows::UI::Input::SystemButtonEventController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.SystemButtonEventController", L"SystemFunctionLockIndicatorChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SystemFunctionLockIndicatorChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemButtonEventController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::SystemButtonEventController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemButtonEventController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemButtonEventController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemButtonEventController[] = {
        { "add_system_function_button_pressed", reinterpret_cast<PyCFunction>(SystemButtonEventController_add_SystemFunctionButtonPressed), METH_O, nullptr },
        { "remove_system_function_button_pressed", reinterpret_cast<PyCFunction>(SystemButtonEventController_remove_SystemFunctionButtonPressed), METH_O, nullptr },
        { "add_system_function_button_released", reinterpret_cast<PyCFunction>(SystemButtonEventController_add_SystemFunctionButtonReleased), METH_O, nullptr },
        { "remove_system_function_button_released", reinterpret_cast<PyCFunction>(SystemButtonEventController_remove_SystemFunctionButtonReleased), METH_O, nullptr },
        { "add_system_function_lock_changed", reinterpret_cast<PyCFunction>(SystemButtonEventController_add_SystemFunctionLockChanged), METH_O, nullptr },
        { "remove_system_function_lock_changed", reinterpret_cast<PyCFunction>(SystemButtonEventController_remove_SystemFunctionLockChanged), METH_O, nullptr },
        { "add_system_function_lock_indicator_changed", reinterpret_cast<PyCFunction>(SystemButtonEventController_add_SystemFunctionLockIndicatorChanged), METH_O, nullptr },
        { "remove_system_function_lock_indicator_changed", reinterpret_cast<PyCFunction>(SystemButtonEventController_remove_SystemFunctionLockIndicatorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SystemButtonEventController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemButtonEventController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemButtonEventController[] = {
        { }};

    static PyType_Slot _type_slots_SystemButtonEventController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemButtonEventController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemButtonEventController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemButtonEventController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemButtonEventController) },
        { }};

    static PyType_Spec type_spec_SystemButtonEventController = {
        "winrt._winrt_windows_ui_input.SystemButtonEventController",
        sizeof(py::wrapper::Windows::UI::Input::SystemButtonEventController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemButtonEventController};

    static PyGetSetDef getset_SystemButtonEventController_Static[] = {
        { }};

    static PyMethodDef methods_SystemButtonEventController_Static[] = {
        { "create_for_dispatcher_queue", reinterpret_cast<PyCFunction>(SystemButtonEventController_CreateForDispatcherQueue), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_SystemButtonEventController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemButtonEventController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemButtonEventController_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemButtonEventController_Static = {
        "winrt._winrt_windows_ui_input.SystemButtonEventController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemButtonEventController_Static};

    // ----- SystemFunctionButtonEventArgs class --------------------

    static PyObject* _new_SystemFunctionButtonEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemFunctionButtonEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemFunctionButtonEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionButtonEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionButtonEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionButtonEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionButtonEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionButtonEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemFunctionButtonEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemFunctionButtonEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionButtonEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionButtonEventArgs[] = {
        { "_assign_array_", _assign_array_SystemFunctionButtonEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemFunctionButtonEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemFunctionButtonEventArgs[] = {
        { "handled", reinterpret_cast<getter>(SystemFunctionButtonEventArgs_get_Handled), reinterpret_cast<setter>(SystemFunctionButtonEventArgs_put_Handled), nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SystemFunctionButtonEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemFunctionButtonEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemFunctionButtonEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemFunctionButtonEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemFunctionButtonEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemFunctionButtonEventArgs) },
        { }};

    static PyType_Spec type_spec_SystemFunctionButtonEventArgs = {
        "winrt._winrt_windows_ui_input.SystemFunctionButtonEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionButtonEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionButtonEventArgs};

    // ----- SystemFunctionLockChangedEventArgs class --------------------

    static PyObject* _new_SystemFunctionLockChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemFunctionLockChangedEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionLockChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_IsLocked(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockChangedEventArgs", L"IsLocked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLocked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemFunctionLockChangedEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockChangedEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemFunctionLockChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemFunctionLockChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionLockChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionLockChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SystemFunctionLockChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemFunctionLockChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemFunctionLockChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(SystemFunctionLockChangedEventArgs_get_Handled), reinterpret_cast<setter>(SystemFunctionLockChangedEventArgs_put_Handled), nullptr, nullptr },
        { "is_locked", reinterpret_cast<getter>(SystemFunctionLockChangedEventArgs_get_IsLocked), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SystemFunctionLockChangedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemFunctionLockChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemFunctionLockChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemFunctionLockChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemFunctionLockChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemFunctionLockChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SystemFunctionLockChangedEventArgs = {
        "winrt._winrt_windows_ui_input.SystemFunctionLockChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionLockChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionLockChangedEventArgs};

    // ----- SystemFunctionLockIndicatorChangedEventArgs class --------------------

    static PyObject* _new_SystemFunctionLockIndicatorChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemFunctionLockIndicatorChangedEventArgs(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockIndicatorChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SystemFunctionLockIndicatorChangedEventArgs_put_Handled(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockIndicatorChangedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_IsIndicatorOn(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockIndicatorChangedEventArgs", L"IsIndicatorOn");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIndicatorOn();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemFunctionLockIndicatorChangedEventArgs_get_Timestamp(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.SystemFunctionLockIndicatorChangedEventArgs", L"Timestamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Timestamp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemFunctionLockIndicatorChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemFunctionLockIndicatorChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemFunctionLockIndicatorChangedEventArgs[] = {
        { "_assign_array_", _assign_array_SystemFunctionLockIndicatorChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemFunctionLockIndicatorChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SystemFunctionLockIndicatorChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(SystemFunctionLockIndicatorChangedEventArgs_get_Handled), reinterpret_cast<setter>(SystemFunctionLockIndicatorChangedEventArgs_put_Handled), nullptr, nullptr },
        { "is_indicator_on", reinterpret_cast<getter>(SystemFunctionLockIndicatorChangedEventArgs_get_IsIndicatorOn), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SystemFunctionLockIndicatorChangedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SystemFunctionLockIndicatorChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemFunctionLockIndicatorChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemFunctionLockIndicatorChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemFunctionLockIndicatorChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemFunctionLockIndicatorChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_SystemFunctionLockIndicatorChangedEventArgs = {
        "winrt._winrt_windows_ui_input.SystemFunctionLockIndicatorChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::SystemFunctionLockIndicatorChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemFunctionLockIndicatorChangedEventArgs};

    // ----- TappedEventArgs class --------------------

    static PyObject* _new_TappedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::TappedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::TappedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TappedEventArgs(py::wrapper::Windows::UI::Input::TappedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TappedEventArgs_get_PointerDeviceType(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TappedEventArgs", L"PointerDeviceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerDeviceType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_Position(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TappedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Position();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_TapCount(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TappedEventArgs", L"TapCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TapCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TappedEventArgs_get_ContactCount(py::wrapper::Windows::UI::Input::TappedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TappedEventArgs", L"ContactCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContactCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::TappedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TappedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::TappedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TappedEventArgs[] = {
        { "_assign_array_", _assign_array_TappedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TappedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TappedEventArgs[] = {
        { "pointer_device_type", reinterpret_cast<getter>(TappedEventArgs_get_PointerDeviceType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TappedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "tap_count", reinterpret_cast<getter>(TappedEventArgs_get_TapCount), nullptr, nullptr, nullptr },
        { "contact_count", reinterpret_cast<getter>(TappedEventArgs_get_ContactCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TappedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TappedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TappedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TappedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TappedEventArgs) },
        { }};

    static PyType_Spec type_spec_TappedEventArgs = {
        "winrt._winrt_windows_ui_input.TappedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::TappedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TappedEventArgs};

    // ----- TouchpadGesturesController class --------------------

    static PyObject* _new_TouchpadGesturesController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::TouchpadGesturesController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::TouchpadGesturesController>::type_name);
        return nullptr;
    }

    static void _dealloc_TouchpadGesturesController(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchpadGesturesController_CreateForProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.TouchpadGesturesController", L"CreateForProcess", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::TouchpadGesturesController::CreateForProcess();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.TouchpadGesturesController", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::UI::Input::TouchpadGesturesController::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_get_SupportedGestures(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TouchpadGesturesController", L"SupportedGestures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedGestures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchpadGesturesController_put_SupportedGestures(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TouchpadGesturesController", L"SupportedGestures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Input::TouchpadGlobalGestureKinds>(arg);

            {
                auto _gil = release_gil();
                self->obj.SupportedGestures(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchpadGesturesController_get_GesturesEnabled(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TouchpadGesturesController", L"GesturesEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GesturesEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TouchpadGesturesController_put_GesturesEnabled(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TouchpadGesturesController", L"GesturesEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.GesturesEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TouchpadGesturesController_add_PointerMoved(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::TouchpadGesturesController, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerMoved(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_remove_PointerMoved(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerMoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerMoved(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_add_PointerPressed(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::TouchpadGesturesController, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerPressed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_remove_PointerPressed(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerPressed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerPressed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_add_PointerReleased(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::TouchpadGesturesController, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PointerReleased(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_remove_PointerReleased(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"PointerReleased");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.PointerReleased(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_add_TouchpadGlobalActionPerformed(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"TouchpadGlobalActionPerformed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::TouchpadGesturesController, winrt::Windows::UI::Input::TouchpadGlobalActionEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TouchpadGlobalActionPerformed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TouchpadGesturesController_remove_TouchpadGlobalActionPerformed(py::wrapper::Windows::UI::Input::TouchpadGesturesController* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Input.TouchpadGesturesController", L"TouchpadGlobalActionPerformed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TouchpadGlobalActionPerformed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchpadGesturesController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::TouchpadGesturesController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchpadGesturesController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::TouchpadGesturesController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchpadGesturesController[] = {
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(TouchpadGesturesController_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(TouchpadGesturesController_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(TouchpadGesturesController_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(TouchpadGesturesController_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(TouchpadGesturesController_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(TouchpadGesturesController_remove_PointerReleased), METH_O, nullptr },
        { "add_touchpad_global_action_performed", reinterpret_cast<PyCFunction>(TouchpadGesturesController_add_TouchpadGlobalActionPerformed), METH_O, nullptr },
        { "remove_touchpad_global_action_performed", reinterpret_cast<PyCFunction>(TouchpadGesturesController_remove_TouchpadGlobalActionPerformed), METH_O, nullptr },
        { "_assign_array_", _assign_array_TouchpadGesturesController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchpadGesturesController), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TouchpadGesturesController[] = {
        { "supported_gestures", reinterpret_cast<getter>(TouchpadGesturesController_get_SupportedGestures), reinterpret_cast<setter>(TouchpadGesturesController_put_SupportedGestures), nullptr, nullptr },
        { "gestures_enabled", reinterpret_cast<getter>(TouchpadGesturesController_get_GesturesEnabled), reinterpret_cast<setter>(TouchpadGesturesController_put_GesturesEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TouchpadGesturesController[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchpadGesturesController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchpadGesturesController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchpadGesturesController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchpadGesturesController) },
        { }};

    static PyType_Spec type_spec_TouchpadGesturesController = {
        "winrt._winrt_windows_ui_input.TouchpadGesturesController",
        sizeof(py::wrapper::Windows::UI::Input::TouchpadGesturesController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchpadGesturesController};

    static PyGetSetDef getset_TouchpadGesturesController_Static[] = {
        { }};

    static PyMethodDef methods_TouchpadGesturesController_Static[] = {
        { "create_for_process", reinterpret_cast<PyCFunction>(TouchpadGesturesController_CreateForProcess), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(TouchpadGesturesController_IsSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_TouchpadGesturesController_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TouchpadGesturesController_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TouchpadGesturesController_Static) },
        { }
    };

    static PyType_Spec type_spec_TouchpadGesturesController_Static = {
        "winrt._winrt_windows_ui_input.TouchpadGesturesController_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TouchpadGesturesController_Static};

    // ----- TouchpadGlobalActionEventArgs class --------------------

    static PyObject* _new_TouchpadGlobalActionEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::TouchpadGlobalActionEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::TouchpadGlobalActionEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_TouchpadGlobalActionEventArgs(py::wrapper::Windows::UI::Input::TouchpadGlobalActionEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TouchpadGlobalActionEventArgs_get_Action(py::wrapper::Windows::UI::Input::TouchpadGlobalActionEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.TouchpadGlobalActionEventArgs", L"Action");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Action();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TouchpadGlobalActionEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::TouchpadGlobalActionEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TouchpadGlobalActionEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::TouchpadGlobalActionEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TouchpadGlobalActionEventArgs[] = {
        { "_assign_array_", _assign_array_TouchpadGlobalActionEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TouchpadGlobalActionEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TouchpadGlobalActionEventArgs[] = {
        { "action", reinterpret_cast<getter>(TouchpadGlobalActionEventArgs_get_Action), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TouchpadGlobalActionEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TouchpadGlobalActionEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TouchpadGlobalActionEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TouchpadGlobalActionEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TouchpadGlobalActionEventArgs) },
        { }};

    static PyType_Spec type_spec_TouchpadGlobalActionEventArgs = {
        "winrt._winrt_windows_ui_input.TouchpadGlobalActionEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::TouchpadGlobalActionEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TouchpadGlobalActionEventArgs};

    // ----- IPointerPointTransform interface --------------------

    static PyObject* _new_IPointerPointTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::IPointerPointTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::IPointerPointTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_IPointerPointTransform(py::wrapper::Windows::UI::Input::IPointerPointTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPointerPointTransform_TransformBounds(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.IPointerPointTransform", L"TransformBounds", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TransformBounds(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_TryTransform(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.IPointerPointTransform", L"TryTransform", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryTransform(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPointerPointTransform_get_Inverse(py::wrapper::Windows::UI::Input::IPointerPointTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.IPointerPointTransform", L"Inverse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Inverse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPointerPointTransform[] = {
        { "transform_bounds", reinterpret_cast<PyCFunction>(IPointerPointTransform_TransformBounds), METH_VARARGS, nullptr },
        { "try_transform", reinterpret_cast<PyCFunction>(IPointerPointTransform_TryTransform), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IPointerPointTransform[] = {
        { "inverse", reinterpret_cast<getter>(IPointerPointTransform_get_Inverse), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IPointerPointTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPointerPointTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPointerPointTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPointerPointTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPointerPointTransform) },
        { }};

    static PyType_Spec type_spec_IPointerPointTransform = {
        "winrt._winrt_windows_ui_input._IPointerPointTransform",
        sizeof(py::wrapper::Windows::UI::Input::IPointerPointTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPointerPointTransform};

    struct ImplementsIPointerPointTransform : py::ImplementsInterfaceT<ImplementsIPointerPointTransform, winrt::Windows::UI::Input::IPointerPointTransform>
    {
        ImplementsIPointerPointTransform() = delete;
        ImplementsIPointerPointTransform(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIPointerPointTransform, winrt::Windows::UI::Input::IPointerPointTransform>(py_obj, runtime_class)
        {
        }

        auto TransformBounds(winrt::Windows::Foundation::Rect param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "transform_bounds")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::Rect>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto TryTransform(winrt::Windows::Foundation::Point param0, winrt::Windows::Foundation::Point& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "try_transform")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                param1 = py::convert_to<winrt::Windows::Foundation::Point>(return_value.get(), 1);

                return py::convert_to<bool>(return_value.get(), 0);
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Inverse()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "inverse")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::UI::Input::IPointerPointTransform>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IPointerPointTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::IPointerPointTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPointerPointTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::IPointerPointTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIPointerPointTransform(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Windows::UI::Input::IPointerPointTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIPointerPointTransform(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIPointerPointTransform>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIPointerPointTransform[] = {
        { "_assign_array_", _assign_array_IPointerPointTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPointerPointTransform), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIPointerPointTransform), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIPointerPointTransform), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIPointerPointTransform[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIPointerPointTransform) },
        { }};

    static PyType_Spec type_spec_ImplementsIPointerPointTransform = {
        "winrt._winrt_windows_ui_input.IPointerPointTransform",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIPointerPointTransform};

    // ----- CrossSlideThresholds struct --------------------

    PyObject* _new_CrossSlideThresholds(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::CrossSlideThresholds>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        float _SelectionStart{};
        float _SpeedBumpStart{};
        float _SpeedBumpEnd{};
        float _RearrangeStart{};

        static const char* kwlist[] = {"selection_start", "speed_bump_start", "speed_bump_end", "rearrange_start", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ffff", const_cast<char**>(kwlist), &_SelectionStart, &_SpeedBumpStart, &_SpeedBumpEnd, &_RearrangeStart))
        {
            return nullptr;
        }

        try
        {
            self->obj.SelectionStart = _SelectionStart;
            self->obj.SpeedBumpStart = _SpeedBumpStart;
            self->obj.SpeedBumpEnd = _SpeedBumpEnd;
            self->obj.RearrangeStart = _RearrangeStart;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_CrossSlideThresholds(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CrossSlideThresholds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::CrossSlideThresholds>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_CrossSlideThresholds[] = {
        { "_assign_array_", _assign_array_CrossSlideThresholds, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* CrossSlideThresholds_get_SelectionStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_SpeedBumpEnd(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedBumpEnd);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CrossSlideThresholds_get_RearrangeStart(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RearrangeStart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_CrossSlideThresholds[] = {
        { "selection_start", reinterpret_cast<getter>(CrossSlideThresholds_get_SelectionStart), nullptr, nullptr, nullptr },
        { "speed_bump_start", reinterpret_cast<getter>(CrossSlideThresholds_get_SpeedBumpStart), nullptr, nullptr, nullptr },
        { "speed_bump_end", reinterpret_cast<getter>(CrossSlideThresholds_get_SpeedBumpEnd), nullptr, nullptr, nullptr },
        { "rearrange_start", reinterpret_cast<getter>(CrossSlideThresholds_get_RearrangeStart), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_CrossSlideThresholds(py::wrapper::Windows::UI::Input::CrossSlideThresholds* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Input::CrossSlideThresholds>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_CrossSlideThresholds(PyObject* self) noexcept
    {
        py::pyobj_handle SelectionStart{PyObject_GetAttrString(self, "selection_start")};
        if (!SelectionStart)
        {
            return nullptr;
        }

        py::pyobj_handle SpeedBumpStart{PyObject_GetAttrString(self, "speed_bump_start")};
        if (!SpeedBumpStart)
        {
            return nullptr;
        }

        py::pyobj_handle SpeedBumpEnd{PyObject_GetAttrString(self, "speed_bump_end")};
        if (!SpeedBumpEnd)
        {
            return nullptr;
        }

        py::pyobj_handle RearrangeStart{PyObject_GetAttrString(self, "rearrange_start")};
        if (!RearrangeStart)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("CrossSlideThresholds(selection_start=%R, speed_bump_start=%R, speed_bump_end=%R, rearrange_start=%R)", SelectionStart.get(), SpeedBumpStart.get(), SpeedBumpEnd.get(), RearrangeStart.get());
    }

    static PyType_Slot _type_slots_CrossSlideThresholds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CrossSlideThresholds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CrossSlideThresholds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CrossSlideThresholds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CrossSlideThresholds) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_CrossSlideThresholds) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_CrossSlideThresholds) },
        { }};

    static PyType_Spec type_spec_CrossSlideThresholds = {
        "winrt._winrt_windows_ui_input.CrossSlideThresholds",
        sizeof(py::wrapper::Windows::UI::Input::CrossSlideThresholds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CrossSlideThresholds};

    // ----- ManipulationDelta struct --------------------

    PyObject* _new_ManipulationDelta(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::ManipulationDelta>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        PyObject* _Translation{};
        float _Scale{};
        float _Rotation{};
        float _Expansion{};

        static const char* kwlist[] = {"translation", "scale", "rotation", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Offf", const_cast<char**>(kwlist), &_Translation, &_Scale, &_Rotation, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            self->obj.Translation = py::convert_to<winrt::Windows::Foundation::Point>(_Translation);
            self->obj.Scale = _Scale;
            self->obj.Rotation = _Rotation;
            self->obj.Expansion = _Expansion;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationDelta(py::wrapper::Windows::UI::Input::ManipulationDelta* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ManipulationDelta(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationDelta>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ManipulationDelta[] = {
        { "_assign_array_", _assign_array_ManipulationDelta, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* ManipulationDelta_get_Translation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Translation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Scale(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scale);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Rotation(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationDelta_get_Expansion(py::wrapper::Windows::UI::Input::ManipulationDelta* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_ManipulationDelta[] = {
        { "translation", reinterpret_cast<getter>(ManipulationDelta_get_Translation), nullptr, nullptr, nullptr },
        { "scale", reinterpret_cast<getter>(ManipulationDelta_get_Scale), nullptr, nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(ManipulationDelta_get_Rotation), nullptr, nullptr, nullptr },
        { "expansion", reinterpret_cast<getter>(ManipulationDelta_get_Expansion), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_ManipulationDelta(py::wrapper::Windows::UI::Input::ManipulationDelta* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Input::ManipulationDelta>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_ManipulationDelta(PyObject* self) noexcept
    {
        py::pyobj_handle Translation{PyObject_GetAttrString(self, "translation")};
        if (!Translation)
        {
            return nullptr;
        }

        py::pyobj_handle Scale{PyObject_GetAttrString(self, "scale")};
        if (!Scale)
        {
            return nullptr;
        }

        py::pyobj_handle Rotation{PyObject_GetAttrString(self, "rotation")};
        if (!Rotation)
        {
            return nullptr;
        }

        py::pyobj_handle Expansion{PyObject_GetAttrString(self, "expansion")};
        if (!Expansion)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("ManipulationDelta(translation=%R, scale=%R, rotation=%R, expansion=%R)", Translation.get(), Scale.get(), Rotation.get(), Expansion.get());
    }

    static PyType_Slot _type_slots_ManipulationDelta[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationDelta) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationDelta) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationDelta) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationDelta) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_ManipulationDelta) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_ManipulationDelta) },
        { }};

    static PyType_Spec type_spec_ManipulationDelta = {
        "winrt._winrt_windows_ui_input.ManipulationDelta",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationDelta),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationDelta};

    // ----- ManipulationVelocities struct --------------------

    PyObject* _new_ManipulationVelocities(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::ManipulationVelocities>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        PyObject* _Linear{};
        float _Angular{};
        float _Expansion{};

        static const char* kwlist[] = {"linear", "angular", "expansion", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Off", const_cast<char**>(kwlist), &_Linear, &_Angular, &_Expansion))
        {
            return nullptr;
        }

        try
        {
            self->obj.Linear = py::convert_to<winrt::Windows::Foundation::Point>(_Linear);
            self->obj.Angular = _Angular;
            self->obj.Expansion = _Expansion;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ManipulationVelocities(py::wrapper::Windows::UI::Input::ManipulationVelocities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ManipulationVelocities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::ManipulationVelocities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_ManipulationVelocities[] = {
        { "_assign_array_", _assign_array_ManipulationVelocities, METH_O | METH_STATIC, nullptr },
        { }};

    static PyObject* ManipulationVelocities_get_Linear(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Linear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationVelocities_get_Angular(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Angular);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ManipulationVelocities_get_Expansion(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Expansion);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_ManipulationVelocities[] = {
        { "linear", reinterpret_cast<getter>(ManipulationVelocities_get_Linear), nullptr, nullptr, nullptr },
        { "angular", reinterpret_cast<getter>(ManipulationVelocities_get_Angular), nullptr, nullptr, nullptr },
        { "expansion", reinterpret_cast<getter>(ManipulationVelocities_get_Expansion), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_ManipulationVelocities(py::wrapper::Windows::UI::Input::ManipulationVelocities* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::UI::Input::ManipulationVelocities>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_ManipulationVelocities(PyObject* self) noexcept
    {
        py::pyobj_handle Linear{PyObject_GetAttrString(self, "linear")};
        if (!Linear)
        {
            return nullptr;
        }

        py::pyobj_handle Angular{PyObject_GetAttrString(self, "angular")};
        if (!Angular)
        {
            return nullptr;
        }

        py::pyobj_handle Expansion{PyObject_GetAttrString(self, "expansion")};
        if (!Expansion)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("ManipulationVelocities(linear=%R, angular=%R, expansion=%R)", Linear.get(), Angular.get(), Expansion.get());
    }

    static PyType_Slot _type_slots_ManipulationVelocities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ManipulationVelocities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ManipulationVelocities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ManipulationVelocities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ManipulationVelocities) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_ManipulationVelocities) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_ManipulationVelocities) },
        { }};

    static PyType_Spec type_spec_ManipulationVelocities = {
        "winrt._winrt_windows_ui_input.ManipulationVelocities",
        sizeof(py::wrapper::Windows::UI::Input::ManipulationVelocities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ManipulationVelocities};

    // ----- Windows.UI.Input Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Input");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_input",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Input

PyMODINIT_FUNC PyInit__winrt_windows_ui_input(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle AttachableInputObject_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!AttachableInputObject_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AttachableInputObject_Static{PyType_FromSpecWithBases(&type_spec_AttachableInputObject_Static, AttachableInputObject_Static_bases.get())};
    if (!type_AttachableInputObject_Static)
    {
        return nullptr;
    }

    py::pytype_handle AttachableInputObject_type{py::register_python_type(module.get(), &type_spec_AttachableInputObject, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AttachableInputObject_Static.get()))};
    if (!AttachableInputObject_type)
    {
        return nullptr;
    }

    py::pytype_handle CrossSlidingEventArgs_type{py::register_python_type(module.get(), &type_spec_CrossSlidingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!CrossSlidingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle DraggingEventArgs_type{py::register_python_type(module.get(), &type_spec_DraggingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DraggingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle EdgeGesture_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!EdgeGesture_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_EdgeGesture_Static{PyType_FromSpecWithBases(&type_spec_EdgeGesture_Static, EdgeGesture_Static_bases.get())};
    if (!type_EdgeGesture_Static)
    {
        return nullptr;
    }

    py::pytype_handle EdgeGesture_type{py::register_python_type(module.get(), &type_spec_EdgeGesture, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EdgeGesture_Static.get()))};
    if (!EdgeGesture_type)
    {
        return nullptr;
    }

    py::pytype_handle EdgeGestureEventArgs_type{py::register_python_type(module.get(), &type_spec_EdgeGestureEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!EdgeGestureEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle GestureRecognizer_type{py::register_python_type(module.get(), &type_spec_GestureRecognizer, object_bases.get(), inspectable_meta_type)};
    if (!GestureRecognizer_type)
    {
        return nullptr;
    }

    py::pytype_handle HoldingEventArgs_type{py::register_python_type(module.get(), &type_spec_HoldingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!HoldingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle InputActivationListener_bases{PyTuple_Pack(1, AttachableInputObject_type.get())};
    if (!InputActivationListener_bases)
    {
        return nullptr;
    }

    py::pytype_handle InputActivationListener_type{py::register_python_type(module.get(), &type_spec_InputActivationListener, InputActivationListener_bases.get(), inspectable_meta_type)};
    if (!InputActivationListener_type)
    {
        return nullptr;
    }

    py::pytype_handle InputActivationListenerActivationChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_InputActivationListenerActivationChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!InputActivationListenerActivationChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle KeyboardDeliveryInterceptor_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!KeyboardDeliveryInterceptor_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KeyboardDeliveryInterceptor_Static{PyType_FromSpecWithBases(&type_spec_KeyboardDeliveryInterceptor_Static, KeyboardDeliveryInterceptor_Static_bases.get())};
    if (!type_KeyboardDeliveryInterceptor_Static)
    {
        return nullptr;
    }

    py::pytype_handle KeyboardDeliveryInterceptor_type{py::register_python_type(module.get(), &type_spec_KeyboardDeliveryInterceptor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KeyboardDeliveryInterceptor_Static.get()))};
    if (!KeyboardDeliveryInterceptor_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationInertiaStartingEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationInertiaStartingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationInertiaStartingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationStartedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationUpdatedEventArgs_type{py::register_python_type(module.get(), &type_spec_ManipulationUpdatedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!ManipulationUpdatedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle MouseWheelParameters_type{py::register_python_type(module.get(), &type_spec_MouseWheelParameters, object_bases.get(), inspectable_meta_type)};
    if (!MouseWheelParameters_type)
    {
        return nullptr;
    }

    py::pytype_handle PhysicalGestureRecognizer_type{py::register_python_type(module.get(), &type_spec_PhysicalGestureRecognizer, object_bases.get(), inspectable_meta_type)};
    if (!PhysicalGestureRecognizer_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerPoint_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PointerPoint_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerPoint_Static{PyType_FromSpecWithBases(&type_spec_PointerPoint_Static, PointerPoint_Static_bases.get())};
    if (!type_PointerPoint_Static)
    {
        return nullptr;
    }

    py::pytype_handle PointerPoint_type{py::register_python_type(module.get(), &type_spec_PointerPoint, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerPoint_Static.get()))};
    if (!PointerPoint_type)
    {
        return nullptr;
    }

    py::pytype_handle PointerPointProperties_type{py::register_python_type(module.get(), &type_spec_PointerPointProperties, object_bases.get(), inspectable_meta_type)};
    if (!PointerPointProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle PointerVisualizationSettings_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PointerVisualizationSettings_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PointerVisualizationSettings_Static{PyType_FromSpecWithBases(&type_spec_PointerVisualizationSettings_Static, PointerVisualizationSettings_Static_bases.get())};
    if (!type_PointerVisualizationSettings_Static)
    {
        return nullptr;
    }

    py::pytype_handle PointerVisualizationSettings_type{py::register_python_type(module.get(), &type_spec_PointerVisualizationSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PointerVisualizationSettings_Static.get()))};
    if (!PointerVisualizationSettings_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadialController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!RadialController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadialController_Static{PyType_FromSpecWithBases(&type_spec_RadialController_Static, RadialController_Static_bases.get())};
    if (!type_RadialController_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadialController_type{py::register_python_type(module.get(), &type_spec_RadialController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadialController_Static.get()))};
    if (!RadialController_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerButtonClickedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerButtonClickedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerButtonClickedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerButtonHoldingEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerButtonHoldingEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerButtonHoldingEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerButtonPressedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerButtonPressedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerButtonPressedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerButtonReleasedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerButtonReleasedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerButtonReleasedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadialControllerConfiguration_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!RadialControllerConfiguration_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadialControllerConfiguration_Static{PyType_FromSpecWithBases(&type_spec_RadialControllerConfiguration_Static, RadialControllerConfiguration_Static_bases.get())};
    if (!type_RadialControllerConfiguration_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerConfiguration_type{py::register_python_type(module.get(), &type_spec_RadialControllerConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadialControllerConfiguration_Static.get()))};
    if (!RadialControllerConfiguration_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerControlAcquiredEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerControlAcquiredEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerControlAcquiredEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerMenu_type{py::register_python_type(module.get(), &type_spec_RadialControllerMenu, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerMenu_type)
    {
        return nullptr;
    }

    py::pyobj_handle RadialControllerMenuItem_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!RadialControllerMenuItem_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadialControllerMenuItem_Static{PyType_FromSpecWithBases(&type_spec_RadialControllerMenuItem_Static, RadialControllerMenuItem_Static_bases.get())};
    if (!type_RadialControllerMenuItem_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerMenuItem_type{py::register_python_type(module.get(), &type_spec_RadialControllerMenuItem, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadialControllerMenuItem_Static.get()))};
    if (!RadialControllerMenuItem_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerRotationChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerRotationChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerRotationChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerScreenContact_type{py::register_python_type(module.get(), &type_spec_RadialControllerScreenContact, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerScreenContact_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerScreenContactContinuedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerScreenContactContinuedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerScreenContactContinuedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerScreenContactEndedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerScreenContactEndedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerScreenContactEndedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RadialControllerScreenContactStartedEventArgs_type{py::register_python_type(module.get(), &type_spec_RadialControllerScreenContactStartedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RadialControllerScreenContactStartedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RightTappedEventArgs_type{py::register_python_type(module.get(), &type_spec_RightTappedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!RightTappedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle SystemButtonEventController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(AttachableInputObject_type.get())))};
    if (!SystemButtonEventController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemButtonEventController_Static{PyType_FromSpecWithBases(&type_spec_SystemButtonEventController_Static, SystemButtonEventController_Static_bases.get())};
    if (!type_SystemButtonEventController_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SystemButtonEventController_bases{PyTuple_Pack(1, AttachableInputObject_type.get())};
    if (!SystemButtonEventController_bases)
    {
        return nullptr;
    }

    py::pytype_handle SystemButtonEventController_type{py::register_python_type(module.get(), &type_spec_SystemButtonEventController, SystemButtonEventController_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemButtonEventController_Static.get()))};
    if (!SystemButtonEventController_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemFunctionButtonEventArgs_type{py::register_python_type(module.get(), &type_spec_SystemFunctionButtonEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SystemFunctionButtonEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemFunctionLockChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SystemFunctionLockChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SystemFunctionLockChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SystemFunctionLockIndicatorChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_SystemFunctionLockIndicatorChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SystemFunctionLockIndicatorChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TappedEventArgs_type{py::register_python_type(module.get(), &type_spec_TappedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TappedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle TouchpadGesturesController_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TouchpadGesturesController_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TouchpadGesturesController_Static{PyType_FromSpecWithBases(&type_spec_TouchpadGesturesController_Static, TouchpadGesturesController_Static_bases.get())};
    if (!type_TouchpadGesturesController_Static)
    {
        return nullptr;
    }

    py::pytype_handle TouchpadGesturesController_type{py::register_python_type(module.get(), &type_spec_TouchpadGesturesController, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TouchpadGesturesController_Static.get()))};
    if (!TouchpadGesturesController_type)
    {
        return nullptr;
    }

    py::pytype_handle TouchpadGlobalActionEventArgs_type{py::register_python_type(module.get(), &type_spec_TouchpadGlobalActionEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!TouchpadGlobalActionEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle IPointerPointTransform_type{py::register_python_type(module.get(), &type_spec_IPointerPointTransform, object_bases.get(), nullptr)};
    if (!IPointerPointTransform_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIPointerPointTransform_type{py::register_python_type(module.get(), &type_spec_ImplementsIPointerPointTransform, nullptr, inspectable_meta_type)};
    if (!ImplementsIPointerPointTransform_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIPointerPointTransform_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle CrossSlideThresholds_type{py::register_python_type(module.get(), &type_spec_CrossSlideThresholds, nullptr, nullptr)};
    if (!CrossSlideThresholds_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationDelta_type{py::register_python_type(module.get(), &type_spec_ManipulationDelta, nullptr, nullptr)};
    if (!ManipulationDelta_type)
    {
        return nullptr;
    }

    py::pytype_handle ManipulationVelocities_type{py::register_python_type(module.get(), &type_spec_ManipulationVelocities, nullptr, nullptr)};
    if (!ManipulationVelocities_type)
    {
        return nullptr;
    }


    return module.detach();
}
