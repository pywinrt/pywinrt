# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.haptics
import winrt.windows.devices.input
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.streams
import winrt.windows.system
import winrt.windows.ui.core

from winrt.windows.ui.input import CrossSlidingState, DraggingState, EdgeGestureKind, GazeInputAccessStatus, GestureSettings, HoldingState, InputActivationState, PointerUpdateKind, RadialControllerMenuKnownIcon, RadialControllerSystemMenuItemKind

Self = typing.TypeVar('Self')

@typing.final
class CrossSlideThresholds:
    selection_start: winrt.system.Single
    speed_bump_start: winrt.system.Single
    speed_bump_end: winrt.system.Single
    rearrange_start: winrt.system.Single
    def __init__(self, selection_start: winrt.system.Single, speed_bump_start: winrt.system.Single, speed_bump_end: winrt.system.Single, rearrange_start: winrt.system.Single) -> None: ...

@typing.final
class ManipulationDelta:
    translation: winrt.windows.foundation.Point
    scale: winrt.system.Single
    rotation: winrt.system.Single
    expansion: winrt.system.Single
    def __init__(self, translation: winrt.windows.foundation.Point, scale: winrt.system.Single, rotation: winrt.system.Single, expansion: winrt.system.Single) -> None: ...

@typing.final
class ManipulationVelocities:
    linear: winrt.windows.foundation.Point
    angular: winrt.system.Single
    expansion: winrt.system.Single
    def __init__(self, linear: winrt.windows.foundation.Point, angular: winrt.system.Single, expansion: winrt.system.Single) -> None: ...

@typing.final
class AttachableInputObject(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AttachableInputObject: ...
    def close(self) -> None: ...

@typing.final
class CrossSlidingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CrossSlidingEventArgs: ...
    @_property
    def cross_sliding_state(self) -> CrossSlidingState: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class DraggingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DraggingEventArgs: ...
    @_property
    def dragging_state(self) -> DraggingState: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class EdgeGesture_Static(type):
    def get_for_current_view(cls) -> typing.Optional[EdgeGesture]: ...

@typing.final
class EdgeGesture(winrt.system.Object, metaclass=EdgeGesture_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGesture: ...
    def add_canceled(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_completed(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_starting(self, handler: winrt.windows.foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class EdgeGestureEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGestureEventArgs: ...
    @_property
    def kind(self) -> EdgeGestureKind: ...

@typing.final
class GestureRecognizer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GestureRecognizer: ...
    def __new__(cls: typing.Type[GestureRecognizer]) -> GestureRecognizer:...
    def can_be_double_tap(self, value: typing.Optional[PointerPoint], /) -> bool: ...
    def complete_gesture(self) -> None: ...
    def process_down_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def process_inertia(self) -> None: ...
    def process_mouse_wheel_event(self, value: typing.Optional[PointerPoint], is_shift_key_down: bool, is_control_key_down: bool, /) -> None: ...
    def process_move_events(self, value: winrt.windows.foundation.collections.IVector[PointerPoint], /) -> None: ...
    def process_up_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def add_cross_sliding(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, CrossSlidingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_cross_sliding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_dragging(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, DraggingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_dragging(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_holding(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, HoldingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_completed(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_inertia_starting(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationInertiaStartingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_inertia_starting(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_started(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_started(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_updated(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, ManipulationUpdatedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_manipulation_updated(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_right_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, RightTappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_right_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_tapped(self, handler: winrt.windows.foundation.TypedEventHandler[GestureRecognizer, TappedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_tapped(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def show_gesture_feedback(self) -> bool: ...
    @show_gesture_feedback.setter
    def show_gesture_feedback(self, value: bool) -> None: ...
    @_property
    def pivot_radius(self) -> winrt.system.Single: ...
    @pivot_radius.setter
    def pivot_radius(self, value: winrt.system.Single) -> None: ...
    @_property
    def pivot_center(self) -> winrt.windows.foundation.Point: ...
    @pivot_center.setter
    def pivot_center(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def manipulation_exact(self) -> bool: ...
    @manipulation_exact.setter
    def manipulation_exact(self, value: bool) -> None: ...
    @_property
    def inertia_translation_displacement(self) -> winrt.system.Single: ...
    @inertia_translation_displacement.setter
    def inertia_translation_displacement(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_translation_deceleration(self) -> winrt.system.Single: ...
    @inertia_translation_deceleration.setter
    def inertia_translation_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_rotation_deceleration(self) -> winrt.system.Single: ...
    @inertia_rotation_deceleration.setter
    def inertia_rotation_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_rotation_angle(self) -> winrt.system.Single: ...
    @inertia_rotation_angle.setter
    def inertia_rotation_angle(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_expansion_deceleration(self) -> winrt.system.Single: ...
    @inertia_expansion_deceleration.setter
    def inertia_expansion_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_expansion(self) -> winrt.system.Single: ...
    @inertia_expansion.setter
    def inertia_expansion(self, value: winrt.system.Single) -> None: ...
    @_property
    def gesture_settings(self) -> GestureSettings: ...
    @gesture_settings.setter
    def gesture_settings(self, value: GestureSettings) -> None: ...
    @_property
    def cross_slide_thresholds(self) -> CrossSlideThresholds: ...
    @cross_slide_thresholds.setter
    def cross_slide_thresholds(self, value: CrossSlideThresholds) -> None: ...
    @_property
    def cross_slide_horizontally(self) -> bool: ...
    @cross_slide_horizontally.setter
    def cross_slide_horizontally(self, value: bool) -> None: ...
    @_property
    def cross_slide_exact(self) -> bool: ...
    @cross_slide_exact.setter
    def cross_slide_exact(self, value: bool) -> None: ...
    @_property
    def auto_process_inertia(self) -> bool: ...
    @auto_process_inertia.setter
    def auto_process_inertia(self, value: bool) -> None: ...
    @_property
    def is_active(self) -> bool: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def mouse_wheel_parameters(self) -> typing.Optional[MouseWheelParameters]: ...
    @_property
    def translation_min_contact_count(self) -> winrt.system.UInt32: ...
    @translation_min_contact_count.setter
    def translation_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def translation_max_contact_count(self) -> winrt.system.UInt32: ...
    @translation_max_contact_count.setter
    def translation_max_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def tap_min_contact_count(self) -> winrt.system.UInt32: ...
    @tap_min_contact_count.setter
    def tap_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def tap_max_contact_count(self) -> winrt.system.UInt32: ...
    @tap_max_contact_count.setter
    def tap_max_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hold_start_delay(self) -> datetime.timedelta: ...
    @hold_start_delay.setter
    def hold_start_delay(self, value: datetime.timedelta) -> None: ...
    @_property
    def hold_radius(self) -> winrt.system.Single: ...
    @hold_radius.setter
    def hold_radius(self, value: winrt.system.Single) -> None: ...
    @_property
    def hold_min_contact_count(self) -> winrt.system.UInt32: ...
    @hold_min_contact_count.setter
    def hold_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hold_max_contact_count(self) -> winrt.system.UInt32: ...
    @hold_max_contact_count.setter
    def hold_max_contact_count(self, value: winrt.system.UInt32) -> None: ...

@typing.final
class HoldingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingEventArgs: ...
    @_property
    def holding_state(self) -> HoldingState: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class InputActivationListener(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListener: ...
    def add_input_activation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[InputActivationListener, InputActivationListenerActivationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_input_activation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def state(self) -> InputActivationState: ...

@typing.final
class InputActivationListenerActivationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListenerActivationChangedEventArgs: ...
    @_property
    def state(self) -> InputActivationState: ...

@typing.final
class KeyboardDeliveryInterceptor_Static(type):
    def get_for_current_view(cls) -> typing.Optional[KeyboardDeliveryInterceptor]: ...

@typing.final
class KeyboardDeliveryInterceptor(winrt.system.Object, metaclass=KeyboardDeliveryInterceptor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardDeliveryInterceptor: ...
    def add_key_down(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardDeliveryInterceptor, winrt.windows.ui.core.KeyEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_down(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_key_up(self, handler: winrt.windows.foundation.TypedEventHandler[KeyboardDeliveryInterceptor, winrt.windows.ui.core.KeyEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_key_up(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_interception_enabled_when_in_foreground(self) -> bool: ...
    @is_interception_enabled_when_in_foreground.setter
    def is_interception_enabled_when_in_foreground(self, value: bool) -> None: ...

@typing.final
class ManipulationCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationInertiaStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def delta(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationStartedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationUpdatedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def delta(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class MouseWheelParameters(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MouseWheelParameters: ...
    @_property
    def page_translation(self) -> winrt.windows.foundation.Point: ...
    @page_translation.setter
    def page_translation(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def delta_scale(self) -> winrt.system.Single: ...
    @delta_scale.setter
    def delta_scale(self, value: winrt.system.Single) -> None: ...
    @_property
    def delta_rotation_angle(self) -> winrt.system.Single: ...
    @delta_rotation_angle.setter
    def delta_rotation_angle(self, value: winrt.system.Single) -> None: ...
    @_property
    def char_translation(self) -> winrt.windows.foundation.Point: ...
    @char_translation.setter
    def char_translation(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class PointerPoint_Static(type):
    @typing.overload
    def get_current_point(cls, pointer_id: winrt.system.UInt32, /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    def get_current_point(cls, pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    def get_intermediate_points(cls, pointer_id: winrt.system.UInt32, /) -> typing.Optional[winrt.windows.foundation.collections.IVector[PointerPoint]]: ...
    @typing.overload
    def get_intermediate_points(cls, pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[winrt.windows.foundation.collections.IVector[PointerPoint]]: ...

@typing.final
class PointerPoint(winrt.system.Object, metaclass=PointerPoint_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPoint: ...
    @_property
    def frame_id(self) -> winrt.system.UInt32: ...
    @_property
    def is_in_contact(self) -> bool: ...
    @_property
    def pointer_device(self) -> typing.Optional[winrt.windows.devices.input.PointerDevice]: ...
    @_property
    def pointer_id(self) -> winrt.system.UInt32: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def properties(self) -> typing.Optional[PointerPointProperties]: ...
    @_property
    def raw_position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class PointerPointProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPointProperties: ...
    def get_usage_value(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> winrt.system.Int32: ...
    def has_usage(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> bool: ...
    @_property
    def contact_rect(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def contact_rect_raw(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def is_barrel_button_pressed(self) -> bool: ...
    @_property
    def is_canceled(self) -> bool: ...
    @_property
    def is_eraser(self) -> bool: ...
    @_property
    def is_horizontal_mouse_wheel(self) -> bool: ...
    @_property
    def is_in_range(self) -> bool: ...
    @_property
    def is_inverted(self) -> bool: ...
    @_property
    def is_left_button_pressed(self) -> bool: ...
    @_property
    def is_middle_button_pressed(self) -> bool: ...
    @_property
    def is_primary(self) -> bool: ...
    @_property
    def is_right_button_pressed(self) -> bool: ...
    @_property
    def is_x_button1_pressed(self) -> bool: ...
    @_property
    def is_x_button2_pressed(self) -> bool: ...
    @_property
    def mouse_wheel_delta(self) -> winrt.system.Int32: ...
    @_property
    def orientation(self) -> winrt.system.Single: ...
    @_property
    def pointer_update_kind(self) -> PointerUpdateKind: ...
    @_property
    def pressure(self) -> winrt.system.Single: ...
    @_property
    def touch_confidence(self) -> bool: ...
    @_property
    def twist(self) -> winrt.system.Single: ...
    @_property
    def x_tilt(self) -> winrt.system.Single: ...
    @_property
    def y_tilt(self) -> winrt.system.Single: ...
    @_property
    def z_distance(self) -> typing.Optional[typing.Optional[winrt.system.Single]]: ...

@typing.final
class PointerVisualizationSettings_Static(type):
    def get_for_current_view(cls) -> typing.Optional[PointerVisualizationSettings]: ...

@typing.final
class PointerVisualizationSettings(winrt.system.Object, metaclass=PointerVisualizationSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerVisualizationSettings: ...
    @_property
    def is_contact_feedback_enabled(self) -> bool: ...
    @is_contact_feedback_enabled.setter
    def is_contact_feedback_enabled(self, value: bool) -> None: ...
    @_property
    def is_barrel_button_feedback_enabled(self) -> bool: ...
    @is_barrel_button_feedback_enabled.setter
    def is_barrel_button_feedback_enabled(self, value: bool) -> None: ...

@typing.final
class RadialController_Static(type):
    def create_for_current_view(cls) -> typing.Optional[RadialController]: ...
    def is_supported(cls) -> bool: ...

@typing.final
class RadialController(winrt.system.Object, metaclass=RadialController_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialController: ...
    def add_button_clicked(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonClickedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_clicked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_control_acquired(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerControlAcquiredEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_control_acquired(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_control_lost(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_control_lost(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rotation_changed(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerRotationChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rotation_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_continued(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerScreenContactContinuedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_continued(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_ended(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_ended(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_started(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerScreenContactStartedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_screen_contact_started(self, cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_holding(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonHoldingEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_holding(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_pressed(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonPressedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_button_released(self, handler: winrt.windows.foundation.TypedEventHandler[RadialController, RadialControllerButtonReleasedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_button_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def use_automatic_haptic_feedback(self) -> bool: ...
    @use_automatic_haptic_feedback.setter
    def use_automatic_haptic_feedback(self, value: bool) -> None: ...
    @_property
    def rotation_resolution_in_degrees(self) -> winrt.system.Double: ...
    @rotation_resolution_in_degrees.setter
    def rotation_resolution_in_degrees(self, value: winrt.system.Double) -> None: ...
    @_property
    def menu(self) -> typing.Optional[RadialControllerMenu]: ...

@typing.final
class RadialControllerButtonClickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonClickedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonHoldingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonHoldingEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonPressedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonPressedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonReleasedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonReleasedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerConfiguration_Static(type):
    def get_for_current_view(cls) -> typing.Optional[RadialControllerConfiguration]: ...
    @_property
    def is_app_controller_enabled(cls) -> bool: ...
    @is_app_controller_enabled.setter
    def is_app_controller_enabled(cls, value: bool) -> None: ...
    @_property
    def app_controller(cls) -> typing.Optional[RadialController]: ...
    @app_controller.setter
    def app_controller(cls, value: typing.Optional[RadialController]) -> None: ...

@typing.final
class RadialControllerConfiguration(winrt.system.Object, metaclass=RadialControllerConfiguration_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerConfiguration: ...
    def reset_to_default_menu_items(self) -> None: ...
    def set_default_menu_items(self, buttons: typing.Iterable[RadialControllerSystemMenuItemKind], /) -> None: ...
    def try_select_default_menu_item(self, type: RadialControllerSystemMenuItemKind, /) -> bool: ...
    @_property
    def is_menu_suppressed(self) -> bool: ...
    @is_menu_suppressed.setter
    def is_menu_suppressed(self, value: bool) -> None: ...
    @_property
    def active_controller_when_menu_is_suppressed(self) -> typing.Optional[RadialController]: ...
    @active_controller_when_menu_is_suppressed.setter
    def active_controller_when_menu_is_suppressed(self, value: typing.Optional[RadialController]) -> None: ...

@typing.final
class RadialControllerControlAcquiredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerControlAcquiredEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerMenu(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenu: ...
    def get_selected_menu_item(self) -> typing.Optional[RadialControllerMenuItem]: ...
    def select_menu_item(self, menu_item: typing.Optional[RadialControllerMenuItem], /) -> None: ...
    def try_select_previously_selected_menu_item(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[RadialControllerMenuItem]]: ...

@typing.final
class RadialControllerMenuItem_Static(type):
    @typing.overload
    def create_from_font_glyph(cls, display_text: str, glyph: str, font_family: str, /) -> typing.Optional[RadialControllerMenuItem]: ...
    @typing.overload
    def create_from_font_glyph(cls, display_text: str, glyph: str, font_family: str, font_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[RadialControllerMenuItem]: ...
    def create_from_icon(cls, display_text: str, icon: typing.Optional[winrt.windows.storage.streams.RandomAccessStreamReference], /) -> typing.Optional[RadialControllerMenuItem]: ...
    def create_from_known_icon(cls, display_text: str, value: RadialControllerMenuKnownIcon, /) -> typing.Optional[RadialControllerMenuItem]: ...

@typing.final
class RadialControllerMenuItem(winrt.system.Object, metaclass=RadialControllerMenuItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenuItem: ...
    def add_invoked(self, handler: winrt.windows.foundation.TypedEventHandler[RadialControllerMenuItem, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def tag(self) -> typing.Optional[winrt.system.Object]: ...
    @tag.setter
    def tag(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def display_text(self) -> str: ...

@typing.final
class RadialControllerRotationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerRotationChangedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def rotation_delta_in_degrees(self) -> winrt.system.Double: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContact(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContact: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...

@typing.final
class RadialControllerScreenContactContinuedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactContinuedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContactEndedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactEndedEventArgs: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContactStartedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactStartedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[winrt.windows.devices.haptics.SimpleHapticsController]: ...

@typing.final
class RightTappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedEventArgs: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class SystemButtonEventController_Static(type):
    def create_for_dispatcher_queue(cls, queue: typing.Optional[winrt.windows.system.DispatcherQueue], /) -> typing.Optional[SystemButtonEventController]: ...

@typing.final
class SystemButtonEventController(winrt.system.Object, metaclass=SystemButtonEventController_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemButtonEventController: ...
    def add_system_function_button_pressed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_button_pressed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_button_released(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_button_released(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_lock_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_indicator_changed(self, handler: winrt.windows.foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockIndicatorChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_system_function_lock_indicator_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class SystemFunctionButtonEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionButtonEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class SystemFunctionLockChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_locked(self) -> bool: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class SystemFunctionLockIndicatorChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockIndicatorChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_indicator_on(self) -> bool: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class TappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedEventArgs: ...
    @_property
    def pointer_device_type(self) -> winrt.windows.devices.input.PointerDeviceType: ...
    @_property
    def position(self) -> winrt.windows.foundation.Point: ...
    @_property
    def tap_count(self) -> winrt.system.UInt32: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class IPointerPointTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPointerPointTransform: ...
    def transform_bounds(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def try_transform(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    @_property
    def inverse(self) -> typing.Optional[IPointerPointTransform]: ...

