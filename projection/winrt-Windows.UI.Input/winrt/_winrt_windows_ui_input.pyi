# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.devices.haptics as windows_devices_haptics
import winrt.windows.devices.input as windows_devices_input
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.storage.streams as windows_storage_streams
import winrt.windows.system as windows_system
import winrt.windows.ui.core as windows_ui_core

from winrt.windows.ui.input import CrossSlidingState, DraggingState, EdgeGestureKind, GazeInputAccessStatus, GestureSettings, HoldingState, InputActivationState, PointerUpdateKind, RadialControllerMenuKnownIcon, RadialControllerSystemMenuItemKind

Self = typing.TypeVar('Self')

@typing.final
class CrossSlideThresholds:
    selection_start: winrt.system.Single
    speed_bump_start: winrt.system.Single
    speed_bump_end: winrt.system.Single
    rearrange_start: winrt.system.Single
    def __init__(self, selection_start: winrt.system.Single, speed_bump_start: winrt.system.Single, speed_bump_end: winrt.system.Single, rearrange_start: winrt.system.Single) -> None: ...

@typing.final
class ManipulationDelta:
    translation: windows_foundation.Point
    scale: winrt.system.Single
    rotation: winrt.system.Single
    expansion: winrt.system.Single
    def __init__(self, translation: windows_foundation.Point, scale: winrt.system.Single, rotation: winrt.system.Single, expansion: winrt.system.Single) -> None: ...

@typing.final
class ManipulationVelocities:
    linear: windows_foundation.Point
    angular: winrt.system.Single
    expansion: winrt.system.Single
    def __init__(self, linear: windows_foundation.Point, angular: winrt.system.Single, expansion: winrt.system.Single) -> None: ...

@typing.final
class AttachableInputObject(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AttachableInputObject: ...
    def close(self) -> None: ...

@typing.final
class CrossSlidingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CrossSlidingEventArgs: ...
    @_property
    def cross_sliding_state(self) -> CrossSlidingState: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class DraggingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DraggingEventArgs: ...
    @_property
    def dragging_state(self) -> DraggingState: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class EdgeGesture_Static(type):
    def get_for_current_view(cls) -> typing.Optional[EdgeGesture]: ...

@typing.final
class EdgeGesture(winrt.system.Object, metaclass=EdgeGesture_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGesture: ...
    def add_canceled(self, handler: windows_foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_canceled(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_completed(self, handler: windows_foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_starting(self, handler: windows_foundation.TypedEventHandler[EdgeGesture, EdgeGestureEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_starting(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class EdgeGestureEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EdgeGestureEventArgs: ...
    @_property
    def kind(self) -> EdgeGestureKind: ...

@typing.final
class GestureRecognizer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GestureRecognizer: ...
    def __new__(cls: typing.Type[GestureRecognizer]) -> GestureRecognizer: ...
    def can_be_double_tap(self, value: typing.Optional[PointerPoint], /) -> bool: ...
    def complete_gesture(self) -> None: ...
    def process_down_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def process_inertia(self) -> None: ...
    def process_mouse_wheel_event(self, value: typing.Optional[PointerPoint], is_shift_key_down: bool, is_control_key_down: bool, /) -> None: ...
    def process_move_events(self, value: windows_foundation_collections.IVector[PointerPoint], /) -> None: ...
    def process_up_event(self, value: typing.Optional[PointerPoint], /) -> None: ...
    def add_cross_sliding(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, CrossSlidingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_cross_sliding(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_dragging(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, DraggingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_dragging(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_holding(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, HoldingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_holding(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_completed(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, ManipulationCompletedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_manipulation_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_inertia_starting(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, ManipulationInertiaStartingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_manipulation_inertia_starting(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_started(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, ManipulationStartedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_manipulation_started(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_manipulation_updated(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, ManipulationUpdatedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_manipulation_updated(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_right_tapped(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, RightTappedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_right_tapped(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_tapped(self, handler: windows_foundation.TypedEventHandler[GestureRecognizer, TappedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_tapped(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def show_gesture_feedback(self) -> bool: ...
    @show_gesture_feedback.setter
    def show_gesture_feedback(self, value: bool) -> None: ...
    @_property
    def pivot_radius(self) -> winrt.system.Single: ...
    @pivot_radius.setter
    def pivot_radius(self, value: winrt.system.Single) -> None: ...
    @_property
    def pivot_center(self) -> windows_foundation.Point: ...
    @pivot_center.setter
    def pivot_center(self, value: windows_foundation.Point) -> None: ...
    @_property
    def manipulation_exact(self) -> bool: ...
    @manipulation_exact.setter
    def manipulation_exact(self, value: bool) -> None: ...
    @_property
    def inertia_translation_displacement(self) -> winrt.system.Single: ...
    @inertia_translation_displacement.setter
    def inertia_translation_displacement(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_translation_deceleration(self) -> winrt.system.Single: ...
    @inertia_translation_deceleration.setter
    def inertia_translation_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_rotation_deceleration(self) -> winrt.system.Single: ...
    @inertia_rotation_deceleration.setter
    def inertia_rotation_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_rotation_angle(self) -> winrt.system.Single: ...
    @inertia_rotation_angle.setter
    def inertia_rotation_angle(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_expansion_deceleration(self) -> winrt.system.Single: ...
    @inertia_expansion_deceleration.setter
    def inertia_expansion_deceleration(self, value: winrt.system.Single) -> None: ...
    @_property
    def inertia_expansion(self) -> winrt.system.Single: ...
    @inertia_expansion.setter
    def inertia_expansion(self, value: winrt.system.Single) -> None: ...
    @_property
    def gesture_settings(self) -> GestureSettings: ...
    @gesture_settings.setter
    def gesture_settings(self, value: GestureSettings) -> None: ...
    @_property
    def cross_slide_thresholds(self) -> CrossSlideThresholds: ...
    @cross_slide_thresholds.setter
    def cross_slide_thresholds(self, value: CrossSlideThresholds) -> None: ...
    @_property
    def cross_slide_horizontally(self) -> bool: ...
    @cross_slide_horizontally.setter
    def cross_slide_horizontally(self, value: bool) -> None: ...
    @_property
    def cross_slide_exact(self) -> bool: ...
    @cross_slide_exact.setter
    def cross_slide_exact(self, value: bool) -> None: ...
    @_property
    def auto_process_inertia(self) -> bool: ...
    @auto_process_inertia.setter
    def auto_process_inertia(self, value: bool) -> None: ...
    @_property
    def is_active(self) -> bool: ...
    @_property
    def is_inertial(self) -> bool: ...
    @_property
    def mouse_wheel_parameters(self) -> typing.Optional[MouseWheelParameters]: ...
    @_property
    def translation_min_contact_count(self) -> winrt.system.UInt32: ...
    @translation_min_contact_count.setter
    def translation_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def translation_max_contact_count(self) -> winrt.system.UInt32: ...
    @translation_max_contact_count.setter
    def translation_max_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def tap_min_contact_count(self) -> winrt.system.UInt32: ...
    @tap_min_contact_count.setter
    def tap_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def tap_max_contact_count(self) -> winrt.system.UInt32: ...
    @tap_max_contact_count.setter
    def tap_max_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hold_start_delay(self) -> datetime.timedelta: ...
    @hold_start_delay.setter
    def hold_start_delay(self, value: datetime.timedelta) -> None: ...
    @_property
    def hold_radius(self) -> winrt.system.Single: ...
    @hold_radius.setter
    def hold_radius(self, value: winrt.system.Single) -> None: ...
    @_property
    def hold_min_contact_count(self) -> winrt.system.UInt32: ...
    @hold_min_contact_count.setter
    def hold_min_contact_count(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def hold_max_contact_count(self) -> winrt.system.UInt32: ...
    @hold_max_contact_count.setter
    def hold_max_contact_count(self, value: winrt.system.UInt32) -> None: ...

@typing.final
class HoldingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> HoldingEventArgs: ...
    @_property
    def holding_state(self) -> HoldingState: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class InputActivationListener(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListener: ...
    def close(self) -> None: ...
    def add_input_activation_changed(self, handler: windows_foundation.TypedEventHandler[InputActivationListener, InputActivationListenerActivationChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_input_activation_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def state(self) -> InputActivationState: ...

@typing.final
class InputActivationListenerActivationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputActivationListenerActivationChangedEventArgs: ...
    @_property
    def state(self) -> InputActivationState: ...

@typing.final
class KeyboardDeliveryInterceptor_Static(type):
    def get_for_current_view(cls) -> typing.Optional[KeyboardDeliveryInterceptor]: ...

@typing.final
class KeyboardDeliveryInterceptor(winrt.system.Object, metaclass=KeyboardDeliveryInterceptor_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> KeyboardDeliveryInterceptor: ...
    def add_key_down(self, handler: windows_foundation.TypedEventHandler[KeyboardDeliveryInterceptor, windows_ui_core.KeyEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_key_down(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_key_up(self, handler: windows_foundation.TypedEventHandler[KeyboardDeliveryInterceptor, windows_ui_core.KeyEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_key_up(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def is_interception_enabled_when_in_foreground(self) -> bool: ...
    @is_interception_enabled_when_in_foreground.setter
    def is_interception_enabled_when_in_foreground(self, value: bool) -> None: ...

@typing.final
class ManipulationCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationCompletedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationInertiaStartingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationInertiaStartingEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def delta(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationStartedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationStartedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class ManipulationUpdatedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ManipulationUpdatedEventArgs: ...
    @_property
    def cumulative(self) -> ManipulationDelta: ...
    @_property
    def delta(self) -> ManipulationDelta: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def velocities(self) -> ManipulationVelocities: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...
    @_property
    def current_contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class MouseWheelParameters(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MouseWheelParameters: ...
    @_property
    def page_translation(self) -> windows_foundation.Point: ...
    @page_translation.setter
    def page_translation(self, value: windows_foundation.Point) -> None: ...
    @_property
    def delta_scale(self) -> winrt.system.Single: ...
    @delta_scale.setter
    def delta_scale(self, value: winrt.system.Single) -> None: ...
    @_property
    def delta_rotation_angle(self) -> winrt.system.Single: ...
    @delta_rotation_angle.setter
    def delta_rotation_angle(self, value: winrt.system.Single) -> None: ...
    @_property
    def char_translation(self) -> windows_foundation.Point: ...
    @char_translation.setter
    def char_translation(self, value: windows_foundation.Point) -> None: ...

@typing.final
class PointerPoint_Static(type):
    @typing.overload
    def get_current_point(cls, pointer_id: winrt.system.UInt32, /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    def get_current_point(cls, pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[PointerPoint]: ...
    @typing.overload
    def get_intermediate_points(cls, pointer_id: winrt.system.UInt32, /) -> typing.Optional[windows_foundation_collections.IVector[PointerPoint]]: ...
    @typing.overload
    def get_intermediate_points(cls, pointer_id: winrt.system.UInt32, transform: typing.Optional[IPointerPointTransform], /) -> typing.Optional[windows_foundation_collections.IVector[PointerPoint]]: ...

@typing.final
class PointerPoint(winrt.system.Object, metaclass=PointerPoint_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPoint: ...
    @_property
    def frame_id(self) -> winrt.system.UInt32: ...
    @_property
    def is_in_contact(self) -> bool: ...
    @_property
    def pointer_device(self) -> typing.Optional[windows_devices_input.PointerDevice]: ...
    @_property
    def pointer_id(self) -> winrt.system.UInt32: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def properties(self) -> typing.Optional[PointerPointProperties]: ...
    @_property
    def raw_position(self) -> windows_foundation.Point: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class PointerPointProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerPointProperties: ...
    def get_usage_value(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> winrt.system.Int32: ...
    def has_usage(self, usage_page: winrt.system.UInt32, usage_id: winrt.system.UInt32, /) -> bool: ...
    @_property
    def contact_rect(self) -> windows_foundation.Rect: ...
    @_property
    def contact_rect_raw(self) -> windows_foundation.Rect: ...
    @_property
    def is_barrel_button_pressed(self) -> bool: ...
    @_property
    def is_canceled(self) -> bool: ...
    @_property
    def is_eraser(self) -> bool: ...
    @_property
    def is_horizontal_mouse_wheel(self) -> bool: ...
    @_property
    def is_in_range(self) -> bool: ...
    @_property
    def is_inverted(self) -> bool: ...
    @_property
    def is_left_button_pressed(self) -> bool: ...
    @_property
    def is_middle_button_pressed(self) -> bool: ...
    @_property
    def is_primary(self) -> bool: ...
    @_property
    def is_right_button_pressed(self) -> bool: ...
    @_property
    def is_x_button1_pressed(self) -> bool: ...
    @_property
    def is_x_button2_pressed(self) -> bool: ...
    @_property
    def mouse_wheel_delta(self) -> winrt.system.Int32: ...
    @_property
    def orientation(self) -> winrt.system.Single: ...
    @_property
    def pointer_update_kind(self) -> PointerUpdateKind: ...
    @_property
    def pressure(self) -> winrt.system.Single: ...
    @_property
    def touch_confidence(self) -> bool: ...
    @_property
    def twist(self) -> winrt.system.Single: ...
    @_property
    def x_tilt(self) -> winrt.system.Single: ...
    @_property
    def y_tilt(self) -> winrt.system.Single: ...
    @_property
    def z_distance(self) -> typing.Optional[typing.Optional[winrt.system.Single]]: ...

@typing.final
class PointerVisualizationSettings_Static(type):
    def get_for_current_view(cls) -> typing.Optional[PointerVisualizationSettings]: ...

@typing.final
class PointerVisualizationSettings(winrt.system.Object, metaclass=PointerVisualizationSettings_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointerVisualizationSettings: ...
    @_property
    def is_contact_feedback_enabled(self) -> bool: ...
    @is_contact_feedback_enabled.setter
    def is_contact_feedback_enabled(self, value: bool) -> None: ...
    @_property
    def is_barrel_button_feedback_enabled(self) -> bool: ...
    @is_barrel_button_feedback_enabled.setter
    def is_barrel_button_feedback_enabled(self, value: bool) -> None: ...

@typing.final
class RadialController_Static(type):
    def create_for_current_view(cls) -> typing.Optional[RadialController]: ...
    def is_supported(cls) -> bool: ...

@typing.final
class RadialController(winrt.system.Object, metaclass=RadialController_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialController: ...
    def add_button_clicked(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerButtonClickedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_button_clicked(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_control_acquired(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerControlAcquiredEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_control_acquired(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_control_lost(self, handler: windows_foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_control_lost(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_rotation_changed(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerRotationChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_rotation_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_continued(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerScreenContactContinuedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_screen_contact_continued(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_ended(self, handler: windows_foundation.TypedEventHandler[RadialController, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_screen_contact_ended(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_screen_contact_started(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerScreenContactStartedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_screen_contact_started(self, cookie: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_button_holding(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerButtonHoldingEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_button_holding(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_button_pressed(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerButtonPressedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_button_pressed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_button_released(self, handler: windows_foundation.TypedEventHandler[RadialController, RadialControllerButtonReleasedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_button_released(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def use_automatic_haptic_feedback(self) -> bool: ...
    @use_automatic_haptic_feedback.setter
    def use_automatic_haptic_feedback(self, value: bool) -> None: ...
    @_property
    def rotation_resolution_in_degrees(self) -> winrt.system.Double: ...
    @rotation_resolution_in_degrees.setter
    def rotation_resolution_in_degrees(self, value: winrt.system.Double) -> None: ...
    @_property
    def menu(self) -> typing.Optional[RadialControllerMenu]: ...

@typing.final
class RadialControllerButtonClickedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonClickedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonHoldingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonHoldingEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonPressedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonPressedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerButtonReleasedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerButtonReleasedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerConfiguration_Static(type):
    def get_for_current_view(cls) -> typing.Optional[RadialControllerConfiguration]: ...
    @_property
    def is_app_controller_enabled(cls) -> bool: ...
    @is_app_controller_enabled.setter
    def is_app_controller_enabled(cls, value: bool) -> None: ...
    @_property
    def app_controller(cls) -> typing.Optional[RadialController]: ...
    @app_controller.setter
    def app_controller(cls, value: typing.Optional[RadialController]) -> None: ...

@typing.final
class RadialControllerConfiguration(winrt.system.Object, metaclass=RadialControllerConfiguration_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerConfiguration: ...
    def reset_to_default_menu_items(self) -> None: ...
    def set_default_menu_items(self, buttons: typing.Iterable[RadialControllerSystemMenuItemKind], /) -> None: ...
    def try_select_default_menu_item(self, type: RadialControllerSystemMenuItemKind, /) -> bool: ...
    @_property
    def is_menu_suppressed(self) -> bool: ...
    @is_menu_suppressed.setter
    def is_menu_suppressed(self, value: bool) -> None: ...
    @_property
    def active_controller_when_menu_is_suppressed(self) -> typing.Optional[RadialController]: ...
    @active_controller_when_menu_is_suppressed.setter
    def active_controller_when_menu_is_suppressed(self, value: typing.Optional[RadialController]) -> None: ...

@typing.final
class RadialControllerControlAcquiredEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerControlAcquiredEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerMenu(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenu: ...
    def get_selected_menu_item(self) -> typing.Optional[RadialControllerMenuItem]: ...
    def select_menu_item(self, menu_item: typing.Optional[RadialControllerMenuItem], /) -> None: ...
    def try_select_previously_selected_menu_item(self) -> bool: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    @_property
    def items(self) -> typing.Optional[windows_foundation_collections.IVector[RadialControllerMenuItem]]: ...

@typing.final
class RadialControllerMenuItem_Static(type):
    @typing.overload
    def create_from_font_glyph(cls, display_text: str, glyph: str, font_family: str, /) -> typing.Optional[RadialControllerMenuItem]: ...
    @typing.overload
    def create_from_font_glyph(cls, display_text: str, glyph: str, font_family: str, font_uri: typing.Optional[windows_foundation.Uri], /) -> typing.Optional[RadialControllerMenuItem]: ...
    def create_from_icon(cls, display_text: str, icon: typing.Optional[windows_storage_streams.RandomAccessStreamReference], /) -> typing.Optional[RadialControllerMenuItem]: ...
    def create_from_known_icon(cls, display_text: str, value: RadialControllerMenuKnownIcon, /) -> typing.Optional[RadialControllerMenuItem]: ...

@typing.final
class RadialControllerMenuItem(winrt.system.Object, metaclass=RadialControllerMenuItem_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerMenuItem: ...
    def add_invoked(self, handler: windows_foundation.TypedEventHandler[RadialControllerMenuItem, winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_invoked(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def tag(self) -> typing.Optional[winrt.system.Object]: ...
    @tag.setter
    def tag(self, value: typing.Optional[winrt.system.Object]) -> None: ...
    @_property
    def display_text(self) -> str: ...

@typing.final
class RadialControllerRotationChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerRotationChangedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def rotation_delta_in_degrees(self) -> winrt.system.Double: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContact(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContact: ...
    @_property
    def bounds(self) -> windows_foundation.Rect: ...
    @_property
    def position(self) -> windows_foundation.Point: ...

@typing.final
class RadialControllerScreenContactContinuedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactContinuedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContactEndedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactEndedEventArgs: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RadialControllerScreenContactStartedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialControllerScreenContactStartedEventArgs: ...
    @_property
    def contact(self) -> typing.Optional[RadialControllerScreenContact]: ...
    @_property
    def is_button_pressed(self) -> bool: ...
    @_property
    def simple_haptics_controller(self) -> typing.Optional[windows_devices_haptics.SimpleHapticsController]: ...

@typing.final
class RightTappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RightTappedEventArgs: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class SystemButtonEventController_Static(type):
    def create_for_dispatcher_queue(cls, queue: typing.Optional[windows_system.DispatcherQueue], /) -> typing.Optional[SystemButtonEventController]: ...

@typing.final
class SystemButtonEventController(winrt.system.Object, metaclass=SystemButtonEventController_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemButtonEventController: ...
    def close(self) -> None: ...
    def add_system_function_button_pressed(self, handler: windows_foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_system_function_button_pressed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_button_released(self, handler: windows_foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionButtonEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_system_function_button_released(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_changed(self, handler: windows_foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_system_function_lock_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_system_function_lock_indicator_changed(self, handler: windows_foundation.TypedEventHandler[SystemButtonEventController, SystemFunctionLockIndicatorChangedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_system_function_lock_indicator_changed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class SystemFunctionButtonEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionButtonEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class SystemFunctionLockChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_locked(self) -> bool: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class SystemFunctionLockIndicatorChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemFunctionLockIndicatorChangedEventArgs: ...
    @_property
    def handled(self) -> bool: ...
    @handled.setter
    def handled(self, value: bool) -> None: ...
    @_property
    def is_indicator_on(self) -> bool: ...
    @_property
    def timestamp(self) -> winrt.system.UInt64: ...

@typing.final
class TappedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TappedEventArgs: ...
    @_property
    def pointer_device_type(self) -> windows_devices_input.PointerDeviceType: ...
    @_property
    def position(self) -> windows_foundation.Point: ...
    @_property
    def tap_count(self) -> winrt.system.UInt32: ...
    @_property
    def contact_count(self) -> winrt.system.UInt32: ...

@typing.final
class IPointerPointTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPointerPointTransform: ...
    def transform_bounds(self, rect: windows_foundation.Rect, /) -> windows_foundation.Rect: ...
    def try_transform(self, in_point: windows_foundation.Point, /) -> typing.Tuple[bool, windows_foundation.Point]: ...
    @_property
    def inverse(self) -> typing.Optional[IPointerPointTransform]: ...

