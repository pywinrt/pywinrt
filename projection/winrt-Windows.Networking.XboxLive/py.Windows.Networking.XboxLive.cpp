// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Networking.XboxLive.h"


namespace py::cpp::Windows::Networking::XboxLive
{
    // ----- XboxLiveDeviceAddress class --------------------

    static PyObject* _new_XboxLiveDeviceAddress(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveDeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveDeviceAddress_Compare(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"Compare", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert(self->obj.Compare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBase64(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBase64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBase64(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_CreateFromSnapshotBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"CreateFromSnapshotBytes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::CreateFromSnapshotBytes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetLocal(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetLocal", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::GetLocal());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBase64(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBase64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSnapshotAsBase64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBuffer(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSnapshotAsBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_GetSnapshotAsBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"GetSnapshotAsBytes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);
                uint32_t param1 {  };

                self->obj.GetSnapshotAsBytes(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_IsLocal(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"IsLocal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLocal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_IsValid(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"IsValid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_NetworkAccessKind(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"NetworkAccessKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NetworkAccessKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_get_MaxSnapshotBytesSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"MaxSnapshotBytesSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress::MaxSnapshotBytesSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_add_SnapshotChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"SnapshotChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SnapshotChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveDeviceAddress_remove_SnapshotChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveDeviceAddress", L"SnapshotChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SnapshotChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveDeviceAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveDeviceAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveDeviceAddress[] = {
        { "compare", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_Compare), METH_VARARGS, nullptr },
        { "get_snapshot_as_base64", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBase64), METH_VARARGS, nullptr },
        { "get_snapshot_as_buffer", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBuffer), METH_VARARGS, nullptr },
        { "get_snapshot_as_bytes", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetSnapshotAsBytes), METH_VARARGS, nullptr },
        { "add_snapshot_changed", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_add_SnapshotChanged), METH_O, nullptr },
        { "remove_snapshot_changed", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_remove_SnapshotChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveDeviceAddress, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveDeviceAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveDeviceAddress[] = {
        { "is_local", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_IsLocal), nullptr, nullptr, nullptr },
        { "is_valid", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_IsValid), nullptr, nullptr, nullptr },
        { "network_access_kind", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_NetworkAccessKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveDeviceAddress[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveDeviceAddress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveDeviceAddress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveDeviceAddress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveDeviceAddress) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveDeviceAddress =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveDeviceAddress",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveDeviceAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveDeviceAddress
    };

    static PyGetSetDef getset_XboxLiveDeviceAddress_Static[] = {
        { "max_snapshot_bytes_size", reinterpret_cast<getter>(XboxLiveDeviceAddress_get_MaxSnapshotBytesSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XboxLiveDeviceAddress_Static[] = {
        { "create_from_snapshot_base64", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBase64), METH_VARARGS, nullptr },
        { "create_from_snapshot_buffer", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBuffer), METH_VARARGS, nullptr },
        { "create_from_snapshot_bytes", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_CreateFromSnapshotBytes), METH_VARARGS, nullptr },
        { "get_local", reinterpret_cast<PyCFunction>(XboxLiveDeviceAddress_GetLocal), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XboxLiveDeviceAddress_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveDeviceAddress_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveDeviceAddress_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveDeviceAddress_Static =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveDeviceAddress_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveDeviceAddress_Static
    };

    // ----- XboxLiveEndpointPair class --------------------

    static PyObject* _new_XboxLiveEndpointPair(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPair_DeleteAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"DeleteAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_FindEndpointPairByHostNamesAndPorts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"FindEndpointPairByHostNamesAndPorts", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostName>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair::FindEndpointPairByHostNamesAndPorts(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_FindEndpointPairBySocketAddressBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"FindEndpointPairBySocketAddressBytes", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 1);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair::FindEndpointPairBySocketAddressBytes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_GetLocalSocketAddressBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"GetLocalSocketAddressBytes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                self->obj.GetLocalSocketAddressBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_GetRemoteSocketAddressBytes(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"GetRemoteSocketAddressBytes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                self->obj.GetRemoteSocketAddressBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_LocalHostName(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"LocalHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_LocalPort(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"LocalPort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemoteDeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemoteDeviceAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteDeviceAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemoteHostName(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemoteHostName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_RemotePort(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"RemotePort"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_State(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_get_Template(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_add_StateChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair, winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPair_remove_StateChanged(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPair", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPair(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPair(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPair>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPair[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_DeleteAsync), METH_VARARGS, nullptr },
        { "get_local_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_GetLocalSocketAddressBytes), METH_VARARGS, nullptr },
        { "get_remote_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_GetRemoteSocketAddressBytes), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveEndpointPair, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPair), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveEndpointPair[] = {
        { "local_host_name", reinterpret_cast<getter>(XboxLiveEndpointPair_get_LocalHostName), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(XboxLiveEndpointPair_get_LocalPort), nullptr, nullptr, nullptr },
        { "remote_device_address", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemoteDeviceAddress), nullptr, nullptr, nullptr },
        { "remote_host_name", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemoteHostName), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(XboxLiveEndpointPair_get_RemotePort), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(XboxLiveEndpointPair_get_State), nullptr, nullptr, nullptr },
        { "template", reinterpret_cast<getter>(XboxLiveEndpointPair_get_Template), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveEndpointPair[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPair) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPair) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPair) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPair) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveEndpointPair =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPair",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPair),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPair
    };

    static PyGetSetDef getset_XboxLiveEndpointPair_Static[] = {
        { }
    };

    static PyMethodDef methods_XboxLiveEndpointPair_Static[] = {
        { "find_endpoint_pair_by_host_names_and_ports", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_FindEndpointPairByHostNamesAndPorts), METH_VARARGS, nullptr },
        { "find_endpoint_pair_by_socket_address_bytes", reinterpret_cast<PyCFunction>(XboxLiveEndpointPair_FindEndpointPairBySocketAddressBytes), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XboxLiveEndpointPair_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveEndpointPair_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveEndpointPair_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveEndpointPair_Static =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPair_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveEndpointPair_Static
    };

    // ----- XboxLiveEndpointPairCreationResult class --------------------

    static PyObject* _new_XboxLiveEndpointPairCreationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairCreationResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"DeviceAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_EndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"EndpointPair"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointPair());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_IsExistingPathEvaluation(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"IsExistingPathEvaluation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsExistingPathEvaluation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairCreationResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairCreationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairCreationResult[] = {
        { "_assign_array_", _assign_array_XboxLiveEndpointPairCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveEndpointPairCreationResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "endpoint_pair", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_EndpointPair), nullptr, nullptr, nullptr },
        { "is_existing_path_evaluation", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_IsExistingPathEvaluation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveEndpointPairCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveEndpointPairCreationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairCreationResult) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveEndpointPairCreationResult =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairCreationResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairCreationResult
    };

    // ----- XboxLiveEndpointPairStateChangedEventArgs class --------------------

    static PyObject* _new_XboxLiveEndpointPairStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairStateChangedEventArgs(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairStateChangedEventArgs_get_NewState(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs", L"NewState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairStateChangedEventArgs_get_OldState(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairStateChangedEventArgs", L"OldState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_XboxLiveEndpointPairStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveEndpointPairStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(XboxLiveEndpointPairStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(XboxLiveEndpointPairStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveEndpointPairStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveEndpointPairStateChangedEventArgs =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairStateChangedEventArgs
    };

    // ----- XboxLiveEndpointPairTemplate class --------------------

    static PyObject* _new_XboxLiveEndpointPairTemplate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveEndpointPairTemplate(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert(self->obj.CreateEndpointPairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationBehaviors>(args, 1);

                return py::convert(self->obj.CreateEndpointPairAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairForPortsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateEndpointPairForPortsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"CreateEndpointPairForPortsAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairCreationBehaviors>(args, 3);

                return py::convert(self->obj.CreateEndpointPairForPortsAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_GetTemplateByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"GetTemplateByName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate::GetTemplateByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeLower(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"AcceptorBoundPortRangeLower"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcceptorBoundPortRangeLower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeUpper(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"AcceptorBoundPortRangeUpper"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AcceptorBoundPortRangeUpper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_EndpointPairs(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"EndpointPairs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointPairs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeLower(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InitiatorBoundPortRangeLower"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitiatorBoundPortRangeLower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeUpper(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InitiatorBoundPortRangeUpper"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitiatorBoundPortRangeUpper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_Name(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_SocketKind(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"SocketKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SocketKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_get_Templates(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"Templates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate::Templates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_add_InboundEndpointPairCreated(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InboundEndpointPairCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate, winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>>(arg);

            return py::convert(self->obj.InboundEndpointPairCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveEndpointPairTemplate_remove_InboundEndpointPairCreated(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Networking.XboxLive.XboxLiveEndpointPairTemplate", L"InboundEndpointPairCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InboundEndpointPairCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveEndpointPairTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveEndpointPairTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveEndpointPairTemplate[] = {
        { "create_endpoint_pair_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairAsync), METH_VARARGS, nullptr },
        { "create_endpoint_pair_for_ports_async", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_CreateEndpointPairForPortsAsync), METH_VARARGS, nullptr },
        { "add_inbound_endpoint_pair_created", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_add_InboundEndpointPairCreated), METH_O, nullptr },
        { "remove_inbound_endpoint_pair_created", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_remove_InboundEndpointPairCreated), METH_O, nullptr },
        { "_assign_array_", _assign_array_XboxLiveEndpointPairTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveEndpointPairTemplate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveEndpointPairTemplate[] = {
        { "acceptor_bound_port_range_lower", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeLower), nullptr, nullptr, nullptr },
        { "acceptor_bound_port_range_upper", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_AcceptorBoundPortRangeUpper), nullptr, nullptr, nullptr },
        { "endpoint_pairs", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_EndpointPairs), nullptr, nullptr, nullptr },
        { "initiator_bound_port_range_lower", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeLower), nullptr, nullptr, nullptr },
        { "initiator_bound_port_range_upper", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_InitiatorBoundPortRangeUpper), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_Name), nullptr, nullptr, nullptr },
        { "socket_kind", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_SocketKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveEndpointPairTemplate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveEndpointPairTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveEndpointPairTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveEndpointPairTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveEndpointPairTemplate) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveEndpointPairTemplate =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairTemplate",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveEndpointPairTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveEndpointPairTemplate
    };

    static PyGetSetDef getset_XboxLiveEndpointPairTemplate_Static[] = {
        { "templates", reinterpret_cast<getter>(XboxLiveEndpointPairTemplate_get_Templates), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XboxLiveEndpointPairTemplate_Static[] = {
        { "get_template_by_name", reinterpret_cast<PyCFunction>(XboxLiveEndpointPairTemplate_GetTemplateByName), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XboxLiveEndpointPairTemplate_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveEndpointPairTemplate_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveEndpointPairTemplate_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveEndpointPairTemplate_Static =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveEndpointPairTemplate_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveEndpointPairTemplate_Static
    };

    // ----- XboxLiveInboundEndpointPairCreatedEventArgs class --------------------

    static PyObject* _new_XboxLiveInboundEndpointPairCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveInboundEndpointPairCreatedEventArgs(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveInboundEndpointPairCreatedEventArgs_get_EndpointPair(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveInboundEndpointPairCreatedEventArgs", L"EndpointPair"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndpointPair());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveInboundEndpointPairCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveInboundEndpointPairCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveInboundEndpointPairCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_XboxLiveInboundEndpointPairCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveInboundEndpointPairCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveInboundEndpointPairCreatedEventArgs[] = {
        { "endpoint_pair", reinterpret_cast<getter>(XboxLiveInboundEndpointPairCreatedEventArgs_get_EndpointPair), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveInboundEndpointPairCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveInboundEndpointPairCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveInboundEndpointPairCreatedEventArgs =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveInboundEndpointPairCreatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveInboundEndpointPairCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveInboundEndpointPairCreatedEventArgs
    };

    // ----- XboxLiveQualityOfServiceMeasurement class --------------------

    static PyObject* _new_XboxLiveQualityOfServiceMeasurement(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XboxLiveQualityOfServiceMeasurement(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_ClearPrivatePayload(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ClearPrivatePayload", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::ClearPrivatePayload();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResult", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetric>(args, 1);

                return py::convert(self->obj.GetMetricResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResultsForDevice(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResultsForDevice", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert(self->obj.GetMetricResultsForDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetMetricResultsForMetric(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetMetricResultsForMetric", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetric>(args, 0);

                return py::convert(self->obj.GetMetricResultsForMetric(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_GetPrivatePayloadResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"GetPrivatePayloadResult", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::XboxLive::XboxLiveDeviceAddress>(args, 0);

                return py::convert(self->obj.GetPrivatePayloadResult(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_MeasureAsync(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MeasureAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MeasureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_PublishPrivatePayloadBytes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishPrivatePayloadBytes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishPrivatePayloadBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_TimeoutInMilliseconds(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"TimeoutInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeoutInMilliseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_TimeoutInMilliseconds(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"TimeoutInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TimeoutInMilliseconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_ShouldRequestPrivatePayloads(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ShouldRequestPrivatePayloads"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldRequestPrivatePayloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_ShouldRequestPrivatePayloads(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"ShouldRequestPrivatePayloads"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldRequestPrivatePayloads(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_NumberOfProbesToAttempt(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfProbesToAttempt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfProbesToAttempt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_NumberOfProbesToAttempt(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfProbesToAttempt"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.NumberOfProbesToAttempt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_DeviceAddresses(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"DeviceAddresses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MetricResults(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MetricResults"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MetricResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_Metrics(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"Metrics"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Metrics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_NumberOfResultsPending(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"NumberOfResultsPending"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberOfResultsPending());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_PrivatePayloadResults(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PrivatePayloadResults"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrivatePayloadResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_PublishedPrivatePayload(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishedPrivatePayload"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishedPrivatePayload());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_PublishedPrivatePayload(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"PublishedPrivatePayload"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::PublishedPrivatePayload(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MaxSimultaneousProbeConnections(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxSimultaneousProbeConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxSimultaneousProbeConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_MaxSimultaneousProbeConnections(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxSimultaneousProbeConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxSimultaneousProbeConnections(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_IsSystemOutboundBandwidthConstrained(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemOutboundBandwidthConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemOutboundBandwidthConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_IsSystemOutboundBandwidthConstrained(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemOutboundBandwidthConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemOutboundBandwidthConstrained(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_IsSystemInboundBandwidthConstrained(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemInboundBandwidthConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemInboundBandwidthConstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XboxLiveQualityOfServiceMeasurement_put_IsSystemInboundBandwidthConstrained(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"IsSystemInboundBandwidthConstrained"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::IsSystemInboundBandwidthConstrained(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMeasurement_get_MaxPrivatePayloadSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMeasurement", L"MaxPrivatePayloadSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement::MaxPrivatePayloadSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServiceMeasurement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServiceMeasurement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServiceMeasurement[] = {
        { "get_metric_result", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResult), METH_VARARGS, nullptr },
        { "get_metric_results_for_device", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResultsForDevice), METH_VARARGS, nullptr },
        { "get_metric_results_for_metric", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetMetricResultsForMetric), METH_VARARGS, nullptr },
        { "get_private_payload_result", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_GetPrivatePayloadResult), METH_VARARGS, nullptr },
        { "measure_async", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_MeasureAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XboxLiveQualityOfServiceMeasurement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServiceMeasurement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveQualityOfServiceMeasurement[] = {
        { "timeout_in_milliseconds", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_TimeoutInMilliseconds), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_TimeoutInMilliseconds), nullptr, nullptr },
        { "should_request_private_payloads", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_ShouldRequestPrivatePayloads), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_ShouldRequestPrivatePayloads), nullptr, nullptr },
        { "number_of_probes_to_attempt", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_NumberOfProbesToAttempt), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_NumberOfProbesToAttempt), nullptr, nullptr },
        { "device_addresses", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_DeviceAddresses), nullptr, nullptr, nullptr },
        { "metric_results", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MetricResults), nullptr, nullptr, nullptr },
        { "metrics", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_Metrics), nullptr, nullptr, nullptr },
        { "number_of_results_pending", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_NumberOfResultsPending), nullptr, nullptr, nullptr },
        { "private_payload_results", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_PrivatePayloadResults), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveQualityOfServiceMeasurement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServiceMeasurement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServiceMeasurement) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMeasurement =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMeasurement",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMeasurement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServiceMeasurement
    };

    static PyGetSetDef getset_XboxLiveQualityOfServiceMeasurement_Static[] = {
        { "published_private_payload", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_PublishedPrivatePayload), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_PublishedPrivatePayload), nullptr, nullptr },
        { "max_simultaneous_probe_connections", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MaxSimultaneousProbeConnections), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_MaxSimultaneousProbeConnections), nullptr, nullptr },
        { "is_system_outbound_bandwidth_constrained", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_IsSystemOutboundBandwidthConstrained), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_IsSystemOutboundBandwidthConstrained), nullptr, nullptr },
        { "is_system_inbound_bandwidth_constrained", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_IsSystemInboundBandwidthConstrained), reinterpret_cast<setter>(XboxLiveQualityOfServiceMeasurement_put_IsSystemInboundBandwidthConstrained), nullptr, nullptr },
        { "max_private_payload_size", reinterpret_cast<getter>(XboxLiveQualityOfServiceMeasurement_get_MaxPrivatePayloadSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XboxLiveQualityOfServiceMeasurement_Static[] = {
        { "clear_private_payload", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_ClearPrivatePayload), METH_VARARGS, nullptr },
        { "publish_private_payload_bytes", reinterpret_cast<PyCFunction>(XboxLiveQualityOfServiceMeasurement_PublishPrivatePayloadBytes), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XboxLiveQualityOfServiceMeasurement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XboxLiveQualityOfServiceMeasurement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XboxLiveQualityOfServiceMeasurement_Static) },
        { }
    };

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMeasurement_Static =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMeasurement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XboxLiveQualityOfServiceMeasurement_Static
    };

    // ----- XboxLiveQualityOfServiceMetricResult class --------------------

    static PyObject* _new_XboxLiveQualityOfServiceMetricResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveQualityOfServiceMetricResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"DeviceAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Metric(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Metric"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Metric());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServiceMetricResult_get_Value(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServiceMetricResult", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServiceMetricResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServiceMetricResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServiceMetricResult[] = {
        { "_assign_array_", _assign_array_XboxLiveQualityOfServiceMetricResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServiceMetricResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveQualityOfServiceMetricResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "metric", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Metric), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(XboxLiveQualityOfServiceMetricResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveQualityOfServiceMetricResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServiceMetricResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServiceMetricResult) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveQualityOfServiceMetricResult =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServiceMetricResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServiceMetricResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServiceMetricResult
    };

    // ----- XboxLiveQualityOfServicePrivatePayloadResult class --------------------

    static PyObject* _new_XboxLiveQualityOfServicePrivatePayloadResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>::type_name);
        return nullptr;
    }

    static void _dealloc_XboxLiveQualityOfServicePrivatePayloadResult(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_DeviceAddress(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"DeviceAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_Status(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XboxLiveQualityOfServicePrivatePayloadResult_get_Value(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Networking.XboxLive.XboxLiveQualityOfServicePrivatePayloadResult", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XboxLiveQualityOfServicePrivatePayloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XboxLiveQualityOfServicePrivatePayloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XboxLiveQualityOfServicePrivatePayloadResult[] = {
        { "_assign_array_", _assign_array_XboxLiveQualityOfServicePrivatePayloadResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XboxLiveQualityOfServicePrivatePayloadResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XboxLiveQualityOfServicePrivatePayloadResult[] = {
        { "device_address", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_DeviceAddress), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(XboxLiveQualityOfServicePrivatePayloadResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XboxLiveQualityOfServicePrivatePayloadResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XboxLiveQualityOfServicePrivatePayloadResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XboxLiveQualityOfServicePrivatePayloadResult) },
        { },
    };

    static PyType_Spec type_spec_XboxLiveQualityOfServicePrivatePayloadResult =
    {
        "winrt._winrt_windows_networking_xboxlive.XboxLiveQualityOfServicePrivatePayloadResult",
        sizeof(py::wrapper::Windows::Networking::XboxLive::XboxLiveQualityOfServicePrivatePayloadResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XboxLiveQualityOfServicePrivatePayloadResult
    };

    // ----- Windows.Networking.XboxLive Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::XboxLive");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_networking_xboxlive",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Networking::XboxLive

PyMODINIT_FUNC PyInit__winrt_windows_networking_xboxlive(void) noexcept
{
    using namespace py::cpp::Windows::Networking::XboxLive;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveDeviceAddress_Static{PyType_FromSpec(&type_spec_XboxLiveDeviceAddress_Static)};
    if (!type_XboxLiveDeviceAddress_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveDeviceAddress, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveDeviceAddress_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveEndpointPair_Static{PyType_FromSpec(&type_spec_XboxLiveEndpointPair_Static)};
    if (!type_XboxLiveEndpointPair_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPair, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveEndpointPair_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairCreationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveEndpointPairTemplate_Static{PyType_FromSpec(&type_spec_XboxLiveEndpointPairTemplate_Static)};
    if (!type_XboxLiveEndpointPairTemplate_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveEndpointPairTemplate, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveEndpointPairTemplate_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveInboundEndpointPairCreatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XboxLiveQualityOfServiceMeasurement_Static{PyType_FromSpec(&type_spec_XboxLiveQualityOfServiceMeasurement_Static)};
    if (!type_XboxLiveQualityOfServiceMeasurement_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServiceMeasurement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XboxLiveQualityOfServiceMeasurement_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServiceMetricResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XboxLiveQualityOfServicePrivatePayloadResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
