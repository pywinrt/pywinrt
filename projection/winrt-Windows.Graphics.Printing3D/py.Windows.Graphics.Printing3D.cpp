// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Graphics.Printing3D.h"

namespace py::cpp::Windows::Graphics::Printing3D
{
    // ----- Print3DManager class --------------------

    static PyObject* _new_Print3DManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DManager>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DManager(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"GetForCurrentView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Graphics::Printing3D::Print3DManager::GetForCurrentView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Print3DManager_ShowPrintUIAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"ShowPrintUIAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Graphics::Printing3D::Print3DManager::ShowPrintUIAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Print3DManager_add_TaskRequested(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"TaskRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DManager, winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TaskRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DManager_remove_TaskRequested(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"TaskRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.TaskRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DManager[] = {
        { "add_task_requested", reinterpret_cast<PyCFunction>(Print3DManager_add_TaskRequested), METH_O, nullptr },
        { "remove_task_requested", reinterpret_cast<PyCFunction>(Print3DManager_remove_TaskRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_Print3DManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DManager[] = {
        { }};

    static PyType_Slot _type_slots_Print3DManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DManager) },
        { }};

    static PyType_Spec type_spec_Print3DManager = {
        "winrt._winrt_windows_graphics_printing3d.Print3DManager",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DManager};

    static PyGetSetDef getset_Print3DManager_Static[] = {
        { }};

    static PyMethodDef methods_Print3DManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(Print3DManager_GetForCurrentView), METH_VARARGS, nullptr },
        { "show_print_ui_async", reinterpret_cast<PyCFunction>(Print3DManager_ShowPrintUIAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Print3DManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Print3DManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Print3DManager_Static) },
        { }
    };

    static PyType_Spec type_spec_Print3DManager_Static = {
        "winrt._winrt_windows_graphics_printing3d.Print3DManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Print3DManager_Static};

    // ----- Print3DTask class --------------------

    static PyObject* _new_Print3DTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTask>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTask(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTask_get_Source(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_Completed(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_Completed(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Completed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Completed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_SourceChanged(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"SourceChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_SourceChanged(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"SourceChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SourceChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_Submitting(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Submitting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Submitting(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_Submitting(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Submitting");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Submitting(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTask[] = {
        { "add_completed", reinterpret_cast<PyCFunction>(Print3DTask_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(Print3DTask_remove_Completed), METH_O, nullptr },
        { "add_source_changed", reinterpret_cast<PyCFunction>(Print3DTask_add_SourceChanged), METH_O, nullptr },
        { "remove_source_changed", reinterpret_cast<PyCFunction>(Print3DTask_remove_SourceChanged), METH_O, nullptr },
        { "add_submitting", reinterpret_cast<PyCFunction>(Print3DTask_add_Submitting), METH_O, nullptr },
        { "remove_submitting", reinterpret_cast<PyCFunction>(Print3DTask_remove_Submitting), METH_O, nullptr },
        { "_assign_array_", _assign_array_Print3DTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTask), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTask[] = {
        { "source", reinterpret_cast<getter>(Print3DTask_get_Source), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Print3DTask[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTask) },
        { }};

    static PyType_Spec type_spec_Print3DTask = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTask",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTask};

    // ----- Print3DTaskCompletedEventArgs class --------------------

    static PyObject* _new_Print3DTaskCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskCompletedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskCompletedEventArgs_get_Completion(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs", L"Completion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Completion();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTaskCompletedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs", L"ExtendedStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExtendedStatus();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTaskCompletedEventArgs[] = {
        { "completion", reinterpret_cast<getter>(Print3DTaskCompletedEventArgs_get_Completion), nullptr, nullptr, nullptr },
        { "extended_status", reinterpret_cast<getter>(Print3DTaskCompletedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Print3DTaskCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskCompletedEventArgs) },
        { }};

    static PyType_Spec type_spec_Print3DTaskCompletedEventArgs = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskCompletedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskCompletedEventArgs};

    // ----- Print3DTaskRequest class --------------------

    static PyObject* _new_Print3DTaskRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskRequest(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskRequest_CreateTask(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DTaskRequest", L"CreateTask", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedHandler>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateTask(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskRequest[] = {
        { "create_task", reinterpret_cast<PyCFunction>(Print3DTaskRequest_CreateTask), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Print3DTaskRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTaskRequest[] = {
        { }};

    static PyType_Slot _type_slots_Print3DTaskRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskRequest) },
        { }};

    static PyType_Spec type_spec_Print3DTaskRequest = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskRequest",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskRequest};

    // ----- Print3DTaskRequestedEventArgs class --------------------

    static PyObject* _new_Print3DTaskRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskRequestedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskRequestedEventArgs_get_Request(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTaskRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(Print3DTaskRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Print3DTaskRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_Print3DTaskRequestedEventArgs = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskRequestedEventArgs};

    // ----- Print3DTaskSourceChangedEventArgs class --------------------

    static PyObject* _new_Print3DTaskSourceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskSourceChangedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskSourceChangedEventArgs_get_Source(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskSourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskSourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskSourceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskSourceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskSourceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTaskSourceChangedEventArgs[] = {
        { "source", reinterpret_cast<getter>(Print3DTaskSourceChangedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Print3DTaskSourceChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskSourceChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_Print3DTaskSourceChangedEventArgs = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskSourceChangedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskSourceChangedEventArgs};

    // ----- Print3DTaskSourceRequestedArgs class --------------------

    static PyObject* _new_Print3DTaskSourceRequestedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskSourceRequestedArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskSourceRequestedArgs_SetSource(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs", L"SetSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetSource(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskSourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskSourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskSourceRequestedArgs[] = {
        { "set_source", reinterpret_cast<PyCFunction>(Print3DTaskSourceRequestedArgs_SetSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Print3DTaskSourceRequestedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskSourceRequestedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Print3DTaskSourceRequestedArgs[] = {
        { }};

    static PyType_Slot _type_slots_Print3DTaskSourceRequestedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskSourceRequestedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskSourceRequestedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskSourceRequestedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskSourceRequestedArgs) },
        { }};

    static PyType_Spec type_spec_Print3DTaskSourceRequestedArgs = {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskSourceRequestedArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskSourceRequestedArgs};

    // ----- Printing3D3MFPackage class --------------------

    static PyObject* _new_Printing3D3MFPackage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3D3MFPackage(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3D3MFPackage_LoadAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"LoadAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage::LoadAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_LoadModelFromPackageAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"LoadModelFromPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.LoadModelFromPackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_SaveAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_SaveModelToPackageAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"SaveModelToPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModel>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveModelToPackageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            {
                auto _gil = release_gil();
                self->obj.Thumbnail(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_PrintTicket(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrintTicket();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_PrintTicket(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"PrintTicket");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrintTicket(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_ModelPart(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"ModelPart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ModelPart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_ModelPart(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"ModelPart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            {
                auto _gil = release_gil();
                self->obj.ModelPart(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Textures(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Textures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Textures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Compression(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Compression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Compression();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_Compression(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Compression");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DPackageCompression>(arg);

            {
                auto _gil = release_gil();
                self->obj.Compression(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3D3MFPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3D3MFPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3D3MFPackage[] = {
        { "load_model_from_package_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_LoadModelFromPackageAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_SaveAsync), METH_VARARGS, nullptr },
        { "save_model_to_package_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_SaveModelToPackageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3D3MFPackage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3D3MFPackage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3D3MFPackage[] = {
        { "thumbnail", reinterpret_cast<getter>(Printing3D3MFPackage_get_Thumbnail), reinterpret_cast<setter>(Printing3D3MFPackage_put_Thumbnail), nullptr, nullptr },
        { "print_ticket", reinterpret_cast<getter>(Printing3D3MFPackage_get_PrintTicket), reinterpret_cast<setter>(Printing3D3MFPackage_put_PrintTicket), nullptr, nullptr },
        { "model_part", reinterpret_cast<getter>(Printing3D3MFPackage_get_ModelPart), reinterpret_cast<setter>(Printing3D3MFPackage_put_ModelPart), nullptr, nullptr },
        { "textures", reinterpret_cast<getter>(Printing3D3MFPackage_get_Textures), nullptr, nullptr, nullptr },
        { "compression", reinterpret_cast<getter>(Printing3D3MFPackage_get_Compression), reinterpret_cast<setter>(Printing3D3MFPackage_put_Compression), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3D3MFPackage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3D3MFPackage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3D3MFPackage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3D3MFPackage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3D3MFPackage) },
        { }};

    static PyType_Spec type_spec_Printing3D3MFPackage = {
        "winrt._winrt_windows_graphics_printing3d.Printing3D3MFPackage",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3D3MFPackage};

    static PyGetSetDef getset_Printing3D3MFPackage_Static[] = {
        { }};

    static PyMethodDef methods_Printing3D3MFPackage_Static[] = {
        { "load_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_LoadAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Printing3D3MFPackage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Printing3D3MFPackage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Printing3D3MFPackage_Static) },
        { }
    };

    static PyType_Spec type_spec_Printing3D3MFPackage_Static = {
        "winrt._winrt_windows_graphics_printing3d.Printing3D3MFPackage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Printing3D3MFPackage_Static};

    // ----- Printing3DBaseMaterial class --------------------

    static PyObject* _new_Printing3DBaseMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DBaseMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DBaseMaterial_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBaseMaterial_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Color();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBaseMaterial_put_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>(arg);

            {
                auto _gil = release_gil();
                self->obj.Color(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Abs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Abs");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial::Abs();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Pla(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Pla");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial::Pla();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DBaseMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DBaseMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DBaseMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DBaseMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DBaseMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DBaseMaterial[] = {
        { "name", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Name), reinterpret_cast<setter>(Printing3DBaseMaterial_put_Name), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Color), reinterpret_cast<setter>(Printing3DBaseMaterial_put_Color), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DBaseMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBaseMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBaseMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBaseMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBaseMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DBaseMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBaseMaterial};

    static PyGetSetDef getset_Printing3DBaseMaterial_Static[] = {
        { "abs", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Abs), nullptr, nullptr, nullptr },
        { "pla", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Pla), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Printing3DBaseMaterial_Static[] = {
        { }};

    static PyType_Slot type_slots_Printing3DBaseMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Printing3DBaseMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Printing3DBaseMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_Printing3DBaseMaterial_Static = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Printing3DBaseMaterial_Static};

    // ----- Printing3DBaseMaterialGroup class --------------------

    static PyObject* _new_Printing3DBaseMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DBaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DBaseMaterialGroup_get_Bases(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup", L"Bases");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bases();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DBaseMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup", L"MaterialGroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DBaseMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DBaseMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DBaseMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DBaseMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DBaseMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DBaseMaterialGroup[] = {
        { "bases", reinterpret_cast<getter>(Printing3DBaseMaterialGroup_get_Bases), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DBaseMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DBaseMaterialGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBaseMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBaseMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBaseMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBaseMaterialGroup) },
        { }};

    static PyType_Spec type_spec_Printing3DBaseMaterialGroup = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBaseMaterialGroup};

    // ----- Printing3DColorMaterial class --------------------

    static PyObject* _new_Printing3DColorMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DColorMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DColorMaterial_get_Value(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Value();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DColorMaterial_put_Value(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Value(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DColorMaterial_get_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Color();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DColorMaterial_put_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            {
                auto _gil = release_gil();
                self->obj.Color(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DColorMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DColorMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DColorMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DColorMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DColorMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DColorMaterial[] = {
        { "value", reinterpret_cast<getter>(Printing3DColorMaterial_get_Value), reinterpret_cast<setter>(Printing3DColorMaterial_put_Value), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(Printing3DColorMaterial_get_Color), reinterpret_cast<setter>(Printing3DColorMaterial_put_Color), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DColorMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DColorMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DColorMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DColorMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DColorMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DColorMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DColorMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DColorMaterial};

    // ----- Printing3DColorMaterialGroup class --------------------

    static PyObject* _new_Printing3DColorMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DColorMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DColorMaterialGroup_get_Colors(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterialGroup", L"Colors");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Colors();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DColorMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterialGroup", L"MaterialGroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DColorMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DColorMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DColorMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DColorMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DColorMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DColorMaterialGroup[] = {
        { "colors", reinterpret_cast<getter>(Printing3DColorMaterialGroup_get_Colors), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DColorMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DColorMaterialGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DColorMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DColorMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DColorMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DColorMaterialGroup) },
        { }};

    static PyType_Spec type_spec_Printing3DColorMaterialGroup = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DColorMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DColorMaterialGroup};

    // ----- Printing3DComponent class --------------------

    static PyObject* _new_Printing3DComponent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DComponent instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DComponent(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DComponent_get_Type(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Type(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DObjectType>(arg);

            {
                auto _gil = release_gil();
                self->obj.Type(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            {
                auto _gil = release_gil();
                self->obj.Thumbnail(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_PartNumber(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"PartNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PartNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_PartNumber(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"PartNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.PartNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Mesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Mesh");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Mesh();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Mesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Mesh");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMesh>(arg);

            {
                auto _gil = release_gil();
                self->obj.Mesh(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Components(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Components();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DComponent[] = {
        { "_assign_array_", _assign_array_Printing3DComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DComponent), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DComponent[] = {
        { "type", reinterpret_cast<getter>(Printing3DComponent_get_Type), reinterpret_cast<setter>(Printing3DComponent_put_Type), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(Printing3DComponent_get_Thumbnail), reinterpret_cast<setter>(Printing3DComponent_put_Thumbnail), nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(Printing3DComponent_get_PartNumber), reinterpret_cast<setter>(Printing3DComponent_put_PartNumber), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Printing3DComponent_get_Name), reinterpret_cast<setter>(Printing3DComponent_put_Name), nullptr, nullptr },
        { "mesh", reinterpret_cast<getter>(Printing3DComponent_get_Mesh), reinterpret_cast<setter>(Printing3DComponent_put_Mesh), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(Printing3DComponent_get_Components), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DComponent[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DComponent) },
        { }};

    static PyType_Spec type_spec_Printing3DComponent = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DComponent",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DComponent};

    // ----- Printing3DComponentWithMatrix class --------------------

    static PyObject* _new_Printing3DComponentWithMatrix(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DComponentWithMatrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DComponentWithMatrix_get_Matrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Matrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Matrix();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponentWithMatrix_put_Matrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Matrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);

            {
                auto _gil = release_gil();
                self->obj.Matrix(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponentWithMatrix_get_Component(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Component");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Component();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponentWithMatrix_put_Component(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Component");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DComponent>(arg);

            {
                auto _gil = release_gil();
                self->obj.Component(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DComponentWithMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DComponentWithMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DComponentWithMatrix[] = {
        { "_assign_array_", _assign_array_Printing3DComponentWithMatrix, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DComponentWithMatrix), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DComponentWithMatrix[] = {
        { "matrix", reinterpret_cast<getter>(Printing3DComponentWithMatrix_get_Matrix), reinterpret_cast<setter>(Printing3DComponentWithMatrix_put_Matrix), nullptr, nullptr },
        { "component", reinterpret_cast<getter>(Printing3DComponentWithMatrix_get_Component), reinterpret_cast<setter>(Printing3DComponentWithMatrix_put_Component), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DComponentWithMatrix[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DComponentWithMatrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DComponentWithMatrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DComponentWithMatrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DComponentWithMatrix) },
        { }};

    static PyType_Spec type_spec_Printing3DComponentWithMatrix = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DComponentWithMatrix",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DComponentWithMatrix};

    // ----- Printing3DCompositeMaterial class --------------------

    static PyObject* _new_Printing3DCompositeMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DCompositeMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DCompositeMaterial_get_Values(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterial", L"Values");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Values();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DCompositeMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DCompositeMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DCompositeMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DCompositeMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DCompositeMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DCompositeMaterial[] = {
        { "values", reinterpret_cast<getter>(Printing3DCompositeMaterial_get_Values), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DCompositeMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DCompositeMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DCompositeMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DCompositeMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DCompositeMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DCompositeMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DCompositeMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DCompositeMaterial};

    // ----- Printing3DCompositeMaterialGroup class --------------------

    static PyObject* _new_Printing3DCompositeMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DCompositeMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_Composites(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"Composites");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Composites();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"MaterialGroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_MaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"MaterialIndices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialIndices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_BaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"BaseMaterialGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseMaterialGroup();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DCompositeMaterialGroup_put_BaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"BaseMaterialGroup");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>(arg);

            {
                auto _gil = release_gil();
                self->obj.BaseMaterialGroup(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DCompositeMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DCompositeMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DCompositeMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DCompositeMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DCompositeMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DCompositeMaterialGroup[] = {
        { "composites", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_Composites), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "material_indices", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_MaterialIndices), nullptr, nullptr, nullptr },
        { "base_material_group", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_BaseMaterialGroup), reinterpret_cast<setter>(Printing3DCompositeMaterialGroup_put_BaseMaterialGroup), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DCompositeMaterialGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DCompositeMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DCompositeMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DCompositeMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DCompositeMaterialGroup) },
        { }};

    static PyType_Spec type_spec_Printing3DCompositeMaterialGroup = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DCompositeMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DCompositeMaterialGroup};

    // ----- Printing3DFaceReductionOptions class --------------------

    static PyObject* _new_Printing3DFaceReductionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DFaceReductionOptions(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DFaceReductionOptions_get_TargetTriangleCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"TargetTriangleCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TargetTriangleCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_TargetTriangleCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"TargetTriangleCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TargetTriangleCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DFaceReductionOptions_get_MaxReductionArea(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxReductionArea");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxReductionArea();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_MaxReductionArea(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxReductionArea");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxReductionArea(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DFaceReductionOptions_get_MaxEdgeLength(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxEdgeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaxEdgeLength();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_MaxEdgeLength(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxEdgeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.MaxEdgeLength(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DFaceReductionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DFaceReductionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DFaceReductionOptions[] = {
        { "_assign_array_", _assign_array_Printing3DFaceReductionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DFaceReductionOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DFaceReductionOptions[] = {
        { "target_triangle_count", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_TargetTriangleCount), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_TargetTriangleCount), nullptr, nullptr },
        { "max_reduction_area", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_MaxReductionArea), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_MaxReductionArea), nullptr, nullptr },
        { "max_edge_length", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_MaxEdgeLength), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_MaxEdgeLength), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DFaceReductionOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DFaceReductionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DFaceReductionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DFaceReductionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DFaceReductionOptions) },
        { }};

    static PyType_Spec type_spec_Printing3DFaceReductionOptions = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DFaceReductionOptions",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DFaceReductionOptions};

    // ----- Printing3DMaterial class --------------------

    static PyObject* _new_Printing3DMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMaterial_get_BaseGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"BaseGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BaseGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_ColorGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"ColorGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ColorGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_CompositeGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"CompositeGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CompositeGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_MultiplePropertyGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"MultiplePropertyGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MultiplePropertyGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_Texture2CoordGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"Texture2CoordGroups");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Texture2CoordGroups();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DMaterial[] = {
        { "base_groups", reinterpret_cast<getter>(Printing3DMaterial_get_BaseGroups), nullptr, nullptr, nullptr },
        { "color_groups", reinterpret_cast<getter>(Printing3DMaterial_get_ColorGroups), nullptr, nullptr, nullptr },
        { "composite_groups", reinterpret_cast<getter>(Printing3DMaterial_get_CompositeGroups), nullptr, nullptr, nullptr },
        { "multiple_property_groups", reinterpret_cast<getter>(Printing3DMaterial_get_MultiplePropertyGroups), nullptr, nullptr, nullptr },
        { "texture2_coord_groups", reinterpret_cast<getter>(Printing3DMaterial_get_Texture2CoordGroups), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMaterial};

    // ----- Printing3DMesh class --------------------

    static PyObject* _new_Printing3DMesh(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMesh instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMesh_CreateTriangleIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateTriangleIndices", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CreateTriangleIndices(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateTriangleMaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateTriangleMaterialIndices", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CreateTriangleMaterialIndices(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateVertexNormals(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateVertexNormals", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CreateVertexNormals(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateVertexPositions(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateVertexPositions", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CreateVertexPositions(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetTriangleIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetTriangleIndices", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTriangleIndices();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetTriangleMaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetTriangleMaterialIndices", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetTriangleMaterialIndices();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetVertexNormals(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetVertexNormals", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVertexNormals();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetVertexPositions(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetVertexPositions", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetVertexPositions();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_VerifyAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VerifyAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationMode>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.VerifyAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_get_VertexPositionsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexPositionsDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VertexPositionsDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexPositionsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexPositionsDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            {
                auto _gil = release_gil();
                self->obj.VertexPositionsDescription(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_VertexNormalsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexNormalsDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VertexNormalsDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexNormalsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexNormalsDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            {
                auto _gil = release_gil();
                self->obj.VertexNormalsDescription(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_VertexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VertexCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.VertexCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_TriangleMaterialIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleMaterialIndicesDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TriangleMaterialIndicesDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_TriangleMaterialIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleMaterialIndicesDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            {
                auto _gil = release_gil();
                self->obj.TriangleMaterialIndicesDescription(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_TriangleIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleIndicesDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TriangleIndicesDescription();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_TriangleIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleIndicesDescription");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            {
                auto _gil = release_gil();
                self->obj.TriangleIndicesDescription(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_IndexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"IndexCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IndexCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_IndexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"IndexCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.IndexCount(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_BufferDescriptionSet(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"BufferDescriptionSet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BufferDescriptionSet();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_get_BufferSet(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"BufferSet");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BufferSet();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMesh>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMesh>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMesh[] = {
        { "create_triangle_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateTriangleIndices), METH_VARARGS, nullptr },
        { "create_triangle_material_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateTriangleMaterialIndices), METH_VARARGS, nullptr },
        { "create_vertex_normals", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateVertexNormals), METH_VARARGS, nullptr },
        { "create_vertex_positions", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateVertexPositions), METH_VARARGS, nullptr },
        { "get_triangle_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_GetTriangleIndices), METH_VARARGS, nullptr },
        { "get_triangle_material_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_GetTriangleMaterialIndices), METH_VARARGS, nullptr },
        { "get_vertex_normals", reinterpret_cast<PyCFunction>(Printing3DMesh_GetVertexNormals), METH_VARARGS, nullptr },
        { "get_vertex_positions", reinterpret_cast<PyCFunction>(Printing3DMesh_GetVertexPositions), METH_VARARGS, nullptr },
        { "verify_async", reinterpret_cast<PyCFunction>(Printing3DMesh_VerifyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3DMesh, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMesh), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DMesh[] = {
        { "vertex_positions_description", reinterpret_cast<getter>(Printing3DMesh_get_VertexPositionsDescription), reinterpret_cast<setter>(Printing3DMesh_put_VertexPositionsDescription), nullptr, nullptr },
        { "vertex_normals_description", reinterpret_cast<getter>(Printing3DMesh_get_VertexNormalsDescription), reinterpret_cast<setter>(Printing3DMesh_put_VertexNormalsDescription), nullptr, nullptr },
        { "vertex_count", reinterpret_cast<getter>(Printing3DMesh_get_VertexCount), reinterpret_cast<setter>(Printing3DMesh_put_VertexCount), nullptr, nullptr },
        { "triangle_material_indices_description", reinterpret_cast<getter>(Printing3DMesh_get_TriangleMaterialIndicesDescription), reinterpret_cast<setter>(Printing3DMesh_put_TriangleMaterialIndicesDescription), nullptr, nullptr },
        { "triangle_indices_description", reinterpret_cast<getter>(Printing3DMesh_get_TriangleIndicesDescription), reinterpret_cast<setter>(Printing3DMesh_put_TriangleIndicesDescription), nullptr, nullptr },
        { "index_count", reinterpret_cast<getter>(Printing3DMesh_get_IndexCount), reinterpret_cast<setter>(Printing3DMesh_put_IndexCount), nullptr, nullptr },
        { "buffer_description_set", reinterpret_cast<getter>(Printing3DMesh_get_BufferDescriptionSet), nullptr, nullptr, nullptr },
        { "buffer_set", reinterpret_cast<getter>(Printing3DMesh_get_BufferSet), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DMesh[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMesh) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMesh) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMesh) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMesh) },
        { }};

    static PyType_Spec type_spec_Printing3DMesh = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMesh",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMesh};

    // ----- Printing3DMeshVerificationResult class --------------------

    static PyObject* _new_Printing3DMeshVerificationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_Printing3DMeshVerificationResult(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMeshVerificationResult_get_IsValid(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"IsValid");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsValid();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMeshVerificationResult_get_NonmanifoldTriangles(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"NonmanifoldTriangles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NonmanifoldTriangles();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMeshVerificationResult_get_ReversedNormalTriangles(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"ReversedNormalTriangles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReversedNormalTriangles();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMeshVerificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMeshVerificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMeshVerificationResult[] = {
        { "_assign_array_", _assign_array_Printing3DMeshVerificationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMeshVerificationResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DMeshVerificationResult[] = {
        { "is_valid", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_IsValid), nullptr, nullptr, nullptr },
        { "nonmanifold_triangles", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_NonmanifoldTriangles), nullptr, nullptr, nullptr },
        { "reversed_normal_triangles", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_ReversedNormalTriangles), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DMeshVerificationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMeshVerificationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMeshVerificationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMeshVerificationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMeshVerificationResult) },
        { }};

    static PyType_Spec type_spec_Printing3DMeshVerificationResult = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMeshVerificationResult",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMeshVerificationResult};

    // ----- Printing3DModel class --------------------

    static PyObject* _new_Printing3DModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DModel instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DModel(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DModel_Clone(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Clone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Clone();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_RepairAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RepairAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RepairAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_RepairWithProgressAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RepairWithProgressAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RepairWithProgressAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryPartialRepairAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryPartialRepairAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryPartialRepairAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryPartialRepairWithTimeAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryPartialRepairAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryPartialRepairAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryReduceFacesAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryReduceFacesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryReduceFacesWithOptionsAndTimeAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryReduceFacesAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryReduceFacesWithOptionsAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryReduceFacesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Version(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Version();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Version(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Version");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Version(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Unit(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Unit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Unit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Unit(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Unit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelUnit>(arg);

            {
                auto _gil = release_gil();
                self->obj.Unit(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Material(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Material");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Material();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Material(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Material");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>(arg);

            {
                auto _gil = release_gil();
                self->obj.Material(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Build(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Build");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Build();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Build(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Build");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DComponent>(arg);

            {
                auto _gil = release_gil();
                self->obj.Build(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Components(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Components");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Components();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Meshes(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Meshes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Meshes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Metadata(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Metadata");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Metadata();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_RequiredExtensions(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RequiredExtensions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequiredExtensions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Textures(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Textures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Textures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DModel[] = {
        { "clone", reinterpret_cast<PyCFunction>(Printing3DModel_Clone), METH_VARARGS, nullptr },
        { "repair_async", reinterpret_cast<PyCFunction>(Printing3DModel_RepairAsync), METH_VARARGS, nullptr },
        { "repair_with_progress_async", reinterpret_cast<PyCFunction>(Printing3DModel_RepairWithProgressAsync), METH_VARARGS, nullptr },
        { "try_partial_repair_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryPartialRepairAsync), METH_VARARGS, nullptr },
        { "try_partial_repair_with_time_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryPartialRepairWithTimeAsync), METH_VARARGS, nullptr },
        { "try_reduce_faces_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryReduceFacesAsync), METH_VARARGS, nullptr },
        { "try_reduce_faces_with_options_and_time_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryReduceFacesWithOptionsAndTimeAsync), METH_VARARGS, nullptr },
        { "try_reduce_faces_with_options_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryReduceFacesWithOptionsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3DModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DModel), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DModel[] = {
        { "version", reinterpret_cast<getter>(Printing3DModel_get_Version), reinterpret_cast<setter>(Printing3DModel_put_Version), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(Printing3DModel_get_Unit), reinterpret_cast<setter>(Printing3DModel_put_Unit), nullptr, nullptr },
        { "material", reinterpret_cast<getter>(Printing3DModel_get_Material), reinterpret_cast<setter>(Printing3DModel_put_Material), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(Printing3DModel_get_Build), reinterpret_cast<setter>(Printing3DModel_put_Build), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(Printing3DModel_get_Components), nullptr, nullptr, nullptr },
        { "meshes", reinterpret_cast<getter>(Printing3DModel_get_Meshes), nullptr, nullptr, nullptr },
        { "metadata", reinterpret_cast<getter>(Printing3DModel_get_Metadata), nullptr, nullptr, nullptr },
        { "required_extensions", reinterpret_cast<getter>(Printing3DModel_get_RequiredExtensions), nullptr, nullptr, nullptr },
        { "textures", reinterpret_cast<getter>(Printing3DModel_get_Textures), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DModel[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DModel) },
        { }};

    static PyType_Spec type_spec_Printing3DModel = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DModel",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DModel};

    // ----- Printing3DModelTexture class --------------------

    static PyObject* _new_Printing3DModelTexture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DModelTexture instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DModelTexture(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DModelTexture_get_TileStyleV(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleV");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileStyleV();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TileStyleV(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleV");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureEdgeBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.TileStyleV(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModelTexture_get_TileStyleU(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleU");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TileStyleU();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TileStyleU(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleU");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureEdgeBehavior>(arg);

            {
                auto _gil = release_gil();
                self->obj.TileStyleU(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModelTexture_get_TextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TextureResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextureResource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TextureResource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextureResource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DModelTexture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DModelTexture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DModelTexture[] = {
        { "_assign_array_", _assign_array_Printing3DModelTexture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DModelTexture), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DModelTexture[] = {
        { "tile_style_v", reinterpret_cast<getter>(Printing3DModelTexture_get_TileStyleV), reinterpret_cast<setter>(Printing3DModelTexture_put_TileStyleV), nullptr, nullptr },
        { "tile_style_u", reinterpret_cast<getter>(Printing3DModelTexture_get_TileStyleU), reinterpret_cast<setter>(Printing3DModelTexture_put_TileStyleU), nullptr, nullptr },
        { "texture_resource", reinterpret_cast<getter>(Printing3DModelTexture_get_TextureResource), reinterpret_cast<setter>(Printing3DModelTexture_put_TextureResource), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DModelTexture[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DModelTexture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DModelTexture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DModelTexture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DModelTexture) },
        { }};

    static PyType_Spec type_spec_Printing3DModelTexture = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DModelTexture",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DModelTexture};

    // ----- Printing3DMultiplePropertyMaterial class --------------------

    static PyObject* _new_Printing3DMultiplePropertyMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMultiplePropertyMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMultiplePropertyMaterial_get_MaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial", L"MaterialIndices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialIndices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMultiplePropertyMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMultiplePropertyMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMultiplePropertyMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DMultiplePropertyMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMultiplePropertyMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DMultiplePropertyMaterial[] = {
        { "material_indices", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterial_get_MaterialIndices), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DMultiplePropertyMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMultiplePropertyMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMultiplePropertyMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMultiplePropertyMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMultiplePropertyMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DMultiplePropertyMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMultiplePropertyMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMultiplePropertyMaterial};

    // ----- Printing3DMultiplePropertyMaterialGroup class --------------------

    static PyObject* _new_Printing3DMultiplePropertyMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMultiplePropertyMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MaterialGroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MaterialGroupIndices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupIndices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MultipleProperties(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MultipleProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MultipleProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMultiplePropertyMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMultiplePropertyMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMultiplePropertyMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DMultiplePropertyMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMultiplePropertyMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DMultiplePropertyMaterialGroup[] = {
        { "material_group_id", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "material_group_indices", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupIndices), nullptr, nullptr, nullptr },
        { "multiple_properties", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MultipleProperties), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DMultiplePropertyMaterialGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMultiplePropertyMaterialGroup) },
        { }};

    static PyType_Spec type_spec_Printing3DMultiplePropertyMaterialGroup = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMultiplePropertyMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMultiplePropertyMaterialGroup};

    // ----- Printing3DTexture2CoordMaterial class --------------------

    static PyObject* _new_Printing3DTexture2CoordMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTexture2CoordMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_V(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"V");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.V();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_V(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"V");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.V(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_U(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"U");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.U();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_U(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"U");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.U(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"Texture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Texture();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"Texture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>(arg);

            {
                auto _gil = release_gil();
                self->obj.Texture(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTexture2CoordMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTexture2CoordMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTexture2CoordMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DTexture2CoordMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTexture2CoordMaterial), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DTexture2CoordMaterial[] = {
        { "v", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_V), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_V), nullptr, nullptr },
        { "u", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_U), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_U), nullptr, nullptr },
        { "texture", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_Texture), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_Texture), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DTexture2CoordMaterial[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTexture2CoordMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTexture2CoordMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTexture2CoordMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTexture2CoordMaterial) },
        { }};

    static PyType_Spec type_spec_Printing3DTexture2CoordMaterial = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTexture2CoordMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTexture2CoordMaterial};

    // ----- Printing3DTexture2CoordMaterialGroup class --------------------

    static PyObject* _new_Printing3DTexture2CoordMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTexture2CoordMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"MaterialGroupId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MaterialGroupId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_Texture2Coords(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture2Coords");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Texture2Coords();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Texture();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterialGroup_put_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>(arg);

            {
                auto _gil = release_gil();
                self->obj.Texture(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTexture2CoordMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTexture2CoordMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTexture2CoordMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DTexture2CoordMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTexture2CoordMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DTexture2CoordMaterialGroup[] = {
        { "material_group_id", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "texture2_coords", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_Texture2Coords), nullptr, nullptr, nullptr },
        { "texture", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_Texture), reinterpret_cast<setter>(Printing3DTexture2CoordMaterialGroup_put_Texture), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DTexture2CoordMaterialGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTexture2CoordMaterialGroup) },
        { }};

    static PyType_Spec type_spec_Printing3DTexture2CoordMaterialGroup = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTexture2CoordMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTexture2CoordMaterialGroup};

    // ----- Printing3DTextureResource class --------------------

    static PyObject* _new_Printing3DTextureResource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DTextureResource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTextureResource_get_TextureData(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"TextureData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextureData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTextureResource_put_TextureData(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"TextureData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextureData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTextureResource_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTextureResource_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTextureResource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTextureResource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTextureResource[] = {
        { "_assign_array_", _assign_array_Printing3DTextureResource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTextureResource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Printing3DTextureResource[] = {
        { "texture_data", reinterpret_cast<getter>(Printing3DTextureResource_get_TextureData), reinterpret_cast<setter>(Printing3DTextureResource_put_TextureData), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Printing3DTextureResource_get_Name), reinterpret_cast<setter>(Printing3DTextureResource_put_Name), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Printing3DTextureResource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTextureResource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTextureResource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTextureResource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTextureResource) },
        { }};

    static PyType_Spec type_spec_Printing3DTextureResource = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTextureResource",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTextureResource};

    // ----- Printing3DBufferDescription struct --------------------

    winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription Printing3DBufferDescription_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription result{};

        result.Format = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferFormat>(tuple, 0);
        result.Stride = py::convert_to<uint32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_Printing3DBufferDescription(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _Format{};
        uint32_t _Stride{};

        static const char* kwlist[] = {"format", "stride", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|iI", const_cast<char**>(kwlist), &_Format, &_Stride))
        {
            return nullptr;
        }

        try
        {
            self->obj.Format = static_cast<winrt::Windows::Graphics::Printing3D::Printing3DBufferFormat>(_Format);
            self->obj.Stride = _Stride;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_Printing3DBufferDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Printing3DBufferDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_Printing3DBufferDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _Format{static_cast<int32_t>(self->obj.Format)};
            uint32_t _Stride{self->obj.Stride};

            static const char* kwlist[] = {"format", "stride", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$iI", const_cast<char**>(kwlist), &_Format, &_Stride))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Format = static_cast<winrt::Windows::Graphics::Printing3D::Printing3DBufferFormat>(_Format);
            copy.Stride = _Stride;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DBufferDescription[] = {
        { "_assign_array_", _assign_array_Printing3DBufferDescription, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_Printing3DBufferDescription), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* Printing3DBufferDescription_get_Format(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DBufferDescription_get_Stride(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stride);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_Printing3DBufferDescription[] = {
        { "format", reinterpret_cast<getter>(Printing3DBufferDescription_get_Format), nullptr, nullptr, nullptr },
        { "stride", reinterpret_cast<getter>(Printing3DBufferDescription_get_Stride), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_Printing3DBufferDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Printing3DBufferDescription(PyObject* self) noexcept
    {
        py::pyobj_handle Format{PyObject_GetAttrString(self, "format")};
        if (!Format)
        {
            return nullptr;
        }

        py::pyobj_handle Stride{PyObject_GetAttrString(self, "stride")};
        if (!Stride)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Printing3DBufferDescription(format=%R, stride=%R)", Format.get(), Stride.get());
    }

    static PyType_Slot _type_slots_Printing3DBufferDescription[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBufferDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBufferDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBufferDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBufferDescription) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Printing3DBufferDescription) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Printing3DBufferDescription) },
        { }};

    static PyType_Spec type_spec_Printing3DBufferDescription = {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBufferDescription",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBufferDescription};

    // ----- Windows.Graphics.Printing3D Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Printing3D");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics_printing3d",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics::Printing3D

PyMODINIT_FUNC PyInit__winrt_windows_graphics_printing3d(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing3D;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle Print3DManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Print3DManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Print3DManager_Static{PyType_FromSpecWithBases(&type_spec_Print3DManager_Static, Print3DManager_Static_bases.get())};
    if (!type_Print3DManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle Print3DManager_type{py::register_python_type(module.get(), &type_spec_Print3DManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Print3DManager_Static.get()))};
    if (!Print3DManager_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTask_type{py::register_python_type(module.get(), &type_spec_Print3DTask, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTask_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTaskCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_Print3DTaskCompletedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTaskCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTaskRequest_type{py::register_python_type(module.get(), &type_spec_Print3DTaskRequest, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTaskRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTaskRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_Print3DTaskRequestedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTaskRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTaskSourceChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_Print3DTaskSourceChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTaskSourceChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle Print3DTaskSourceRequestedArgs_type{py::register_python_type(module.get(), &type_spec_Print3DTaskSourceRequestedArgs, object_bases.get(), inspectable_meta_type)};
    if (!Print3DTaskSourceRequestedArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle Printing3D3MFPackage_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Printing3D3MFPackage_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Printing3D3MFPackage_Static{PyType_FromSpecWithBases(&type_spec_Printing3D3MFPackage_Static, Printing3D3MFPackage_Static_bases.get())};
    if (!type_Printing3D3MFPackage_Static)
    {
        return nullptr;
    }

    py::pytype_handle Printing3D3MFPackage_type{py::register_python_type(module.get(), &type_spec_Printing3D3MFPackage, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Printing3D3MFPackage_Static.get()))};
    if (!Printing3D3MFPackage_type)
    {
        return nullptr;
    }

    py::pyobj_handle Printing3DBaseMaterial_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Printing3DBaseMaterial_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Printing3DBaseMaterial_Static{PyType_FromSpecWithBases(&type_spec_Printing3DBaseMaterial_Static, Printing3DBaseMaterial_Static_bases.get())};
    if (!type_Printing3DBaseMaterial_Static)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DBaseMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DBaseMaterial, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Printing3DBaseMaterial_Static.get()))};
    if (!Printing3DBaseMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DBaseMaterialGroup_type{py::register_python_type(module.get(), &type_spec_Printing3DBaseMaterialGroup, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DBaseMaterialGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DColorMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DColorMaterial, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DColorMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DColorMaterialGroup_type{py::register_python_type(module.get(), &type_spec_Printing3DColorMaterialGroup, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DColorMaterialGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DComponent_type{py::register_python_type(module.get(), &type_spec_Printing3DComponent, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DComponent_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DComponentWithMatrix_type{py::register_python_type(module.get(), &type_spec_Printing3DComponentWithMatrix, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DComponentWithMatrix_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DCompositeMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DCompositeMaterial, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DCompositeMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DCompositeMaterialGroup_type{py::register_python_type(module.get(), &type_spec_Printing3DCompositeMaterialGroup, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DCompositeMaterialGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DFaceReductionOptions_type{py::register_python_type(module.get(), &type_spec_Printing3DFaceReductionOptions, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DFaceReductionOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DMaterial, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DMesh_type{py::register_python_type(module.get(), &type_spec_Printing3DMesh, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DMesh_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DMeshVerificationResult_type{py::register_python_type(module.get(), &type_spec_Printing3DMeshVerificationResult, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DMeshVerificationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DModel_type{py::register_python_type(module.get(), &type_spec_Printing3DModel, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DModel_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DModelTexture_type{py::register_python_type(module.get(), &type_spec_Printing3DModelTexture, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DModelTexture_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DMultiplePropertyMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DMultiplePropertyMaterial, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DMultiplePropertyMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DMultiplePropertyMaterialGroup_type{py::register_python_type(module.get(), &type_spec_Printing3DMultiplePropertyMaterialGroup, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DMultiplePropertyMaterialGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DTexture2CoordMaterial_type{py::register_python_type(module.get(), &type_spec_Printing3DTexture2CoordMaterial, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DTexture2CoordMaterial_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DTexture2CoordMaterialGroup_type{py::register_python_type(module.get(), &type_spec_Printing3DTexture2CoordMaterialGroup, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DTexture2CoordMaterialGroup_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DTextureResource_type{py::register_python_type(module.get(), &type_spec_Printing3DTextureResource, object_bases.get(), inspectable_meta_type)};
    if (!Printing3DTextureResource_type)
    {
        return nullptr;
    }

    py::pytype_handle Printing3DBufferDescription_type{py::register_python_type(module.get(), &type_spec_Printing3DBufferDescription, nullptr, nullptr)};
    if (!Printing3DBufferDescription_type)
    {
        return nullptr;
    }

    py::pyobj_handle Printing3DBufferDescription_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(Printing3DBufferDescription_from_tuple),"winrt._winrt_windows_graphics_printing3d.Printing3DBufferDescription_from_tuple", nullptr)};
    if (!Printing3DBufferDescription_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "Printing3DBufferDescription_from_tuple", Printing3DBufferDescription_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
