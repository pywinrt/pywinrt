// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Graphics.Printing3D.h"


namespace py::cpp::Windows::Graphics::Printing3D
{
    // ----- Print3DManager class --------------------

    static PyObject* _new_Print3DManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DManager>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DManager(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Graphics::Printing3D::Print3DManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Print3DManager_ShowPrintUIAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"ShowPrintUIAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Graphics::Printing3D::Print3DManager::ShowPrintUIAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Print3DManager_add_TaskRequested(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"TaskRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DManager, winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>>(arg);

            return py::convert(self->obj.TaskRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DManager_remove_TaskRequested(py::wrapper::Windows::Graphics::Printing3D::Print3DManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DManager", L"TaskRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TaskRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DManager[] = {
        { "add_task_requested", reinterpret_cast<PyCFunction>(Print3DManager_add_TaskRequested), METH_O, nullptr },
        { "remove_task_requested", reinterpret_cast<PyCFunction>(Print3DManager_remove_TaskRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_Print3DManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DManager[] = {
        { }
    };

    static PyType_Slot _type_slots_Print3DManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DManager) },
        { },
    };

    static PyType_Spec type_spec_Print3DManager =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DManager",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DManager
    };

    static PyGetSetDef getset_Print3DManager_Static[] = {
        { }
    };

    static PyMethodDef methods_Print3DManager_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(Print3DManager_GetForCurrentView), METH_VARARGS, nullptr },
        { "show_print_u_i_async", reinterpret_cast<PyCFunction>(Print3DManager_ShowPrintUIAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Print3DManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Print3DManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Print3DManager_Static) },
        { }
    };

    static PyType_Spec type_spec_Print3DManager_Static =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Print3DManager_Static
    };

    // ----- Print3DTask class --------------------

    static PyObject* _new_Print3DTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTask>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTask(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTask_get_Source(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_Completed(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_Completed(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Completed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_SourceChanged(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"SourceChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>>(arg);

            return py::convert(self->obj.SourceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_SourceChanged(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"SourceChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_add_Submitting(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Submitting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Graphics::Printing3D::Print3DTask, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Submitting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTask_remove_Submitting(py::wrapper::Windows::Graphics::Printing3D::Print3DTask* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Graphics.Printing3D.Print3DTask", L"Submitting"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Submitting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTask[] = {
        { "add_completed", reinterpret_cast<PyCFunction>(Print3DTask_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(Print3DTask_remove_Completed), METH_O, nullptr },
        { "add_source_changed", reinterpret_cast<PyCFunction>(Print3DTask_add_SourceChanged), METH_O, nullptr },
        { "remove_source_changed", reinterpret_cast<PyCFunction>(Print3DTask_remove_SourceChanged), METH_O, nullptr },
        { "add_submitting", reinterpret_cast<PyCFunction>(Print3DTask_add_Submitting), METH_O, nullptr },
        { "remove_submitting", reinterpret_cast<PyCFunction>(Print3DTask_remove_Submitting), METH_O, nullptr },
        { "_assign_array_", _assign_array_Print3DTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTask[] = {
        { "source", reinterpret_cast<getter>(Print3DTask_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DTask[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTask) },
        { },
    };

    static PyType_Spec type_spec_Print3DTask =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTask",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTask
    };

    // ----- Print3DTaskCompletedEventArgs class --------------------

    static PyObject* _new_Print3DTaskCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskCompletedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskCompletedEventArgs_get_Completion(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs", L"Completion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Completion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DTaskCompletedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskCompletedEventArgs", L"ExtendedStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTaskCompletedEventArgs[] = {
        { "completion", reinterpret_cast<getter>(Print3DTaskCompletedEventArgs_get_Completion), nullptr, nullptr, nullptr },
        { "extended_status", reinterpret_cast<getter>(Print3DTaskCompletedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DTaskCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_Print3DTaskCompletedEventArgs =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskCompletedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskCompletedEventArgs
    };

    // ----- Print3DTaskRequest class --------------------

    static PyObject* _new_Print3DTaskRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskRequest(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskRequest_CreateTask(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DTaskRequest", L"CreateTask", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedHandler>(args, 2);

                return py::convert(self->obj.CreateTask(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskRequest[] = {
        { "create_task", reinterpret_cast<PyCFunction>(Print3DTaskRequest_CreateTask), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Print3DTaskRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTaskRequest[] = {
        { }
    };

    static PyType_Slot _type_slots_Print3DTaskRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskRequest) },
        { },
    };

    static PyType_Spec type_spec_Print3DTaskRequest =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskRequest",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskRequest
    };

    // ----- Print3DTaskRequestedEventArgs class --------------------

    static PyObject* _new_Print3DTaskRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskRequestedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskRequestedEventArgs_get_Request(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskRequestedEventArgs", L"Request"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTaskRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(Print3DTaskRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DTaskRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_Print3DTaskRequestedEventArgs =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskRequestedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskRequestedEventArgs
    };

    // ----- Print3DTaskSourceChangedEventArgs class --------------------

    static PyObject* _new_Print3DTaskSourceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskSourceChangedEventArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskSourceChangedEventArgs_get_Source(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Print3DTaskSourceChangedEventArgs", L"Source"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskSourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskSourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskSourceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_Print3DTaskSourceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskSourceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTaskSourceChangedEventArgs[] = {
        { "source", reinterpret_cast<getter>(Print3DTaskSourceChangedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DTaskSourceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskSourceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskSourceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_Print3DTaskSourceChangedEventArgs =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskSourceChangedEventArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskSourceChangedEventArgs
    };

    // ----- Print3DTaskSourceRequestedArgs class --------------------

    static PyObject* _new_Print3DTaskSourceRequestedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_Print3DTaskSourceRequestedArgs(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DTaskSourceRequestedArgs_SetSource(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Print3DTaskSourceRequestedArgs", L"SetSource", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>(args, 0);

                self->obj.SetSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_Print3DTaskSourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Print3DTaskSourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DTaskSourceRequestedArgs[] = {
        { "set_source", reinterpret_cast<PyCFunction>(Print3DTaskSourceRequestedArgs_SetSource), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Print3DTaskSourceRequestedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DTaskSourceRequestedArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DTaskSourceRequestedArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_Print3DTaskSourceRequestedArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Print3DTaskSourceRequestedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Print3DTaskSourceRequestedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Print3DTaskSourceRequestedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Print3DTaskSourceRequestedArgs) },
        { },
    };

    static PyType_Spec type_spec_Print3DTaskSourceRequestedArgs =
    {
        "winrt._winrt_windows_graphics_printing3d.Print3DTaskSourceRequestedArgs",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Print3DTaskSourceRequestedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DTaskSourceRequestedArgs
    };

    // ----- Printing3D3MFPackage class --------------------

    static PyObject* _new_Printing3D3MFPackage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3D3MFPackage(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3D3MFPackage_LoadAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"LoadAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage::LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_LoadModelFromPackageAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"LoadModelFromPackageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(self->obj.LoadModelFromPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_SaveAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"SaveAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_SaveModelToPackageAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"SaveModelToPackageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModel>(args, 0);

                return py::convert(self->obj.SaveModelToPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_PrintTicket(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"PrintTicket"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintTicket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_PrintTicket(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"PrintTicket"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            self->obj.PrintTicket(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_ModelPart(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"ModelPart"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ModelPart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_ModelPart(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"ModelPart"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            self->obj.ModelPart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Textures(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Textures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Textures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3D3MFPackage_get_Compression(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Compression"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Compression());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3D3MFPackage_put_Compression(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3D3MFPackage", L"Compression"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DPackageCompression>(arg);

            self->obj.Compression(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3D3MFPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3D3MFPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3D3MFPackage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3D3MFPackage[] = {
        { "load_model_from_package_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_LoadModelFromPackageAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_SaveAsync), METH_VARARGS, nullptr },
        { "save_model_to_package_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_SaveModelToPackageAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3D3MFPackage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3D3MFPackage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3D3MFPackage[] = {
        { "thumbnail", reinterpret_cast<getter>(Printing3D3MFPackage_get_Thumbnail), reinterpret_cast<setter>(Printing3D3MFPackage_put_Thumbnail), nullptr, nullptr },
        { "print_ticket", reinterpret_cast<getter>(Printing3D3MFPackage_get_PrintTicket), reinterpret_cast<setter>(Printing3D3MFPackage_put_PrintTicket), nullptr, nullptr },
        { "model_part", reinterpret_cast<getter>(Printing3D3MFPackage_get_ModelPart), reinterpret_cast<setter>(Printing3D3MFPackage_put_ModelPart), nullptr, nullptr },
        { "textures", reinterpret_cast<getter>(Printing3D3MFPackage_get_Textures), nullptr, nullptr, nullptr },
        { "compression", reinterpret_cast<getter>(Printing3D3MFPackage_get_Compression), reinterpret_cast<setter>(Printing3D3MFPackage_put_Compression), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3D3MFPackage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3D3MFPackage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3D3MFPackage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3D3MFPackage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3D3MFPackage) },
        { },
    };

    static PyType_Spec type_spec_Printing3D3MFPackage =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3D3MFPackage",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3D3MFPackage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3D3MFPackage
    };

    static PyGetSetDef getset_Printing3D3MFPackage_Static[] = {
        { }
    };

    static PyMethodDef methods_Printing3D3MFPackage_Static[] = {
        { "load_async", reinterpret_cast<PyCFunction>(Printing3D3MFPackage_LoadAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Printing3D3MFPackage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Printing3D3MFPackage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Printing3D3MFPackage_Static) },
        { }
    };

    static PyType_Spec type_spec_Printing3D3MFPackage_Static =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3D3MFPackage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Printing3D3MFPackage_Static
    };

    // ----- Printing3DBaseMaterial class --------------------

    static PyObject* _new_Printing3DBaseMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DBaseMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DBaseMaterial_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBaseMaterial_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Color"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBaseMaterial_put_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Color"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Abs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Abs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial::Abs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DBaseMaterial_get_Pla(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterial", L"Pla"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial::Pla());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DBaseMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DBaseMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DBaseMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DBaseMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DBaseMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DBaseMaterial[] = {
        { "name", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Name), reinterpret_cast<setter>(Printing3DBaseMaterial_put_Name), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Color), reinterpret_cast<setter>(Printing3DBaseMaterial_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DBaseMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBaseMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBaseMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBaseMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBaseMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DBaseMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBaseMaterial
    };

    static PyGetSetDef getset_Printing3DBaseMaterial_Static[] = {
        { "abs", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Abs), nullptr, nullptr, nullptr },
        { "pla", reinterpret_cast<getter>(Printing3DBaseMaterial_get_Pla), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Printing3DBaseMaterial_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Printing3DBaseMaterial_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Printing3DBaseMaterial_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Printing3DBaseMaterial_Static) },
        { }
    };

    static PyType_Spec type_spec_Printing3DBaseMaterial_Static =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterial_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Printing3DBaseMaterial_Static
    };

    // ----- Printing3DBaseMaterialGroup class --------------------

    static PyObject* _new_Printing3DBaseMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DBaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DBaseMaterialGroup_get_Bases(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup", L"Bases"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bases());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DBaseMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DBaseMaterialGroup", L"MaterialGroupId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DBaseMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DBaseMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DBaseMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DBaseMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DBaseMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DBaseMaterialGroup[] = {
        { "bases", reinterpret_cast<getter>(Printing3DBaseMaterialGroup_get_Bases), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DBaseMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DBaseMaterialGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBaseMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBaseMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBaseMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBaseMaterialGroup) },
        { },
    };

    static PyType_Spec type_spec_Printing3DBaseMaterialGroup =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBaseMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBaseMaterialGroup
    };

    // ----- Printing3DColorMaterial class --------------------

    static PyObject* _new_Printing3DColorMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DColorMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DColorMaterial_get_Value(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DColorMaterial_put_Value(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DColorMaterial_get_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Color"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DColorMaterial_put_Color(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterial", L"Color"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DColorMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DColorMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DColorMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DColorMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DColorMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DColorMaterial[] = {
        { "value", reinterpret_cast<getter>(Printing3DColorMaterial_get_Value), reinterpret_cast<setter>(Printing3DColorMaterial_put_Value), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(Printing3DColorMaterial_get_Color), reinterpret_cast<setter>(Printing3DColorMaterial_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DColorMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DColorMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DColorMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DColorMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DColorMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DColorMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DColorMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DColorMaterial
    };

    // ----- Printing3DColorMaterialGroup class --------------------

    static PyObject* _new_Printing3DColorMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DColorMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DColorMaterialGroup_get_Colors(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterialGroup", L"Colors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Colors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DColorMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DColorMaterialGroup", L"MaterialGroupId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DColorMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DColorMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DColorMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DColorMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DColorMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DColorMaterialGroup[] = {
        { "colors", reinterpret_cast<getter>(Printing3DColorMaterialGroup_get_Colors), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DColorMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DColorMaterialGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DColorMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DColorMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DColorMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DColorMaterialGroup) },
        { },
    };

    static PyType_Spec type_spec_Printing3DColorMaterialGroup =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DColorMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DColorMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DColorMaterialGroup
    };

    // ----- Printing3DComponent class --------------------

    static PyObject* _new_Printing3DComponent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DComponent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DComponent(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DComponent_get_Type(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Type(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Type"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DObjectType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Thumbnail(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Thumbnail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_PartNumber(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"PartNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_PartNumber(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"PartNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PartNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Mesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Mesh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Mesh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponent_put_Mesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Mesh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMesh>(arg);

            self->obj.Mesh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponent_get_Components(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponent", L"Components"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DComponent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DComponent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DComponent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DComponent[] = {
        { "_assign_array_", _assign_array_Printing3DComponent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DComponent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DComponent[] = {
        { "type", reinterpret_cast<getter>(Printing3DComponent_get_Type), reinterpret_cast<setter>(Printing3DComponent_put_Type), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(Printing3DComponent_get_Thumbnail), reinterpret_cast<setter>(Printing3DComponent_put_Thumbnail), nullptr, nullptr },
        { "part_number", reinterpret_cast<getter>(Printing3DComponent_get_PartNumber), reinterpret_cast<setter>(Printing3DComponent_put_PartNumber), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Printing3DComponent_get_Name), reinterpret_cast<setter>(Printing3DComponent_put_Name), nullptr, nullptr },
        { "mesh", reinterpret_cast<getter>(Printing3DComponent_get_Mesh), reinterpret_cast<setter>(Printing3DComponent_put_Mesh), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(Printing3DComponent_get_Components), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DComponent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DComponent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DComponent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DComponent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DComponent) },
        { },
    };

    static PyType_Spec type_spec_Printing3DComponent =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DComponent",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DComponent
    };

    // ----- Printing3DComponentWithMatrix class --------------------

    static PyObject* _new_Printing3DComponentWithMatrix(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DComponentWithMatrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DComponentWithMatrix_get_Matrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Matrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Matrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponentWithMatrix_put_Matrix(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Matrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float4x4>(arg);

            self->obj.Matrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DComponentWithMatrix_get_Component(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Component"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Component());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DComponentWithMatrix_put_Component(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DComponentWithMatrix", L"Component"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DComponent>(arg);

            self->obj.Component(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DComponentWithMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DComponentWithMatrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DComponentWithMatrix[] = {
        { "_assign_array_", _assign_array_Printing3DComponentWithMatrix, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DComponentWithMatrix), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DComponentWithMatrix[] = {
        { "matrix", reinterpret_cast<getter>(Printing3DComponentWithMatrix_get_Matrix), reinterpret_cast<setter>(Printing3DComponentWithMatrix_put_Matrix), nullptr, nullptr },
        { "component", reinterpret_cast<getter>(Printing3DComponentWithMatrix_get_Component), reinterpret_cast<setter>(Printing3DComponentWithMatrix_put_Component), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DComponentWithMatrix[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DComponentWithMatrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DComponentWithMatrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DComponentWithMatrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DComponentWithMatrix) },
        { },
    };

    static PyType_Spec type_spec_Printing3DComponentWithMatrix =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DComponentWithMatrix",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DComponentWithMatrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DComponentWithMatrix
    };

    // ----- Printing3DCompositeMaterial class --------------------

    static PyObject* _new_Printing3DCompositeMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DCompositeMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DCompositeMaterial_get_Values(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterial", L"Values"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DCompositeMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DCompositeMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DCompositeMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DCompositeMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DCompositeMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DCompositeMaterial[] = {
        { "values", reinterpret_cast<getter>(Printing3DCompositeMaterial_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DCompositeMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DCompositeMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DCompositeMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DCompositeMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DCompositeMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DCompositeMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DCompositeMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DCompositeMaterial
    };

    // ----- Printing3DCompositeMaterialGroup class --------------------

    static PyObject* _new_Printing3DCompositeMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DCompositeMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_Composites(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"Composites"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Composites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"MaterialGroupId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_MaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"MaterialIndices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialIndices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DCompositeMaterialGroup_get_BaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"BaseMaterialGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BaseMaterialGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DCompositeMaterialGroup_put_BaseMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DCompositeMaterialGroup", L"BaseMaterialGroup"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBaseMaterialGroup>(arg);

            self->obj.BaseMaterialGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DCompositeMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DCompositeMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DCompositeMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DCompositeMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DCompositeMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DCompositeMaterialGroup[] = {
        { "composites", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_Composites), nullptr, nullptr, nullptr },
        { "material_group_id", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "material_indices", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_MaterialIndices), nullptr, nullptr, nullptr },
        { "base_material_group", reinterpret_cast<getter>(Printing3DCompositeMaterialGroup_get_BaseMaterialGroup), reinterpret_cast<setter>(Printing3DCompositeMaterialGroup_put_BaseMaterialGroup), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DCompositeMaterialGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DCompositeMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DCompositeMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DCompositeMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DCompositeMaterialGroup) },
        { },
    };

    static PyType_Spec type_spec_Printing3DCompositeMaterialGroup =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DCompositeMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DCompositeMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DCompositeMaterialGroup
    };

    // ----- Printing3DFaceReductionOptions class --------------------

    static PyObject* _new_Printing3DFaceReductionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DFaceReductionOptions(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DFaceReductionOptions_get_TargetTriangleCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"TargetTriangleCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetTriangleCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_TargetTriangleCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"TargetTriangleCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TargetTriangleCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DFaceReductionOptions_get_MaxReductionArea(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxReductionArea"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxReductionArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_MaxReductionArea(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxReductionArea"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxReductionArea(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DFaceReductionOptions_get_MaxEdgeLength(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxEdgeLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxEdgeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DFaceReductionOptions_put_MaxEdgeLength(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DFaceReductionOptions", L"MaxEdgeLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxEdgeLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DFaceReductionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DFaceReductionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DFaceReductionOptions[] = {
        { "_assign_array_", _assign_array_Printing3DFaceReductionOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DFaceReductionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DFaceReductionOptions[] = {
        { "target_triangle_count", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_TargetTriangleCount), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_TargetTriangleCount), nullptr, nullptr },
        { "max_reduction_area", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_MaxReductionArea), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_MaxReductionArea), nullptr, nullptr },
        { "max_edge_length", reinterpret_cast<getter>(Printing3DFaceReductionOptions_get_MaxEdgeLength), reinterpret_cast<setter>(Printing3DFaceReductionOptions_put_MaxEdgeLength), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DFaceReductionOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DFaceReductionOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DFaceReductionOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DFaceReductionOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DFaceReductionOptions) },
        { },
    };

    static PyType_Spec type_spec_Printing3DFaceReductionOptions =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DFaceReductionOptions",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DFaceReductionOptions
    };

    // ----- Printing3DMaterial class --------------------

    static PyObject* _new_Printing3DMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMaterial_get_BaseGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"BaseGroups"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BaseGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_ColorGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"ColorGroups"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_CompositeGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"CompositeGroups"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CompositeGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_MultiplePropertyGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"MultiplePropertyGroups"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MultiplePropertyGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMaterial_get_Texture2CoordGroups(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMaterial", L"Texture2CoordGroups"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Texture2CoordGroups());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DMaterial[] = {
        { "base_groups", reinterpret_cast<getter>(Printing3DMaterial_get_BaseGroups), nullptr, nullptr, nullptr },
        { "color_groups", reinterpret_cast<getter>(Printing3DMaterial_get_ColorGroups), nullptr, nullptr, nullptr },
        { "composite_groups", reinterpret_cast<getter>(Printing3DMaterial_get_CompositeGroups), nullptr, nullptr, nullptr },
        { "multiple_property_groups", reinterpret_cast<getter>(Printing3DMaterial_get_MultiplePropertyGroups), nullptr, nullptr, nullptr },
        { "texture2_coord_groups", reinterpret_cast<getter>(Printing3DMaterial_get_Texture2CoordGroups), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMaterial
    };

    // ----- Printing3DMesh class --------------------

    static PyObject* _new_Printing3DMesh(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMesh instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMesh(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMesh_CreateTriangleIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateTriangleIndices", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.CreateTriangleIndices(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateTriangleMaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateTriangleMaterialIndices", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.CreateTriangleMaterialIndices(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateVertexNormals(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateVertexNormals", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.CreateVertexNormals(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_CreateVertexPositions(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"CreateVertexPositions", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.CreateVertexPositions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetTriangleIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetTriangleIndices", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTriangleIndices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetTriangleMaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetTriangleMaterialIndices", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetTriangleMaterialIndices());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetVertexNormals(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetVertexNormals", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVertexNormals());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_GetVertexPositions(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"GetVertexPositions", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetVertexPositions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_VerifyAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VerifyAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationMode>(args, 0);

                return py::convert(self->obj.VerifyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_get_VertexPositionsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexPositionsDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VertexPositionsDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexPositionsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexPositionsDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            self->obj.VertexPositionsDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_VertexNormalsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexNormalsDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VertexNormalsDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexNormalsDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexNormalsDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            self->obj.VertexNormalsDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_VertexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VertexCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_VertexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"VertexCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.VertexCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_TriangleMaterialIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleMaterialIndicesDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TriangleMaterialIndicesDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_TriangleMaterialIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleMaterialIndicesDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            self->obj.TriangleMaterialIndicesDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_TriangleIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleIndicesDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TriangleIndicesDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_TriangleIndicesDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"TriangleIndicesDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>(arg);

            self->obj.TriangleIndicesDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_IndexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"IndexCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IndexCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DMesh_put_IndexCount(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"IndexCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.IndexCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DMesh_get_BufferDescriptionSet(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"BufferDescriptionSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BufferDescriptionSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMesh_get_BufferSet(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMesh", L"BufferSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BufferSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMesh>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMesh(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMesh>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMesh[] = {
        { "create_triangle_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateTriangleIndices), METH_VARARGS, nullptr },
        { "create_triangle_material_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateTriangleMaterialIndices), METH_VARARGS, nullptr },
        { "create_vertex_normals", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateVertexNormals), METH_VARARGS, nullptr },
        { "create_vertex_positions", reinterpret_cast<PyCFunction>(Printing3DMesh_CreateVertexPositions), METH_VARARGS, nullptr },
        { "get_triangle_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_GetTriangleIndices), METH_VARARGS, nullptr },
        { "get_triangle_material_indices", reinterpret_cast<PyCFunction>(Printing3DMesh_GetTriangleMaterialIndices), METH_VARARGS, nullptr },
        { "get_vertex_normals", reinterpret_cast<PyCFunction>(Printing3DMesh_GetVertexNormals), METH_VARARGS, nullptr },
        { "get_vertex_positions", reinterpret_cast<PyCFunction>(Printing3DMesh_GetVertexPositions), METH_VARARGS, nullptr },
        { "verify_async", reinterpret_cast<PyCFunction>(Printing3DMesh_VerifyAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3DMesh, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMesh), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DMesh[] = {
        { "vertex_positions_description", reinterpret_cast<getter>(Printing3DMesh_get_VertexPositionsDescription), reinterpret_cast<setter>(Printing3DMesh_put_VertexPositionsDescription), nullptr, nullptr },
        { "vertex_normals_description", reinterpret_cast<getter>(Printing3DMesh_get_VertexNormalsDescription), reinterpret_cast<setter>(Printing3DMesh_put_VertexNormalsDescription), nullptr, nullptr },
        { "vertex_count", reinterpret_cast<getter>(Printing3DMesh_get_VertexCount), reinterpret_cast<setter>(Printing3DMesh_put_VertexCount), nullptr, nullptr },
        { "triangle_material_indices_description", reinterpret_cast<getter>(Printing3DMesh_get_TriangleMaterialIndicesDescription), reinterpret_cast<setter>(Printing3DMesh_put_TriangleMaterialIndicesDescription), nullptr, nullptr },
        { "triangle_indices_description", reinterpret_cast<getter>(Printing3DMesh_get_TriangleIndicesDescription), reinterpret_cast<setter>(Printing3DMesh_put_TriangleIndicesDescription), nullptr, nullptr },
        { "index_count", reinterpret_cast<getter>(Printing3DMesh_get_IndexCount), reinterpret_cast<setter>(Printing3DMesh_put_IndexCount), nullptr, nullptr },
        { "buffer_description_set", reinterpret_cast<getter>(Printing3DMesh_get_BufferDescriptionSet), nullptr, nullptr, nullptr },
        { "buffer_set", reinterpret_cast<getter>(Printing3DMesh_get_BufferSet), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DMesh[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMesh) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMesh) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMesh) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMesh) },
        { },
    };

    static PyType_Spec type_spec_Printing3DMesh =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMesh",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMesh),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMesh
    };

    // ----- Printing3DMeshVerificationResult class --------------------

    static PyObject* _new_Printing3DMeshVerificationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_Printing3DMeshVerificationResult(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMeshVerificationResult_get_IsValid(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"IsValid"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMeshVerificationResult_get_NonmanifoldTriangles(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"NonmanifoldTriangles"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NonmanifoldTriangles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMeshVerificationResult_get_ReversedNormalTriangles(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMeshVerificationResult", L"ReversedNormalTriangles"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReversedNormalTriangles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMeshVerificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMeshVerificationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMeshVerificationResult[] = {
        { "_assign_array_", _assign_array_Printing3DMeshVerificationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMeshVerificationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DMeshVerificationResult[] = {
        { "is_valid", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_IsValid), nullptr, nullptr, nullptr },
        { "nonmanifold_triangles", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_NonmanifoldTriangles), nullptr, nullptr, nullptr },
        { "reversed_normal_triangles", reinterpret_cast<getter>(Printing3DMeshVerificationResult_get_ReversedNormalTriangles), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DMeshVerificationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMeshVerificationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMeshVerificationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMeshVerificationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMeshVerificationResult) },
        { },
    };

    static PyType_Spec type_spec_Printing3DMeshVerificationResult =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMeshVerificationResult",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMeshVerificationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMeshVerificationResult
    };

    // ----- Printing3DModel class --------------------

    static PyObject* _new_Printing3DModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DModel instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DModel(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DModel_Clone(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Clone", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_RepairAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RepairAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RepairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_RepairWithProgressAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RepairWithProgressAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RepairWithProgressAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryPartialRepairAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryPartialRepairAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryPartialRepairAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryPartialRepairAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.TryPartialRepairAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_TryReduceFacesAsync(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryReduceFacesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>(args, 0);

                return py::convert(self->obj.TryReduceFacesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"TryReduceFacesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DFaceReductionOptions>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.TryReduceFacesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Version(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Version(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Version"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Unit(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Unit(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Unit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelUnit>(arg);

            self->obj.Unit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Material(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Material"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Material());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Material(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Material"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DMaterial>(arg);

            self->obj.Material(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Build(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Build"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Build());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModel_put_Build(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Build"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DComponent>(arg);

            self->obj.Build(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModel_get_Components(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Components"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Components());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Meshes(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Meshes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Meshes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Metadata(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Metadata"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Metadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_RequiredExtensions(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"RequiredExtensions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DModel_get_Textures(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModel", L"Textures"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Textures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DModel[] = {
        { "clone", reinterpret_cast<PyCFunction>(Printing3DModel_Clone), METH_VARARGS, nullptr },
        { "repair_async", reinterpret_cast<PyCFunction>(Printing3DModel_RepairAsync), METH_VARARGS, nullptr },
        { "repair_with_progress_async", reinterpret_cast<PyCFunction>(Printing3DModel_RepairWithProgressAsync), METH_VARARGS, nullptr },
        { "try_partial_repair_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryPartialRepairAsync), METH_VARARGS, nullptr },
        { "try_reduce_faces_async", reinterpret_cast<PyCFunction>(Printing3DModel_TryReduceFacesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Printing3DModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DModel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DModel[] = {
        { "version", reinterpret_cast<getter>(Printing3DModel_get_Version), reinterpret_cast<setter>(Printing3DModel_put_Version), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(Printing3DModel_get_Unit), reinterpret_cast<setter>(Printing3DModel_put_Unit), nullptr, nullptr },
        { "material", reinterpret_cast<getter>(Printing3DModel_get_Material), reinterpret_cast<setter>(Printing3DModel_put_Material), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(Printing3DModel_get_Build), reinterpret_cast<setter>(Printing3DModel_put_Build), nullptr, nullptr },
        { "components", reinterpret_cast<getter>(Printing3DModel_get_Components), nullptr, nullptr, nullptr },
        { "meshes", reinterpret_cast<getter>(Printing3DModel_get_Meshes), nullptr, nullptr, nullptr },
        { "metadata", reinterpret_cast<getter>(Printing3DModel_get_Metadata), nullptr, nullptr, nullptr },
        { "required_extensions", reinterpret_cast<getter>(Printing3DModel_get_RequiredExtensions), nullptr, nullptr, nullptr },
        { "textures", reinterpret_cast<getter>(Printing3DModel_get_Textures), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DModel) },
        { },
    };

    static PyType_Spec type_spec_Printing3DModel =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DModel",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DModel
    };

    // ----- Printing3DModelTexture class --------------------

    static PyObject* _new_Printing3DModelTexture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DModelTexture instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DModelTexture(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DModelTexture_get_TileStyleV(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleV"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileStyleV());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TileStyleV(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleV"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureEdgeBehavior>(arg);

            self->obj.TileStyleV(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModelTexture_get_TileStyleU(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleU"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TileStyleU());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TileStyleU(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TileStyleU"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureEdgeBehavior>(arg);

            self->obj.TileStyleU(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DModelTexture_get_TextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TextureResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextureResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DModelTexture_put_TextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DModelTexture", L"TextureResource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>(arg);

            self->obj.TextureResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DModelTexture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DModelTexture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DModelTexture[] = {
        { "_assign_array_", _assign_array_Printing3DModelTexture, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DModelTexture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DModelTexture[] = {
        { "tile_style_v", reinterpret_cast<getter>(Printing3DModelTexture_get_TileStyleV), reinterpret_cast<setter>(Printing3DModelTexture_put_TileStyleV), nullptr, nullptr },
        { "tile_style_u", reinterpret_cast<getter>(Printing3DModelTexture_get_TileStyleU), reinterpret_cast<setter>(Printing3DModelTexture_put_TileStyleU), nullptr, nullptr },
        { "texture_resource", reinterpret_cast<getter>(Printing3DModelTexture_get_TextureResource), reinterpret_cast<setter>(Printing3DModelTexture_put_TextureResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DModelTexture[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DModelTexture) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DModelTexture) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DModelTexture) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DModelTexture) },
        { },
    };

    static PyType_Spec type_spec_Printing3DModelTexture =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DModelTexture",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DModelTexture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DModelTexture
    };

    // ----- Printing3DMultiplePropertyMaterial class --------------------

    static PyObject* _new_Printing3DMultiplePropertyMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMultiplePropertyMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMultiplePropertyMaterial_get_MaterialIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterial", L"MaterialIndices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialIndices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMultiplePropertyMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMultiplePropertyMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMultiplePropertyMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DMultiplePropertyMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMultiplePropertyMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DMultiplePropertyMaterial[] = {
        { "material_indices", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterial_get_MaterialIndices), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DMultiplePropertyMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMultiplePropertyMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMultiplePropertyMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMultiplePropertyMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMultiplePropertyMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DMultiplePropertyMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMultiplePropertyMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMultiplePropertyMaterial
    };

    // ----- Printing3DMultiplePropertyMaterialGroup class --------------------

    static PyObject* _new_Printing3DMultiplePropertyMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DMultiplePropertyMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MaterialGroupId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupIndices(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MaterialGroupIndices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupIndices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DMultiplePropertyMaterialGroup_get_MultipleProperties(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DMultiplePropertyMaterialGroup", L"MultipleProperties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MultipleProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Printing3DMultiplePropertyMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DMultiplePropertyMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DMultiplePropertyMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DMultiplePropertyMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DMultiplePropertyMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DMultiplePropertyMaterialGroup[] = {
        { "material_group_id", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "material_group_indices", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MaterialGroupIndices), nullptr, nullptr, nullptr },
        { "multiple_properties", reinterpret_cast<getter>(Printing3DMultiplePropertyMaterialGroup_get_MultipleProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DMultiplePropertyMaterialGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DMultiplePropertyMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DMultiplePropertyMaterialGroup) },
        { },
    };

    static PyType_Spec type_spec_Printing3DMultiplePropertyMaterialGroup =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DMultiplePropertyMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DMultiplePropertyMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DMultiplePropertyMaterialGroup
    };

    // ----- Printing3DTexture2CoordMaterial class --------------------

    static PyObject* _new_Printing3DTexture2CoordMaterial(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTexture2CoordMaterial(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_V(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"V"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_V(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"V"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.V(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_U(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"U"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.U());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_U(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"U"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.U(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterial_get_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"Texture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Texture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterial_put_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterial", L"Texture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>(arg);

            self->obj.Texture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTexture2CoordMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTexture2CoordMaterial(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTexture2CoordMaterial[] = {
        { "_assign_array_", _assign_array_Printing3DTexture2CoordMaterial, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTexture2CoordMaterial), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DTexture2CoordMaterial[] = {
        { "v", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_V), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_V), nullptr, nullptr },
        { "u", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_U), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_U), nullptr, nullptr },
        { "texture", reinterpret_cast<getter>(Printing3DTexture2CoordMaterial_get_Texture), reinterpret_cast<setter>(Printing3DTexture2CoordMaterial_put_Texture), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DTexture2CoordMaterial[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTexture2CoordMaterial) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTexture2CoordMaterial) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTexture2CoordMaterial) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTexture2CoordMaterial) },
        { },
    };

    static PyType_Spec type_spec_Printing3DTexture2CoordMaterial =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTexture2CoordMaterial",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterial),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTexture2CoordMaterial
    };

    // ----- Printing3DTexture2CoordMaterialGroup class --------------------

    static PyObject* _new_Printing3DTexture2CoordMaterialGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTexture2CoordMaterialGroup(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_MaterialGroupId(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"MaterialGroupId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaterialGroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_Texture2Coords(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture2Coords"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Texture2Coords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Printing3DTexture2CoordMaterialGroup_get_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Texture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTexture2CoordMaterialGroup_put_Texture(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTexture2CoordMaterialGroup", L"Texture"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::Printing3D::Printing3DModelTexture>(arg);

            self->obj.Texture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTexture2CoordMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTexture2CoordMaterialGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTexture2CoordMaterialGroup[] = {
        { "_assign_array_", _assign_array_Printing3DTexture2CoordMaterialGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTexture2CoordMaterialGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DTexture2CoordMaterialGroup[] = {
        { "material_group_id", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_MaterialGroupId), nullptr, nullptr, nullptr },
        { "texture2_coords", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_Texture2Coords), nullptr, nullptr, nullptr },
        { "texture", reinterpret_cast<getter>(Printing3DTexture2CoordMaterialGroup_get_Texture), reinterpret_cast<setter>(Printing3DTexture2CoordMaterialGroup_put_Texture), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DTexture2CoordMaterialGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTexture2CoordMaterialGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTexture2CoordMaterialGroup) },
        { },
    };

    static PyType_Spec type_spec_Printing3DTexture2CoordMaterialGroup =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTexture2CoordMaterialGroup",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTexture2CoordMaterialGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTexture2CoordMaterialGroup
    };

    // ----- Printing3DTextureResource class --------------------

    static PyObject* _new_Printing3DTextureResource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Printing3D::Printing3DTextureResource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Printing3DTextureResource(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Printing3DTextureResource_get_TextureData(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"TextureData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextureData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTextureResource_put_TextureData(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"TextureData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>(arg);

            self->obj.TextureData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DTextureResource_get_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DTextureResource_put_Name(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Printing3D.Printing3DTextureResource", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Printing3DTextureResource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Printing3DTextureResource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Printing3D::Printing3DTextureResource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Printing3DTextureResource[] = {
        { "_assign_array_", _assign_array_Printing3DTextureResource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Printing3DTextureResource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Printing3DTextureResource[] = {
        { "texture_data", reinterpret_cast<getter>(Printing3DTextureResource_get_TextureData), reinterpret_cast<setter>(Printing3DTextureResource_put_TextureData), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Printing3DTextureResource_get_Name), reinterpret_cast<setter>(Printing3DTextureResource_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DTextureResource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DTextureResource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DTextureResource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DTextureResource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DTextureResource) },
        { },
    };

    static PyType_Spec type_spec_Printing3DTextureResource =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DTextureResource",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DTextureResource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DTextureResource
    };

    // ----- Printing3DBufferDescription struct --------------------

    winrt_struct_wrapper<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>* _new_Printing3DBufferDescription(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Printing3DBufferDescription(winrt_struct_wrapper<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Format{};
        uint32_t _Stride{};

        static const char* kwlist[] = {"format", "stride", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_Format, &_Stride))
        {
            return -1;
        }

        try
        {
            self->obj = {static_cast<winrt::Windows::Graphics::Printing3D::Printing3DBufferFormat>(_Format), _Stride};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Printing3DBufferDescription(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Printing3DBufferDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Printing3D::Printing3DBufferDescription>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Printing3DBufferDescription[] = {
        { "_assign_array_", _assign_array_Printing3DBufferDescription, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Printing3DBufferDescription_get_Format(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBufferDescription_set_Format(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Format = py::converter<winrt::Windows::Graphics::Printing3D::Printing3DBufferFormat>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Printing3DBufferDescription_get_Stride(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stride);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Printing3DBufferDescription_set_Stride(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Stride = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Printing3DBufferDescription[] = {
        { "format", reinterpret_cast<getter>(Printing3DBufferDescription_get_Format), reinterpret_cast<setter>(Printing3DBufferDescription_set_Format), nullptr, nullptr },
        { "stride", reinterpret_cast<getter>(Printing3DBufferDescription_get_Stride), reinterpret_cast<setter>(Printing3DBufferDescription_set_Stride), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Printing3DBufferDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Printing3DBufferDescription) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Printing3DBufferDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Printing3DBufferDescription) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Printing3DBufferDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Printing3DBufferDescription) },
        { },
    };

    static PyType_Spec type_spec_Printing3DBufferDescription =
    {
        "winrt._winrt_windows_graphics_printing3d.Printing3DBufferDescription",
        sizeof(py::wrapper::Windows::Graphics::Printing3D::Printing3DBufferDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Printing3DBufferDescription
    };

    // ----- Windows.Graphics.Printing3D Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Graphics.Printing3D");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_graphics_printing3d",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Graphics::Printing3D

PyMODINIT_FUNC PyInit__winrt_windows_graphics_printing3d(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Printing3D;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Print3DManager_Static{PyType_FromSpec(&type_spec_Print3DManager_Static)};
    if (!type_Print3DManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Print3DManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTask, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTaskCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTaskRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTaskRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTaskSourceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Print3DTaskSourceRequestedArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Printing3D3MFPackage_Static{PyType_FromSpec(&type_spec_Printing3D3MFPackage_Static)};
    if (!type_Printing3D3MFPackage_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3D3MFPackage, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Printing3D3MFPackage_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Printing3DBaseMaterial_Static{PyType_FromSpec(&type_spec_Printing3DBaseMaterial_Static)};
    if (!type_Printing3DBaseMaterial_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DBaseMaterial, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Printing3DBaseMaterial_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DBaseMaterialGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DColorMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DColorMaterialGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DComponent, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DComponentWithMatrix, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DCompositeMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DCompositeMaterialGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DFaceReductionOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DMesh, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DMeshVerificationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DModel, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DModelTexture, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DMultiplePropertyMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DMultiplePropertyMaterialGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DTexture2CoordMaterial, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DTexture2CoordMaterialGroup, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DTextureResource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Printing3DBufferDescription, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
