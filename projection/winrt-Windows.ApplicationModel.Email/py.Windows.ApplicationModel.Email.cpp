// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Email.h"


namespace py::cpp::Windows::ApplicationModel::Email
{
    // ----- EmailAttachment class --------------------

    static PyObject* _new_EmailAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailAttachment_get_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"FileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"FileName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"MimeType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"MimeType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MimeType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsInline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsInline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"EstimatedDownloadSizeInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EstimatedDownloadSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"EstimatedDownloadSizeInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.EstimatedDownloadSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"DownloadState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DownloadState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"DownloadState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailAttachmentDownloadState>(arg);

            self->obj.DownloadState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentLocation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailAttachment_get_IsFromBaseMessage(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsFromBaseMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFromBaseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailAttachment[] = {
        { "_assign_array_", _assign_array_EmailAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailAttachment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailAttachment[] = {
        { "file_name", reinterpret_cast<getter>(EmailAttachment_get_FileName), reinterpret_cast<setter>(EmailAttachment_put_FileName), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(EmailAttachment_get_Data), reinterpret_cast<setter>(EmailAttachment_put_Data), nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(EmailAttachment_get_MimeType), reinterpret_cast<setter>(EmailAttachment_put_MimeType), nullptr, nullptr },
        { "is_inline", reinterpret_cast<getter>(EmailAttachment_get_IsInline), reinterpret_cast<setter>(EmailAttachment_put_IsInline), nullptr, nullptr },
        { "estimated_download_size_in_bytes", reinterpret_cast<getter>(EmailAttachment_get_EstimatedDownloadSizeInBytes), reinterpret_cast<setter>(EmailAttachment_put_EstimatedDownloadSizeInBytes), nullptr, nullptr },
        { "download_state", reinterpret_cast<getter>(EmailAttachment_get_DownloadState), reinterpret_cast<setter>(EmailAttachment_put_DownloadState), nullptr, nullptr },
        { "content_location", reinterpret_cast<getter>(EmailAttachment_get_ContentLocation), reinterpret_cast<setter>(EmailAttachment_put_ContentLocation), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(EmailAttachment_get_ContentId), reinterpret_cast<setter>(EmailAttachment_put_ContentId), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailAttachment_get_Id), nullptr, nullptr, nullptr },
        { "is_from_base_message", reinterpret_cast<getter>(EmailAttachment_get_IsFromBaseMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailAttachment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailAttachment) },
        { },
    };

    static PyType_Spec type_spec_EmailAttachment =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailAttachment
    };

    // ----- EmailConversation class --------------------

    static PyObject* _new_EmailConversation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversation(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversation_FindMessagesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FindMessagesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindMessagesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FindMessagesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.FindMessagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FlagState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlagState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_HasAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"HasAttachment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasAttachment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Importance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Importance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LastEmailResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"LastEmailResponseKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastEmailResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LatestSender(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"LatestSender"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LatestSender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MailboxId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MessageCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MostRecentMessageId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MostRecentMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageTime(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MostRecentMessageTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MostRecentMessageTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Preview"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_UnreadMessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"UnreadMessageCount"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UnreadMessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversation[] = {
        { "find_messages_async", reinterpret_cast<PyCFunction>(EmailConversation_FindMessagesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailConversation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailConversation[] = {
        { "flag_state", reinterpret_cast<getter>(EmailConversation_get_FlagState), nullptr, nullptr, nullptr },
        { "has_attachment", reinterpret_cast<getter>(EmailConversation_get_HasAttachment), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailConversation_get_Id), nullptr, nullptr, nullptr },
        { "importance", reinterpret_cast<getter>(EmailConversation_get_Importance), nullptr, nullptr, nullptr },
        { "last_email_response_kind", reinterpret_cast<getter>(EmailConversation_get_LastEmailResponseKind), nullptr, nullptr, nullptr },
        { "latest_sender", reinterpret_cast<getter>(EmailConversation_get_LatestSender), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailConversation_get_MailboxId), nullptr, nullptr, nullptr },
        { "message_count", reinterpret_cast<getter>(EmailConversation_get_MessageCount), nullptr, nullptr, nullptr },
        { "most_recent_message_id", reinterpret_cast<getter>(EmailConversation_get_MostRecentMessageId), nullptr, nullptr, nullptr },
        { "most_recent_message_time", reinterpret_cast<getter>(EmailConversation_get_MostRecentMessageTime), nullptr, nullptr, nullptr },
        { "preview", reinterpret_cast<getter>(EmailConversation_get_Preview), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailConversation_get_Subject), nullptr, nullptr, nullptr },
        { "unread_message_count", reinterpret_cast<getter>(EmailConversation_get_UnreadMessageCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailConversation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversation) },
        { },
    };

    static PyType_Spec type_spec_EmailConversation =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversation
    };

    // ----- EmailConversationBatch class --------------------

    static PyObject* _new_EmailConversationBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversationBatch(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversationBatch_get_Conversations(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversationBatch", L"Conversations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Conversations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversationBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversationBatch", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversationBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversationBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationBatch[] = {
        { "_assign_array_", _assign_array_EmailConversationBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversationBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailConversationBatch[] = {
        { "conversations", reinterpret_cast<getter>(EmailConversationBatch_get_Conversations), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailConversationBatch_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailConversationBatch[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversationBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversationBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversationBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversationBatch) },
        { },
    };

    static PyType_Spec type_spec_EmailConversationBatch =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailConversationBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationBatch
    };

    // ----- EmailConversationReader class --------------------

    static PyObject* _new_EmailConversationReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversationReader", L"ReadBatchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversationReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailConversationReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailConversationReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversationReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailConversationReader[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailConversationReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversationReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversationReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversationReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversationReader) },
        { },
    };

    static PyType_Spec type_spec_EmailConversationReader =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationReader
    };

    // ----- EmailFolder class --------------------

    static PyObject* _new_EmailFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailFolder(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailFolder_CreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"CreateFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_FindChildFoldersAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"FindChildFoldersAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindChildFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetConversationReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetConversationReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageCountsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageCountsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMessageCountsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"SaveMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TryMoveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TryMoveAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);

                return py::convert(self->obj.TryMoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TryMoveAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TrySaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TrySaveAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TrySaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"IsSyncEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"IsSyncEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"MailboxId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_ParentFolderId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"ParentFolderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ParentFolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailFolder[] = {
        { "create_folder_async", reinterpret_cast<PyCFunction>(EmailFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(EmailFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "find_child_folders_async", reinterpret_cast<PyCFunction>(EmailFolder_FindChildFoldersAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailFolder_GetConversationReader), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_counts_async", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageCountsAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageReader), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(EmailFolder_SaveMessageAsync), METH_VARARGS, nullptr },
        { "try_move_async", reinterpret_cast<PyCFunction>(EmailFolder_TryMoveAsync), METH_VARARGS, nullptr },
        { "try_save_async", reinterpret_cast<PyCFunction>(EmailFolder_TrySaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailFolder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailFolder[] = {
        { "remote_id", reinterpret_cast<getter>(EmailFolder_get_RemoteId), reinterpret_cast<setter>(EmailFolder_put_RemoteId), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(EmailFolder_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(EmailFolder_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "is_sync_enabled", reinterpret_cast<getter>(EmailFolder_get_IsSyncEnabled), reinterpret_cast<setter>(EmailFolder_put_IsSyncEnabled), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(EmailFolder_get_DisplayName), reinterpret_cast<setter>(EmailFolder_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailFolder_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailFolder_get_Kind), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailFolder_get_MailboxId), nullptr, nullptr, nullptr },
        { "parent_folder_id", reinterpret_cast<getter>(EmailFolder_get_ParentFolderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailFolder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailFolder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailFolder) },
        { },
    };

    static PyType_Spec type_spec_EmailFolder =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailFolder",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailFolder
    };

    // ----- EmailIrmInfo class --------------------

    static PyObject* _new_EmailIrmInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailIrmInfo_get_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanRemoveIrmOnResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanRemoveIrmOnResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanRemoveIrmOnResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanRemoveIrmOnResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanPrintData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanPrintData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanPrintData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanPrintData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanModifyRecipientsOnResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanModifyRecipientsOnResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanModifyRecipientsOnResponse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanModifyRecipientsOnResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanForward"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanForward());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanForward"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForward(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanExtractData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanExtractData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanExtractData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanExtractData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReply"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReply"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReply(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanEdit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanEdit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanEdit"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanEdit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"Template"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"Template"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsProgramaticAccessAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsProgramaticAccessAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsProgramaticAccessAllowed"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsProgramaticAccessAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsIrmOriginator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsIrmOriginator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsIrmOriginator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIrmOriginator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ExpirationDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReplyAll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReplyAll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReplyAll"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanReplyAll(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailIrmInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailIrmInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmInfo[] = {
        { "_assign_array_", _assign_array_EmailIrmInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailIrmInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailIrmInfo[] = {
        { "can_remove_irm_on_response", reinterpret_cast<getter>(EmailIrmInfo_get_CanRemoveIrmOnResponse), reinterpret_cast<setter>(EmailIrmInfo_put_CanRemoveIrmOnResponse), nullptr, nullptr },
        { "can_print_data", reinterpret_cast<getter>(EmailIrmInfo_get_CanPrintData), reinterpret_cast<setter>(EmailIrmInfo_put_CanPrintData), nullptr, nullptr },
        { "can_modify_recipients_on_response", reinterpret_cast<getter>(EmailIrmInfo_get_CanModifyRecipientsOnResponse), reinterpret_cast<setter>(EmailIrmInfo_put_CanModifyRecipientsOnResponse), nullptr, nullptr },
        { "can_forward", reinterpret_cast<getter>(EmailIrmInfo_get_CanForward), reinterpret_cast<setter>(EmailIrmInfo_put_CanForward), nullptr, nullptr },
        { "can_extract_data", reinterpret_cast<getter>(EmailIrmInfo_get_CanExtractData), reinterpret_cast<setter>(EmailIrmInfo_put_CanExtractData), nullptr, nullptr },
        { "can_reply", reinterpret_cast<getter>(EmailIrmInfo_get_CanReply), reinterpret_cast<setter>(EmailIrmInfo_put_CanReply), nullptr, nullptr },
        { "can_edit", reinterpret_cast<getter>(EmailIrmInfo_get_CanEdit), reinterpret_cast<setter>(EmailIrmInfo_put_CanEdit), nullptr, nullptr },
        { "template", reinterpret_cast<getter>(EmailIrmInfo_get_Template), reinterpret_cast<setter>(EmailIrmInfo_put_Template), nullptr, nullptr },
        { "is_programatic_access_allowed", reinterpret_cast<getter>(EmailIrmInfo_get_IsProgramaticAccessAllowed), reinterpret_cast<setter>(EmailIrmInfo_put_IsProgramaticAccessAllowed), nullptr, nullptr },
        { "is_irm_originator", reinterpret_cast<getter>(EmailIrmInfo_get_IsIrmOriginator), reinterpret_cast<setter>(EmailIrmInfo_put_IsIrmOriginator), nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(EmailIrmInfo_get_ExpirationDate), reinterpret_cast<setter>(EmailIrmInfo_put_ExpirationDate), nullptr, nullptr },
        { "can_reply_all", reinterpret_cast<getter>(EmailIrmInfo_get_CanReplyAll), reinterpret_cast<setter>(EmailIrmInfo_put_CanReplyAll), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailIrmInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailIrmInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailIrmInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailIrmInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailIrmInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailIrmInfo =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailIrmInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmInfo
    };

    // ----- EmailIrmTemplate class --------------------

    static PyObject* _new_EmailIrmTemplate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmTemplate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailIrmTemplate_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Description"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailIrmTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailIrmTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmTemplate[] = {
        { "_assign_array_", _assign_array_EmailIrmTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailIrmTemplate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailIrmTemplate[] = {
        { "name", reinterpret_cast<getter>(EmailIrmTemplate_get_Name), reinterpret_cast<setter>(EmailIrmTemplate_put_Name), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailIrmTemplate_get_Id), reinterpret_cast<setter>(EmailIrmTemplate_put_Id), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(EmailIrmTemplate_get_Description), reinterpret_cast<setter>(EmailIrmTemplate_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailIrmTemplate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailIrmTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailIrmTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailIrmTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailIrmTemplate) },
        { },
    };

    static PyType_Spec type_spec_EmailIrmTemplate =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailIrmTemplate",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmTemplate
    };

    // ----- EmailItemCounts class --------------------

    static PyObject* _new_EmailItemCounts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailItemCounts(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailItemCounts_get_Flagged(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Flagged"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Flagged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Important(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Important"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Important());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Total(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Total"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Total());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Unread(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Unread"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Unread());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailItemCounts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailItemCounts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailItemCounts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailItemCounts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailItemCounts[] = {
        { "_assign_array_", _assign_array_EmailItemCounts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailItemCounts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailItemCounts[] = {
        { "flagged", reinterpret_cast<getter>(EmailItemCounts_get_Flagged), nullptr, nullptr, nullptr },
        { "important", reinterpret_cast<getter>(EmailItemCounts_get_Important), nullptr, nullptr, nullptr },
        { "total", reinterpret_cast<getter>(EmailItemCounts_get_Total), nullptr, nullptr, nullptr },
        { "unread", reinterpret_cast<getter>(EmailItemCounts_get_Unread), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailItemCounts[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailItemCounts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailItemCounts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailItemCounts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailItemCounts) },
        { },
    };

    static PyType_Spec type_spec_EmailItemCounts =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailItemCounts",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailItemCounts
    };

    // ----- EmailMailbox class --------------------

    static PyObject* _new_EmailMailbox(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailbox_ChangeMessageFlagStateAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ChangeMessageFlagStateAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(args, 1);

                return py::convert(self->obj.ChangeMessageFlagStateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_CreateResponseMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"CreateResponseMessageAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.CreateResponseMessageAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DeleteMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadAttachmentAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DownloadAttachmentAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadAttachmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DownloadMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetChangeTracker", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetSpecialFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetSpecialFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailSpecialFolderKind>(args, 0);

                return py::convert(self->obj.GetSpecialFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkFolderAsSeenAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkFolderAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderSyncEnabledAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkFolderSyncEnabledAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.MarkFolderSyncEnabledAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkMessageAsSeenAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkMessageAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkMessageReadAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.MarkMessageReadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"RegisterSyncManagerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ResolveRecipientsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ResolveRecipientsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResolveRecipientsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SaveAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveDraftAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SaveDraftAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SaveDraftAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SendMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SendMessageAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SendMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryCreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryCreateFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryCreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryDeleteFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryDeleteFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDeleteFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryEmptyFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryEmptyFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryEmptyFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryForwardMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryForwardMeetingAsync", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailRecipient>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.TryForwardMeetingAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryGetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryGetAutoReplySettingsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(args, 0);

                return py::convert(self->obj.TryGetAutoReplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveFolderAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveFolderAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.TryMoveFolderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveMessageAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.TryMoveMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryProposeNewTimeForMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryProposeNewTimeForMeetingAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryProposeNewTimeForMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TrySetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TrySetAutoReplySettingsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>(args, 0);

                return py::convert(self->obj.TrySetAutoReplySettingsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryUpdateMeetingResponseAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryUpdateMeetingResponseAsync", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingResponseType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);

                return py::convert(self->obj.TryUpdateMeetingResponseAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ValidateCertificatesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ValidateCertificatesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.ValidateCertificatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppWriteAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppWriteAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MailAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppReadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppReadAccess"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsDataEncryptedUnderLock(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"IsDataEncryptedUnderLock"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDataEncryptedUnderLock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsOwnedByCurrentApp(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"IsOwnedByCurrentApp"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOwnedByCurrentApp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_MailAddressAliases(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddressAliases"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailAddressAliases());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Capabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ChangeTracker"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Policies(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Policies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Policies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SourceDisplayName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SyncManager"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"UserDataAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_LinkedMailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"LinkedMailboxId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinkedMailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"NetworkAccountId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"NetworkId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_add_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailboxChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailbox, winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>>(arg);

            return py::convert(self->obj.MailboxChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_remove_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailboxChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MailboxChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailbox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailbox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailbox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailbox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailbox[] = {
        { "change_message_flag_state_async", reinterpret_cast<PyCFunction>(EmailMailbox_ChangeMessageFlagStateAsync), METH_VARARGS, nullptr },
        { "create_response_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_CreateResponseMessageAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(EmailMailbox_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "download_attachment_async", reinterpret_cast<PyCFunction>(EmailMailbox_DownloadAttachmentAsync), METH_VARARGS, nullptr },
        { "download_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_DownloadMessageAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(EmailMailbox_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailMailbox_GetConversationReader), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailMailbox_GetMessageReader), METH_VARARGS, nullptr },
        { "get_special_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetSpecialFolderAsync), METH_VARARGS, nullptr },
        { "mark_folder_as_seen_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkFolderAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_folder_sync_enabled_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkFolderSyncEnabledAsync), METH_VARARGS, nullptr },
        { "mark_message_as_seen_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkMessageAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_message_read_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkMessageReadAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(EmailMailbox_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "resolve_recipients_async", reinterpret_cast<PyCFunction>(EmailMailbox_ResolveRecipientsAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(EmailMailbox_SaveAsync), METH_VARARGS, nullptr },
        { "save_draft_async", reinterpret_cast<PyCFunction>(EmailMailbox_SaveDraftAsync), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_SendMessageAsync), METH_VARARGS, nullptr },
        { "try_create_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryCreateFolderAsync), METH_VARARGS, nullptr },
        { "try_delete_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryDeleteFolderAsync), METH_VARARGS, nullptr },
        { "try_empty_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryEmptyFolderAsync), METH_VARARGS, nullptr },
        { "try_forward_meeting_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryForwardMeetingAsync), METH_VARARGS, nullptr },
        { "try_get_auto_reply_settings_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryGetAutoReplySettingsAsync), METH_VARARGS, nullptr },
        { "try_move_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryMoveFolderAsync), METH_VARARGS, nullptr },
        { "try_move_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryMoveMessageAsync), METH_VARARGS, nullptr },
        { "try_propose_new_time_for_meeting_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryProposeNewTimeForMeetingAsync), METH_VARARGS, nullptr },
        { "try_set_auto_reply_settings_async", reinterpret_cast<PyCFunction>(EmailMailbox_TrySetAutoReplySettingsAsync), METH_VARARGS, nullptr },
        { "try_update_meeting_response_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryUpdateMeetingResponseAsync), METH_VARARGS, nullptr },
        { "validate_certificates_async", reinterpret_cast<PyCFunction>(EmailMailbox_ValidateCertificatesAsync), METH_VARARGS, nullptr },
        { "add_mailbox_changed", reinterpret_cast<PyCFunction>(EmailMailbox_add_MailboxChanged), METH_O, nullptr },
        { "remove_mailbox_changed", reinterpret_cast<PyCFunction>(EmailMailbox_remove_MailboxChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailMailbox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailbox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailbox[] = {
        { "other_app_write_access", reinterpret_cast<getter>(EmailMailbox_get_OtherAppWriteAccess), reinterpret_cast<setter>(EmailMailbox_put_OtherAppWriteAccess), nullptr, nullptr },
        { "mail_address", reinterpret_cast<getter>(EmailMailbox_get_MailAddress), reinterpret_cast<setter>(EmailMailbox_put_MailAddress), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(EmailMailbox_get_OtherAppReadAccess), reinterpret_cast<setter>(EmailMailbox_put_OtherAppReadAccess), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(EmailMailbox_get_DisplayName), reinterpret_cast<setter>(EmailMailbox_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailMailbox_get_Id), nullptr, nullptr, nullptr },
        { "is_data_encrypted_under_lock", reinterpret_cast<getter>(EmailMailbox_get_IsDataEncryptedUnderLock), nullptr, nullptr, nullptr },
        { "is_owned_by_current_app", reinterpret_cast<getter>(EmailMailbox_get_IsOwnedByCurrentApp), nullptr, nullptr, nullptr },
        { "mail_address_aliases", reinterpret_cast<getter>(EmailMailbox_get_MailAddressAliases), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(EmailMailbox_get_Capabilities), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(EmailMailbox_get_ChangeTracker), nullptr, nullptr, nullptr },
        { "policies", reinterpret_cast<getter>(EmailMailbox_get_Policies), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(EmailMailbox_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(EmailMailbox_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(EmailMailbox_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { "linked_mailbox_id", reinterpret_cast<getter>(EmailMailbox_get_LinkedMailboxId), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(EmailMailbox_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "network_id", reinterpret_cast<getter>(EmailMailbox_get_NetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailbox[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailbox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailbox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailbox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailbox) },
        { },
    };

    static PyType_Spec type_spec_EmailMailbox =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailbox",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailbox
    };

    // ----- EmailMailboxAction class --------------------

    static PyObject* _new_EmailMailboxAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAction(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAction_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAction", L"ChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAction_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAction", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAction[] = {
        { "_assign_array_", _assign_array_EmailMailboxAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxAction[] = {
        { "change_number", reinterpret_cast<getter>(EmailMailboxAction_get_ChangeNumber), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailMailboxAction_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxAction[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAction) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxAction =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAction
    };

    // ----- EmailMailboxAutoReply class --------------------

    static PyObject* _new_EmailMailboxAutoReply(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAutoReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAutoReply_get_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"Response"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"Response"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReply_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxAutoReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAutoReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReply[] = {
        { "_assign_array_", _assign_array_EmailMailboxAutoReply, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAutoReply), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxAutoReply[] = {
        { "response", reinterpret_cast<getter>(EmailMailboxAutoReply_get_Response), reinterpret_cast<setter>(EmailMailboxAutoReply_put_Response), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(EmailMailboxAutoReply_get_IsEnabled), reinterpret_cast<setter>(EmailMailboxAutoReply_put_IsEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxAutoReply[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAutoReply) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAutoReply) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAutoReply) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAutoReply) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxAutoReply =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAutoReply",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReply
    };

    // ----- EmailMailboxAutoReplySettings class --------------------

    static PyObject* _new_EmailMailboxAutoReplySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMailboxAutoReplySettings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAutoReplySettings_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"ResponseKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"ResponseKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(arg);

            self->obj.ResponseKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"EndTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"EndTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_InternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"InternalReply"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_KnownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"KnownExternalReply"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.KnownExternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_UnknownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"UnknownExternalReply"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UnknownExternalReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxAutoReplySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAutoReplySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReplySettings[] = {
        { "_assign_array_", _assign_array_EmailMailboxAutoReplySettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAutoReplySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxAutoReplySettings[] = {
        { "start_time", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_StartTime), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_StartTime), nullptr, nullptr },
        { "response_kind", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_ResponseKind), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_ResponseKind), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_IsEnabled), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_IsEnabled), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_EndTime), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_EndTime), nullptr, nullptr },
        { "internal_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_InternalReply), nullptr, nullptr, nullptr },
        { "known_external_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_KnownExternalReply), nullptr, nullptr, nullptr },
        { "unknown_external_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_UnknownExternalReply), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxAutoReplySettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAutoReplySettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAutoReplySettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAutoReplySettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAutoReplySettings) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxAutoReplySettings =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAutoReplySettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReplySettings
    };

    // ----- EmailMailboxCapabilities class --------------------

    static PyObject* _new_EmailMailboxCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCapabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCapabilities_get_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanSmartSend"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSmartSend());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanSmartSend"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSmartSend(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanUpdateMeetingResponses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanUpdateMeetingResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanUpdateMeetingResponses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanUpdateMeetingResponses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchMailbox"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanServerSearchMailbox());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchMailbox"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanServerSearchMailbox(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchFolders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanServerSearchFolders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchFolders"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanServerSearchFolders(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanForwardMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanForwardMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanForwardMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForwardMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanProposeNewTimeForMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanProposeNewTimeForMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanProposeNewTimeForMeetings"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanProposeNewTimeForMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetInternalAutoReplies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanGetAndSetInternalAutoReplies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetInternalAutoReplies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanGetAndSetInternalAutoReplies(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetExternalAutoReplies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanGetAndSetExternalAutoReplies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetExternalAutoReplies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanGetAndSetExternalAutoReplies(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanValidateCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanValidateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanValidateCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanValidateCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanResolveRecipients"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanResolveRecipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanResolveRecipients"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanResolveRecipients(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanMoveFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMoveFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanMoveFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanMoveFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanEmptyFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanEmptyFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanEmptyFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanEmptyFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanDeleteFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDeleteFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanDeleteFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanDeleteFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanCreateFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCreateFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanCreateFolder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCreateFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCapabilities[] = {
        { "_assign_array_", _assign_array_EmailMailboxCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCapabilities[] = {
        { "can_smart_send", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanSmartSend), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanSmartSend), nullptr, nullptr },
        { "can_update_meeting_responses", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanUpdateMeetingResponses), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanUpdateMeetingResponses), nullptr, nullptr },
        { "can_server_search_mailbox", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanServerSearchMailbox), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanServerSearchMailbox), nullptr, nullptr },
        { "can_server_search_folders", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanServerSearchFolders), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanServerSearchFolders), nullptr, nullptr },
        { "can_forward_meetings", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanForwardMeetings), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanForwardMeetings), nullptr, nullptr },
        { "can_propose_new_time_for_meetings", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings), nullptr, nullptr },
        { "can_get_and_set_internal_auto_replies", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies), nullptr, nullptr },
        { "can_get_and_set_external_auto_replies", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies), nullptr, nullptr },
        { "can_validate_certificates", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanValidateCertificates), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanValidateCertificates), nullptr, nullptr },
        { "can_resolve_recipients", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanResolveRecipients), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanResolveRecipients), nullptr, nullptr },
        { "can_move_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanMoveFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanMoveFolder), nullptr, nullptr },
        { "can_empty_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanEmptyFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanEmptyFolder), nullptr, nullptr },
        { "can_delete_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanDeleteFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanDeleteFolder), nullptr, nullptr },
        { "can_create_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanCreateFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanCreateFolder), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCapabilities[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCapabilities) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxCapabilities =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCapabilities
    };

    // ----- EmailMailboxChange class --------------------

    static PyObject* _new_EmailMailboxChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChange(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"ChangeType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"Folder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_MailboxActions(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"MailboxActions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailboxActions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Message(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"Message"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChange[] = {
        { "_assign_array_", _assign_array_EmailMailboxChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxChange[] = {
        { "change_type", reinterpret_cast<getter>(EmailMailboxChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(EmailMailboxChange_get_Folder), nullptr, nullptr, nullptr },
        { "mailbox_actions", reinterpret_cast<getter>(EmailMailboxChange_get_MailboxActions), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(EmailMailboxChange_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxChange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChange) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxChange =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChange
    };

    // ----- EmailMailboxChangeReader class --------------------

    static PyObject* _new_EmailMailboxChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"AcceptChanges", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"AcceptChangesThrough", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"ReadBatchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxChangeReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangeReader) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxChangeReader =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeReader
    };

    // ----- EmailMailboxChangeTracker class --------------------

    static PyObject* _new_EmailMailboxChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"Enable", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"GetChangeReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"Reset", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"IsTracking"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(EmailMailboxChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxChangeTracker[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangeTracker) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxChangeTracker =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeTracker
    };

    // ----- EmailMailboxChangedDeferral class --------------------

    static PyObject* _new_EmailMailboxChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangedDeferral", L"Complete", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(EmailMailboxChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxChangedDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangedDeferral) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxChangedDeferral =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedDeferral
    };

    // ----- EmailMailboxChangedEventArgs class --------------------

    static PyObject* _new_EmailMailboxChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedEventArgs(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs", L"GetDeferral", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedEventArgs
    };

    // ----- EmailMailboxCreateFolderResult class --------------------

    static PyObject* _new_EmailMailboxCreateFolderResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderResult(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult", L"Folder"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderResult[] = {
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxCreateFolderResult[] = {
        { "folder", reinterpret_cast<getter>(EmailMailboxCreateFolderResult_get_Folder), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailMailboxCreateFolderResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxCreateFolderResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderResult) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxCreateFolderResult =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxCreateFolderResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderResult
    };

    // ----- EmailMailboxPolicies class --------------------

    static PyObject* _new_EmailMailboxPolicies(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxPolicies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeSigningAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredSmimeSigningAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeSigningAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeSigningAlgorithm>>(arg);

            self->obj.RequiredSmimeSigningAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeEncryptionAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredSmimeEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeEncryptionAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeEncryptionAlgorithm>>(arg);

            self->obj.RequiredSmimeEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowedSmimeEncryptionAlgorithmNegotiation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowedSmimeEncryptionAlgorithmNegotiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowedSmimeEncryptionAlgorithmNegotiation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation>(arg);

            self->obj.AllowedSmimeEncryptionAlgorithmNegotiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowSmimeSoftCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowSmimeSoftCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowSmimeSoftCertificates"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowSmimeSoftCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustSignSmimeMessages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MustSignSmimeMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustSignSmimeMessages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustSignSmimeMessages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustEncryptSmimeMessages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MustEncryptSmimeMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustEncryptSmimeMessages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustEncryptSmimeMessages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxPolicies(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxPolicies(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxPolicies[] = {
        { "_assign_array_", _assign_array_EmailMailboxPolicies, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxPolicies), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxPolicies[] = {
        { "required_smime_signing_algorithm", reinterpret_cast<getter>(EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm), reinterpret_cast<setter>(EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm), nullptr, nullptr },
        { "required_smime_encryption_algorithm", reinterpret_cast<getter>(EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm), reinterpret_cast<setter>(EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm), nullptr, nullptr },
        { "allowed_smime_encryption_algorithm_negotiation", reinterpret_cast<getter>(EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation), reinterpret_cast<setter>(EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation), nullptr, nullptr },
        { "allow_smime_soft_certificates", reinterpret_cast<getter>(EmailMailboxPolicies_get_AllowSmimeSoftCertificates), reinterpret_cast<setter>(EmailMailboxPolicies_put_AllowSmimeSoftCertificates), nullptr, nullptr },
        { "must_sign_smime_messages", reinterpret_cast<getter>(EmailMailboxPolicies_get_MustSignSmimeMessages), reinterpret_cast<setter>(EmailMailboxPolicies_put_MustSignSmimeMessages), nullptr, nullptr },
        { "must_encrypt_smime_messages", reinterpret_cast<getter>(EmailMailboxPolicies_get_MustEncryptSmimeMessages), reinterpret_cast<setter>(EmailMailboxPolicies_put_MustEncryptSmimeMessages), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxPolicies[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxPolicies) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxPolicies) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxPolicies) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxPolicies) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxPolicies =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxPolicies",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxPolicies
    };

    // ----- EmailMailboxSyncManager class --------------------

    static PyObject* _new_EmailMailboxSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastSuccessfulSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastAttemptedSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastAttemptedSyncTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMailboxSyncManager[] = {
        { "status", reinterpret_cast<getter>(EmailMailboxSyncManager_get_Status), reinterpret_cast<setter>(EmailMailboxSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(EmailMailboxSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(EmailMailboxSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(EmailMailboxSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(EmailMailboxSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMailboxSyncManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManager) },
        { },
    };

    static PyType_Spec type_spec_EmailMailboxSyncManager =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManager
    };

    // ----- EmailManager class --------------------

    static PyObject* _new_EmailManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManager>::type_name);
        return nullptr;
    }

    static PyObject* EmailManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"GetForUser", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"RequestStoreAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_ShowComposeNewEmailAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"ShowComposeNewEmailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Email::EmailManager::ShowComposeNewEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManager[] = {
        { }
    };

    static PyGetSetDef _getset_EmailManager[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailManager) },
        { },
    };

    static PyType_Spec type_spec_EmailManager =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManager
    };

    static PyGetSetDef getset_EmailManager_Static[] = {
        { }
    };

    static PyMethodDef methods_EmailManager_Static[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(EmailManager_GetForUser), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(EmailManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_compose_new_email_async", reinterpret_cast<PyCFunction>(EmailManager_ShowComposeNewEmailAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_EmailManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EmailManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EmailManager_Static) },
        { }
    };

    static PyType_Spec type_spec_EmailManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EmailManager_Static
    };

    // ----- EmailManagerForUser class --------------------

    static PyObject* _new_EmailManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailManagerForUser(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"RequestStoreAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_ShowComposeNewEmailAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"ShowComposeNewEmailAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert(self->obj.ShowComposeNewEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"User"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(EmailManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_compose_new_email_async", reinterpret_cast<PyCFunction>(EmailManagerForUser_ShowComposeNewEmailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailManagerForUser[] = {
        { "user", reinterpret_cast<getter>(EmailManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_EmailManagerForUser =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManagerForUser
    };

    // ----- EmailMeetingInfo class --------------------

    static PyObject* _new_EmailMeetingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMeetingInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMeetingInfo_get_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Location"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsResponseRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsResponseRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResponseRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsAllDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsAllDay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAllDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AllowNewTimeProposal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AllowNewTimeProposal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowNewTimeProposal(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Duration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentRoamingId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppointmentRoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentRoamingId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AppointmentRoamingId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentOriginalStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppointmentOriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentOriginalStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.AppointmentOriginalStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProposedDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.ProposedDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RemoteChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RemoteChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.RemoteChangeNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"StartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RecurrenceStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RecurrenceStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RecurrenceStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.RecurrenceStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Recurrence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Recurrence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>(arg);

            self->obj.Recurrence(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProposedStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedStartTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ProposedStartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsReportedOutOfDateByServer(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsReportedOutOfDateByServer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReportedOutOfDateByServer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMeetingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMeetingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMeetingInfo[] = {
        { "_assign_array_", _assign_array_EmailMeetingInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMeetingInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMeetingInfo[] = {
        { "location", reinterpret_cast<getter>(EmailMeetingInfo_get_Location), reinterpret_cast<setter>(EmailMeetingInfo_put_Location), nullptr, nullptr },
        { "is_response_requested", reinterpret_cast<getter>(EmailMeetingInfo_get_IsResponseRequested), reinterpret_cast<setter>(EmailMeetingInfo_put_IsResponseRequested), nullptr, nullptr },
        { "is_all_day", reinterpret_cast<getter>(EmailMeetingInfo_get_IsAllDay), reinterpret_cast<setter>(EmailMeetingInfo_put_IsAllDay), nullptr, nullptr },
        { "allow_new_time_proposal", reinterpret_cast<getter>(EmailMeetingInfo_get_AllowNewTimeProposal), reinterpret_cast<setter>(EmailMeetingInfo_put_AllowNewTimeProposal), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(EmailMeetingInfo_get_Duration), reinterpret_cast<setter>(EmailMeetingInfo_put_Duration), nullptr, nullptr },
        { "appointment_roaming_id", reinterpret_cast<getter>(EmailMeetingInfo_get_AppointmentRoamingId), reinterpret_cast<setter>(EmailMeetingInfo_put_AppointmentRoamingId), nullptr, nullptr },
        { "appointment_original_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_AppointmentOriginalStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_AppointmentOriginalStartTime), nullptr, nullptr },
        { "proposed_duration", reinterpret_cast<getter>(EmailMeetingInfo_get_ProposedDuration), reinterpret_cast<setter>(EmailMeetingInfo_put_ProposedDuration), nullptr, nullptr },
        { "remote_change_number", reinterpret_cast<getter>(EmailMeetingInfo_get_RemoteChangeNumber), reinterpret_cast<setter>(EmailMeetingInfo_put_RemoteChangeNumber), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_StartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_StartTime), nullptr, nullptr },
        { "recurrence_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_RecurrenceStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_RecurrenceStartTime), nullptr, nullptr },
        { "recurrence", reinterpret_cast<getter>(EmailMeetingInfo_get_Recurrence), reinterpret_cast<setter>(EmailMeetingInfo_put_Recurrence), nullptr, nullptr },
        { "proposed_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_ProposedStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_ProposedStartTime), nullptr, nullptr },
        { "is_reported_out_of_date_by_server", reinterpret_cast<getter>(EmailMeetingInfo_get_IsReportedOutOfDateByServer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMeetingInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMeetingInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMeetingInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMeetingInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMeetingInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailMeetingInfo =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMeetingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMeetingInfo
    };

    // ----- EmailMessage class --------------------

    static PyObject* _new_EmailMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessage_GetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"GetBodyStream", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);

                return py::convert(self->obj.GetBodyStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_SetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SetBodyStream", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                self->obj.SetBodyStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Subject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Body"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Bcc(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Bcc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bcc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_CC(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"CC"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CC());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Attachments"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Attachments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_To(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"To"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"AllowInternetImages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowInternetImages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"AllowInternetImages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowInternetImages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FlagState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FlagState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FlagState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(arg);

            self->obj.FlagState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"EstimatedDownloadSizeInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EstimatedDownloadSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"EstimatedDownloadSizeInBytes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.EstimatedDownloadSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"DownloadState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DownloadState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"DownloadState"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageDownloadState>(arg);

            self->obj.DownloadState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Importance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Importance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Importance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailImportance>(arg);

            self->obj.Importance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IrmInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IrmInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IrmInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>(arg);

            self->obj.IrmInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"OriginalCodePage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OriginalCodePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"OriginalCodePage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.OriginalCodePage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SentTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.SentTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Sender"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Sender"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            self->obj.Sender(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"RemoteId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Preview"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Preview"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Preview(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MessageClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MessageClass(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MeetingInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MeetingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MeetingInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>(arg);

            self->obj.MeetingInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"LastResponseKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LastResponseKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"LastResponseKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(arg);

            self->obj.LastResponseKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSeen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSeen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsRead"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsRead"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsServerSearchMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsServerSearchMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsServerSearchMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsSmartSendable(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSmartSendable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSmartSendable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MailboxId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MailboxId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ChangeNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ConversationId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ConversationId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConversationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_NormalizedSubject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"NormalizedSubject"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NormalizedSubject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_FolderId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FolderId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_HasPartialBodies(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"HasPartialBodies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasPartialBodies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_InResponseToMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"InResponseToMessageId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InResponseToMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsDraftMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsDraftMessage"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDraftMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmimeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageSmimeKind>(arg);

            self->obj.SmimeKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmimeData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.SmimeData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentRepresenting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SentRepresenting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentRepresenting"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            self->obj.SentRepresenting(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_ReplyTo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ReplyTo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReplyTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessage[] = {
        { "get_body_stream", reinterpret_cast<PyCFunction>(EmailMessage_GetBodyStream), METH_VARARGS, nullptr },
        { "set_body_stream", reinterpret_cast<PyCFunction>(EmailMessage_SetBodyStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMessage[] = {
        { "subject", reinterpret_cast<getter>(EmailMessage_get_Subject), reinterpret_cast<setter>(EmailMessage_put_Subject), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(EmailMessage_get_Body), reinterpret_cast<setter>(EmailMessage_put_Body), nullptr, nullptr },
        { "bcc", reinterpret_cast<getter>(EmailMessage_get_Bcc), nullptr, nullptr, nullptr },
        { "c_c", reinterpret_cast<getter>(EmailMessage_get_CC), nullptr, nullptr, nullptr },
        { "attachments", reinterpret_cast<getter>(EmailMessage_get_Attachments), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(EmailMessage_get_To), nullptr, nullptr, nullptr },
        { "allow_internet_images", reinterpret_cast<getter>(EmailMessage_get_AllowInternetImages), reinterpret_cast<setter>(EmailMessage_put_AllowInternetImages), nullptr, nullptr },
        { "flag_state", reinterpret_cast<getter>(EmailMessage_get_FlagState), reinterpret_cast<setter>(EmailMessage_put_FlagState), nullptr, nullptr },
        { "estimated_download_size_in_bytes", reinterpret_cast<getter>(EmailMessage_get_EstimatedDownloadSizeInBytes), reinterpret_cast<setter>(EmailMessage_put_EstimatedDownloadSizeInBytes), nullptr, nullptr },
        { "download_state", reinterpret_cast<getter>(EmailMessage_get_DownloadState), reinterpret_cast<setter>(EmailMessage_put_DownloadState), nullptr, nullptr },
        { "importance", reinterpret_cast<getter>(EmailMessage_get_Importance), reinterpret_cast<setter>(EmailMessage_put_Importance), nullptr, nullptr },
        { "irm_info", reinterpret_cast<getter>(EmailMessage_get_IrmInfo), reinterpret_cast<setter>(EmailMessage_put_IrmInfo), nullptr, nullptr },
        { "original_code_page", reinterpret_cast<getter>(EmailMessage_get_OriginalCodePage), reinterpret_cast<setter>(EmailMessage_put_OriginalCodePage), nullptr, nullptr },
        { "sent_time", reinterpret_cast<getter>(EmailMessage_get_SentTime), reinterpret_cast<setter>(EmailMessage_put_SentTime), nullptr, nullptr },
        { "sender", reinterpret_cast<getter>(EmailMessage_get_Sender), reinterpret_cast<setter>(EmailMessage_put_Sender), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(EmailMessage_get_RemoteId), reinterpret_cast<setter>(EmailMessage_put_RemoteId), nullptr, nullptr },
        { "preview", reinterpret_cast<getter>(EmailMessage_get_Preview), reinterpret_cast<setter>(EmailMessage_put_Preview), nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(EmailMessage_get_MessageClass), reinterpret_cast<setter>(EmailMessage_put_MessageClass), nullptr, nullptr },
        { "meeting_info", reinterpret_cast<getter>(EmailMessage_get_MeetingInfo), reinterpret_cast<setter>(EmailMessage_put_MeetingInfo), nullptr, nullptr },
        { "last_response_kind", reinterpret_cast<getter>(EmailMessage_get_LastResponseKind), reinterpret_cast<setter>(EmailMessage_put_LastResponseKind), nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(EmailMessage_get_IsSeen), reinterpret_cast<setter>(EmailMessage_put_IsSeen), nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(EmailMessage_get_IsRead), reinterpret_cast<setter>(EmailMessage_put_IsRead), nullptr, nullptr },
        { "is_server_search_message", reinterpret_cast<getter>(EmailMessage_get_IsServerSearchMessage), nullptr, nullptr, nullptr },
        { "is_smart_sendable", reinterpret_cast<getter>(EmailMessage_get_IsSmartSendable), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailMessage_get_MailboxId), nullptr, nullptr, nullptr },
        { "change_number", reinterpret_cast<getter>(EmailMessage_get_ChangeNumber), nullptr, nullptr, nullptr },
        { "conversation_id", reinterpret_cast<getter>(EmailMessage_get_ConversationId), nullptr, nullptr, nullptr },
        { "normalized_subject", reinterpret_cast<getter>(EmailMessage_get_NormalizedSubject), nullptr, nullptr, nullptr },
        { "folder_id", reinterpret_cast<getter>(EmailMessage_get_FolderId), nullptr, nullptr, nullptr },
        { "has_partial_bodies", reinterpret_cast<getter>(EmailMessage_get_HasPartialBodies), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailMessage_get_Id), nullptr, nullptr, nullptr },
        { "in_response_to_message_id", reinterpret_cast<getter>(EmailMessage_get_InResponseToMessageId), nullptr, nullptr, nullptr },
        { "is_draft_message", reinterpret_cast<getter>(EmailMessage_get_IsDraftMessage), nullptr, nullptr, nullptr },
        { "smime_kind", reinterpret_cast<getter>(EmailMessage_get_SmimeKind), reinterpret_cast<setter>(EmailMessage_put_SmimeKind), nullptr, nullptr },
        { "smime_data", reinterpret_cast<getter>(EmailMessage_get_SmimeData), reinterpret_cast<setter>(EmailMessage_put_SmimeData), nullptr, nullptr },
        { "sent_representing", reinterpret_cast<getter>(EmailMessage_get_SentRepresenting), reinterpret_cast<setter>(EmailMessage_put_SentRepresenting), nullptr, nullptr },
        { "reply_to", reinterpret_cast<getter>(EmailMessage_get_ReplyTo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMessage[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessage) },
        { },
    };

    static PyType_Spec type_spec_EmailMessage =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessage
    };

    // ----- EmailMessageBatch class --------------------

    static PyObject* _new_EmailMessageBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMessageBatch(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessageBatch_get_Messages(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessageBatch", L"Messages"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Messages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessageBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessageBatch", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessageBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessageBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageBatch[] = {
        { "_assign_array_", _assign_array_EmailMessageBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessageBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMessageBatch[] = {
        { "messages", reinterpret_cast<getter>(EmailMessageBatch_get_Messages), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailMessageBatch_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailMessageBatch[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessageBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessageBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessageBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessageBatch) },
        { },
    };

    static PyType_Spec type_spec_EmailMessageBatch =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMessageBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageBatch
    };

    // ----- EmailMessageReader class --------------------

    static PyObject* _new_EmailMessageReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessageReader", L"ReadBatchAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessageReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailMessageReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMessageReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessageReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailMessageReader[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailMessageReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessageReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessageReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessageReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessageReader) },
        { },
    };

    static PyType_Spec type_spec_EmailMessageReader =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageReader
    };

    // ----- EmailQueryOptions class --------------------

    static PyObject* _new_EmailQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailQueryOptions(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailQueryOptions_get_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SortProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortProperty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortProperty>(arg);

            self->obj.SortProperty(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SortDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortDirection"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortDirection>(arg);

            self->obj.SortDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"Kind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_FolderIds(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"FolderIds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FolderIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"TextSearch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryOptions[] = {
        { "_assign_array_", _assign_array_EmailQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailQueryOptions[] = {
        { "sort_property", reinterpret_cast<getter>(EmailQueryOptions_get_SortProperty), reinterpret_cast<setter>(EmailQueryOptions_put_SortProperty), nullptr, nullptr },
        { "sort_direction", reinterpret_cast<getter>(EmailQueryOptions_get_SortDirection), reinterpret_cast<setter>(EmailQueryOptions_put_SortDirection), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailQueryOptions_get_Kind), reinterpret_cast<setter>(EmailQueryOptions_put_Kind), nullptr, nullptr },
        { "folder_ids", reinterpret_cast<getter>(EmailQueryOptions_get_FolderIds), nullptr, nullptr, nullptr },
        { "text_search", reinterpret_cast<getter>(EmailQueryOptions_get_TextSearch), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailQueryOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailQueryOptions) },
        { },
    };

    static PyType_Spec type_spec_EmailQueryOptions =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryOptions
    };

    // ----- EmailQueryTextSearch class --------------------

    static PyObject* _new_EmailQueryTextSearch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailQueryTextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"SearchScope"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SearchScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"SearchScope"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchScope>(arg);

            self->obj.SearchScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Fields"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Fields"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(arg);

            self->obj.Fields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryTextSearch[] = {
        { "_assign_array_", _assign_array_EmailQueryTextSearch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailQueryTextSearch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailQueryTextSearch[] = {
        { "text", reinterpret_cast<getter>(EmailQueryTextSearch_get_Text), reinterpret_cast<setter>(EmailQueryTextSearch_put_Text), nullptr, nullptr },
        { "search_scope", reinterpret_cast<getter>(EmailQueryTextSearch_get_SearchScope), reinterpret_cast<setter>(EmailQueryTextSearch_put_SearchScope), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(EmailQueryTextSearch_get_Fields), reinterpret_cast<setter>(EmailQueryTextSearch_put_Fields), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailQueryTextSearch[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailQueryTextSearch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailQueryTextSearch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailQueryTextSearch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailQueryTextSearch) },
        { },
    };

    static PyType_Spec type_spec_EmailQueryTextSearch =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryTextSearch
    };

    // ----- EmailRecipient class --------------------

    static PyObject* _new_EmailRecipient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipient(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailRecipient_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipient_get_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailRecipient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailRecipient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailRecipient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipient[] = {
        { "_assign_array_", _assign_array_EmailRecipient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailRecipient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailRecipient[] = {
        { "name", reinterpret_cast<getter>(EmailRecipient_get_Name), reinterpret_cast<setter>(EmailRecipient_put_Name), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(EmailRecipient_get_Address), reinterpret_cast<setter>(EmailRecipient_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailRecipient[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailRecipient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailRecipient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailRecipient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailRecipient) },
        { },
    };

    static PyType_Spec type_spec_EmailRecipient =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailRecipient",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipient
    };

    // ----- EmailRecipientResolutionResult class --------------------

    static PyObject* _new_EmailRecipientResolutionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipientResolutionResult(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailRecipientResolutionResult_SetPublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"SetPublicKeys", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                self->obj.SetPublicKeys(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipientResolutionResult_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_PublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"PublicKeys"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PublicKeys());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailRecipientResolutionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailRecipientResolutionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipientResolutionResult[] = {
        { "set_public_keys", reinterpret_cast<PyCFunction>(EmailRecipientResolutionResult_SetPublicKeys), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailRecipientResolutionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailRecipientResolutionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailRecipientResolutionResult[] = {
        { "status", reinterpret_cast<getter>(EmailRecipientResolutionResult_get_Status), reinterpret_cast<setter>(EmailRecipientResolutionResult_put_Status), nullptr, nullptr },
        { "public_keys", reinterpret_cast<getter>(EmailRecipientResolutionResult_get_PublicKeys), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailRecipientResolutionResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailRecipientResolutionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailRecipientResolutionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailRecipientResolutionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailRecipientResolutionResult) },
        { },
    };

    static PyType_Spec type_spec_EmailRecipientResolutionResult =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailRecipientResolutionResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipientResolutionResult
    };

    // ----- EmailStore class --------------------

    static PyObject* _new_EmailStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStore>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailStore(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailStore_CreateMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"CreateMailboxAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateMailboxAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"CreateMailboxAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateMailboxAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_FindMailboxesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"FindMailboxesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.FindMailboxesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetFolderAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMailboxAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMailboxAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageReader", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageReader", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStore[] = {
        { "create_mailbox_async", reinterpret_cast<PyCFunction>(EmailStore_CreateMailboxAsync), METH_VARARGS, nullptr },
        { "find_mailboxes_async", reinterpret_cast<PyCFunction>(EmailStore_FindMailboxesAsync), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(EmailStore_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailStore_GetConversationReader), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(EmailStore_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_mailbox_async", reinterpret_cast<PyCFunction>(EmailStore_GetMailboxAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailStore_GetMessageReader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailStore[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailStore[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStore) },
        { },
    };

    static PyType_Spec type_spec_EmailStore =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStore
    };

    // ----- EmailStoreNotificationTriggerDetails class --------------------

    static PyObject* _new_EmailStoreNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EmailStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailStoreNotificationTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_EmailStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStoreNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStoreNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStoreNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStoreNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailStoreNotificationTriggerDetails =
    {
        "winrt._winrt_windows_applicationmodel_email.EmailStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTriggerDetails
    };

    // ----- Windows.ApplicationModel.Email Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Email");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_email",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Email

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_email(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Email;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailAttachment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailConversation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailConversationBatch, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailConversationReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailFolder, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailIrmInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailIrmTemplate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailItemCounts, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailbox, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxAction, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxAutoReply, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxAutoReplySettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxChange, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxChangeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxChangeTracker, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxChangedDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxCreateFolderResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxPolicies, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMailboxSyncManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_EmailManager_Static{PyType_FromSpec(&type_spec_EmailManager_Static)};
    if (!type_EmailManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EmailManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailManagerForUser, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMeetingInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMessage, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMessageBatch, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailMessageReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailQueryOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailQueryTextSearch, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailRecipient, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailRecipientResolutionResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailStore, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailStoreNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
