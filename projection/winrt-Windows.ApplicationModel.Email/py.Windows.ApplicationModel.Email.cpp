// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.ApplicationModel.Email.h"

namespace py::cpp::Windows::ApplicationModel::Email
{
    // ----- EmailAttachment class --------------------

    static PyObject* _new_EmailAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailAttachment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailAttachment_get_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"FileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FileName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_FileName(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"FileName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.FileName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_Data(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"MimeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MimeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"MimeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.MimeType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsInline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsInline();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_IsInline(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsInline");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsInline(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"EstimatedDownloadSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EstimatedDownloadSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"EstimatedDownloadSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.EstimatedDownloadSizeInBytes(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"DownloadState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DownloadState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"DownloadState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailAttachmentDownloadState>(arg);

            {
                auto _gil = release_gil();
                self->obj.DownloadState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentLocation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentLocation(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentLocation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailAttachment_put_ContentId(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"ContentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.ContentId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailAttachment_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailAttachment_get_IsFromBaseMessage(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailAttachment", L"IsFromBaseMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsFromBaseMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailAttachment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailAttachment[] = {
        { "_assign_array_", _assign_array_EmailAttachment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailAttachment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailAttachment[] = {
        { "file_name", reinterpret_cast<getter>(EmailAttachment_get_FileName), reinterpret_cast<setter>(EmailAttachment_put_FileName), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(EmailAttachment_get_Data), reinterpret_cast<setter>(EmailAttachment_put_Data), nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(EmailAttachment_get_MimeType), reinterpret_cast<setter>(EmailAttachment_put_MimeType), nullptr, nullptr },
        { "is_inline", reinterpret_cast<getter>(EmailAttachment_get_IsInline), reinterpret_cast<setter>(EmailAttachment_put_IsInline), nullptr, nullptr },
        { "estimated_download_size_in_bytes", reinterpret_cast<getter>(EmailAttachment_get_EstimatedDownloadSizeInBytes), reinterpret_cast<setter>(EmailAttachment_put_EstimatedDownloadSizeInBytes), nullptr, nullptr },
        { "download_state", reinterpret_cast<getter>(EmailAttachment_get_DownloadState), reinterpret_cast<setter>(EmailAttachment_put_DownloadState), nullptr, nullptr },
        { "content_location", reinterpret_cast<getter>(EmailAttachment_get_ContentLocation), reinterpret_cast<setter>(EmailAttachment_put_ContentLocation), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(EmailAttachment_get_ContentId), reinterpret_cast<setter>(EmailAttachment_put_ContentId), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailAttachment_get_Id), nullptr, nullptr, nullptr },
        { "is_from_base_message", reinterpret_cast<getter>(EmailAttachment_get_IsFromBaseMessage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailAttachment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailAttachment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailAttachment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailAttachment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailAttachment) },
        { }};

    static PyType_Spec type_spec_EmailAttachment = {
        "winrt._winrt_windows_applicationmodel_email.EmailAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailAttachment};

    // ----- EmailConversation class --------------------

    static PyObject* _new_EmailConversation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversation>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversation(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversation_FindMessagesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FindMessagesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindMessagesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailConversation_FindMessagesWithCountAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FindMessagesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindMessagesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"FlagState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FlagState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_HasAttachment(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"HasAttachment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasAttachment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Importance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Importance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LastEmailResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"LastEmailResponseKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastEmailResponseKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_LatestSender(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"LatestSender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LatestSender();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailboxId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MessageCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MostRecentMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MostRecentMessageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_MostRecentMessageTime(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"MostRecentMessageTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MostRecentMessageTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Preview");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Preview();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Subject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversation_get_UnreadMessageCount(py::wrapper::Windows::ApplicationModel::Email::EmailConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversation", L"UnreadMessageCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnreadMessageCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversation[] = {
        { "find_messages_async", reinterpret_cast<PyCFunction>(EmailConversation_FindMessagesAsync), METH_VARARGS, nullptr },
        { "find_messages_with_count_async", reinterpret_cast<PyCFunction>(EmailConversation_FindMessagesWithCountAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailConversation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailConversation[] = {
        { "flag_state", reinterpret_cast<getter>(EmailConversation_get_FlagState), nullptr, nullptr, nullptr },
        { "has_attachment", reinterpret_cast<getter>(EmailConversation_get_HasAttachment), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailConversation_get_Id), nullptr, nullptr, nullptr },
        { "importance", reinterpret_cast<getter>(EmailConversation_get_Importance), nullptr, nullptr, nullptr },
        { "last_email_response_kind", reinterpret_cast<getter>(EmailConversation_get_LastEmailResponseKind), nullptr, nullptr, nullptr },
        { "latest_sender", reinterpret_cast<getter>(EmailConversation_get_LatestSender), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailConversation_get_MailboxId), nullptr, nullptr, nullptr },
        { "message_count", reinterpret_cast<getter>(EmailConversation_get_MessageCount), nullptr, nullptr, nullptr },
        { "most_recent_message_id", reinterpret_cast<getter>(EmailConversation_get_MostRecentMessageId), nullptr, nullptr, nullptr },
        { "most_recent_message_time", reinterpret_cast<getter>(EmailConversation_get_MostRecentMessageTime), nullptr, nullptr, nullptr },
        { "preview", reinterpret_cast<getter>(EmailConversation_get_Preview), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(EmailConversation_get_Subject), nullptr, nullptr, nullptr },
        { "unread_message_count", reinterpret_cast<getter>(EmailConversation_get_UnreadMessageCount), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailConversation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversation) },
        { }};

    static PyType_Spec type_spec_EmailConversation = {
        "winrt._winrt_windows_applicationmodel_email.EmailConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversation};

    // ----- EmailConversationBatch class --------------------

    static PyObject* _new_EmailConversationBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversationBatch(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversationBatch_get_Conversations(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversationBatch", L"Conversations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Conversations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailConversationBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailConversationBatch", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversationBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversationBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationBatch[] = {
        { "_assign_array_", _assign_array_EmailConversationBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversationBatch), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailConversationBatch[] = {
        { "conversations", reinterpret_cast<getter>(EmailConversationBatch_get_Conversations), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailConversationBatch_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailConversationBatch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversationBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversationBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversationBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversationBatch) },
        { }};

    static PyType_Spec type_spec_EmailConversationBatch = {
        "winrt._winrt_windows_applicationmodel_email.EmailConversationBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationBatch};

    // ----- EmailConversationReader class --------------------

    static PyObject* _new_EmailConversationReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailConversationReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailConversationReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailConversationReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailConversationReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailConversationReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailConversationReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailConversationReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailConversationReader[] = {
        { }};

    static PyType_Slot _type_slots_EmailConversationReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailConversationReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailConversationReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailConversationReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailConversationReader) },
        { }};

    static PyType_Spec type_spec_EmailConversationReader = {
        "winrt._winrt_windows_applicationmodel_email.EmailConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailConversationReader};

    // ----- EmailFolder class --------------------

    static PyObject* _new_EmailFolder(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailFolder>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailFolder(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailFolder_CreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"CreateFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_FindChildFoldersAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"FindChildFoldersAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindChildFoldersAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetConversationReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetConversationReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetConversationReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageCountsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageCountsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageCountsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_GetMessageReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"GetMessageReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"SaveMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TryMoveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TryMoveAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryMoveAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TryMoveWithNewNameAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TryMoveAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryMoveAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_TrySaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"TrySaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySaveAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"LastSuccessfulSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastSuccessfulSyncTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"LastSuccessfulSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.LastSuccessfulSyncTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"IsSyncEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSyncEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"IsSyncEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSyncEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailFolder_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailFolder_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"MailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailboxId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolder_get_ParentFolderId(py::wrapper::Windows::ApplicationModel::Email::EmailFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailFolder", L"ParentFolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ParentFolderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailFolder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailFolder[] = {
        { "create_folder_async", reinterpret_cast<PyCFunction>(EmailFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(EmailFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "find_child_folders_async", reinterpret_cast<PyCFunction>(EmailFolder_FindChildFoldersAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailFolder_GetConversationReader), METH_VARARGS, nullptr },
        { "get_conversation_reader_with_options", reinterpret_cast<PyCFunction>(EmailFolder_GetConversationReaderWithOptions), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_counts_async", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageCountsAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageReader), METH_VARARGS, nullptr },
        { "get_message_reader_with_options", reinterpret_cast<PyCFunction>(EmailFolder_GetMessageReaderWithOptions), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(EmailFolder_SaveMessageAsync), METH_VARARGS, nullptr },
        { "try_move_async", reinterpret_cast<PyCFunction>(EmailFolder_TryMoveAsync), METH_VARARGS, nullptr },
        { "try_move_with_new_name_async", reinterpret_cast<PyCFunction>(EmailFolder_TryMoveWithNewNameAsync), METH_VARARGS, nullptr },
        { "try_save_async", reinterpret_cast<PyCFunction>(EmailFolder_TrySaveAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailFolder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailFolder), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailFolder[] = {
        { "remote_id", reinterpret_cast<getter>(EmailFolder_get_RemoteId), reinterpret_cast<setter>(EmailFolder_put_RemoteId), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(EmailFolder_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(EmailFolder_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "is_sync_enabled", reinterpret_cast<getter>(EmailFolder_get_IsSyncEnabled), reinterpret_cast<setter>(EmailFolder_put_IsSyncEnabled), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(EmailFolder_get_DisplayName), reinterpret_cast<setter>(EmailFolder_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailFolder_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailFolder_get_Kind), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailFolder_get_MailboxId), nullptr, nullptr, nullptr },
        { "parent_folder_id", reinterpret_cast<getter>(EmailFolder_get_ParentFolderId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailFolder[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailFolder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailFolder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailFolder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailFolder) },
        { }};

    static PyType_Spec type_spec_EmailFolder = {
        "winrt._winrt_windows_applicationmodel_email.EmailFolder",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailFolder};

    // ----- EmailIrmInfo class --------------------

    static PyObject* _new_EmailIrmInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailIrmInfo_get_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanRemoveIrmOnResponse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanRemoveIrmOnResponse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanRemoveIrmOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanRemoveIrmOnResponse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanRemoveIrmOnResponse(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanPrintData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanPrintData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanPrintData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanPrintData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanPrintData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanModifyRecipientsOnResponse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanModifyRecipientsOnResponse();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanModifyRecipientsOnResponse(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanModifyRecipientsOnResponse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanModifyRecipientsOnResponse(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanForward();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanForward(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanForward");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanForward(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanExtractData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanExtractData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanExtractData(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanExtractData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanExtractData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanReply();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReply(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanReply(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanEdit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanEdit();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanEdit(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanEdit");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanEdit(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Template();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_Template(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>(arg);

            {
                auto _gil = release_gil();
                self->obj.Template(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsProgramaticAccessAllowed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsProgramaticAccessAllowed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsProgramaticAccessAllowed(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsProgramaticAccessAllowed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsProgramaticAccessAllowed(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsIrmOriginator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsIrmOriginator();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_IsIrmOriginator(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"IsIrmOriginator");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsIrmOriginator(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ExpirationDate();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"ExpirationDate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.ExpirationDate(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmInfo_get_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReplyAll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanReplyAll();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmInfo_put_CanReplyAll(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmInfo", L"CanReplyAll");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanReplyAll(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailIrmInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailIrmInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmInfo[] = {
        { "_assign_array_", _assign_array_EmailIrmInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailIrmInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailIrmInfo[] = {
        { "can_remove_irm_on_response", reinterpret_cast<getter>(EmailIrmInfo_get_CanRemoveIrmOnResponse), reinterpret_cast<setter>(EmailIrmInfo_put_CanRemoveIrmOnResponse), nullptr, nullptr },
        { "can_print_data", reinterpret_cast<getter>(EmailIrmInfo_get_CanPrintData), reinterpret_cast<setter>(EmailIrmInfo_put_CanPrintData), nullptr, nullptr },
        { "can_modify_recipients_on_response", reinterpret_cast<getter>(EmailIrmInfo_get_CanModifyRecipientsOnResponse), reinterpret_cast<setter>(EmailIrmInfo_put_CanModifyRecipientsOnResponse), nullptr, nullptr },
        { "can_forward", reinterpret_cast<getter>(EmailIrmInfo_get_CanForward), reinterpret_cast<setter>(EmailIrmInfo_put_CanForward), nullptr, nullptr },
        { "can_extract_data", reinterpret_cast<getter>(EmailIrmInfo_get_CanExtractData), reinterpret_cast<setter>(EmailIrmInfo_put_CanExtractData), nullptr, nullptr },
        { "can_reply", reinterpret_cast<getter>(EmailIrmInfo_get_CanReply), reinterpret_cast<setter>(EmailIrmInfo_put_CanReply), nullptr, nullptr },
        { "can_edit", reinterpret_cast<getter>(EmailIrmInfo_get_CanEdit), reinterpret_cast<setter>(EmailIrmInfo_put_CanEdit), nullptr, nullptr },
        { "template", reinterpret_cast<getter>(EmailIrmInfo_get_Template), reinterpret_cast<setter>(EmailIrmInfo_put_Template), nullptr, nullptr },
        { "is_programatic_access_allowed", reinterpret_cast<getter>(EmailIrmInfo_get_IsProgramaticAccessAllowed), reinterpret_cast<setter>(EmailIrmInfo_put_IsProgramaticAccessAllowed), nullptr, nullptr },
        { "is_irm_originator", reinterpret_cast<getter>(EmailIrmInfo_get_IsIrmOriginator), reinterpret_cast<setter>(EmailIrmInfo_put_IsIrmOriginator), nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(EmailIrmInfo_get_ExpirationDate), reinterpret_cast<setter>(EmailIrmInfo_put_ExpirationDate), nullptr, nullptr },
        { "can_reply_all", reinterpret_cast<getter>(EmailIrmInfo_get_CanReplyAll), reinterpret_cast<setter>(EmailIrmInfo_put_CanReplyAll), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailIrmInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailIrmInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailIrmInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailIrmInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailIrmInfo) },
        { }};

    static PyType_Spec type_spec_EmailIrmInfo = {
        "winrt._winrt_windows_applicationmodel_email.EmailIrmInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmInfo};

    // ----- EmailIrmTemplate class --------------------

    static PyObject* _new_EmailIrmTemplate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailIrmTemplate instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailIrmTemplate(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailIrmTemplate_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Id(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Id(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailIrmTemplate_get_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailIrmTemplate_put_Description(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailIrmTemplate", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Description(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailIrmTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailIrmTemplate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailIrmTemplate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailIrmTemplate[] = {
        { "_assign_array_", _assign_array_EmailIrmTemplate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailIrmTemplate), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailIrmTemplate[] = {
        { "name", reinterpret_cast<getter>(EmailIrmTemplate_get_Name), reinterpret_cast<setter>(EmailIrmTemplate_put_Name), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailIrmTemplate_get_Id), reinterpret_cast<setter>(EmailIrmTemplate_put_Id), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(EmailIrmTemplate_get_Description), reinterpret_cast<setter>(EmailIrmTemplate_put_Description), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailIrmTemplate[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailIrmTemplate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailIrmTemplate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailIrmTemplate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailIrmTemplate) },
        { }};

    static PyType_Spec type_spec_EmailIrmTemplate = {
        "winrt._winrt_windows_applicationmodel_email.EmailIrmTemplate",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailIrmTemplate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailIrmTemplate};

    // ----- EmailItemCounts class --------------------

    static PyObject* _new_EmailItemCounts(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailItemCounts>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailItemCounts(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailItemCounts_get_Flagged(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Flagged");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Flagged();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Important(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Important");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Important();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Total(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Total");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Total();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailItemCounts_get_Unread(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailItemCounts", L"Unread");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Unread();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailItemCounts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailItemCounts>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailItemCounts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailItemCounts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailItemCounts[] = {
        { "_assign_array_", _assign_array_EmailItemCounts, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailItemCounts), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailItemCounts[] = {
        { "flagged", reinterpret_cast<getter>(EmailItemCounts_get_Flagged), nullptr, nullptr, nullptr },
        { "important", reinterpret_cast<getter>(EmailItemCounts_get_Important), nullptr, nullptr, nullptr },
        { "total", reinterpret_cast<getter>(EmailItemCounts_get_Total), nullptr, nullptr, nullptr },
        { "unread", reinterpret_cast<getter>(EmailItemCounts_get_Unread), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailItemCounts[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailItemCounts) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailItemCounts) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailItemCounts) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailItemCounts) },
        { }};

    static PyType_Spec type_spec_EmailItemCounts = {
        "winrt._winrt_windows_applicationmodel_email.EmailItemCounts",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailItemCounts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailItemCounts};

    // ----- EmailMailbox class --------------------

    static PyObject* _new_EmailMailbox(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailbox>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailbox_ChangeMessageFlagStateAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ChangeMessageFlagStateAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ChangeMessageFlagStateAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_CreateResponseMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"CreateResponseMessageAsync", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateResponseMessageAsync(param0, param1, param2, param3, param4);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DeleteAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DeleteMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadAttachmentAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DownloadAttachmentAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DownloadAttachmentAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DownloadMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DownloadMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetChangeTracker", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChangeTracker(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetConversationReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetConversationReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetMessageReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetMessageReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_GetSpecialFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"GetSpecialFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailSpecialFolderKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetSpecialFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkFolderAsSeenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkFolderAsSeenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkFolderSyncEnabledAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkFolderSyncEnabledAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkFolderSyncEnabledAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageAsSeenAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkMessageAsSeenAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkMessageAsSeenAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MarkMessageReadAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.MarkMessageReadAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"RegisterSyncManagerAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RegisterSyncManagerAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ResolveRecipientsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ResolveRecipientsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ResolveRecipientsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SaveAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SaveDraftAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SaveDraftAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SaveDraftAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SendMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_SmartSendMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SendMessageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SendMessageAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryCreateFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryCreateFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryCreateFolderAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryDeleteFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryDeleteFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryDeleteFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryEmptyFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryEmptyFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryEmptyFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryForwardMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryForwardMeetingAsync", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Email::EmailRecipient>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryForwardMeetingAsync(param0, param1, param2, param3, param4, param5);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryGetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryGetAutoReplySettingsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryGetAutoReplySettingsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveFolderAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryMoveFolderAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveFolderWithNewNameAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveFolderAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryMoveFolderAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryMoveMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryMoveMessageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryMoveMessageAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryProposeNewTimeForMeetingAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryProposeNewTimeForMeetingAsync", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryProposeNewTimeForMeetingAsync(param0, param1, param2, param3, param4);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TrySetAutoReplySettingsAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TrySetAutoReplySettingsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TrySetAutoReplySettingsAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_TryUpdateMeetingResponseAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"TryUpdateMeetingResponseAsync", 5);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingResponseType>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.TryUpdateMeetingResponseAsync(param0, param1, param2, param3, param4);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_ValidateCertificatesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ValidateCertificatesAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ValidateCertificatesAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppWriteAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OtherAppWriteAccess();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppWriteAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppWriteAccess>(arg);

            {
                auto _gil = release_gil();
                self->obj.OtherAppWriteAccess(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailAddress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_MailAddress(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.MailAddress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppReadAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OtherAppReadAccess();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"OtherAppReadAccess");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxOtherAppReadAccess>(arg);

            {
                auto _gil = release_gil();
                self->obj.OtherAppReadAccess(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailbox_put_DisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DisplayName(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailbox_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsDataEncryptedUnderLock(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"IsDataEncryptedUnderLock");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDataEncryptedUnderLock();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_IsOwnedByCurrentApp(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"IsOwnedByCurrentApp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsOwnedByCurrentApp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_MailAddressAliases(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailAddressAliases");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailAddressAliases();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Capabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Capabilities");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Capabilities();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"ChangeTracker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeTracker();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_Policies(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"Policies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Policies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SourceDisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SourceDisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_SyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"SyncManager");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SyncManager();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"UserDataAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UserDataAccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_LinkedMailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"LinkedMailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LinkedMailboxId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkAccountId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"NetworkAccountId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NetworkAccountId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_get_NetworkId(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"NetworkId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NetworkId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_add_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailboxChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailbox, winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailboxChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailbox_remove_MailboxChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailbox", L"MailboxChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.MailboxChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailbox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailbox>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailbox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailbox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailbox[] = {
        { "change_message_flag_state_async", reinterpret_cast<PyCFunction>(EmailMailbox_ChangeMessageFlagStateAsync), METH_VARARGS, nullptr },
        { "create_response_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_CreateResponseMessageAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(EmailMailbox_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "download_attachment_async", reinterpret_cast<PyCFunction>(EmailMailbox_DownloadAttachmentAsync), METH_VARARGS, nullptr },
        { "download_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_DownloadMessageAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(EmailMailbox_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailMailbox_GetConversationReader), METH_VARARGS, nullptr },
        { "get_conversation_reader_with_options", reinterpret_cast<PyCFunction>(EmailMailbox_GetConversationReaderWithOptions), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailMailbox_GetMessageReader), METH_VARARGS, nullptr },
        { "get_message_reader_with_options", reinterpret_cast<PyCFunction>(EmailMailbox_GetMessageReaderWithOptions), METH_VARARGS, nullptr },
        { "get_special_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_GetSpecialFolderAsync), METH_VARARGS, nullptr },
        { "mark_folder_as_seen_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkFolderAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_folder_sync_enabled_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkFolderSyncEnabledAsync), METH_VARARGS, nullptr },
        { "mark_message_as_seen_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkMessageAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_message_read_async", reinterpret_cast<PyCFunction>(EmailMailbox_MarkMessageReadAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(EmailMailbox_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "resolve_recipients_async", reinterpret_cast<PyCFunction>(EmailMailbox_ResolveRecipientsAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(EmailMailbox_SaveAsync), METH_VARARGS, nullptr },
        { "save_draft_async", reinterpret_cast<PyCFunction>(EmailMailbox_SaveDraftAsync), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_SendMessageAsync), METH_VARARGS, nullptr },
        { "smart_send_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_SmartSendMessageAsync), METH_VARARGS, nullptr },
        { "try_create_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryCreateFolderAsync), METH_VARARGS, nullptr },
        { "try_delete_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryDeleteFolderAsync), METH_VARARGS, nullptr },
        { "try_empty_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryEmptyFolderAsync), METH_VARARGS, nullptr },
        { "try_forward_meeting_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryForwardMeetingAsync), METH_VARARGS, nullptr },
        { "try_get_auto_reply_settings_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryGetAutoReplySettingsAsync), METH_VARARGS, nullptr },
        { "try_move_folder_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryMoveFolderAsync), METH_VARARGS, nullptr },
        { "try_move_folder_with_new_name_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryMoveFolderWithNewNameAsync), METH_VARARGS, nullptr },
        { "try_move_message_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryMoveMessageAsync), METH_VARARGS, nullptr },
        { "try_propose_new_time_for_meeting_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryProposeNewTimeForMeetingAsync), METH_VARARGS, nullptr },
        { "try_set_auto_reply_settings_async", reinterpret_cast<PyCFunction>(EmailMailbox_TrySetAutoReplySettingsAsync), METH_VARARGS, nullptr },
        { "try_update_meeting_response_async", reinterpret_cast<PyCFunction>(EmailMailbox_TryUpdateMeetingResponseAsync), METH_VARARGS, nullptr },
        { "validate_certificates_async", reinterpret_cast<PyCFunction>(EmailMailbox_ValidateCertificatesAsync), METH_VARARGS, nullptr },
        { "add_mailbox_changed", reinterpret_cast<PyCFunction>(EmailMailbox_add_MailboxChanged), METH_O, nullptr },
        { "remove_mailbox_changed", reinterpret_cast<PyCFunction>(EmailMailbox_remove_MailboxChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailMailbox, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailbox), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailbox[] = {
        { "other_app_write_access", reinterpret_cast<getter>(EmailMailbox_get_OtherAppWriteAccess), reinterpret_cast<setter>(EmailMailbox_put_OtherAppWriteAccess), nullptr, nullptr },
        { "mail_address", reinterpret_cast<getter>(EmailMailbox_get_MailAddress), reinterpret_cast<setter>(EmailMailbox_put_MailAddress), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(EmailMailbox_get_OtherAppReadAccess), reinterpret_cast<setter>(EmailMailbox_put_OtherAppReadAccess), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(EmailMailbox_get_DisplayName), reinterpret_cast<setter>(EmailMailbox_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailMailbox_get_Id), nullptr, nullptr, nullptr },
        { "is_data_encrypted_under_lock", reinterpret_cast<getter>(EmailMailbox_get_IsDataEncryptedUnderLock), nullptr, nullptr, nullptr },
        { "is_owned_by_current_app", reinterpret_cast<getter>(EmailMailbox_get_IsOwnedByCurrentApp), nullptr, nullptr, nullptr },
        { "mail_address_aliases", reinterpret_cast<getter>(EmailMailbox_get_MailAddressAliases), nullptr, nullptr, nullptr },
        { "capabilities", reinterpret_cast<getter>(EmailMailbox_get_Capabilities), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(EmailMailbox_get_ChangeTracker), nullptr, nullptr, nullptr },
        { "policies", reinterpret_cast<getter>(EmailMailbox_get_Policies), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(EmailMailbox_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(EmailMailbox_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(EmailMailbox_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { "linked_mailbox_id", reinterpret_cast<getter>(EmailMailbox_get_LinkedMailboxId), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(EmailMailbox_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "network_id", reinterpret_cast<getter>(EmailMailbox_get_NetworkId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailbox[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailbox) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailbox) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailbox) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailbox) },
        { }};

    static PyType_Spec type_spec_EmailMailbox = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailbox",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailbox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailbox};

    // ----- EmailMailboxAction class --------------------

    static PyObject* _new_EmailMailboxAction(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAction(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAction_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAction", L"ChangeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAction_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAction", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAction[] = {
        { "_assign_array_", _assign_array_EmailMailboxAction, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAction), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxAction[] = {
        { "change_number", reinterpret_cast<getter>(EmailMailboxAction_get_ChangeNumber), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailMailboxAction_get_Kind), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxAction[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAction) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAction) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAction) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAction) },
        { }};

    static PyType_Spec type_spec_EmailMailboxAction = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAction};

    // ----- EmailMailboxAutoReply class --------------------

    static PyObject* _new_EmailMailboxAutoReply(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxAutoReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAutoReply_get_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_Response(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Response(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReply_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReply_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReply", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxAutoReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAutoReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReply[] = {
        { "_assign_array_", _assign_array_EmailMailboxAutoReply, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAutoReply), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxAutoReply[] = {
        { "response", reinterpret_cast<getter>(EmailMailboxAutoReply_get_Response), reinterpret_cast<setter>(EmailMailboxAutoReply_put_Response), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(EmailMailboxAutoReply_get_IsEnabled), reinterpret_cast<setter>(EmailMailboxAutoReply_put_IsEnabled), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxAutoReply[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAutoReply) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAutoReply) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAutoReply) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAutoReply) },
        { }};

    static PyType_Spec type_spec_EmailMailboxAutoReply = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAutoReply",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReply};

    // ----- EmailMailboxAutoReplySettings class --------------------

    static PyObject* _new_EmailMailboxAutoReplySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMailboxAutoReplySettings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxAutoReplySettings_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.StartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"ResponseKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResponseKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_ResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"ResponseKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplyMessageResponseKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResponseKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_IsEnabled(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EndTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxAutoReplySettings_put_EndTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"EndTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.EndTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_InternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"InternalReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InternalReply();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_KnownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"KnownExternalReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.KnownExternalReply();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxAutoReplySettings_get_UnknownExternalReply(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxAutoReplySettings", L"UnknownExternalReply");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnknownExternalReply();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxAutoReplySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxAutoReplySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxAutoReplySettings[] = {
        { "_assign_array_", _assign_array_EmailMailboxAutoReplySettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxAutoReplySettings), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxAutoReplySettings[] = {
        { "start_time", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_StartTime), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_StartTime), nullptr, nullptr },
        { "response_kind", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_ResponseKind), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_ResponseKind), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_IsEnabled), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_IsEnabled), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_EndTime), reinterpret_cast<setter>(EmailMailboxAutoReplySettings_put_EndTime), nullptr, nullptr },
        { "internal_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_InternalReply), nullptr, nullptr, nullptr },
        { "known_external_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_KnownExternalReply), nullptr, nullptr, nullptr },
        { "unknown_external_reply", reinterpret_cast<getter>(EmailMailboxAutoReplySettings_get_UnknownExternalReply), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxAutoReplySettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxAutoReplySettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxAutoReplySettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxAutoReplySettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxAutoReplySettings) },
        { }};

    static PyType_Spec type_spec_EmailMailboxAutoReplySettings = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxAutoReplySettings",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxAutoReplySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxAutoReplySettings};

    // ----- EmailMailboxCapabilities class --------------------

    static PyObject* _new_EmailMailboxCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCapabilities(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCapabilities_get_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanSmartSend");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanSmartSend();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanSmartSend(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanSmartSend");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanSmartSend(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanUpdateMeetingResponses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanUpdateMeetingResponses();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanUpdateMeetingResponses");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanUpdateMeetingResponses(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchMailbox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanServerSearchMailbox();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchMailbox(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchMailbox");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanServerSearchMailbox(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchFolders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanServerSearchFolders();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanServerSearchFolders(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanServerSearchFolders");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanServerSearchFolders(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanForwardMeetings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanForwardMeetings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanForwardMeetings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanForwardMeetings(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanProposeNewTimeForMeetings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanProposeNewTimeForMeetings();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanProposeNewTimeForMeetings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanProposeNewTimeForMeetings(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetInternalAutoReplies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGetAndSetInternalAutoReplies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetInternalAutoReplies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanGetAndSetInternalAutoReplies(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetExternalAutoReplies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanGetAndSetExternalAutoReplies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanGetAndSetExternalAutoReplies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanGetAndSetExternalAutoReplies(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanValidateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanValidateCertificates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanValidateCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanValidateCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanValidateCertificates(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanResolveRecipients");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanResolveRecipients();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanResolveRecipients(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanResolveRecipients");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanResolveRecipients(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanMoveFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanMoveFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanMoveFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanMoveFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanMoveFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanEmptyFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanEmptyFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanEmptyFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanEmptyFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanEmptyFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanDeleteFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanDeleteFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanDeleteFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanDeleteFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanDeleteFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxCapabilities_get_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanCreateFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CanCreateFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxCapabilities_put_CanCreateFolder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCapabilities", L"CanCreateFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.CanCreateFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCapabilities[] = {
        { "_assign_array_", _assign_array_EmailMailboxCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCapabilities), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxCapabilities[] = {
        { "can_smart_send", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanSmartSend), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanSmartSend), nullptr, nullptr },
        { "can_update_meeting_responses", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanUpdateMeetingResponses), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanUpdateMeetingResponses), nullptr, nullptr },
        { "can_server_search_mailbox", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanServerSearchMailbox), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanServerSearchMailbox), nullptr, nullptr },
        { "can_server_search_folders", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanServerSearchFolders), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanServerSearchFolders), nullptr, nullptr },
        { "can_forward_meetings", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanForwardMeetings), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanForwardMeetings), nullptr, nullptr },
        { "can_propose_new_time_for_meetings", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanProposeNewTimeForMeetings), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanProposeNewTimeForMeetings), nullptr, nullptr },
        { "can_get_and_set_internal_auto_replies", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanGetAndSetInternalAutoReplies), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanGetAndSetInternalAutoReplies), nullptr, nullptr },
        { "can_get_and_set_external_auto_replies", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanGetAndSetExternalAutoReplies), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanGetAndSetExternalAutoReplies), nullptr, nullptr },
        { "can_validate_certificates", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanValidateCertificates), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanValidateCertificates), nullptr, nullptr },
        { "can_resolve_recipients", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanResolveRecipients), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanResolveRecipients), nullptr, nullptr },
        { "can_move_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanMoveFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanMoveFolder), nullptr, nullptr },
        { "can_empty_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanEmptyFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanEmptyFolder), nullptr, nullptr },
        { "can_delete_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanDeleteFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanDeleteFolder), nullptr, nullptr },
        { "can_create_folder", reinterpret_cast<getter>(EmailMailboxCapabilities_get_CanCreateFolder), reinterpret_cast<setter>(EmailMailboxCapabilities_put_CanCreateFolder), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCapabilities) },
        { }};

    static PyType_Spec type_spec_EmailMailboxCapabilities = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCapabilities};

    // ----- EmailMailboxChange class --------------------

    static PyObject* _new_EmailMailboxChange(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChange(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"ChangeType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_MailboxActions(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"MailboxActions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailboxActions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChange_get_Message(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChange", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChange[] = {
        { "_assign_array_", _assign_array_EmailMailboxChange, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChange), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxChange[] = {
        { "change_type", reinterpret_cast<getter>(EmailMailboxChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(EmailMailboxChange_get_Folder), nullptr, nullptr, nullptr },
        { "mailbox_actions", reinterpret_cast<getter>(EmailMailboxChange_get_MailboxActions), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(EmailMailboxChange_get_Message), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxChange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChange) },
        { }};

    static PyType_Spec type_spec_EmailMailboxChange = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChange};

    // ----- EmailMailboxChangeReader class --------------------

    static PyObject* _new_EmailMailboxChangeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"AcceptChanges", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.AcceptChanges();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"AcceptChangesThrough", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxChange>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.AcceptChangesThrough(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailMailboxChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangeReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxChangeReader[] = {
        { }};

    static PyType_Slot _type_slots_EmailMailboxChangeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangeReader) },
        { }};

    static PyType_Spec type_spec_EmailMailboxChangeReader = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeReader};

    // ----- EmailMailboxChangeTracker class --------------------

    static PyObject* _new_EmailMailboxChangeTracker(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangeTracker(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"Enable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Enable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"GetChangeReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetChangeReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"Reset", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Reset();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangeTracker", L"IsTracking");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTracking();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(EmailMailboxChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangeTracker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangeTracker), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(EmailMailboxChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxChangeTracker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangeTracker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangeTracker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangeTracker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangeTracker) },
        { }};

    static PyType_Spec type_spec_EmailMailboxChangeTracker = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangeTracker};

    // ----- EmailMailboxChangedDeferral class --------------------

    static PyObject* _new_EmailMailboxChangedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangedDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(EmailMailboxChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxChangedDeferral[] = {
        { }};

    static PyType_Slot _type_slots_EmailMailboxChangedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangedDeferral) },
        { }};

    static PyType_Spec type_spec_EmailMailboxChangedDeferral = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedDeferral};

    // ----- EmailMailboxChangedEventArgs class --------------------

    static PyObject* _new_EmailMailboxChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxChangedEventArgs(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxChangedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EmailMailboxChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxChangedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_EmailMailboxChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_EmailMailboxChangedEventArgs = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxChangedEventArgs};

    // ----- EmailMailboxCreateFolderResult class --------------------

    static PyObject* _new_EmailMailboxCreateFolderResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxCreateFolderResult(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Folder(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult", L"Folder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Folder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxCreateFolderResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxCreateFolderResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxCreateFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxCreateFolderResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxCreateFolderResult[] = {
        { "_assign_array_", _assign_array_EmailMailboxCreateFolderResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxCreateFolderResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxCreateFolderResult[] = {
        { "folder", reinterpret_cast<getter>(EmailMailboxCreateFolderResult_get_Folder), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailMailboxCreateFolderResult_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxCreateFolderResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxCreateFolderResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxCreateFolderResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxCreateFolderResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxCreateFolderResult) },
        { }};

    static PyType_Spec type_spec_EmailMailboxCreateFolderResult = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxCreateFolderResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxCreateFolderResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxCreateFolderResult};

    // ----- EmailMailboxPolicies class --------------------

    static PyObject* _new_EmailMailboxPolicies(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxPolicies(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeSigningAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequiredSmimeSigningAlgorithm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeSigningAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeSigningAlgorithm>>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequiredSmimeSigningAlgorithm(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeEncryptionAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RequiredSmimeEncryptionAlgorithm();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"RequiredSmimeEncryptionAlgorithm");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::ApplicationModel::Email::EmailMailboxSmimeEncryptionAlgorithm>>(arg);

            {
                auto _gil = release_gil();
                self->obj.RequiredSmimeEncryptionAlgorithm(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowedSmimeEncryptionAlgorithmNegotiation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowedSmimeEncryptionAlgorithmNegotiation();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowedSmimeEncryptionAlgorithmNegotiation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowedSmimeEncryptionAlgorithmNegotiation(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowSmimeSoftCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowSmimeSoftCertificates();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_AllowSmimeSoftCertificates(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"AllowSmimeSoftCertificates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowSmimeSoftCertificates(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustSignSmimeMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MustSignSmimeMessages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustSignSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustSignSmimeMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.MustSignSmimeMessages(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxPolicies_get_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustEncryptSmimeMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MustEncryptSmimeMessages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxPolicies_put_MustEncryptSmimeMessages(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxPolicies", L"MustEncryptSmimeMessages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.MustEncryptSmimeMessages(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailMailboxPolicies(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxPolicies(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxPolicies>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxPolicies[] = {
        { "_assign_array_", _assign_array_EmailMailboxPolicies, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxPolicies), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxPolicies[] = {
        { "required_smime_signing_algorithm", reinterpret_cast<getter>(EmailMailboxPolicies_get_RequiredSmimeSigningAlgorithm), reinterpret_cast<setter>(EmailMailboxPolicies_put_RequiredSmimeSigningAlgorithm), nullptr, nullptr },
        { "required_smime_encryption_algorithm", reinterpret_cast<getter>(EmailMailboxPolicies_get_RequiredSmimeEncryptionAlgorithm), reinterpret_cast<setter>(EmailMailboxPolicies_put_RequiredSmimeEncryptionAlgorithm), nullptr, nullptr },
        { "allowed_smime_encryption_algorithm_negotiation", reinterpret_cast<getter>(EmailMailboxPolicies_get_AllowedSmimeEncryptionAlgorithmNegotiation), reinterpret_cast<setter>(EmailMailboxPolicies_put_AllowedSmimeEncryptionAlgorithmNegotiation), nullptr, nullptr },
        { "allow_smime_soft_certificates", reinterpret_cast<getter>(EmailMailboxPolicies_get_AllowSmimeSoftCertificates), reinterpret_cast<setter>(EmailMailboxPolicies_put_AllowSmimeSoftCertificates), nullptr, nullptr },
        { "must_sign_smime_messages", reinterpret_cast<getter>(EmailMailboxPolicies_get_MustSignSmimeMessages), reinterpret_cast<setter>(EmailMailboxPolicies_put_MustSignSmimeMessages), nullptr, nullptr },
        { "must_encrypt_smime_messages", reinterpret_cast<getter>(EmailMailboxPolicies_get_MustEncryptSmimeMessages), reinterpret_cast<setter>(EmailMailboxPolicies_put_MustEncryptSmimeMessages), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxPolicies[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxPolicies) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxPolicies) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxPolicies) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxPolicies) },
        { }};

    static PyType_Spec type_spec_EmailMailboxPolicies = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxPolicies",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxPolicies),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxPolicies};

    // ----- EmailMailboxSyncManager class --------------------

    static PyObject* _new_EmailMailboxSyncManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMailboxSyncManager(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMailboxSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SyncAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastSuccessfulSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastSuccessfulSyncTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastSuccessfulSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.LastSuccessfulSyncTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastAttemptedSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastAttemptedSyncTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMailboxSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"LastAttemptedSyncTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.LastAttemptedSyncTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMailboxSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SyncStatusChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMailboxSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.Email.EmailMailboxSyncManager", L"SyncStatusChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SyncStatusChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMailboxSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMailboxSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMailboxSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMailboxSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(EmailMailboxSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_EmailMailboxSyncManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMailboxSyncManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMailboxSyncManager[] = {
        { "status", reinterpret_cast<getter>(EmailMailboxSyncManager_get_Status), reinterpret_cast<setter>(EmailMailboxSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(EmailMailboxSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(EmailMailboxSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(EmailMailboxSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(EmailMailboxSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMailboxSyncManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMailboxSyncManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMailboxSyncManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMailboxSyncManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMailboxSyncManager) },
        { }};

    static PyType_Spec type_spec_EmailMailboxSyncManager = {
        "winrt._winrt_windows_applicationmodel_email.EmailMailboxSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMailboxSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMailboxSyncManager};

    // ----- EmailManager class --------------------

    static PyObject* _new_EmailManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManager>::type_name);
        return nullptr;
    }

    static PyObject* EmailManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"GetForUser", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Email::EmailManager::GetForUser(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"RequestStoreAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Email::EmailManager::RequestStoreAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManager_ShowComposeNewEmailAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManager", L"ShowComposeNewEmailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::ApplicationModel::Email::EmailManager::ShowComposeNewEmailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManager[] = {
        { }};

    static PyGetSetDef _getset_EmailManager[] = {
        { }};

    static PyType_Slot _type_slots_EmailManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailManager) },
        { }};

    static PyType_Spec type_spec_EmailManager = {
        "winrt._winrt_windows_applicationmodel_email.EmailManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManager};

    static PyGetSetDef getset_EmailManager_Static[] = {
        { }};

    static PyMethodDef methods_EmailManager_Static[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(EmailManager_GetForUser), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(EmailManager_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_compose_new_email_async", reinterpret_cast<PyCFunction>(EmailManager_ShowComposeNewEmailAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_EmailManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EmailManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EmailManager_Static) },
        { }
    };

    static PyType_Spec type_spec_EmailManager_Static = {
        "winrt._winrt_windows_applicationmodel_email.EmailManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EmailManager_Static};

    // ----- EmailManagerForUser class --------------------

    static PyObject* _new_EmailManagerForUser(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailManagerForUser(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"RequestStoreAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailStoreAccessType>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RequestStoreAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_ShowComposeNewEmailAsync(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"ShowComposeNewEmailAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessage>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ShowComposeNewEmailAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailManagerForUser", L"User");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.User();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(EmailManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_compose_new_email_async", reinterpret_cast<PyCFunction>(EmailManagerForUser_ShowComposeNewEmailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailManagerForUser), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailManagerForUser[] = {
        { "user", reinterpret_cast<getter>(EmailManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailManagerForUser[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailManagerForUser) },
        { }};

    static PyType_Spec type_spec_EmailManagerForUser = {
        "winrt._winrt_windows_applicationmodel_email.EmailManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailManagerForUser};

    // ----- EmailMeetingInfo class --------------------

    static PyObject* _new_EmailMeetingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMeetingInfo instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMeetingInfo_get_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Location");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Location();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Location(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Location");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Location(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsResponseRequested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsResponseRequested();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsResponseRequested");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsResponseRequested(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsAllDay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAllDay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_IsAllDay(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsAllDay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsAllDay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AllowNewTimeProposal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowNewTimeProposal();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AllowNewTimeProposal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowNewTimeProposal(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Duration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Duration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Duration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            {
                auto _gil = release_gil();
                self->obj.Duration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentRoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppointmentRoamingId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentRoamingId(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentRoamingId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.AppointmentRoamingId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentOriginalStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppointmentOriginalStartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_AppointmentOriginalStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"AppointmentOriginalStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.AppointmentOriginalStartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProposedDuration();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedDuration(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProposedDuration(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RemoteChangeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteChangeNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RemoteChangeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint64_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteChangeNumber(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_StartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"StartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            {
                auto _gil = release_gil();
                self->obj.StartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RecurrenceStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RecurrenceStartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_RecurrenceStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"RecurrenceStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.RecurrenceStartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Recurrence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Recurrence();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_Recurrence(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"Recurrence");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>(arg);

            {
                auto _gil = release_gil();
                self->obj.Recurrence(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ProposedStartTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMeetingInfo_put_ProposedStartTime(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"ProposedStartTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.ProposedStartTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMeetingInfo_get_IsReportedOutOfDateByServer(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMeetingInfo", L"IsReportedOutOfDateByServer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsReportedOutOfDateByServer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMeetingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMeetingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMeetingInfo[] = {
        { "_assign_array_", _assign_array_EmailMeetingInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMeetingInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMeetingInfo[] = {
        { "location", reinterpret_cast<getter>(EmailMeetingInfo_get_Location), reinterpret_cast<setter>(EmailMeetingInfo_put_Location), nullptr, nullptr },
        { "is_response_requested", reinterpret_cast<getter>(EmailMeetingInfo_get_IsResponseRequested), reinterpret_cast<setter>(EmailMeetingInfo_put_IsResponseRequested), nullptr, nullptr },
        { "is_all_day", reinterpret_cast<getter>(EmailMeetingInfo_get_IsAllDay), reinterpret_cast<setter>(EmailMeetingInfo_put_IsAllDay), nullptr, nullptr },
        { "allow_new_time_proposal", reinterpret_cast<getter>(EmailMeetingInfo_get_AllowNewTimeProposal), reinterpret_cast<setter>(EmailMeetingInfo_put_AllowNewTimeProposal), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(EmailMeetingInfo_get_Duration), reinterpret_cast<setter>(EmailMeetingInfo_put_Duration), nullptr, nullptr },
        { "appointment_roaming_id", reinterpret_cast<getter>(EmailMeetingInfo_get_AppointmentRoamingId), reinterpret_cast<setter>(EmailMeetingInfo_put_AppointmentRoamingId), nullptr, nullptr },
        { "appointment_original_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_AppointmentOriginalStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_AppointmentOriginalStartTime), nullptr, nullptr },
        { "proposed_duration", reinterpret_cast<getter>(EmailMeetingInfo_get_ProposedDuration), reinterpret_cast<setter>(EmailMeetingInfo_put_ProposedDuration), nullptr, nullptr },
        { "remote_change_number", reinterpret_cast<getter>(EmailMeetingInfo_get_RemoteChangeNumber), reinterpret_cast<setter>(EmailMeetingInfo_put_RemoteChangeNumber), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_StartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_StartTime), nullptr, nullptr },
        { "recurrence_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_RecurrenceStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_RecurrenceStartTime), nullptr, nullptr },
        { "recurrence", reinterpret_cast<getter>(EmailMeetingInfo_get_Recurrence), reinterpret_cast<setter>(EmailMeetingInfo_put_Recurrence), nullptr, nullptr },
        { "proposed_start_time", reinterpret_cast<getter>(EmailMeetingInfo_get_ProposedStartTime), reinterpret_cast<setter>(EmailMeetingInfo_put_ProposedStartTime), nullptr, nullptr },
        { "is_reported_out_of_date_by_server", reinterpret_cast<getter>(EmailMeetingInfo_get_IsReportedOutOfDateByServer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMeetingInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMeetingInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMeetingInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMeetingInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMeetingInfo) },
        { }};

    static PyType_Spec type_spec_EmailMeetingInfo = {
        "winrt._winrt_windows_applicationmodel_email.EmailMeetingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMeetingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMeetingInfo};

    // ----- EmailMessage class --------------------

    static PyObject* _new_EmailMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailMessage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessage_GetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"GetBodyStream", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetBodyStream(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_SetBodyStream(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SetBodyStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageBodyKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetBodyStream(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Subject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Subject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Subject(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Body();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Body(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Body");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Body(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Bcc(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Bcc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Bcc();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_CC(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"CC");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CC();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Attachments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Attachments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_To(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"To");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.To();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"AllowInternetImages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AllowInternetImages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_AllowInternetImages(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"AllowInternetImages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AllowInternetImages(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FlagState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FlagState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_FlagState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FlagState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailFlagState>(arg);

            {
                auto _gil = release_gil();
                self->obj.FlagState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"EstimatedDownloadSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.EstimatedDownloadSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_EstimatedDownloadSizeInBytes(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"EstimatedDownloadSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.EstimatedDownloadSizeInBytes(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"DownloadState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DownloadState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_DownloadState(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"DownloadState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageDownloadState>(arg);

            {
                auto _gil = release_gil();
                self->obj.DownloadState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Importance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Importance();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Importance(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Importance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailImportance>(arg);

            {
                auto _gil = release_gil();
                self->obj.Importance(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IrmInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IrmInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IrmInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IrmInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailIrmInfo>(arg);

            {
                auto _gil = release_gil();
                self->obj.IrmInfo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"OriginalCodePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OriginalCodePage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_OriginalCodePage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"OriginalCodePage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.OriginalCodePage(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SentTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentTime(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            {
                auto _gil = release_gil();
                self->obj.SentTime(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Sender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Sender();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Sender(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Sender");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            {
                auto _gil = release_gil();
                self->obj.Sender(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RemoteId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"RemoteId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.RemoteId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Preview");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Preview();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_Preview(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Preview");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Preview(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MessageClass();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MessageClass(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MessageClass");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.MessageClass(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MeetingInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MeetingInfo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_MeetingInfo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MeetingInfo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMeetingInfo>(arg);

            {
                auto _gil = release_gil();
                self->obj.MeetingInfo(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"LastResponseKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastResponseKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_LastResponseKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"LastResponseKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageResponseKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.LastResponseKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSeen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSeen();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSeen");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSeen(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsRead");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsRead();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsRead");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsRead(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_IsServerSearchMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsServerSearchMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsServerSearchMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsSmartSendable(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsSmartSendable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSmartSendable();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_MailboxId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"MailboxId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.MailboxId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ChangeNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ChangeNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_ConversationId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ConversationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConversationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_NormalizedSubject(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"NormalizedSubject");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NormalizedSubject();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_FolderId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"FolderId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_HasPartialBodies(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"HasPartialBodies");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasPartialBodies();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_Id(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_InResponseToMessageId(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"InResponseToMessageId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.InResponseToMessageId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_IsDraftMessage(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"IsDraftMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsDraftMessage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessage_get_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmimeKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeKind(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailMessageSmimeKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmimeKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SmimeData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SmimeData(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SmimeData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.SmimeData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentRepresenting");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SentRepresenting();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailMessage_put_SentRepresenting(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"SentRepresenting");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipient>(arg);

            {
                auto _gil = release_gil();
                self->obj.SentRepresenting(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailMessage_get_ReplyTo(py::wrapper::Windows::ApplicationModel::Email::EmailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessage", L"ReplyTo");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReplyTo();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessage[] = {
        { "get_body_stream", reinterpret_cast<PyCFunction>(EmailMessage_GetBodyStream), METH_VARARGS, nullptr },
        { "set_body_stream", reinterpret_cast<PyCFunction>(EmailMessage_SetBodyStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMessage[] = {
        { "subject", reinterpret_cast<getter>(EmailMessage_get_Subject), reinterpret_cast<setter>(EmailMessage_put_Subject), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(EmailMessage_get_Body), reinterpret_cast<setter>(EmailMessage_put_Body), nullptr, nullptr },
        { "bcc", reinterpret_cast<getter>(EmailMessage_get_Bcc), nullptr, nullptr, nullptr },
        { "cc", reinterpret_cast<getter>(EmailMessage_get_CC), nullptr, nullptr, nullptr },
        { "attachments", reinterpret_cast<getter>(EmailMessage_get_Attachments), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(EmailMessage_get_To), nullptr, nullptr, nullptr },
        { "allow_internet_images", reinterpret_cast<getter>(EmailMessage_get_AllowInternetImages), reinterpret_cast<setter>(EmailMessage_put_AllowInternetImages), nullptr, nullptr },
        { "flag_state", reinterpret_cast<getter>(EmailMessage_get_FlagState), reinterpret_cast<setter>(EmailMessage_put_FlagState), nullptr, nullptr },
        { "estimated_download_size_in_bytes", reinterpret_cast<getter>(EmailMessage_get_EstimatedDownloadSizeInBytes), reinterpret_cast<setter>(EmailMessage_put_EstimatedDownloadSizeInBytes), nullptr, nullptr },
        { "download_state", reinterpret_cast<getter>(EmailMessage_get_DownloadState), reinterpret_cast<setter>(EmailMessage_put_DownloadState), nullptr, nullptr },
        { "importance", reinterpret_cast<getter>(EmailMessage_get_Importance), reinterpret_cast<setter>(EmailMessage_put_Importance), nullptr, nullptr },
        { "irm_info", reinterpret_cast<getter>(EmailMessage_get_IrmInfo), reinterpret_cast<setter>(EmailMessage_put_IrmInfo), nullptr, nullptr },
        { "original_code_page", reinterpret_cast<getter>(EmailMessage_get_OriginalCodePage), reinterpret_cast<setter>(EmailMessage_put_OriginalCodePage), nullptr, nullptr },
        { "sent_time", reinterpret_cast<getter>(EmailMessage_get_SentTime), reinterpret_cast<setter>(EmailMessage_put_SentTime), nullptr, nullptr },
        { "sender", reinterpret_cast<getter>(EmailMessage_get_Sender), reinterpret_cast<setter>(EmailMessage_put_Sender), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(EmailMessage_get_RemoteId), reinterpret_cast<setter>(EmailMessage_put_RemoteId), nullptr, nullptr },
        { "preview", reinterpret_cast<getter>(EmailMessage_get_Preview), reinterpret_cast<setter>(EmailMessage_put_Preview), nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(EmailMessage_get_MessageClass), reinterpret_cast<setter>(EmailMessage_put_MessageClass), nullptr, nullptr },
        { "meeting_info", reinterpret_cast<getter>(EmailMessage_get_MeetingInfo), reinterpret_cast<setter>(EmailMessage_put_MeetingInfo), nullptr, nullptr },
        { "last_response_kind", reinterpret_cast<getter>(EmailMessage_get_LastResponseKind), reinterpret_cast<setter>(EmailMessage_put_LastResponseKind), nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(EmailMessage_get_IsSeen), reinterpret_cast<setter>(EmailMessage_put_IsSeen), nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(EmailMessage_get_IsRead), reinterpret_cast<setter>(EmailMessage_put_IsRead), nullptr, nullptr },
        { "is_server_search_message", reinterpret_cast<getter>(EmailMessage_get_IsServerSearchMessage), nullptr, nullptr, nullptr },
        { "is_smart_sendable", reinterpret_cast<getter>(EmailMessage_get_IsSmartSendable), nullptr, nullptr, nullptr },
        { "mailbox_id", reinterpret_cast<getter>(EmailMessage_get_MailboxId), nullptr, nullptr, nullptr },
        { "change_number", reinterpret_cast<getter>(EmailMessage_get_ChangeNumber), nullptr, nullptr, nullptr },
        { "conversation_id", reinterpret_cast<getter>(EmailMessage_get_ConversationId), nullptr, nullptr, nullptr },
        { "normalized_subject", reinterpret_cast<getter>(EmailMessage_get_NormalizedSubject), nullptr, nullptr, nullptr },
        { "folder_id", reinterpret_cast<getter>(EmailMessage_get_FolderId), nullptr, nullptr, nullptr },
        { "has_partial_bodies", reinterpret_cast<getter>(EmailMessage_get_HasPartialBodies), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(EmailMessage_get_Id), nullptr, nullptr, nullptr },
        { "in_response_to_message_id", reinterpret_cast<getter>(EmailMessage_get_InResponseToMessageId), nullptr, nullptr, nullptr },
        { "is_draft_message", reinterpret_cast<getter>(EmailMessage_get_IsDraftMessage), nullptr, nullptr, nullptr },
        { "smime_kind", reinterpret_cast<getter>(EmailMessage_get_SmimeKind), reinterpret_cast<setter>(EmailMessage_put_SmimeKind), nullptr, nullptr },
        { "smime_data", reinterpret_cast<getter>(EmailMessage_get_SmimeData), reinterpret_cast<setter>(EmailMessage_put_SmimeData), nullptr, nullptr },
        { "sent_representing", reinterpret_cast<getter>(EmailMessage_get_SentRepresenting), reinterpret_cast<setter>(EmailMessage_put_SentRepresenting), nullptr, nullptr },
        { "reply_to", reinterpret_cast<getter>(EmailMessage_get_ReplyTo), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMessage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessage) },
        { }};

    static PyType_Spec type_spec_EmailMessage = {
        "winrt._winrt_windows_applicationmodel_email.EmailMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessage};

    // ----- EmailMessageBatch class --------------------

    static PyObject* _new_EmailMessageBatch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMessageBatch(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessageBatch_get_Messages(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessageBatch", L"Messages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Messages();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailMessageBatch_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailMessageBatch", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessageBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessageBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageBatch[] = {
        { "_assign_array_", _assign_array_EmailMessageBatch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessageBatch), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMessageBatch[] = {
        { "messages", reinterpret_cast<getter>(EmailMessageBatch_get_Messages), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(EmailMessageBatch_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailMessageBatch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessageBatch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessageBatch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessageBatch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessageBatch) },
        { }};

    static PyType_Spec type_spec_EmailMessageBatch = {
        "winrt._winrt_windows_applicationmodel_email.EmailMessageBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageBatch};

    // ----- EmailMessageReader class --------------------

    static PyObject* _new_EmailMessageReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailMessageReader>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailMessageReader", L"ReadBatchAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ReadBatchAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailMessageReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailMessageReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(EmailMessageReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailMessageReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailMessageReader), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailMessageReader[] = {
        { }};

    static PyType_Slot _type_slots_EmailMessageReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailMessageReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailMessageReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailMessageReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailMessageReader) },
        { }};

    static PyType_Spec type_spec_EmailMessageReader = {
        "winrt._winrt_windows_applicationmodel_email.EmailMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailMessageReader};

    // ----- EmailQueryOptions class --------------------

    static PyObject* _new_EmailQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailQueryOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailQueryOptions(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailQueryOptions_get_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SortProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortProperty(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortProperty>(arg);

            {
                auto _gil = release_gil();
                self->obj.SortProperty(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SortDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_SortDirection(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"SortDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySortDirection>(arg);

            {
                auto _gil = release_gil();
                self->obj.SortDirection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Kind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryOptions_put_Kind(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"Kind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.Kind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryOptions_get_FolderIds(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"FolderIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FolderIds();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryOptions", L"TextSearch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextSearch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryOptions[] = {
        { "_assign_array_", _assign_array_EmailQueryOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailQueryOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailQueryOptions[] = {
        { "sort_property", reinterpret_cast<getter>(EmailQueryOptions_get_SortProperty), reinterpret_cast<setter>(EmailQueryOptions_put_SortProperty), nullptr, nullptr },
        { "sort_direction", reinterpret_cast<getter>(EmailQueryOptions_get_SortDirection), reinterpret_cast<setter>(EmailQueryOptions_put_SortDirection), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(EmailQueryOptions_get_Kind), reinterpret_cast<setter>(EmailQueryOptions_put_Kind), nullptr, nullptr },
        { "folder_ids", reinterpret_cast<getter>(EmailQueryOptions_get_FolderIds), nullptr, nullptr, nullptr },
        { "text_search", reinterpret_cast<getter>(EmailQueryOptions_get_TextSearch), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailQueryOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailQueryOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailQueryOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailQueryOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailQueryOptions) },
        { }};

    static PyType_Spec type_spec_EmailQueryOptions = {
        "winrt._winrt_windows_applicationmodel_email.EmailQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryOptions};

    // ----- EmailQueryTextSearch class --------------------

    static PyObject* _new_EmailQueryTextSearch(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailQueryTextSearch(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"SearchScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SearchScope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"SearchScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchScope>(arg);

            {
                auto _gil = release_gil();
                self->obj.SearchScope(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Fields");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Fields();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailQueryTextSearch", L"Fields");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQuerySearchFields>(arg);

            {
                auto _gil = release_gil();
                self->obj.Fields(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailQueryTextSearch[] = {
        { "_assign_array_", _assign_array_EmailQueryTextSearch, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailQueryTextSearch), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailQueryTextSearch[] = {
        { "text", reinterpret_cast<getter>(EmailQueryTextSearch_get_Text), reinterpret_cast<setter>(EmailQueryTextSearch_put_Text), nullptr, nullptr },
        { "search_scope", reinterpret_cast<getter>(EmailQueryTextSearch_get_SearchScope), reinterpret_cast<setter>(EmailQueryTextSearch_put_SearchScope), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(EmailQueryTextSearch_get_Fields), reinterpret_cast<setter>(EmailQueryTextSearch_put_Fields), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailQueryTextSearch[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailQueryTextSearch) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailQueryTextSearch) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailQueryTextSearch) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailQueryTextSearch) },
        { }};

    static PyType_Spec type_spec_EmailQueryTextSearch = {
        "winrt._winrt_windows_applicationmodel_email.EmailQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailQueryTextSearch};

    // ----- EmailRecipient class --------------------

    static PyObject* _new_EmailRecipient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipient instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipient(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailRecipient_get_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Name(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Name(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipient_get_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Address();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipient_put_Address(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipient", L"Address");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Address(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EmailRecipient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailRecipient>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailRecipient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipient[] = {
        { "_assign_array_", _assign_array_EmailRecipient, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailRecipient), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailRecipient[] = {
        { "name", reinterpret_cast<getter>(EmailRecipient_get_Name), reinterpret_cast<setter>(EmailRecipient_put_Name), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(EmailRecipient_get_Address), reinterpret_cast<setter>(EmailRecipient_put_Address), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailRecipient[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailRecipient) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailRecipient) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailRecipient) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailRecipient) },
        { }};

    static PyType_Spec type_spec_EmailRecipient = {
        "winrt._winrt_windows_applicationmodel_email.EmailRecipient",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipient};

    // ----- EmailRecipientResolutionResult class --------------------

    static PyObject* _new_EmailRecipientResolutionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EmailRecipientResolutionResult(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailRecipientResolutionResult_SetPublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"SetPublicKeys", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetPublicKeys(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailRecipientResolutionResult_put_Status(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionStatus>(arg);

            {
                auto _gil = release_gil();
                self->obj.Status(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailRecipientResolutionResult_get_PublicKeys(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.Email.EmailRecipientResolutionResult", L"PublicKeys");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PublicKeys();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailRecipientResolutionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailRecipientResolutionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailRecipientResolutionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailRecipientResolutionResult[] = {
        { "set_public_keys", reinterpret_cast<PyCFunction>(EmailRecipientResolutionResult_SetPublicKeys), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailRecipientResolutionResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailRecipientResolutionResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailRecipientResolutionResult[] = {
        { "status", reinterpret_cast<getter>(EmailRecipientResolutionResult_get_Status), reinterpret_cast<setter>(EmailRecipientResolutionResult_put_Status), nullptr, nullptr },
        { "public_keys", reinterpret_cast<getter>(EmailRecipientResolutionResult_get_PublicKeys), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_EmailRecipientResolutionResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailRecipientResolutionResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailRecipientResolutionResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailRecipientResolutionResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailRecipientResolutionResult) },
        { }};

    static PyType_Spec type_spec_EmailRecipientResolutionResult = {
        "winrt._winrt_windows_applicationmodel_email.EmailRecipientResolutionResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailRecipientResolutionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailRecipientResolutionResult};

    // ----- EmailStore class --------------------

    static PyObject* _new_EmailStore(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStore>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStore>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailStore(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailStore_CreateMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"CreateMailboxAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateMailboxAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_CreateMailboxInAccountAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"CreateMailboxAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateMailboxAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_FindMailboxesAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"FindMailboxesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindMailboxesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetConversationReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetConversationReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetConversationReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetFolderAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMailboxAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMailboxAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMailboxAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* EmailStore_GetMessageReaderWithOptions(py::wrapper::Windows::ApplicationModel::Email::EmailStore* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.Email.EmailStore", L"GetMessageReader", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Email::EmailQueryOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMessageReader(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailStore>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStore[] = {
        { "create_mailbox_async", reinterpret_cast<PyCFunction>(EmailStore_CreateMailboxAsync), METH_VARARGS, nullptr },
        { "create_mailbox_in_account_async", reinterpret_cast<PyCFunction>(EmailStore_CreateMailboxInAccountAsync), METH_VARARGS, nullptr },
        { "find_mailboxes_async", reinterpret_cast<PyCFunction>(EmailStore_FindMailboxesAsync), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(EmailStore_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(EmailStore_GetConversationReader), METH_VARARGS, nullptr },
        { "get_conversation_reader_with_options", reinterpret_cast<PyCFunction>(EmailStore_GetConversationReaderWithOptions), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(EmailStore_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_mailbox_async", reinterpret_cast<PyCFunction>(EmailStore_GetMailboxAsync), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(EmailStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(EmailStore_GetMessageReader), METH_VARARGS, nullptr },
        { "get_message_reader_with_options", reinterpret_cast<PyCFunction>(EmailStore_GetMessageReaderWithOptions), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_EmailStore, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStore), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailStore[] = {
        { }};

    static PyType_Slot _type_slots_EmailStore[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStore) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStore) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStore) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStore) },
        { }};

    static PyType_Spec type_spec_EmailStore = {
        "winrt._winrt_windows_applicationmodel_email.EmailStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStore};

    // ----- EmailStoreNotificationTriggerDetails class --------------------

    static PyObject* _new_EmailStoreNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_EmailStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailStoreNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailStoreNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_EmailStoreNotificationTriggerDetails[] = {
        { }};

    static PyType_Slot _type_slots_EmailStoreNotificationTriggerDetails[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailStoreNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailStoreNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailStoreNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailStoreNotificationTriggerDetails) },
        { }};

    static PyType_Spec type_spec_EmailStoreNotificationTriggerDetails = {
        "winrt._winrt_windows_applicationmodel_email.EmailStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Email::EmailStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailStoreNotificationTriggerDetails};

    // ----- Windows.ApplicationModel.Email Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Email");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_applicationmodel_email",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::ApplicationModel::Email

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_email(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Email;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle EmailAttachment_type{py::register_python_type(module.get(), &type_spec_EmailAttachment, object_bases.get(), inspectable_meta_type)};
    if (!EmailAttachment_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailConversation_type{py::register_python_type(module.get(), &type_spec_EmailConversation, object_bases.get(), inspectable_meta_type)};
    if (!EmailConversation_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailConversationBatch_type{py::register_python_type(module.get(), &type_spec_EmailConversationBatch, object_bases.get(), inspectable_meta_type)};
    if (!EmailConversationBatch_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailConversationReader_type{py::register_python_type(module.get(), &type_spec_EmailConversationReader, object_bases.get(), inspectable_meta_type)};
    if (!EmailConversationReader_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailFolder_type{py::register_python_type(module.get(), &type_spec_EmailFolder, object_bases.get(), inspectable_meta_type)};
    if (!EmailFolder_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailIrmInfo_type{py::register_python_type(module.get(), &type_spec_EmailIrmInfo, object_bases.get(), inspectable_meta_type)};
    if (!EmailIrmInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailIrmTemplate_type{py::register_python_type(module.get(), &type_spec_EmailIrmTemplate, object_bases.get(), inspectable_meta_type)};
    if (!EmailIrmTemplate_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailItemCounts_type{py::register_python_type(module.get(), &type_spec_EmailItemCounts, object_bases.get(), inspectable_meta_type)};
    if (!EmailItemCounts_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailbox_type{py::register_python_type(module.get(), &type_spec_EmailMailbox, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailbox_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxAction_type{py::register_python_type(module.get(), &type_spec_EmailMailboxAction, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxAction_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxAutoReply_type{py::register_python_type(module.get(), &type_spec_EmailMailboxAutoReply, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxAutoReply_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxAutoReplySettings_type{py::register_python_type(module.get(), &type_spec_EmailMailboxAutoReplySettings, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxAutoReplySettings_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxCapabilities_type{py::register_python_type(module.get(), &type_spec_EmailMailboxCapabilities, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxCapabilities_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxChange_type{py::register_python_type(module.get(), &type_spec_EmailMailboxChange, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxChange_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxChangeReader_type{py::register_python_type(module.get(), &type_spec_EmailMailboxChangeReader, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxChangeReader_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxChangeTracker_type{py::register_python_type(module.get(), &type_spec_EmailMailboxChangeTracker, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxChangeTracker_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxChangedDeferral_type{py::register_python_type(module.get(), &type_spec_EmailMailboxChangedDeferral, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxChangedDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_EmailMailboxChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxCreateFolderResult_type{py::register_python_type(module.get(), &type_spec_EmailMailboxCreateFolderResult, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxCreateFolderResult_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxPolicies_type{py::register_python_type(module.get(), &type_spec_EmailMailboxPolicies, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxPolicies_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMailboxSyncManager_type{py::register_python_type(module.get(), &type_spec_EmailMailboxSyncManager, object_bases.get(), inspectable_meta_type)};
    if (!EmailMailboxSyncManager_type)
    {
        return nullptr;
    }

    py::pyobj_handle EmailManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!EmailManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_EmailManager_Static{PyType_FromSpecWithBases(&type_spec_EmailManager_Static, EmailManager_Static_bases.get())};
    if (!type_EmailManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle EmailManager_type{py::register_python_type(module.get(), &type_spec_EmailManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EmailManager_Static.get()))};
    if (!EmailManager_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailManagerForUser_type{py::register_python_type(module.get(), &type_spec_EmailManagerForUser, object_bases.get(), inspectable_meta_type)};
    if (!EmailManagerForUser_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMeetingInfo_type{py::register_python_type(module.get(), &type_spec_EmailMeetingInfo, object_bases.get(), inspectable_meta_type)};
    if (!EmailMeetingInfo_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMessage_type{py::register_python_type(module.get(), &type_spec_EmailMessage, object_bases.get(), inspectable_meta_type)};
    if (!EmailMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMessageBatch_type{py::register_python_type(module.get(), &type_spec_EmailMessageBatch, object_bases.get(), inspectable_meta_type)};
    if (!EmailMessageBatch_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailMessageReader_type{py::register_python_type(module.get(), &type_spec_EmailMessageReader, object_bases.get(), inspectable_meta_type)};
    if (!EmailMessageReader_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailQueryOptions_type{py::register_python_type(module.get(), &type_spec_EmailQueryOptions, object_bases.get(), inspectable_meta_type)};
    if (!EmailQueryOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailQueryTextSearch_type{py::register_python_type(module.get(), &type_spec_EmailQueryTextSearch, object_bases.get(), inspectable_meta_type)};
    if (!EmailQueryTextSearch_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailRecipient_type{py::register_python_type(module.get(), &type_spec_EmailRecipient, object_bases.get(), inspectable_meta_type)};
    if (!EmailRecipient_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailRecipientResolutionResult_type{py::register_python_type(module.get(), &type_spec_EmailRecipientResolutionResult, object_bases.get(), inspectable_meta_type)};
    if (!EmailRecipientResolutionResult_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailStore_type{py::register_python_type(module.get(), &type_spec_EmailStore, object_bases.get(), inspectable_meta_type)};
    if (!EmailStore_type)
    {
        return nullptr;
    }

    py::pytype_handle EmailStoreNotificationTriggerDetails_type{py::register_python_type(module.get(), &type_spec_EmailStoreNotificationTriggerDetails, object_bases.get(), inspectable_meta_type)};
    if (!EmailStoreNotificationTriggerDetails_type)
    {
        return nullptr;
    }


    return module.detach();
}
