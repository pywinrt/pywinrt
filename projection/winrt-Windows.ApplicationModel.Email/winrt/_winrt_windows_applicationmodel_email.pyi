# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.applicationmodel.appointments
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.security.cryptography.certificates
import winrt.windows.storage.streams
import winrt.windows.system

from winrt.windows.applicationmodel.email import EmailAttachmentDownloadState, EmailBatchStatus, EmailCertificateValidationStatus, EmailFlagState, EmailImportance, EmailMailboxActionKind, EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation, EmailMailboxAutoReplyMessageResponseKind, EmailMailboxChangeType, EmailMailboxCreateFolderStatus, EmailMailboxDeleteFolderStatus, EmailMailboxEmptyFolderStatus, EmailMailboxOtherAppReadAccess, EmailMailboxOtherAppWriteAccess, EmailMailboxSmimeEncryptionAlgorithm, EmailMailboxSmimeSigningAlgorithm, EmailMailboxSyncStatus, EmailMeetingResponseType, EmailMessageBodyKind, EmailMessageDownloadState, EmailMessageResponseKind, EmailMessageSmimeKind, EmailQueryKind, EmailQuerySearchFields, EmailQuerySearchScope, EmailQuerySortDirection, EmailQuerySortProperty, EmailRecipientResolutionStatus, EmailSpecialFolderKind, EmailStoreAccessType

Self = typing.TypeVar('Self')

@typing.final
class EmailAttachment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailAttachment: ...
    @typing.overload
    def __new__(cls: typing.Type[EmailAttachment], file_name: str, data: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], mime_type: str) -> EmailAttachment:...
    @typing.overload
    def __new__(cls: typing.Type[EmailAttachment], file_name: str, data: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> EmailAttachment:...
    @typing.overload
    def __new__(cls: typing.Type[EmailAttachment]) -> EmailAttachment:...
    @_property
    def file_name(self) -> str: ...
    @file_name.setter
    def file_name(self, value: str) -> None: ...
    @_property
    def data(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @data.setter
    def data(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def mime_type(self) -> str: ...
    @mime_type.setter
    def mime_type(self, value: str) -> None: ...
    @_property
    def is_inline(self) -> bool: ...
    @is_inline.setter
    def is_inline(self, value: bool) -> None: ...
    @_property
    def estimated_download_size_in_bytes(self) -> winrt.system.UInt64: ...
    @estimated_download_size_in_bytes.setter
    def estimated_download_size_in_bytes(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def download_state(self) -> EmailAttachmentDownloadState: ...
    @download_state.setter
    def download_state(self, value: EmailAttachmentDownloadState) -> None: ...
    @_property
    def content_location(self) -> str: ...
    @content_location.setter
    def content_location(self, value: str) -> None: ...
    @_property
    def content_id(self) -> str: ...
    @content_id.setter
    def content_id(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_from_base_message(self) -> bool: ...

@typing.final
class EmailConversation(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailConversation: ...
    @typing.overload
    def find_messages_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailMessage]]: ...
    @typing.overload
    def find_messages_async(self, count: winrt.system.UInt32, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailMessage]]: ...
    @_property
    def flag_state(self) -> EmailFlagState: ...
    @_property
    def has_attachment(self) -> bool: ...
    @_property
    def id(self) -> str: ...
    @_property
    def importance(self) -> EmailImportance: ...
    @_property
    def last_email_response_kind(self) -> EmailMessageResponseKind: ...
    @_property
    def latest_sender(self) -> typing.Optional[EmailRecipient]: ...
    @_property
    def mailbox_id(self) -> str: ...
    @_property
    def message_count(self) -> winrt.system.UInt32: ...
    @_property
    def most_recent_message_id(self) -> str: ...
    @_property
    def most_recent_message_time(self) -> datetime.datetime: ...
    @_property
    def preview(self) -> str: ...
    @_property
    def subject(self) -> str: ...
    @_property
    def unread_message_count(self) -> winrt.system.UInt32: ...

@typing.final
class EmailConversationBatch(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailConversationBatch: ...
    @_property
    def conversations(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[EmailConversation]]: ...
    @_property
    def status(self) -> EmailBatchStatus: ...

@typing.final
class EmailConversationReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailConversationReader: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[EmailConversationBatch]: ...

@typing.final
class EmailFolder(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailFolder: ...
    def create_folder_async(self, name: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailFolder]: ...
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def find_child_folders_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailFolder]]: ...
    @typing.overload
    def get_conversation_reader(self) -> typing.Optional[EmailConversationReader]: ...
    @typing.overload
    def get_conversation_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailConversationReader]: ...
    def get_message_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMessage]: ...
    def get_message_counts_async(self) -> winrt.windows.foundation.IAsyncOperation[EmailItemCounts]: ...
    @typing.overload
    def get_message_reader(self) -> typing.Optional[EmailMessageReader]: ...
    @typing.overload
    def get_message_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailMessageReader]: ...
    def save_message_async(self, message: typing.Optional[EmailMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def try_move_async(self, new_parent_folder: typing.Optional[EmailFolder], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_move_async(self, new_parent_folder: typing.Optional[EmailFolder], new_folder_name: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_save_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @_property
    def remote_id(self) -> str: ...
    @remote_id.setter
    def remote_id(self, value: str) -> None: ...
    @_property
    def last_successful_sync_time(self) -> datetime.datetime: ...
    @last_successful_sync_time.setter
    def last_successful_sync_time(self, value: datetime.datetime) -> None: ...
    @_property
    def is_sync_enabled(self) -> bool: ...
    @is_sync_enabled.setter
    def is_sync_enabled(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def kind(self) -> EmailSpecialFolderKind: ...
    @_property
    def mailbox_id(self) -> str: ...
    @_property
    def parent_folder_id(self) -> str: ...

@typing.final
class EmailIrmInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailIrmInfo: ...
    @typing.overload
    def __new__(cls: typing.Type[EmailIrmInfo], expiration: datetime.datetime, irm_template: typing.Optional[EmailIrmTemplate]) -> EmailIrmInfo:...
    @typing.overload
    def __new__(cls: typing.Type[EmailIrmInfo]) -> EmailIrmInfo:...
    @_property
    def can_remove_irm_on_response(self) -> bool: ...
    @can_remove_irm_on_response.setter
    def can_remove_irm_on_response(self, value: bool) -> None: ...
    @_property
    def can_print_data(self) -> bool: ...
    @can_print_data.setter
    def can_print_data(self, value: bool) -> None: ...
    @_property
    def can_modify_recipients_on_response(self) -> bool: ...
    @can_modify_recipients_on_response.setter
    def can_modify_recipients_on_response(self, value: bool) -> None: ...
    @_property
    def can_forward(self) -> bool: ...
    @can_forward.setter
    def can_forward(self, value: bool) -> None: ...
    @_property
    def can_extract_data(self) -> bool: ...
    @can_extract_data.setter
    def can_extract_data(self, value: bool) -> None: ...
    @_property
    def can_reply(self) -> bool: ...
    @can_reply.setter
    def can_reply(self, value: bool) -> None: ...
    @_property
    def can_edit(self) -> bool: ...
    @can_edit.setter
    def can_edit(self, value: bool) -> None: ...
    @_property
    def template(self) -> typing.Optional[EmailIrmTemplate]: ...
    @template.setter
    def template(self, value: typing.Optional[EmailIrmTemplate]) -> None: ...
    @_property
    def is_programatic_access_allowed(self) -> bool: ...
    @is_programatic_access_allowed.setter
    def is_programatic_access_allowed(self, value: bool) -> None: ...
    @_property
    def is_irm_originator(self) -> bool: ...
    @is_irm_originator.setter
    def is_irm_originator(self, value: bool) -> None: ...
    @_property
    def expiration_date(self) -> datetime.datetime: ...
    @expiration_date.setter
    def expiration_date(self, value: datetime.datetime) -> None: ...
    @_property
    def can_reply_all(self) -> bool: ...
    @can_reply_all.setter
    def can_reply_all(self, value: bool) -> None: ...

@typing.final
class EmailIrmTemplate(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailIrmTemplate: ...
    @typing.overload
    def __new__(cls: typing.Type[EmailIrmTemplate], id: str, name: str, description: str) -> EmailIrmTemplate:...
    @typing.overload
    def __new__(cls: typing.Type[EmailIrmTemplate]) -> EmailIrmTemplate:...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def description(self) -> str: ...
    @description.setter
    def description(self, value: str) -> None: ...

@typing.final
class EmailItemCounts(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailItemCounts: ...
    @_property
    def flagged(self) -> winrt.system.UInt32: ...
    @_property
    def important(self) -> winrt.system.UInt32: ...
    @_property
    def total(self) -> winrt.system.UInt32: ...
    @_property
    def unread(self) -> winrt.system.UInt32: ...

@typing.final
class EmailMailbox(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailbox: ...
    def change_message_flag_state_async(self, message_id: str, flag_state: EmailFlagState, /) -> winrt.windows.foundation.IAsyncAction: ...
    def create_response_message_async(self, message_id: str, response_type: EmailMessageResponseKind, subject: str, response_header_type: EmailMessageBodyKind, response_header: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMessage]: ...
    def delete_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def delete_message_async(self, message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def download_attachment_async(self, attachment_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def download_message_async(self, message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def get_change_tracker(self, identity: str, /) -> typing.Optional[EmailMailboxChangeTracker]: ...
    def get_conversation_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailConversation]: ...
    @typing.overload
    def get_conversation_reader(self) -> typing.Optional[EmailConversationReader]: ...
    @typing.overload
    def get_conversation_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailConversationReader]: ...
    def get_folder_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailFolder]: ...
    def get_message_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMessage]: ...
    @typing.overload
    def get_message_reader(self) -> typing.Optional[EmailMessageReader]: ...
    @typing.overload
    def get_message_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailMessageReader]: ...
    def get_special_folder_async(self, folder_type: EmailSpecialFolderKind, /) -> winrt.windows.foundation.IAsyncOperation[EmailFolder]: ...
    def mark_folder_as_seen_async(self, folder_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def mark_folder_sync_enabled_async(self, folder_id: str, is_sync_enabled: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def mark_message_as_seen_async(self, message_id: str, /) -> winrt.windows.foundation.IAsyncAction: ...
    def mark_message_read_async(self, message_id: str, is_read: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def register_sync_manager_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def resolve_recipients_async(self, recipients: typing.Iterable[str], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailRecipientResolutionResult]]: ...
    def save_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def save_draft_async(self, message: typing.Optional[EmailMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def send_message_async(self, message: typing.Optional[EmailMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    @typing.overload
    def send_message_async(self, message: typing.Optional[EmailMessage], smart_send: bool, /) -> winrt.windows.foundation.IAsyncAction: ...
    def try_create_folder_async(self, parent_folder_id: str, name: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailboxCreateFolderResult]: ...
    def try_delete_folder_async(self, folder_id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailboxDeleteFolderStatus]: ...
    def try_empty_folder_async(self, folder_id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailboxEmptyFolderStatus]: ...
    def try_forward_meeting_async(self, meeting: typing.Optional[EmailMessage], recipients: typing.Iterable[EmailRecipient], subject: str, forward_header_type: EmailMessageBodyKind, forward_header: str, comment: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_get_auto_reply_settings_async(self, requested_format: EmailMailboxAutoReplyMessageResponseKind, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailboxAutoReplySettings]: ...
    @typing.overload
    def try_move_folder_async(self, folder_id: str, new_parent_folder_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    @typing.overload
    def try_move_folder_async(self, folder_id: str, new_parent_folder_id: str, new_folder_name: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_move_message_async(self, message_id: str, new_parent_folder_id: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_propose_new_time_for_meeting_async(self, meeting: typing.Optional[EmailMessage], new_start_time: datetime.datetime, new_duration: datetime.timedelta, subject: str, comment: str, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_set_auto_reply_settings_async(self, auto_reply_settings: typing.Optional[EmailMailboxAutoReplySettings], /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def try_update_meeting_response_async(self, meeting: typing.Optional[EmailMessage], response: EmailMeetingResponseType, subject: str, comment: str, send_update: bool, /) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def validate_certificates_async(self, certificates: typing.Iterable[winrt.windows.security.cryptography.certificates.Certificate], /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailCertificateValidationStatus]]: ...
    def add_mailbox_changed(self, p_handler: winrt.windows.foundation.TypedEventHandler[EmailMailbox, EmailMailboxChangedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_mailbox_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def other_app_write_access(self) -> EmailMailboxOtherAppWriteAccess: ...
    @other_app_write_access.setter
    def other_app_write_access(self, value: EmailMailboxOtherAppWriteAccess) -> None: ...
    @_property
    def mail_address(self) -> str: ...
    @mail_address.setter
    def mail_address(self, value: str) -> None: ...
    @_property
    def other_app_read_access(self) -> EmailMailboxOtherAppReadAccess: ...
    @other_app_read_access.setter
    def other_app_read_access(self, value: EmailMailboxOtherAppReadAccess) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def id(self) -> str: ...
    @_property
    def is_data_encrypted_under_lock(self) -> bool: ...
    @_property
    def is_owned_by_current_app(self) -> bool: ...
    @_property
    def mail_address_aliases(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def capabilities(self) -> typing.Optional[EmailMailboxCapabilities]: ...
    @_property
    def change_tracker(self) -> typing.Optional[EmailMailboxChangeTracker]: ...
    @_property
    def policies(self) -> typing.Optional[EmailMailboxPolicies]: ...
    @_property
    def source_display_name(self) -> str: ...
    @_property
    def sync_manager(self) -> typing.Optional[EmailMailboxSyncManager]: ...
    @_property
    def user_data_account_id(self) -> str: ...
    @_property
    def linked_mailbox_id(self) -> str: ...
    @_property
    def network_account_id(self) -> str: ...
    @_property
    def network_id(self) -> str: ...

@typing.final
class EmailMailboxAction(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxAction: ...
    @_property
    def change_number(self) -> winrt.system.UInt64: ...
    @_property
    def kind(self) -> EmailMailboxActionKind: ...

@typing.final
class EmailMailboxAutoReply(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxAutoReply: ...
    @_property
    def response(self) -> str: ...
    @response.setter
    def response(self, value: str) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...

@typing.final
class EmailMailboxAutoReplySettings(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxAutoReplySettings: ...
    def __new__(cls: typing.Type[EmailMailboxAutoReplySettings]) -> EmailMailboxAutoReplySettings:...
    @_property
    def start_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @start_time.setter
    def start_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def response_kind(self) -> EmailMailboxAutoReplyMessageResponseKind: ...
    @response_kind.setter
    def response_kind(self, value: EmailMailboxAutoReplyMessageResponseKind) -> None: ...
    @_property
    def is_enabled(self) -> bool: ...
    @is_enabled.setter
    def is_enabled(self, value: bool) -> None: ...
    @_property
    def end_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @end_time.setter
    def end_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def internal_reply(self) -> typing.Optional[EmailMailboxAutoReply]: ...
    @_property
    def known_external_reply(self) -> typing.Optional[EmailMailboxAutoReply]: ...
    @_property
    def unknown_external_reply(self) -> typing.Optional[EmailMailboxAutoReply]: ...

@typing.final
class EmailMailboxCapabilities(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxCapabilities: ...
    @_property
    def can_smart_send(self) -> bool: ...
    @can_smart_send.setter
    def can_smart_send(self, value: bool) -> None: ...
    @_property
    def can_update_meeting_responses(self) -> bool: ...
    @can_update_meeting_responses.setter
    def can_update_meeting_responses(self, value: bool) -> None: ...
    @_property
    def can_server_search_mailbox(self) -> bool: ...
    @can_server_search_mailbox.setter
    def can_server_search_mailbox(self, value: bool) -> None: ...
    @_property
    def can_server_search_folders(self) -> bool: ...
    @can_server_search_folders.setter
    def can_server_search_folders(self, value: bool) -> None: ...
    @_property
    def can_forward_meetings(self) -> bool: ...
    @can_forward_meetings.setter
    def can_forward_meetings(self, value: bool) -> None: ...
    @_property
    def can_propose_new_time_for_meetings(self) -> bool: ...
    @can_propose_new_time_for_meetings.setter
    def can_propose_new_time_for_meetings(self, value: bool) -> None: ...
    @_property
    def can_get_and_set_internal_auto_replies(self) -> bool: ...
    @can_get_and_set_internal_auto_replies.setter
    def can_get_and_set_internal_auto_replies(self, value: bool) -> None: ...
    @_property
    def can_get_and_set_external_auto_replies(self) -> bool: ...
    @can_get_and_set_external_auto_replies.setter
    def can_get_and_set_external_auto_replies(self, value: bool) -> None: ...
    @_property
    def can_validate_certificates(self) -> bool: ...
    @can_validate_certificates.setter
    def can_validate_certificates(self, value: bool) -> None: ...
    @_property
    def can_resolve_recipients(self) -> bool: ...
    @can_resolve_recipients.setter
    def can_resolve_recipients(self, value: bool) -> None: ...
    @_property
    def can_move_folder(self) -> bool: ...
    @can_move_folder.setter
    def can_move_folder(self, value: bool) -> None: ...
    @_property
    def can_empty_folder(self) -> bool: ...
    @can_empty_folder.setter
    def can_empty_folder(self, value: bool) -> None: ...
    @_property
    def can_delete_folder(self) -> bool: ...
    @can_delete_folder.setter
    def can_delete_folder(self, value: bool) -> None: ...
    @_property
    def can_create_folder(self) -> bool: ...
    @can_create_folder.setter
    def can_create_folder(self, value: bool) -> None: ...

@typing.final
class EmailMailboxChange(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxChange: ...
    @_property
    def change_type(self) -> EmailMailboxChangeType: ...
    @_property
    def folder(self) -> typing.Optional[EmailFolder]: ...
    @_property
    def mailbox_actions(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailMailboxAction]]: ...
    @_property
    def message(self) -> typing.Optional[EmailMessage]: ...

@typing.final
class EmailMailboxChangeReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxChangeReader: ...
    def accept_changes(self) -> None: ...
    def accept_changes_through(self, last_change_to_acknowledge: typing.Optional[EmailMailboxChange], /) -> None: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailMailboxChange]]: ...

@typing.final
class EmailMailboxChangeTracker(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxChangeTracker: ...
    def enable(self) -> None: ...
    def get_change_reader(self) -> typing.Optional[EmailMailboxChangeReader]: ...
    def reset(self) -> None: ...
    @_property
    def is_tracking(self) -> bool: ...

@typing.final
class EmailMailboxChangedDeferral(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxChangedDeferral: ...
    def complete(self) -> None: ...

@typing.final
class EmailMailboxChangedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxChangedEventArgs: ...
    def get_deferral(self) -> typing.Optional[EmailMailboxChangedDeferral]: ...

@typing.final
class EmailMailboxCreateFolderResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxCreateFolderResult: ...
    @_property
    def folder(self) -> typing.Optional[EmailFolder]: ...
    @_property
    def status(self) -> EmailMailboxCreateFolderStatus: ...

@typing.final
class EmailMailboxPolicies(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxPolicies: ...
    @_property
    def required_smime_signing_algorithm(self) -> typing.Optional[typing.Optional[EmailMailboxSmimeSigningAlgorithm]]: ...
    @required_smime_signing_algorithm.setter
    def required_smime_signing_algorithm(self, value: typing.Optional[typing.Optional[EmailMailboxSmimeSigningAlgorithm]]) -> None: ...
    @_property
    def required_smime_encryption_algorithm(self) -> typing.Optional[typing.Optional[EmailMailboxSmimeEncryptionAlgorithm]]: ...
    @required_smime_encryption_algorithm.setter
    def required_smime_encryption_algorithm(self, value: typing.Optional[typing.Optional[EmailMailboxSmimeEncryptionAlgorithm]]) -> None: ...
    @_property
    def allowed_smime_encryption_algorithm_negotiation(self) -> EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation: ...
    @allowed_smime_encryption_algorithm_negotiation.setter
    def allowed_smime_encryption_algorithm_negotiation(self, value: EmailMailboxAllowedSmimeEncryptionAlgorithmNegotiation) -> None: ...
    @_property
    def allow_smime_soft_certificates(self) -> bool: ...
    @allow_smime_soft_certificates.setter
    def allow_smime_soft_certificates(self, value: bool) -> None: ...
    @_property
    def must_sign_smime_messages(self) -> bool: ...
    @must_sign_smime_messages.setter
    def must_sign_smime_messages(self, value: bool) -> None: ...
    @_property
    def must_encrypt_smime_messages(self) -> bool: ...
    @must_encrypt_smime_messages.setter
    def must_encrypt_smime_messages(self, value: bool) -> None: ...

@typing.final
class EmailMailboxSyncManager(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMailboxSyncManager: ...
    def sync_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def add_sync_status_changed(self, handler: winrt.windows.foundation.TypedEventHandler[EmailMailboxSyncManager, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_sync_status_changed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def status(self) -> EmailMailboxSyncStatus: ...
    @status.setter
    def status(self, value: EmailMailboxSyncStatus) -> None: ...
    @_property
    def last_successful_sync_time(self) -> datetime.datetime: ...
    @last_successful_sync_time.setter
    def last_successful_sync_time(self, value: datetime.datetime) -> None: ...
    @_property
    def last_attempted_sync_time(self) -> datetime.datetime: ...
    @last_attempted_sync_time.setter
    def last_attempted_sync_time(self, value: datetime.datetime) -> None: ...

@typing.final
class EmailManager_Static(type):
    def get_for_user(cls, user: typing.Optional[winrt.windows.system.User], /) -> typing.Optional[EmailManagerForUser]: ...
    def request_store_async(cls, access_type: EmailStoreAccessType, /) -> winrt.windows.foundation.IAsyncOperation[EmailStore]: ...
    def show_compose_new_email_async(cls, message: typing.Optional[EmailMessage], /) -> winrt.windows.foundation.IAsyncAction: ...

@typing.final
class EmailManager(winrt.system.Object, metaclass=EmailManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailManager: ...

@typing.final
class EmailManagerForUser(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailManagerForUser: ...
    def request_store_async(self, access_type: EmailStoreAccessType, /) -> winrt.windows.foundation.IAsyncOperation[EmailStore]: ...
    def show_compose_new_email_async(self, message: typing.Optional[EmailMessage], /) -> winrt.windows.foundation.IAsyncAction: ...
    @_property
    def user(self) -> typing.Optional[winrt.windows.system.User]: ...

@typing.final
class EmailMeetingInfo(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMeetingInfo: ...
    def __new__(cls: typing.Type[EmailMeetingInfo]) -> EmailMeetingInfo:...
    @_property
    def location(self) -> str: ...
    @location.setter
    def location(self, value: str) -> None: ...
    @_property
    def is_response_requested(self) -> bool: ...
    @is_response_requested.setter
    def is_response_requested(self, value: bool) -> None: ...
    @_property
    def is_all_day(self) -> bool: ...
    @is_all_day.setter
    def is_all_day(self, value: bool) -> None: ...
    @_property
    def allow_new_time_proposal(self) -> bool: ...
    @allow_new_time_proposal.setter
    def allow_new_time_proposal(self, value: bool) -> None: ...
    @_property
    def duration(self) -> datetime.timedelta: ...
    @duration.setter
    def duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def appointment_roaming_id(self) -> str: ...
    @appointment_roaming_id.setter
    def appointment_roaming_id(self, value: str) -> None: ...
    @_property
    def appointment_original_start_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @appointment_original_start_time.setter
    def appointment_original_start_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def proposed_duration(self) -> typing.Optional[typing.Optional[datetime.timedelta]]: ...
    @proposed_duration.setter
    def proposed_duration(self, value: typing.Optional[typing.Optional[datetime.timedelta]]) -> None: ...
    @_property
    def remote_change_number(self) -> winrt.system.UInt64: ...
    @remote_change_number.setter
    def remote_change_number(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def start_time(self) -> datetime.datetime: ...
    @start_time.setter
    def start_time(self, value: datetime.datetime) -> None: ...
    @_property
    def recurrence_start_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @recurrence_start_time.setter
    def recurrence_start_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def recurrence(self) -> typing.Optional[winrt.windows.applicationmodel.appointments.AppointmentRecurrence]: ...
    @recurrence.setter
    def recurrence(self, value: typing.Optional[winrt.windows.applicationmodel.appointments.AppointmentRecurrence]) -> None: ...
    @_property
    def proposed_start_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @proposed_start_time.setter
    def proposed_start_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def is_reported_out_of_date_by_server(self) -> bool: ...

@typing.final
class EmailMessage(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMessage: ...
    def __new__(cls: typing.Type[EmailMessage]) -> EmailMessage:...
    def get_body_stream(self, type: EmailMessageBodyKind, /) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    def set_body_stream(self, type: EmailMessageBodyKind, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference], /) -> None: ...
    @_property
    def subject(self) -> str: ...
    @subject.setter
    def subject(self, value: str) -> None: ...
    @_property
    def body(self) -> str: ...
    @body.setter
    def body(self, value: str) -> None: ...
    @_property
    def bcc(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailRecipient]]: ...
    @_property
    def c_c(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailRecipient]]: ...
    @_property
    def attachments(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailAttachment]]: ...
    @_property
    def to(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailRecipient]]: ...
    @_property
    def allow_internet_images(self) -> bool: ...
    @allow_internet_images.setter
    def allow_internet_images(self, value: bool) -> None: ...
    @_property
    def flag_state(self) -> EmailFlagState: ...
    @flag_state.setter
    def flag_state(self, value: EmailFlagState) -> None: ...
    @_property
    def estimated_download_size_in_bytes(self) -> winrt.system.UInt32: ...
    @estimated_download_size_in_bytes.setter
    def estimated_download_size_in_bytes(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def download_state(self) -> EmailMessageDownloadState: ...
    @download_state.setter
    def download_state(self, value: EmailMessageDownloadState) -> None: ...
    @_property
    def importance(self) -> EmailImportance: ...
    @importance.setter
    def importance(self, value: EmailImportance) -> None: ...
    @_property
    def irm_info(self) -> typing.Optional[EmailIrmInfo]: ...
    @irm_info.setter
    def irm_info(self, value: typing.Optional[EmailIrmInfo]) -> None: ...
    @_property
    def original_code_page(self) -> winrt.system.Int32: ...
    @original_code_page.setter
    def original_code_page(self, value: winrt.system.Int32) -> None: ...
    @_property
    def sent_time(self) -> typing.Optional[typing.Optional[datetime.datetime]]: ...
    @sent_time.setter
    def sent_time(self, value: typing.Optional[typing.Optional[datetime.datetime]]) -> None: ...
    @_property
    def sender(self) -> typing.Optional[EmailRecipient]: ...
    @sender.setter
    def sender(self, value: typing.Optional[EmailRecipient]) -> None: ...
    @_property
    def remote_id(self) -> str: ...
    @remote_id.setter
    def remote_id(self, value: str) -> None: ...
    @_property
    def preview(self) -> str: ...
    @preview.setter
    def preview(self, value: str) -> None: ...
    @_property
    def message_class(self) -> str: ...
    @message_class.setter
    def message_class(self, value: str) -> None: ...
    @_property
    def meeting_info(self) -> typing.Optional[EmailMeetingInfo]: ...
    @meeting_info.setter
    def meeting_info(self, value: typing.Optional[EmailMeetingInfo]) -> None: ...
    @_property
    def last_response_kind(self) -> EmailMessageResponseKind: ...
    @last_response_kind.setter
    def last_response_kind(self, value: EmailMessageResponseKind) -> None: ...
    @_property
    def is_seen(self) -> bool: ...
    @is_seen.setter
    def is_seen(self, value: bool) -> None: ...
    @_property
    def is_read(self) -> bool: ...
    @is_read.setter
    def is_read(self, value: bool) -> None: ...
    @_property
    def is_server_search_message(self) -> bool: ...
    @_property
    def is_smart_sendable(self) -> bool: ...
    @_property
    def mailbox_id(self) -> str: ...
    @_property
    def change_number(self) -> winrt.system.UInt64: ...
    @_property
    def conversation_id(self) -> str: ...
    @_property
    def normalized_subject(self) -> str: ...
    @_property
    def folder_id(self) -> str: ...
    @_property
    def has_partial_bodies(self) -> bool: ...
    @_property
    def id(self) -> str: ...
    @_property
    def in_response_to_message_id(self) -> str: ...
    @_property
    def is_draft_message(self) -> bool: ...
    @_property
    def smime_kind(self) -> EmailMessageSmimeKind: ...
    @smime_kind.setter
    def smime_kind(self, value: EmailMessageSmimeKind) -> None: ...
    @_property
    def smime_data(self) -> typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]: ...
    @smime_data.setter
    def smime_data(self, value: typing.Optional[winrt.windows.storage.streams.IRandomAccessStreamReference]) -> None: ...
    @_property
    def sent_representing(self) -> typing.Optional[EmailRecipient]: ...
    @sent_representing.setter
    def sent_representing(self, value: typing.Optional[EmailRecipient]) -> None: ...
    @_property
    def reply_to(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[EmailRecipient]]: ...

@typing.final
class EmailMessageBatch(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMessageBatch: ...
    @_property
    def messages(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[EmailMessage]]: ...
    @_property
    def status(self) -> EmailBatchStatus: ...

@typing.final
class EmailMessageReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailMessageReader: ...
    def read_batch_async(self) -> winrt.windows.foundation.IAsyncOperation[EmailMessageBatch]: ...

@typing.final
class EmailQueryOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailQueryOptions: ...
    @typing.overload
    def __new__(cls: typing.Type[EmailQueryOptions], text: str) -> EmailQueryOptions:...
    @typing.overload
    def __new__(cls: typing.Type[EmailQueryOptions], text: str, fields: EmailQuerySearchFields) -> EmailQueryOptions:...
    @typing.overload
    def __new__(cls: typing.Type[EmailQueryOptions]) -> EmailQueryOptions:...
    @_property
    def sort_property(self) -> EmailQuerySortProperty: ...
    @sort_property.setter
    def sort_property(self, value: EmailQuerySortProperty) -> None: ...
    @_property
    def sort_direction(self) -> EmailQuerySortDirection: ...
    @sort_direction.setter
    def sort_direction(self, value: EmailQuerySortDirection) -> None: ...
    @_property
    def kind(self) -> EmailQueryKind: ...
    @kind.setter
    def kind(self, value: EmailQueryKind) -> None: ...
    @_property
    def folder_ids(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def text_search(self) -> typing.Optional[EmailQueryTextSearch]: ...

@typing.final
class EmailQueryTextSearch(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailQueryTextSearch: ...
    @_property
    def text(self) -> str: ...
    @text.setter
    def text(self, value: str) -> None: ...
    @_property
    def search_scope(self) -> EmailQuerySearchScope: ...
    @search_scope.setter
    def search_scope(self, value: EmailQuerySearchScope) -> None: ...
    @_property
    def fields(self) -> EmailQuerySearchFields: ...
    @fields.setter
    def fields(self, value: EmailQuerySearchFields) -> None: ...

@typing.final
class EmailRecipient(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailRecipient: ...
    @typing.overload
    def __new__(cls: typing.Type[EmailRecipient], address: str) -> EmailRecipient:...
    @typing.overload
    def __new__(cls: typing.Type[EmailRecipient], address: str, name: str) -> EmailRecipient:...
    @typing.overload
    def __new__(cls: typing.Type[EmailRecipient]) -> EmailRecipient:...
    @_property
    def name(self) -> str: ...
    @name.setter
    def name(self, value: str) -> None: ...
    @_property
    def address(self) -> str: ...
    @address.setter
    def address(self, value: str) -> None: ...

@typing.final
class EmailRecipientResolutionResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailRecipientResolutionResult: ...
    def __new__(cls: typing.Type[EmailRecipientResolutionResult]) -> EmailRecipientResolutionResult:...
    def set_public_keys(self, value: typing.Iterable[winrt.windows.security.cryptography.certificates.Certificate], /) -> None: ...
    @_property
    def status(self) -> EmailRecipientResolutionStatus: ...
    @status.setter
    def status(self, value: EmailRecipientResolutionStatus) -> None: ...
    @_property
    def public_keys(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.security.cryptography.certificates.Certificate]]: ...

@typing.final
class EmailStore(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailStore: ...
    @typing.overload
    def create_mailbox_async(self, account_name: str, account_address: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailbox]: ...
    @typing.overload
    def create_mailbox_async(self, account_name: str, account_address: str, user_data_account_id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailbox]: ...
    def find_mailboxes_async(self) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[EmailMailbox]]: ...
    def get_conversation_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailConversation]: ...
    @typing.overload
    def get_conversation_reader(self) -> typing.Optional[EmailConversationReader]: ...
    @typing.overload
    def get_conversation_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailConversationReader]: ...
    def get_folder_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailFolder]: ...
    def get_mailbox_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMailbox]: ...
    def get_message_async(self, id: str, /) -> winrt.windows.foundation.IAsyncOperation[EmailMessage]: ...
    @typing.overload
    def get_message_reader(self) -> typing.Optional[EmailMessageReader]: ...
    @typing.overload
    def get_message_reader(self, options: typing.Optional[EmailQueryOptions], /) -> typing.Optional[EmailMessageReader]: ...

@typing.final
class EmailStoreNotificationTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EmailStoreNotificationTriggerDetails: ...

