// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.ViewManagement.h"


namespace py::cpp::Windows::UI::ViewManagement
{
    // ----- AccessibilitySettings class --------------------

    static PyObject* _new_AccessibilitySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::AccessibilitySettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessibilitySettings(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessibilitySettings_get_HighContrast(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.AccessibilitySettings", L"HighContrast"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_get_HighContrastScheme(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.AccessibilitySettings", L"HighContrastScheme"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HighContrastScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_add_HighContrastChanged(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.AccessibilitySettings", L"HighContrastChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::AccessibilitySettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HighContrastChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_remove_HighContrastChanged(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.AccessibilitySettings", L"HighContrastChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HighContrastChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AccessibilitySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::AccessibilitySettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AccessibilitySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::AccessibilitySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessibilitySettings[] = {
        { "add_high_contrast_changed", reinterpret_cast<PyCFunction>(AccessibilitySettings_add_HighContrastChanged), METH_O, nullptr },
        { "remove_high_contrast_changed", reinterpret_cast<PyCFunction>(AccessibilitySettings_remove_HighContrastChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AccessibilitySettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessibilitySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessibilitySettings[] = {
        { "high_contrast", reinterpret_cast<getter>(AccessibilitySettings_get_HighContrast), nullptr, nullptr, nullptr },
        { "high_contrast_scheme", reinterpret_cast<getter>(AccessibilitySettings_get_HighContrastScheme), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccessibilitySettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessibilitySettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AccessibilitySettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessibilitySettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessibilitySettings) },
        { },
    };

    static PyType_Spec type_spec_AccessibilitySettings =
    {
        "winrt._winrt_windows_ui_viewmanagement.AccessibilitySettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessibilitySettings
    };

    // ----- ActivationViewSwitcher class --------------------

    static PyObject* _new_ActivationViewSwitcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivationViewSwitcher(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationViewSwitcher_IsViewPresentedOnActivationVirtualDesktop(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ActivationViewSwitcher", L"IsViewPresentedOnActivationVirtualDesktop", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.IsViewPresentedOnActivationVirtualDesktop(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationViewSwitcher_ShowAsStandaloneAsync(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ActivationViewSwitcher", L"ShowAsStandaloneAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ShowAsStandaloneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ActivationViewSwitcher", L"ShowAsStandaloneAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);

                return py::convert(self->obj.ShowAsStandaloneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivationViewSwitcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivationViewSwitcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationViewSwitcher[] = {
        { "is_view_presented_on_activation_virtual_desktop", reinterpret_cast<PyCFunction>(ActivationViewSwitcher_IsViewPresentedOnActivationVirtualDesktop), METH_VARARGS, nullptr },
        { "show_as_standalone_async", reinterpret_cast<PyCFunction>(ActivationViewSwitcher_ShowAsStandaloneAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivationViewSwitcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationViewSwitcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationViewSwitcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivationViewSwitcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivationViewSwitcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivationViewSwitcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivationViewSwitcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivationViewSwitcher) },
        { },
    };

    static PyType_Spec type_spec_ActivationViewSwitcher =
    {
        "winrt._winrt_windows_ui_viewmanagement.ActivationViewSwitcher",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationViewSwitcher
    };

    // ----- ApplicationView class --------------------

    static PyObject* _new_ApplicationView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationView>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationView(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationView_ClearAllPersistedState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"ClearAllPersistedState", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::UI::ViewManagement::ApplicationView::ClearAllPersistedState();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ClearPersistedState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"ClearPersistedState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::ViewManagement::ApplicationView::ClearPersistedState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ExitFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"ExitFullScreenMode", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ExitFullScreenMode();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetApplicationViewIdForWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"GetApplicationViewIdForWindow", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Core::ICoreWindow>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::GetApplicationViewIdForWindow(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetDisplayRegions(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"GetDisplayRegions", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDisplayRegions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_IsViewModeSupported(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsViewModeSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(self->obj.IsViewModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_SetDesiredBoundsMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"SetDesiredBoundsMode", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewBoundsMode>(args, 0);

                return py::convert(self->obj.SetDesiredBoundsMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_SetPreferredMinSize(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"SetPreferredMinSize", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetPreferredMinSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ShowStandardSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"ShowStandardSystemOverlays", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ShowStandardSystemOverlays();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryConsolidateAsync(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryConsolidateAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryConsolidateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryEnterFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryEnterFullScreenMode", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryEnterFullScreenMode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryEnterViewModeAsync(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryEnterViewModeAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(self->obj.TryEnterViewModeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryEnterViewModeAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewModePreferences>(args, 1);

                return py::convert(self->obj.TryEnterViewModeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryResizeView(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryResizeView", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.TryResizeView(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryUnsnap(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryUnsnap", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TryUnsnap());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryUnsnapToFullscreen(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TryUnsnapToFullscreen", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TryUnsnapToFullscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Title(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_Title(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_IsScreenCaptureEnabled(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsScreenCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsScreenCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_IsScreenCaptureEnabled(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsScreenCaptureEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsScreenCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_AdjacentToLeftDisplayEdge(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"AdjacentToLeftDisplayEdge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdjacentToLeftDisplayEdge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_AdjacentToRightDisplayEdge(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"AdjacentToRightDisplayEdge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdjacentToRightDisplayEdge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Id(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsFullScreen(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsFullScreen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsOnLockScreen(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsOnLockScreen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOnLockScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Orientation(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Orientation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_SuppressSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"SuppressSystemOverlays"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SuppressSystemOverlays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_SuppressSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"SuppressSystemOverlays"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressSystemOverlays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_VisibleBounds(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"VisibleBounds"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VisibleBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_DesiredBoundsMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"DesiredBoundsMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredBoundsMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_FullScreenSystemOverlayMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"FullScreenSystemOverlayMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FullScreenSystemOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_FullScreenSystemOverlayMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"FullScreenSystemOverlayMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::FullScreenSystemOverlayMode>(arg);

            self->obj.FullScreenSystemOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_TitleBar(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TitleBar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TitleBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"IsFullScreenMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullScreenMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_ViewMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"ViewMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_PersistedStateId(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PersistedStateId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PersistedStateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_PersistedStateId(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PersistedStateId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PersistedStateId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_WindowingEnvironment(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"WindowingEnvironment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WindowingEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_UIContext(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"UIContext"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Value(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Value"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_TerminateAppOnFinalViewClose(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TerminateAppOnFinalViewClose"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TerminateAppOnFinalViewClose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_TerminateAppOnFinalViewClose(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"TerminateAppOnFinalViewClose"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::TerminateAppOnFinalViewClose(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_PreferredLaunchWindowingMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PreferredLaunchWindowingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchWindowingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_PreferredLaunchWindowingMode(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PreferredLaunchWindowingMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewWindowingMode>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchWindowingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_PreferredLaunchViewSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PreferredLaunchViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_PreferredLaunchViewSize(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationView", L"PreferredLaunchViewSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchViewSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_add_Consolidated(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Consolidated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::ApplicationView, winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>>(arg);

            return py::convert(self->obj.Consolidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_remove_Consolidated(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ApplicationView", L"Consolidated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Consolidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_add_VisibleBoundsChanged(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ApplicationView", L"VisibleBoundsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::ApplicationView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VisibleBoundsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_remove_VisibleBoundsChanged(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ApplicationView", L"VisibleBoundsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibleBoundsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ApplicationView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationView[] = {
        { "exit_full_screen_mode", reinterpret_cast<PyCFunction>(ApplicationView_ExitFullScreenMode), METH_VARARGS, nullptr },
        { "get_display_regions", reinterpret_cast<PyCFunction>(ApplicationView_GetDisplayRegions), METH_VARARGS, nullptr },
        { "is_view_mode_supported", reinterpret_cast<PyCFunction>(ApplicationView_IsViewModeSupported), METH_VARARGS, nullptr },
        { "set_desired_bounds_mode", reinterpret_cast<PyCFunction>(ApplicationView_SetDesiredBoundsMode), METH_VARARGS, nullptr },
        { "set_preferred_min_size", reinterpret_cast<PyCFunction>(ApplicationView_SetPreferredMinSize), METH_VARARGS, nullptr },
        { "show_standard_system_overlays", reinterpret_cast<PyCFunction>(ApplicationView_ShowStandardSystemOverlays), METH_VARARGS, nullptr },
        { "try_consolidate_async", reinterpret_cast<PyCFunction>(ApplicationView_TryConsolidateAsync), METH_VARARGS, nullptr },
        { "try_enter_full_screen_mode", reinterpret_cast<PyCFunction>(ApplicationView_TryEnterFullScreenMode), METH_VARARGS, nullptr },
        { "try_enter_view_mode_async", reinterpret_cast<PyCFunction>(ApplicationView_TryEnterViewModeAsync), METH_VARARGS, nullptr },
        { "try_resize_view", reinterpret_cast<PyCFunction>(ApplicationView_TryResizeView), METH_VARARGS, nullptr },
        { "add_consolidated", reinterpret_cast<PyCFunction>(ApplicationView_add_Consolidated), METH_O, nullptr },
        { "remove_consolidated", reinterpret_cast<PyCFunction>(ApplicationView_remove_Consolidated), METH_O, nullptr },
        { "add_visible_bounds_changed", reinterpret_cast<PyCFunction>(ApplicationView_add_VisibleBoundsChanged), METH_O, nullptr },
        { "remove_visible_bounds_changed", reinterpret_cast<PyCFunction>(ApplicationView_remove_VisibleBoundsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ApplicationView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationView[] = {
        { "title", reinterpret_cast<getter>(ApplicationView_get_Title), reinterpret_cast<setter>(ApplicationView_put_Title), nullptr, nullptr },
        { "is_screen_capture_enabled", reinterpret_cast<getter>(ApplicationView_get_IsScreenCaptureEnabled), reinterpret_cast<setter>(ApplicationView_put_IsScreenCaptureEnabled), nullptr, nullptr },
        { "adjacent_to_left_display_edge", reinterpret_cast<getter>(ApplicationView_get_AdjacentToLeftDisplayEdge), nullptr, nullptr, nullptr },
        { "adjacent_to_right_display_edge", reinterpret_cast<getter>(ApplicationView_get_AdjacentToRightDisplayEdge), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ApplicationView_get_Id), nullptr, nullptr, nullptr },
        { "is_full_screen", reinterpret_cast<getter>(ApplicationView_get_IsFullScreen), nullptr, nullptr, nullptr },
        { "is_on_lock_screen", reinterpret_cast<getter>(ApplicationView_get_IsOnLockScreen), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ApplicationView_get_Orientation), nullptr, nullptr, nullptr },
        { "suppress_system_overlays", reinterpret_cast<getter>(ApplicationView_get_SuppressSystemOverlays), reinterpret_cast<setter>(ApplicationView_put_SuppressSystemOverlays), nullptr, nullptr },
        { "visible_bounds", reinterpret_cast<getter>(ApplicationView_get_VisibleBounds), nullptr, nullptr, nullptr },
        { "desired_bounds_mode", reinterpret_cast<getter>(ApplicationView_get_DesiredBoundsMode), nullptr, nullptr, nullptr },
        { "full_screen_system_overlay_mode", reinterpret_cast<getter>(ApplicationView_get_FullScreenSystemOverlayMode), reinterpret_cast<setter>(ApplicationView_put_FullScreenSystemOverlayMode), nullptr, nullptr },
        { "title_bar", reinterpret_cast<getter>(ApplicationView_get_TitleBar), nullptr, nullptr, nullptr },
        { "is_full_screen_mode", reinterpret_cast<getter>(ApplicationView_get_IsFullScreenMode), nullptr, nullptr, nullptr },
        { "view_mode", reinterpret_cast<getter>(ApplicationView_get_ViewMode), nullptr, nullptr, nullptr },
        { "persisted_state_id", reinterpret_cast<getter>(ApplicationView_get_PersistedStateId), reinterpret_cast<setter>(ApplicationView_put_PersistedStateId), nullptr, nullptr },
        { "windowing_environment", reinterpret_cast<getter>(ApplicationView_get_WindowingEnvironment), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(ApplicationView_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationView) },
        { },
    };

    static PyType_Spec type_spec_ApplicationView =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationView",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationView
    };

    static PyGetSetDef getset_ApplicationView_Static[] = {
        { "value", reinterpret_cast<getter>(ApplicationView_get_Value), nullptr, nullptr, nullptr },
        { "terminate_app_on_final_view_close", reinterpret_cast<getter>(ApplicationView_get_TerminateAppOnFinalViewClose), reinterpret_cast<setter>(ApplicationView_put_TerminateAppOnFinalViewClose), nullptr, nullptr },
        { "preferred_launch_windowing_mode", reinterpret_cast<getter>(ApplicationView_get_PreferredLaunchWindowingMode), reinterpret_cast<setter>(ApplicationView_put_PreferredLaunchWindowingMode), nullptr, nullptr },
        { "preferred_launch_view_size", reinterpret_cast<getter>(ApplicationView_get_PreferredLaunchViewSize), reinterpret_cast<setter>(ApplicationView_put_PreferredLaunchViewSize), nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ApplicationView_Static[] = {
        { "clear_all_persisted_state", reinterpret_cast<PyCFunction>(ApplicationView_ClearAllPersistedState), METH_VARARGS, nullptr },
        { "clear_persisted_state", reinterpret_cast<PyCFunction>(ApplicationView_ClearPersistedState), METH_VARARGS, nullptr },
        { "get_application_view_id_for_window", reinterpret_cast<PyCFunction>(ApplicationView_GetApplicationViewIdForWindow), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ApplicationView_GetForCurrentView), METH_VARARGS, nullptr },
        { "try_unsnap", reinterpret_cast<PyCFunction>(ApplicationView_TryUnsnap), METH_VARARGS, nullptr },
        { "try_unsnap_to_fullscreen", reinterpret_cast<PyCFunction>(ApplicationView_TryUnsnapToFullscreen), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ApplicationView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationView_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationView_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationView_Static
    };

    // ----- ApplicationViewConsolidatedEventArgs class --------------------

    static PyObject* _new_ApplicationViewConsolidatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationViewConsolidatedEventArgs(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewConsolidatedEventArgs_get_IsUserInitiated(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs", L"IsUserInitiated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationViewConsolidatedEventArgs_get_IsAppInitiated(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewConsolidatedEventArgs", L"IsAppInitiated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAppInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationViewConsolidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationViewConsolidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewConsolidatedEventArgs[] = {
        { "_assign_array_", _assign_array_ApplicationViewConsolidatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewConsolidatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewConsolidatedEventArgs[] = {
        { "is_user_initiated", reinterpret_cast<getter>(ApplicationViewConsolidatedEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "is_app_initiated", reinterpret_cast<getter>(ApplicationViewConsolidatedEventArgs_get_IsAppInitiated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewConsolidatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationViewConsolidatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationViewConsolidatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationViewConsolidatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationViewConsolidatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewConsolidatedEventArgs =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewConsolidatedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewConsolidatedEventArgs
    };

    // ----- ApplicationViewScaling class --------------------

    static PyObject* _new_ApplicationViewScaling(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationViewScaling(py::wrapper::Windows::UI::ViewManagement::ApplicationViewScaling* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewScaling_TrySetDisableLayoutScaling(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewScaling", L"TrySetDisableLayoutScaling", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewScaling::TrySetDisableLayoutScaling(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewScaling_get_DisableLayoutScaling(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewScaling", L"DisableLayoutScaling"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewScaling::DisableLayoutScaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationViewScaling(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationViewScaling(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewScaling[] = {
        { "_assign_array_", _assign_array_ApplicationViewScaling, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewScaling), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewScaling[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewScaling[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationViewScaling) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationViewScaling) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationViewScaling) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationViewScaling) },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewScaling =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewScaling",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewScaling),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewScaling
    };

    static PyGetSetDef getset_ApplicationViewScaling_Static[] = {
        { "disable_layout_scaling", reinterpret_cast<getter>(ApplicationViewScaling_get_DisableLayoutScaling), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ApplicationViewScaling_Static[] = {
        { "try_set_disable_layout_scaling", reinterpret_cast<PyCFunction>(ApplicationViewScaling_TrySetDisableLayoutScaling), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ApplicationViewScaling_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationViewScaling_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationViewScaling_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationViewScaling_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewScaling_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationViewScaling_Static
    };

    // ----- ApplicationViewSwitcher class --------------------

    static PyObject* _new_ApplicationViewSwitcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher>::type_name);
        return nullptr;
    }

    static PyObject* ApplicationViewSwitcher_DisableShowingMainViewOnActivation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"DisableShowingMainViewOnActivation", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::DisableShowingMainViewOnActivation();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_DisableSystemViewActivationPolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"DisableSystemViewActivationPolicy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::DisableSystemViewActivationPolicy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_PrepareForCustomAnimatedSwitchAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"PrepareForCustomAnimatedSwitchAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::PrepareForCustomAnimatedSwitchAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_SwitchAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"SwitchAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"SwitchAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"SwitchAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_TryShowAsStandaloneAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"TryShowAsStandaloneAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"TryShowAsStandaloneAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"TryShowAsStandaloneAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 3);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_TryShowAsViewModeAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"TryShowAsViewModeAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsViewModeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ApplicationViewSwitcher", L"TryShowAsViewModeAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewModePreferences>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsViewModeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewSwitcher[] = {
        { }
    };

    static PyGetSetDef _getset_ApplicationViewSwitcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewSwitcher[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationViewSwitcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationViewSwitcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationViewSwitcher) },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewSwitcher =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewSwitcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewSwitcher
    };

    static PyGetSetDef getset_ApplicationViewSwitcher_Static[] = {
        { }
    };

    static PyMethodDef methods_ApplicationViewSwitcher_Static[] = {
        { "disable_showing_main_view_on_activation", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_DisableShowingMainViewOnActivation), METH_VARARGS, nullptr },
        { "disable_system_view_activation_policy", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_DisableSystemViewActivationPolicy), METH_VARARGS, nullptr },
        { "prepare_for_custom_animated_switch_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_PrepareForCustomAnimatedSwitchAsync), METH_VARARGS, nullptr },
        { "switch_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_SwitchAsync), METH_VARARGS, nullptr },
        { "try_show_as_standalone_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_TryShowAsStandaloneAsync), METH_VARARGS, nullptr },
        { "try_show_as_view_mode_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_TryShowAsViewModeAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ApplicationViewSwitcher_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationViewSwitcher_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationViewSwitcher_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationViewSwitcher_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewSwitcher_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationViewSwitcher_Static
    };

    // ----- ApplicationViewTitleBar class --------------------

    static PyObject* _new_ApplicationViewTitleBar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>::type_name);
        return nullptr;
    }

    static void _dealloc_ApplicationViewTitleBar(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewTitleBar_get_InactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"InactiveForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_InactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"InactiveForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_InactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"InactiveBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_InactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"InactiveBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonPressedForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonPressedForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonPressedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonPressedForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonPressedForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonPressedBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonPressedBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonPressedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonPressedBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonPressedBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonInactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonInactiveForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonInactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonInactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonInactiveForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonInactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonInactiveBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonInactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonInactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonInactiveBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonHoverForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonHoverForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonHoverForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonHoverForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonHoverForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonHoverBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonHoverBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonHoverBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonHoverBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonHoverBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ButtonBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"ButtonBackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"BackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTitleBar", L"BackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ApplicationViewTitleBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationViewTitleBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewTitleBar[] = {
        { "_assign_array_", _assign_array_ApplicationViewTitleBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewTitleBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewTitleBar[] = {
        { "inactive_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_InactiveForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_InactiveForegroundColor), nullptr, nullptr },
        { "inactive_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_InactiveBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_InactiveBackgroundColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ForegroundColor), nullptr, nullptr },
        { "button_pressed_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonPressedForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonPressedForegroundColor), nullptr, nullptr },
        { "button_pressed_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonPressedBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonPressedBackgroundColor), nullptr, nullptr },
        { "button_inactive_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonInactiveForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonInactiveForegroundColor), nullptr, nullptr },
        { "button_inactive_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonInactiveBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonInactiveBackgroundColor), nullptr, nullptr },
        { "button_hover_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonHoverForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonHoverForegroundColor), nullptr, nullptr },
        { "button_hover_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonHoverBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonHoverBackgroundColor), nullptr, nullptr },
        { "button_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonForegroundColor), nullptr, nullptr },
        { "button_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonBackgroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_BackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_BackgroundColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewTitleBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationViewTitleBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationViewTitleBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationViewTitleBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationViewTitleBar) },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewTitleBar =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewTitleBar",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewTitleBar
    };

    // ----- ApplicationViewTransferContext class --------------------

    static PyObject* _new_ApplicationViewTransferContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationViewTransferContext(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewTransferContext_get_ViewId(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTransferContext", L"ViewId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTransferContext_put_ViewId(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTransferContext", L"ViewId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ViewId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTransferContext_get_DataPackageFormatId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ApplicationViewTransferContext", L"DataPackageFormatId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext::DataPackageFormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ApplicationViewTransferContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ApplicationViewTransferContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewTransferContext[] = {
        { "_assign_array_", _assign_array_ApplicationViewTransferContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewTransferContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewTransferContext[] = {
        { "view_id", reinterpret_cast<getter>(ApplicationViewTransferContext_get_ViewId), reinterpret_cast<setter>(ApplicationViewTransferContext_put_ViewId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewTransferContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ApplicationViewTransferContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ApplicationViewTransferContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ApplicationViewTransferContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ApplicationViewTransferContext) },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewTransferContext =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewTransferContext",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewTransferContext
    };

    static PyGetSetDef getset_ApplicationViewTransferContext_Static[] = {
        { "data_package_format_id", reinterpret_cast<getter>(ApplicationViewTransferContext_get_DataPackageFormatId), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ApplicationViewTransferContext_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ApplicationViewTransferContext_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ApplicationViewTransferContext_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ApplicationViewTransferContext_Static) },
        { }
    };

    static PyType_Spec type_spec_ApplicationViewTransferContext_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ApplicationViewTransferContext_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ApplicationViewTransferContext_Static
    };

    // ----- InputPane class --------------------

    static PyObject* _new_InputPane(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::InputPane>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::InputPane>::type_name);
        return nullptr;
    }

    static void _dealloc_InputPane(py::wrapper::Windows::UI::ViewManagement::InputPane* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPane_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.InputPane", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::InputPane::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_GetForUIContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.InputPane", L"GetForUIContext", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIContext>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::InputPane::GetForUIContext(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_TryHide(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.InputPane", L"TryHide", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryHide());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_TryShow(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.InputPane", L"TryShow", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryShow());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::InputPane* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPane", L"OccludedRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_get_Visible(py::wrapper::Windows::UI::ViewManagement::InputPane* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPane", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputPane_put_Visible(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPane", L"Visible"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputPane_add_Hiding(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.InputPane", L"Hiding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::InputPane, winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>>(arg);

            return py::convert(self->obj.Hiding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_remove_Hiding(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.InputPane", L"Hiding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Hiding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_add_Showing(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.InputPane", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::InputPane, winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_remove_Showing(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.InputPane", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::InputPane>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::InputPane>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPane[] = {
        { "try_hide", reinterpret_cast<PyCFunction>(InputPane_TryHide), METH_VARARGS, nullptr },
        { "try_show", reinterpret_cast<PyCFunction>(InputPane_TryShow), METH_VARARGS, nullptr },
        { "add_hiding", reinterpret_cast<PyCFunction>(InputPane_add_Hiding), METH_O, nullptr },
        { "remove_hiding", reinterpret_cast<PyCFunction>(InputPane_remove_Hiding), METH_O, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(InputPane_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(InputPane_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_InputPane, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPane), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputPane[] = {
        { "occluded_rect", reinterpret_cast<getter>(InputPane_get_OccludedRect), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(InputPane_get_Visible), reinterpret_cast<setter>(InputPane_put_Visible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputPane[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputPane) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputPane) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputPane) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputPane) },
        { },
    };

    static PyType_Spec type_spec_InputPane =
    {
        "winrt._winrt_windows_ui_viewmanagement.InputPane",
        sizeof(py::wrapper::Windows::UI::ViewManagement::InputPane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPane
    };

    static PyGetSetDef getset_InputPane_Static[] = {
        { }
    };

    static PyMethodDef methods_InputPane_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(InputPane_GetForCurrentView), METH_VARARGS, nullptr },
        { "get_for_u_i_context", reinterpret_cast<PyCFunction>(InputPane_GetForUIContext), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InputPane_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputPane_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputPane_Static) },
        { }
    };

    static PyType_Spec type_spec_InputPane_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.InputPane_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputPane_Static
    };

    // ----- InputPaneVisibilityEventArgs class --------------------

    static PyObject* _new_InputPaneVisibilityEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_InputPaneVisibilityEventArgs(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPaneVisibilityEventArgs_get_EnsuredFocusedElementInView(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPaneVisibilityEventArgs", L"EnsuredFocusedElementInView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EnsuredFocusedElementInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputPaneVisibilityEventArgs_put_EnsuredFocusedElementInView(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPaneVisibilityEventArgs", L"EnsuredFocusedElementInView"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnsuredFocusedElementInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputPaneVisibilityEventArgs_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.InputPaneVisibilityEventArgs", L"OccludedRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputPaneVisibilityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputPaneVisibilityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPaneVisibilityEventArgs[] = {
        { "_assign_array_", _assign_array_InputPaneVisibilityEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPaneVisibilityEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputPaneVisibilityEventArgs[] = {
        { "ensured_focused_element_in_view", reinterpret_cast<getter>(InputPaneVisibilityEventArgs_get_EnsuredFocusedElementInView), reinterpret_cast<setter>(InputPaneVisibilityEventArgs_put_EnsuredFocusedElementInView), nullptr, nullptr },
        { "occluded_rect", reinterpret_cast<getter>(InputPaneVisibilityEventArgs_get_OccludedRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputPaneVisibilityEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputPaneVisibilityEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputPaneVisibilityEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputPaneVisibilityEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputPaneVisibilityEventArgs) },
        { },
    };

    static PyType_Spec type_spec_InputPaneVisibilityEventArgs =
    {
        "winrt._winrt_windows_ui_viewmanagement.InputPaneVisibilityEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPaneVisibilityEventArgs
    };

    // ----- ProjectionManager class --------------------

    static PyObject* _new_ProjectionManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ProjectionManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ProjectionManager>::type_name);
        return nullptr;
    }

    static PyObject* ProjectionManager_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_RequestStartProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"RequestStartProjectingAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::RequestStartProjectingAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"RequestStartProjectingAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::RequestStartProjectingAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_StartProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"StartProjectingAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StartProjectingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"StartProjectingAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StartProjectingAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_StopProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"StopProjectingAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StopProjectingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_SwapDisplaysForViewsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"SwapDisplaysForViewsAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::SwapDisplaysForViewsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_get_ProjectionDisplayAvailable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"ProjectionDisplayAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_add_ProjectionDisplayAvailableChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"ProjectionDisplayAvailableChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_remove_ProjectionDisplayAvailableChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.ProjectionManager", L"ProjectionDisplayAvailableChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProjectionManager[] = {
        { "add_projection_display_available_changed", reinterpret_cast<PyCFunction>(ProjectionManager_add_ProjectionDisplayAvailableChanged), METH_O | METH_STATIC, nullptr },
        { "remove_projection_display_available_changed", reinterpret_cast<PyCFunction>(ProjectionManager_remove_ProjectionDisplayAvailableChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProjectionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ProjectionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProjectionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProjectionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProjectionManager) },
        { },
    };

    static PyType_Spec type_spec_ProjectionManager =
    {
        "winrt._winrt_windows_ui_viewmanagement.ProjectionManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProjectionManager
    };

    static PyGetSetDef getset_ProjectionManager_Static[] = {
        { "projection_display_available", reinterpret_cast<getter>(ProjectionManager_get_ProjectionDisplayAvailable), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ProjectionManager_Static[] = {
        { "get_device_selector", reinterpret_cast<PyCFunction>(ProjectionManager_GetDeviceSelector), METH_VARARGS, nullptr },
        { "request_start_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_RequestStartProjectingAsync), METH_VARARGS, nullptr },
        { "start_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_StartProjectingAsync), METH_VARARGS, nullptr },
        { "stop_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_StopProjectingAsync), METH_VARARGS, nullptr },
        { "swap_displays_for_views_async", reinterpret_cast<PyCFunction>(ProjectionManager_SwapDisplaysForViewsAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ProjectionManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProjectionManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProjectionManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ProjectionManager_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ProjectionManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProjectionManager_Static
    };

    // ----- StatusBar class --------------------

    static PyObject* _new_StatusBar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::StatusBar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::StatusBar>::type_name);
        return nullptr;
    }

    static void _dealloc_StatusBar(py::wrapper::Windows::UI::ViewManagement::StatusBar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StatusBar_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.StatusBar", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::StatusBar::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_HideAsync(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.StatusBar", L"HideAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.HideAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_ShowAsync(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.StatusBar", L"ShowAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_get_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"ForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"ForegroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_BackgroundOpacity(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"BackgroundOpacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_BackgroundOpacity(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"BackgroundOpacity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.BackgroundOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"BackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"BackgroundColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"OccludedRect"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_get_ProgressIndicator(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBar", L"ProgressIndicator"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgressIndicator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_add_Hiding(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.StatusBar", L"Hiding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::StatusBar, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Hiding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_remove_Hiding(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.StatusBar", L"Hiding"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Hiding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_add_Showing(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.StatusBar", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::StatusBar, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_remove_Showing(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.StatusBar", L"Showing"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StatusBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::StatusBar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StatusBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::StatusBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusBar[] = {
        { "hide_async", reinterpret_cast<PyCFunction>(StatusBar_HideAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(StatusBar_ShowAsync), METH_VARARGS, nullptr },
        { "add_hiding", reinterpret_cast<PyCFunction>(StatusBar_add_Hiding), METH_O, nullptr },
        { "remove_hiding", reinterpret_cast<PyCFunction>(StatusBar_remove_Hiding), METH_O, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(StatusBar_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(StatusBar_remove_Showing), METH_O, nullptr },
        { "_assign_array_", _assign_array_StatusBar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StatusBar[] = {
        { "foreground_color", reinterpret_cast<getter>(StatusBar_get_ForegroundColor), reinterpret_cast<setter>(StatusBar_put_ForegroundColor), nullptr, nullptr },
        { "background_opacity", reinterpret_cast<getter>(StatusBar_get_BackgroundOpacity), reinterpret_cast<setter>(StatusBar_put_BackgroundOpacity), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(StatusBar_get_BackgroundColor), reinterpret_cast<setter>(StatusBar_put_BackgroundColor), nullptr, nullptr },
        { "occluded_rect", reinterpret_cast<getter>(StatusBar_get_OccludedRect), nullptr, nullptr, nullptr },
        { "progress_indicator", reinterpret_cast<getter>(StatusBar_get_ProgressIndicator), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StatusBar[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StatusBar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StatusBar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StatusBar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StatusBar) },
        { },
    };

    static PyType_Spec type_spec_StatusBar =
    {
        "winrt._winrt_windows_ui_viewmanagement.StatusBar",
        sizeof(py::wrapper::Windows::UI::ViewManagement::StatusBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusBar
    };

    static PyGetSetDef getset_StatusBar_Static[] = {
        { }
    };

    static PyMethodDef methods_StatusBar_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(StatusBar_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_StatusBar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_StatusBar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_StatusBar_Static) },
        { }
    };

    static PyType_Spec type_spec_StatusBar_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.StatusBar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_StatusBar_Static
    };

    // ----- StatusBarProgressIndicator class --------------------

    static PyObject* _new_StatusBarProgressIndicator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>::type_name);
        return nullptr;
    }

    static void _dealloc_StatusBarProgressIndicator(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StatusBarProgressIndicator_HideAsync(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"HideAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.HideAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBarProgressIndicator_ShowAsync(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"ShowAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBarProgressIndicator_get_Text(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBarProgressIndicator_put_Text(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"Text"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBarProgressIndicator_get_ProgressValue(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"ProgressValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgressValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBarProgressIndicator_put_ProgressValue(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.StatusBarProgressIndicator", L"ProgressValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.ProgressValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_StatusBarProgressIndicator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StatusBarProgressIndicator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusBarProgressIndicator[] = {
        { "hide_async", reinterpret_cast<PyCFunction>(StatusBarProgressIndicator_HideAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(StatusBarProgressIndicator_ShowAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_StatusBarProgressIndicator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusBarProgressIndicator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StatusBarProgressIndicator[] = {
        { "text", reinterpret_cast<getter>(StatusBarProgressIndicator_get_Text), reinterpret_cast<setter>(StatusBarProgressIndicator_put_Text), nullptr, nullptr },
        { "progress_value", reinterpret_cast<getter>(StatusBarProgressIndicator_get_ProgressValue), reinterpret_cast<setter>(StatusBarProgressIndicator_put_ProgressValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StatusBarProgressIndicator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_StatusBarProgressIndicator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StatusBarProgressIndicator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StatusBarProgressIndicator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StatusBarProgressIndicator) },
        { },
    };

    static PyType_Spec type_spec_StatusBarProgressIndicator =
    {
        "winrt._winrt_windows_ui_viewmanagement.StatusBarProgressIndicator",
        sizeof(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusBarProgressIndicator
    };

    // ----- UISettings class --------------------

    static PyObject* _new_UISettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::UISettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UISettings(py::wrapper::Windows::UI::ViewManagement::UISettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UISettings_GetColorValue(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.UISettings", L"GetColorValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::UIColorType>(args, 0);

                return py::convert(self->obj.GetColorValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettings_UIElementColor(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.UISettings", L"UIElementColor", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::UIElementType>(args, 0);

                return py::convert(self->obj.UIElementColor(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AnimationsEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"AnimationsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AnimationsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretBlinkRate(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"CaretBlinkRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaretBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretBrowsingEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"CaretBrowsingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaretBrowsingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretWidth(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"CaretWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CaretWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CursorSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"CursorSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CursorSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_DoubleClickTime(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"DoubleClickTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DoubleClickTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_HandPreference(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"HandPreference"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HandPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_MessageDuration(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"MessageDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MessageDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_MouseHoverTime(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"MouseHoverTime"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MouseHoverTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarArrowSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"ScrollBarArrowSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollBarArrowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"ScrollBarSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollBarSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarThumbBoxSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"ScrollBarThumbBoxSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollBarThumbBoxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_TextScaleFactor(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"TextScaleFactor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TextScaleFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AdvancedEffectsEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"AdvancedEffectsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdvancedEffectsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AutoHideScrollBars(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UISettings", L"AutoHideScrollBars"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutoHideScrollBars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_TextScaleFactorChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"TextScaleFactorChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TextScaleFactorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_TextScaleFactorChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"TextScaleFactorChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextScaleFactorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_ColorValuesChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"ColorValuesChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ColorValuesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_ColorValuesChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"ColorValuesChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ColorValuesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AdvancedEffectsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AdvancedEffectsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AdvancedEffectsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AdvancedEffectsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AdvancedEffectsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AdvancedEffectsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AutoHideScrollBarsChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AutoHideScrollBarsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>>(arg);

            return py::convert(self->obj.AutoHideScrollBarsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AutoHideScrollBarsChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AutoHideScrollBarsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoHideScrollBarsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AnimationsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AnimationsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.AnimationsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AnimationsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"AnimationsEnabledChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnimationsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_MessageDurationChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"MessageDurationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>>(arg);

            return py::convert(self->obj.MessageDurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_MessageDurationChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.ViewManagement.UISettings", L"MessageDurationChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageDurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UISettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::UISettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UISettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettings[] = {
        { "get_color_value", reinterpret_cast<PyCFunction>(UISettings_GetColorValue), METH_VARARGS, nullptr },
        { "u_i_element_color", reinterpret_cast<PyCFunction>(UISettings_UIElementColor), METH_VARARGS, nullptr },
        { "add_text_scale_factor_changed", reinterpret_cast<PyCFunction>(UISettings_add_TextScaleFactorChanged), METH_O, nullptr },
        { "remove_text_scale_factor_changed", reinterpret_cast<PyCFunction>(UISettings_remove_TextScaleFactorChanged), METH_O, nullptr },
        { "add_color_values_changed", reinterpret_cast<PyCFunction>(UISettings_add_ColorValuesChanged), METH_O, nullptr },
        { "remove_color_values_changed", reinterpret_cast<PyCFunction>(UISettings_remove_ColorValuesChanged), METH_O, nullptr },
        { "add_advanced_effects_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_add_AdvancedEffectsEnabledChanged), METH_O, nullptr },
        { "remove_advanced_effects_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AdvancedEffectsEnabledChanged), METH_O, nullptr },
        { "add_auto_hide_scroll_bars_changed", reinterpret_cast<PyCFunction>(UISettings_add_AutoHideScrollBarsChanged), METH_O, nullptr },
        { "remove_auto_hide_scroll_bars_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AutoHideScrollBarsChanged), METH_O, nullptr },
        { "add_animations_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_add_AnimationsEnabledChanged), METH_O, nullptr },
        { "remove_animations_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AnimationsEnabledChanged), METH_O, nullptr },
        { "add_message_duration_changed", reinterpret_cast<PyCFunction>(UISettings_add_MessageDurationChanged), METH_O, nullptr },
        { "remove_message_duration_changed", reinterpret_cast<PyCFunction>(UISettings_remove_MessageDurationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_UISettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettings[] = {
        { "animations_enabled", reinterpret_cast<getter>(UISettings_get_AnimationsEnabled), nullptr, nullptr, nullptr },
        { "caret_blink_rate", reinterpret_cast<getter>(UISettings_get_CaretBlinkRate), nullptr, nullptr, nullptr },
        { "caret_browsing_enabled", reinterpret_cast<getter>(UISettings_get_CaretBrowsingEnabled), nullptr, nullptr, nullptr },
        { "caret_width", reinterpret_cast<getter>(UISettings_get_CaretWidth), nullptr, nullptr, nullptr },
        { "cursor_size", reinterpret_cast<getter>(UISettings_get_CursorSize), nullptr, nullptr, nullptr },
        { "double_click_time", reinterpret_cast<getter>(UISettings_get_DoubleClickTime), nullptr, nullptr, nullptr },
        { "hand_preference", reinterpret_cast<getter>(UISettings_get_HandPreference), nullptr, nullptr, nullptr },
        { "message_duration", reinterpret_cast<getter>(UISettings_get_MessageDuration), nullptr, nullptr, nullptr },
        { "mouse_hover_time", reinterpret_cast<getter>(UISettings_get_MouseHoverTime), nullptr, nullptr, nullptr },
        { "scroll_bar_arrow_size", reinterpret_cast<getter>(UISettings_get_ScrollBarArrowSize), nullptr, nullptr, nullptr },
        { "scroll_bar_size", reinterpret_cast<getter>(UISettings_get_ScrollBarSize), nullptr, nullptr, nullptr },
        { "scroll_bar_thumb_box_size", reinterpret_cast<getter>(UISettings_get_ScrollBarThumbBoxSize), nullptr, nullptr, nullptr },
        { "text_scale_factor", reinterpret_cast<getter>(UISettings_get_TextScaleFactor), nullptr, nullptr, nullptr },
        { "advanced_effects_enabled", reinterpret_cast<getter>(UISettings_get_AdvancedEffectsEnabled), nullptr, nullptr, nullptr },
        { "auto_hide_scroll_bars", reinterpret_cast<getter>(UISettings_get_AutoHideScrollBars), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UISettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UISettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UISettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UISettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UISettings) },
        { },
    };

    static PyType_Spec type_spec_UISettings =
    {
        "winrt._winrt_windows_ui_viewmanagement.UISettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettings
    };

    // ----- UISettingsAnimationsEnabledChangedEventArgs class --------------------

    static PyObject* _new_UISettingsAnimationsEnabledChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UISettingsAnimationsEnabledChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UISettingsAnimationsEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UISettingsAnimationsEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsAnimationsEnabledChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UISettingsAnimationsEnabledChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsAnimationsEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsAnimationsEnabledChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsAnimationsEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UISettingsAnimationsEnabledChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UISettingsAnimationsEnabledChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UISettingsAnimationsEnabledChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UISettingsAnimationsEnabledChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UISettingsAnimationsEnabledChangedEventArgs =
    {
        "winrt._winrt_windows_ui_viewmanagement.UISettingsAnimationsEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsAnimationsEnabledChangedEventArgs
    };

    // ----- UISettingsAutoHideScrollBarsChangedEventArgs class --------------------

    static PyObject* _new_UISettingsAutoHideScrollBarsChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UISettingsAutoHideScrollBarsChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UISettingsAutoHideScrollBarsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UISettingsAutoHideScrollBarsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsAutoHideScrollBarsChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UISettingsAutoHideScrollBarsChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsAutoHideScrollBarsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsAutoHideScrollBarsChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsAutoHideScrollBarsChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UISettingsAutoHideScrollBarsChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UISettingsAutoHideScrollBarsChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UISettingsAutoHideScrollBarsChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UISettingsAutoHideScrollBarsChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UISettingsAutoHideScrollBarsChangedEventArgs =
    {
        "winrt._winrt_windows_ui_viewmanagement.UISettingsAutoHideScrollBarsChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsAutoHideScrollBarsChangedEventArgs
    };

    // ----- UISettingsMessageDurationChangedEventArgs class --------------------

    static PyObject* _new_UISettingsMessageDurationChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_UISettingsMessageDurationChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_UISettingsMessageDurationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UISettingsMessageDurationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsMessageDurationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UISettingsMessageDurationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsMessageDurationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsMessageDurationChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsMessageDurationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UISettingsMessageDurationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UISettingsMessageDurationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UISettingsMessageDurationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UISettingsMessageDurationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UISettingsMessageDurationChangedEventArgs =
    {
        "winrt._winrt_windows_ui_viewmanagement.UISettingsMessageDurationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsMessageDurationChangedEventArgs
    };

    // ----- UIViewSettings class --------------------

    static PyObject* _new_UIViewSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::UIViewSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::UIViewSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_UIViewSettings(py::wrapper::Windows::UI::ViewManagement::UIViewSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UIViewSettings_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.UIViewSettings", L"GetForCurrentView", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::UI::ViewManagement::UIViewSettings::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIViewSettings_get_UserInteractionMode(py::wrapper::Windows::UI::ViewManagement::UIViewSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.UIViewSettings", L"UserInteractionMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UserInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UIViewSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::UIViewSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UIViewSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UIViewSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UIViewSettings[] = {
        { "_assign_array_", _assign_array_UIViewSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIViewSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UIViewSettings[] = {
        { "user_interaction_mode", reinterpret_cast<getter>(UIViewSettings_get_UserInteractionMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UIViewSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UIViewSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UIViewSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UIViewSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UIViewSettings) },
        { },
    };

    static PyType_Spec type_spec_UIViewSettings =
    {
        "winrt._winrt_windows_ui_viewmanagement.UIViewSettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UIViewSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIViewSettings
    };

    static PyGetSetDef getset_UIViewSettings_Static[] = {
        { }
    };

    static PyMethodDef methods_UIViewSettings_Static[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(UIViewSettings_GetForCurrentView), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_UIViewSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_UIViewSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_UIViewSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_UIViewSettings_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.UIViewSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_UIViewSettings_Static
    };

    // ----- ViewModePreferences class --------------------

    static PyObject* _new_ViewModePreferences(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::ViewManagement::ViewModePreferences>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::ViewManagement::ViewModePreferences>::type_name);
        return nullptr;
    }

    static void _dealloc_ViewModePreferences(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ViewModePreferences_CreateDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.ViewManagement.ViewModePreferences", L"CreateDefault", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ViewModePreferences::CreateDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ViewModePreferences_get_ViewSizePreference(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ViewModePreferences", L"ViewSizePreference"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ViewSizePreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ViewModePreferences_put_ViewSizePreference(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ViewModePreferences", L"ViewSizePreference"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.ViewSizePreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ViewModePreferences_get_CustomSize(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ViewModePreferences", L"CustomSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ViewModePreferences_put_CustomSize(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.ViewManagement.ViewModePreferences", L"CustomSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CustomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ViewModePreferences(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::ViewManagement::ViewModePreferences>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ViewModePreferences(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ViewModePreferences>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ViewModePreferences[] = {
        { "_assign_array_", _assign_array_ViewModePreferences, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ViewModePreferences), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ViewModePreferences[] = {
        { "view_size_preference", reinterpret_cast<getter>(ViewModePreferences_get_ViewSizePreference), reinterpret_cast<setter>(ViewModePreferences_put_ViewSizePreference), nullptr, nullptr },
        { "custom_size", reinterpret_cast<getter>(ViewModePreferences_get_CustomSize), reinterpret_cast<setter>(ViewModePreferences_put_CustomSize), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ViewModePreferences[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ViewModePreferences) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ViewModePreferences) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ViewModePreferences) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ViewModePreferences) },
        { },
    };

    static PyType_Spec type_spec_ViewModePreferences =
    {
        "winrt._winrt_windows_ui_viewmanagement.ViewModePreferences",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ViewModePreferences
    };

    static PyGetSetDef getset_ViewModePreferences_Static[] = {
        { }
    };

    static PyMethodDef methods_ViewModePreferences_Static[] = {
        { "create_default", reinterpret_cast<PyCFunction>(ViewModePreferences_CreateDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ViewModePreferences_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ViewModePreferences_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ViewModePreferences_Static) },
        { }
    };

    static PyType_Spec type_spec_ViewModePreferences_Static =
    {
        "winrt._winrt_windows_ui_viewmanagement.ViewModePreferences_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ViewModePreferences_Static
    };

    // ----- Windows.UI.ViewManagement Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::ViewManagement");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_viewmanagement",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::ViewManagement

PyMODINIT_FUNC PyInit__winrt_windows_ui_viewmanagement(void) noexcept
{
    using namespace py::cpp::Windows::UI::ViewManagement;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessibilitySettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivationViewSwitcher, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationView_Static{PyType_FromSpec(&type_spec_ApplicationView_Static)};
    if (!type_ApplicationView_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationView_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationViewConsolidatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationViewScaling_Static{PyType_FromSpec(&type_spec_ApplicationViewScaling_Static)};
    if (!type_ApplicationViewScaling_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationViewScaling, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationViewScaling_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationViewSwitcher_Static{PyType_FromSpec(&type_spec_ApplicationViewSwitcher_Static)};
    if (!type_ApplicationViewSwitcher_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationViewSwitcher, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationViewSwitcher_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationViewTitleBar, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ApplicationViewTransferContext_Static{PyType_FromSpec(&type_spec_ApplicationViewTransferContext_Static)};
    if (!type_ApplicationViewTransferContext_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ApplicationViewTransferContext, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ApplicationViewTransferContext_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputPane_Static{PyType_FromSpec(&type_spec_InputPane_Static)};
    if (!type_InputPane_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputPane, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputPane_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputPaneVisibilityEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProjectionManager_Static{PyType_FromSpec(&type_spec_ProjectionManager_Static)};
    if (!type_ProjectionManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ProjectionManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProjectionManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_StatusBar_Static{PyType_FromSpec(&type_spec_StatusBar_Static)};
    if (!type_StatusBar_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StatusBar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_StatusBar_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_StatusBarProgressIndicator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UISettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UISettingsAnimationsEnabledChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UISettingsAutoHideScrollBarsChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UISettingsMessageDurationChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_UIViewSettings_Static{PyType_FromSpec(&type_spec_UIViewSettings_Static)};
    if (!type_UIViewSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UIViewSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_UIViewSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ViewModePreferences_Static{PyType_FromSpec(&type_spec_ViewModePreferences_Static)};
    if (!type_ViewModePreferences_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ViewModePreferences, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ViewModePreferences_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
