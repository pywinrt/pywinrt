# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.windows.applicationmodel.dynamicdependency
import winrt.windows.applicationmodel
import winrt.windows.foundation
import winrt.windows.foundation.collections

from winrt.microsoft.windows.management.deployment import PackageDeploymentProgressStatus, PackageDeploymentStatus, StubPackageOption

Self = typing.TypeVar('Self')

@typing.final
class PackageDeploymentProgress:
    status: PackageDeploymentProgressStatus
    progress: winrt.system.Double
    def __init__(self, status: PackageDeploymentProgressStatus, progress: winrt.system.Double) -> None: ...

@typing.final
class AddPackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AddPackageOptions: ...
    def __new__(cls: typing.Type[AddPackageOptions]) -> AddPackageOptions:...
    @_property
    def target_volume(self) -> typing.Optional[PackageVolume]: ...
    @target_volume.setter
    def target_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def stub_package_option(self) -> StubPackageOption: ...
    @stub_package_option.setter
    def stub_package_option(self, value: StubPackageOption) -> None: ...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def retain_files_on_failure(self) -> bool: ...
    @retain_files_on_failure.setter
    def retain_files_on_failure(self, value: bool) -> None: ...
    @_property
    def required_content_group_only(self) -> bool: ...
    @required_content_group_only.setter
    def required_content_group_only(self, value: bool) -> None: ...
    @_property
    def limit_to_existing_packages(self) -> bool: ...
    @limit_to_existing_packages.setter
    def limit_to_existing_packages(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def force_target_app_shutdown(self) -> bool: ...
    @force_target_app_shutdown.setter
    def force_target_app_shutdown(self, value: bool) -> None: ...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def defer_registration_when_packages_are_in_use(self) -> bool: ...
    @defer_registration_when_packages_are_in_use.setter
    def defer_registration_when_packages_are_in_use(self, value: bool) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...
    @_property
    def is_expected_digests_supported(self) -> bool: ...
    @_property
    def is_limit_to_existing_packages_supported(self) -> bool: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def optional_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def related_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...

@typing.final
class EnsureReadyOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EnsureReadyOptions: ...
    def __new__(cls: typing.Type[EnsureReadyOptions]) -> EnsureReadyOptions:...
    @_property
    def add_package_options(self) -> typing.Optional[AddPackageOptions]: ...

@typing.final
class PackageDeploymentManager_Static(type):
    def get_default(cls) -> typing.Optional[PackageDeploymentManager]: ...

@typing.final
class PackageDeploymentManager(winrt.system.Object, metaclass=PackageDeploymentManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageDeploymentManager: ...
    def add_package_async(self, package: str, options: typing.Optional[AddPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def add_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[AddPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def add_package_set_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[AddPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def deprovision_package_async(self, package: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def deprovision_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def deprovision_package_set_async(self, package_set: typing.Optional[PackageSet], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def ensure_package_ready_async(self, package: str, options: typing.Optional[EnsureReadyOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def ensure_package_ready_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[EnsureReadyOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def ensure_package_set_ready_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[EnsureReadyOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def is_package_ready(self, package: str, /) -> bool: ...
    def is_package_ready_by_uri(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> bool: ...
    def is_package_registration_pending(self, package_family_name: str, /) -> bool: ...
    def is_package_registration_pending_for_user(self, user_security_id: str, package_family_name: str, /) -> bool: ...
    def is_package_set_ready(self, package_set: typing.Optional[PackageSet], /) -> bool: ...
    def provision_package_async(self, package: str, options: typing.Optional[ProvisionPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def provision_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[ProvisionPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def provision_package_set_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[ProvisionPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def register_package_async(self, package: str, options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def register_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def register_package_set_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[RegisterPackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def remove_package_async(self, package: str, options: typing.Optional[RemovePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def remove_package_by_family_name_async(self, package_family_name: str, options: typing.Optional[RemovePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def remove_package_by_full_name_async(self, package_full_name: str, options: typing.Optional[RemovePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def remove_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[RemovePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def remove_package_set_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[RemovePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def repair_package_async(self, package: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def repair_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def repair_package_set_async(self, package_set: typing.Optional[PackageSet], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def reset_package_async(self, package: str, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def reset_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def reset_package_set_async(self, package_set: typing.Optional[PackageSet], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def stage_package_async(self, package: str, options: typing.Optional[StagePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def stage_package_by_uri_async(self, package_uri: typing.Optional[winrt.windows.foundation.Uri], options: typing.Optional[StagePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...
    def stage_package_set_async(self, package_set: typing.Optional[PackageSet], options: typing.Optional[StagePackageOptions], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[PackageDeploymentResult, PackageDeploymentProgress]: ...

@typing.final
class PackageDeploymentResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageDeploymentResult: ...
    @_property
    def activity_id(self) -> _uuid.UUID: ...
    @_property
    def error(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def error_text(self) -> str: ...
    @_property
    def extended_error(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def status(self) -> PackageDeploymentStatus: ...

@typing.final
class PackageRuntimeManager_Static(type):
    def get_default(cls) -> typing.Optional[PackageRuntimeManager]: ...

@typing.final
class PackageRuntimeManager(winrt.system.Object, metaclass=PackageRuntimeManager_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageRuntimeManager: ...
    @typing.overload
    def add_package_set(self, package_set: typing.Optional[PackageSet], /) -> typing.Optional[PackageSetRuntimeDisposition]: ...
    @typing.overload
    def add_package_set(self, package_set: typing.Optional[PackageSet], create_options: typing.Optional[winrt.microsoft.windows.applicationmodel.dynamicdependency.CreatePackageDependencyOptions], add_options: typing.Optional[winrt.microsoft.windows.applicationmodel.dynamicdependency.AddPackageDependencyOptions], /) -> typing.Optional[PackageSetRuntimeDisposition]: ...
    def remove_package_set(self, package_set_runtime_disposition: typing.Optional[PackageSetRuntimeDisposition], /) -> None: ...

@typing.final
class PackageSet(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageSet: ...
    def __new__(cls: typing.Type[PackageSet]) -> PackageSet:...
    @_property
    def package_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @package_uri.setter
    def package_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...
    @_property
    def items(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[PackageSetItem]]: ...

@typing.final
class PackageSetItem(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageSetItem: ...
    def __new__(cls: typing.Type[PackageSetItem]) -> PackageSetItem:...
    @_property
    def processor_architecture_filter(self) -> winrt.microsoft.windows.applicationmodel.dynamicdependency.PackageDependencyProcessorArchitectures: ...
    @processor_architecture_filter.setter
    def processor_architecture_filter(self, value: winrt.microsoft.windows.applicationmodel.dynamicdependency.PackageDependencyProcessorArchitectures) -> None: ...
    @_property
    def package_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @package_uri.setter
    def package_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def package_family_name(self) -> str: ...
    @package_family_name.setter
    def package_family_name(self, value: str) -> None: ...
    @_property
    def min_version(self) -> winrt.windows.applicationmodel.PackageVersion: ...
    @min_version.setter
    def min_version(self, value: winrt.windows.applicationmodel.PackageVersion) -> None: ...
    @_property
    def id(self) -> str: ...
    @id.setter
    def id(self, value: str) -> None: ...

@typing.final
class PackageSetItemRuntimeDisposition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageSetItemRuntimeDisposition: ...
    def __new__(cls: typing.Type[PackageSetItemRuntimeDisposition]) -> PackageSetItemRuntimeDisposition:...
    @_property
    def package_dependency_context_id(self) -> winrt.microsoft.windows.applicationmodel.dynamicdependency.PackageDependencyContextId: ...
    @_property
    def package_dependency_id(self) -> str: ...
    @_property
    def package_full_name(self) -> str: ...
    @_property
    def package_set_item_id(self) -> str: ...

@typing.final
class PackageSetRuntimeDisposition(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageSetRuntimeDisposition: ...
    def __new__(cls: typing.Type[PackageSetRuntimeDisposition]) -> PackageSetRuntimeDisposition:...
    @_property
    def package_set_id(self) -> str: ...
    @package_set_id.setter
    def package_set_id(self, value: str) -> None: ...
    @_property
    def package_set_item_runtime_dispositions(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[PackageSetItemRuntimeDisposition]]: ...

@typing.final
class PackageVolume_Static(type):
    def find_package_volume_by_name(cls, name: str, /) -> typing.Optional[PackageVolume]: ...
    def find_package_volume_by_path(cls, package_store_path: str, /) -> typing.Optional[PackageVolume]: ...
    def find_package_volumes(cls) -> typing.Optional[winrt.windows.foundation.collections.IVector[PackageVolume]]: ...

@typing.final
class PackageVolume(winrt.system.Object, metaclass=PackageVolume_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PackageVolume: ...
    def is_repair_needed(self) -> bool: ...
    def repair(self) -> None: ...
    @_property
    def is_appx_install_supported(self) -> bool: ...
    @_property
    def is_full_trust_package_supported(self) -> bool: ...
    @_property
    def is_system_volume(self) -> bool: ...
    @_property
    def mount_point(self) -> str: ...
    @_property
    def name(self) -> str: ...
    @_property
    def package_store_path(self) -> str: ...
    @_property
    def supports_hard_links(self) -> bool: ...

@typing.final
class ProvisionPackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ProvisionPackageOptions: ...
    def __new__(cls: typing.Type[ProvisionPackageOptions]) -> ProvisionPackageOptions:...
    @_property
    def is_optional_package_family_names_supported(self) -> bool: ...
    @_property
    def is_projection_order_package_family_names_supported(self) -> bool: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def projection_order_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class RegisterPackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RegisterPackageOptions: ...
    def __new__(cls: typing.Type[RegisterPackageOptions]) -> RegisterPackageOptions:...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def force_target_app_shutdown(self) -> bool: ...
    @force_target_app_shutdown.setter
    def force_target_app_shutdown(self, value: bool) -> None: ...
    @_property
    def force_app_shutdown(self) -> bool: ...
    @force_app_shutdown.setter
    def force_app_shutdown(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def defer_registration_when_packages_are_in_use(self) -> bool: ...
    @defer_registration_when_packages_are_in_use.setter
    def defer_registration_when_packages_are_in_use(self, value: bool) -> None: ...
    @_property
    def app_data_volume(self) -> typing.Optional[PackageVolume]: ...
    @app_data_volume.setter
    def app_data_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...
    @_property
    def is_expected_digests_supported(self) -> bool: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...

@typing.final
class RemovePackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RemovePackageOptions: ...
    def __new__(cls: typing.Type[RemovePackageOptions]) -> RemovePackageOptions:...
    @_property
    def remove_for_all_users(self) -> bool: ...
    @remove_for_all_users.setter
    def remove_for_all_users(self, value: bool) -> None: ...
    @_property
    def preserve_roamable_application_data(self) -> bool: ...
    @preserve_roamable_application_data.setter
    def preserve_roamable_application_data(self, value: bool) -> None: ...
    @_property
    def preserve_application_data(self) -> bool: ...
    @preserve_application_data.setter
    def preserve_application_data(self, value: bool) -> None: ...
    @_property
    def fail_if_not_found(self) -> bool: ...
    @fail_if_not_found.setter
    def fail_if_not_found(self, value: bool) -> None: ...

@typing.final
class StagePackageOptions(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> StagePackageOptions: ...
    def __new__(cls: typing.Type[StagePackageOptions]) -> StagePackageOptions:...
    @_property
    def target_volume(self) -> typing.Optional[PackageVolume]: ...
    @target_volume.setter
    def target_volume(self, value: typing.Optional[PackageVolume]) -> None: ...
    @_property
    def stub_package_option(self) -> StubPackageOption: ...
    @stub_package_option.setter
    def stub_package_option(self, value: StubPackageOption) -> None: ...
    @_property
    def stage_in_place(self) -> bool: ...
    @stage_in_place.setter
    def stage_in_place(self, value: bool) -> None: ...
    @_property
    def required_content_group_only(self) -> bool: ...
    @required_content_group_only.setter
    def required_content_group_only(self, value: bool) -> None: ...
    @_property
    def install_all_resources(self) -> bool: ...
    @install_all_resources.setter
    def install_all_resources(self, value: bool) -> None: ...
    @_property
    def force_update_from_any_version(self) -> bool: ...
    @force_update_from_any_version.setter
    def force_update_from_any_version(self, value: bool) -> None: ...
    @_property
    def external_location_uri(self) -> typing.Optional[winrt.windows.foundation.Uri]: ...
    @external_location_uri.setter
    def external_location_uri(self, value: typing.Optional[winrt.windows.foundation.Uri]) -> None: ...
    @_property
    def developer_mode(self) -> bool: ...
    @developer_mode.setter
    def developer_mode(self, value: bool) -> None: ...
    @_property
    def allow_unsigned(self) -> bool: ...
    @allow_unsigned.setter
    def allow_unsigned(self, value: bool) -> None: ...
    @_property
    def dependency_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def expected_digests(self) -> typing.Optional[winrt.windows.foundation.collections.IMap[winrt.windows.foundation.Uri, str]]: ...
    @_property
    def is_expected_digests_supported(self) -> bool: ...
    @_property
    def optional_package_family_names(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[str]]: ...
    @_property
    def optional_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...
    @_property
    def related_package_uris(self) -> typing.Optional[winrt.windows.foundation.collections.IVector[winrt.windows.foundation.Uri]]: ...

