// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.Windows.Management.Deployment.h"

namespace py::cpp::Microsoft::Windows::Management::Deployment
{
    // ----- AddPackageOptions class --------------------

    static PyObject* _new_AddPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AddPackageOptions_get_TargetVolume(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"TargetVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_TargetVolume(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"TargetVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StubPackageOption(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"StubPackageOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StubPackageOption(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"StubPackageOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RetainFilesOnFailure(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"RetainFilesOnFailure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RetainFilesOnFailure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RetainFilesOnFailure(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"RetainFilesOnFailure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RetainFilesOnFailure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RequiredContentGroupOnly(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"RequiredContentGroupOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RequiredContentGroupOnly(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"RequiredContentGroupOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_LimitToExistingPackages(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"LimitToExistingPackages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LimitToExistingPackages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_LimitToExistingPackages(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"LimitToExistingPackages");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.LimitToExistingPackages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceTargetAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceTargetAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ForceAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"DeferRegistrationWhenPackagesAreInUse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"DeferRegistrationWhenPackagesAreInUse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DependencyPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"DependencyPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_ExpectedDigests(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"ExpectedDigests");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_IsExpectedDigestsSupported(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"IsExpectedDigestsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExpectedDigestsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_IsLimitToExistingPackagesSupported(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"IsLimitToExistingPackagesSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLimitToExistingPackagesSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"OptionalPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"OptionalPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_RelatedPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.AddPackageOptions", L"RelatedPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageOptions[] = {
        { "_assign_array_", _assign_array_AddPackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AddPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AddPackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(AddPackageOptions_get_TargetVolume), reinterpret_cast<setter>(AddPackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(AddPackageOptions_get_StubPackageOption), reinterpret_cast<setter>(AddPackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(AddPackageOptions_get_StageInPlace), reinterpret_cast<setter>(AddPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "retain_files_on_failure", reinterpret_cast<getter>(AddPackageOptions_get_RetainFilesOnFailure), reinterpret_cast<setter>(AddPackageOptions_put_RetainFilesOnFailure), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(AddPackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(AddPackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "limit_to_existing_packages", reinterpret_cast<getter>(AddPackageOptions_get_LimitToExistingPackages), reinterpret_cast<setter>(AddPackageOptions_put_LimitToExistingPackages), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(AddPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(AddPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AddPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(AddPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(AddPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(AddPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(AddPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(AddPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(AddPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(AddPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(AddPackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { "is_expected_digests_supported", reinterpret_cast<getter>(AddPackageOptions_get_IsExpectedDigestsSupported), nullptr, nullptr, nullptr },
        { "is_limit_to_existing_packages_supported", reinterpret_cast<getter>(AddPackageOptions_get_IsLimitToExistingPackagesSupported), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AddPackageOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AddPackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AddPackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AddPackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AddPackageOptions) },
        { }
    };

    static PyType_Spec type_spec_AddPackageOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.AddPackageOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::AddPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageOptions};

    // ----- EnsureReadyOptions class --------------------

    static PyObject* _new_EnsureReadyOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EnsureReadyOptions(py::wrapper::Microsoft::Windows::Management::Deployment::EnsureReadyOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EnsureReadyOptions_get_AddPackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::EnsureReadyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.EnsureReadyOptions", L"AddPackageOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AddPackageOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EnsureReadyOptions_get_RegisterNewerIfAvailable(py::wrapper::Microsoft::Windows::Management::Deployment::EnsureReadyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.EnsureReadyOptions", L"RegisterNewerIfAvailable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RegisterNewerIfAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EnsureReadyOptions_put_RegisterNewerIfAvailable(py::wrapper::Microsoft::Windows::Management::Deployment::EnsureReadyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.EnsureReadyOptions", L"RegisterNewerIfAvailable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RegisterNewerIfAvailable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EnsureReadyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EnsureReadyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnsureReadyOptions[] = {
        { "_assign_array_", _assign_array_EnsureReadyOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnsureReadyOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnsureReadyOptions[] = {
        { "add_package_options", reinterpret_cast<getter>(EnsureReadyOptions_get_AddPackageOptions), nullptr, nullptr, nullptr },
        { "register_newer_if_available", reinterpret_cast<getter>(EnsureReadyOptions_get_RegisterNewerIfAvailable), reinterpret_cast<setter>(EnsureReadyOptions_put_RegisterNewerIfAvailable), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EnsureReadyOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EnsureReadyOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EnsureReadyOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EnsureReadyOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EnsureReadyOptions) },
        { }
    };

    static PyType_Spec type_spec_EnsureReadyOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.EnsureReadyOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::EnsureReadyOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnsureReadyOptions};

    // ----- PackageDeploymentManager class --------------------

    static PyObject* _new_PackageDeploymentManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageDeploymentManager(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDeploymentManager_AddPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"AddPackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_AddPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"AddPackageByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_AddPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"AddPackageSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_DeprovisionPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"DeprovisionPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeprovisionPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_DeprovisionPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"DeprovisionPackageByUriAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.DeprovisionPackageByUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_DeprovisionPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"DeprovisionPackageSetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.DeprovisionPackageSetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_EnsurePackageReadyAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"EnsurePackageReadyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>(args, 1);

                return py::convert(self->obj.EnsurePackageReadyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_EnsurePackageReadyByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"EnsurePackageReadyByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>(args, 1);

                return py::convert(self->obj.EnsurePackageReadyByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_EnsurePackageSetReadyAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"EnsurePackageSetReadyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::EnsureReadyOptions>(args, 1);

                return py::convert(self->obj.EnsurePackageSetReadyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageDeploymentFeatureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageDeploymentFeatureSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentFeature>(args, 0);

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager::IsPackageDeploymentFeatureSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageProvisioned(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageProvisioned", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPackageProvisioned(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageProvisionedByUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageProvisionedByUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.IsPackageProvisionedByUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageReady(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageReady", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPackageReady(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageReadyByUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageReadyByUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.IsPackageReadyByUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageReadyOrNewerAvailable(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageReadyOrNewerAvailable", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPackageReadyOrNewerAvailable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageReadyOrNewerAvailableByUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageReadyOrNewerAvailableByUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.IsPackageReadyOrNewerAvailableByUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageRegistrationPending(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageRegistrationPending", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPackageRegistrationPending(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageRegistrationPendingForUser(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageRegistrationPendingForUser", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.IsPackageRegistrationPendingForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageSetProvisioned(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageSetProvisioned", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.IsPackageSetProvisioned(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageSetReady(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageSetReady", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.IsPackageSetReady(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_IsPackageSetReadyOrNewerAvailable(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"IsPackageSetReadyOrNewerAvailable", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.IsPackageSetReadyOrNewerAvailable(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ProvisionPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ProvisionPackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ProvisionPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ProvisionPackageByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ProvisionPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ProvisionPackageSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RegisterPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RegisterPackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RegisterPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RegisterPackageByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RegisterPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RegisterPackageSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RemovePackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RemovePackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>(args, 1);

                return py::convert(self->obj.RemovePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RemovePackageByFamilyNameAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RemovePackageByFamilyNameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>(args, 1);

                return py::convert(self->obj.RemovePackageByFamilyNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RemovePackageByFullNameAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RemovePackageByFullNameAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>(args, 1);

                return py::convert(self->obj.RemovePackageByFullNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RemovePackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RemovePackageByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>(args, 1);

                return py::convert(self->obj.RemovePackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RemovePackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RemovePackageSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>(args, 1);

                return py::convert(self->obj.RemovePackageSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RepairPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RepairPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RepairPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RepairPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RepairPackageByUriAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.RepairPackageByUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_RepairPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"RepairPackageSetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.RepairPackageSetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ResetPackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ResetPackageAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ResetPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ResetPackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ResetPackageByUriAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ResetPackageByUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_ResetPackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"ResetPackageSetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.ResetPackageSetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_StagePackageAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"StagePackageAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_StagePackageByUriAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"StagePackageByUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentManager_StagePackageSetAsync(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentManager", L"StagePackageSetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageSetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDeploymentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDeploymentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDeploymentManager[] = {
        { "add_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_AddPackageAsync), METH_VARARGS, nullptr },
        { "add_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_AddPackageByUriAsync), METH_VARARGS, nullptr },
        { "add_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_AddPackageSetAsync), METH_VARARGS, nullptr },
        { "deprovision_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_DeprovisionPackageAsync), METH_VARARGS, nullptr },
        { "deprovision_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_DeprovisionPackageByUriAsync), METH_VARARGS, nullptr },
        { "deprovision_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_DeprovisionPackageSetAsync), METH_VARARGS, nullptr },
        { "ensure_package_ready_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_EnsurePackageReadyAsync), METH_VARARGS, nullptr },
        { "ensure_package_ready_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_EnsurePackageReadyByUriAsync), METH_VARARGS, nullptr },
        { "ensure_package_set_ready_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_EnsurePackageSetReadyAsync), METH_VARARGS, nullptr },
        { "is_package_provisioned", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageProvisioned), METH_VARARGS, nullptr },
        { "is_package_provisioned_by_uri", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageProvisionedByUri), METH_VARARGS, nullptr },
        { "is_package_ready", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageReady), METH_VARARGS, nullptr },
        { "is_package_ready_by_uri", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageReadyByUri), METH_VARARGS, nullptr },
        { "is_package_ready_or_newer_available", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageReadyOrNewerAvailable), METH_VARARGS, nullptr },
        { "is_package_ready_or_newer_available_by_uri", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageReadyOrNewerAvailableByUri), METH_VARARGS, nullptr },
        { "is_package_registration_pending", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageRegistrationPending), METH_VARARGS, nullptr },
        { "is_package_registration_pending_for_user", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageRegistrationPendingForUser), METH_VARARGS, nullptr },
        { "is_package_set_provisioned", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageSetProvisioned), METH_VARARGS, nullptr },
        { "is_package_set_ready", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageSetReady), METH_VARARGS, nullptr },
        { "is_package_set_ready_or_newer_available", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageSetReadyOrNewerAvailable), METH_VARARGS, nullptr },
        { "provision_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ProvisionPackageAsync), METH_VARARGS, nullptr },
        { "provision_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ProvisionPackageByUriAsync), METH_VARARGS, nullptr },
        { "provision_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ProvisionPackageSetAsync), METH_VARARGS, nullptr },
        { "register_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RegisterPackageAsync), METH_VARARGS, nullptr },
        { "register_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RegisterPackageByUriAsync), METH_VARARGS, nullptr },
        { "register_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RegisterPackageSetAsync), METH_VARARGS, nullptr },
        { "remove_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RemovePackageAsync), METH_VARARGS, nullptr },
        { "remove_package_by_family_name_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RemovePackageByFamilyNameAsync), METH_VARARGS, nullptr },
        { "remove_package_by_full_name_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RemovePackageByFullNameAsync), METH_VARARGS, nullptr },
        { "remove_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RemovePackageByUriAsync), METH_VARARGS, nullptr },
        { "remove_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RemovePackageSetAsync), METH_VARARGS, nullptr },
        { "repair_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RepairPackageAsync), METH_VARARGS, nullptr },
        { "repair_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RepairPackageByUriAsync), METH_VARARGS, nullptr },
        { "repair_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_RepairPackageSetAsync), METH_VARARGS, nullptr },
        { "reset_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ResetPackageAsync), METH_VARARGS, nullptr },
        { "reset_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ResetPackageByUriAsync), METH_VARARGS, nullptr },
        { "reset_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_ResetPackageSetAsync), METH_VARARGS, nullptr },
        { "stage_package_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_StagePackageAsync), METH_VARARGS, nullptr },
        { "stage_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_StagePackageByUriAsync), METH_VARARGS, nullptr },
        { "stage_package_set_async", reinterpret_cast<PyCFunction>(PackageDeploymentManager_StagePackageSetAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageDeploymentManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDeploymentManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageDeploymentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageDeploymentManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDeploymentManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDeploymentManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDeploymentManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDeploymentManager) },
        { }
    };

    static PyType_Spec type_spec_PackageDeploymentManager = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageDeploymentManager",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDeploymentManager};

    static PyGetSetDef getset_PackageDeploymentManager_Static[] = {
        { }
    };

    static PyMethodDef methods_PackageDeploymentManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PackageDeploymentManager_GetDefault), METH_VARARGS, nullptr },
        { "is_package_deployment_feature_supported", reinterpret_cast<PyCFunction>(PackageDeploymentManager_IsPackageDeploymentFeatureSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageDeploymentManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageDeploymentManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageDeploymentManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageDeploymentManager_Static =
    {
        "winrt._winrt_microsoft_windows_management_deployment.PackageDeploymentManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageDeploymentManager_Static
    };

    // ----- PackageDeploymentResult class --------------------

    static PyObject* _new_PackageDeploymentResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageDeploymentResult(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDeploymentResult_get_ActivityId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentResult", L"ActivityId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentResult_get_Error(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentResult", L"Error");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentResult_get_ErrorText(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentResult", L"ErrorText");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentResult_get_ExtendedError(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDeploymentResult_get_Status(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageDeploymentResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDeploymentResult[] = {
        { "_assign_array_", _assign_array_PackageDeploymentResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDeploymentResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageDeploymentResult[] = {
        { "activity_id", reinterpret_cast<getter>(PackageDeploymentResult_get_ActivityId), nullptr, nullptr, nullptr },
        { "error", reinterpret_cast<getter>(PackageDeploymentResult_get_Error), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(PackageDeploymentResult_get_ErrorText), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PackageDeploymentResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PackageDeploymentResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageDeploymentResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDeploymentResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDeploymentResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDeploymentResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDeploymentResult) },
        { }
    };

    static PyType_Spec type_spec_PackageDeploymentResult = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageDeploymentResult",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDeploymentResult};

    // ----- PackageRuntimeManager class --------------------

    static PyObject* _new_PackageRuntimeManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageRuntimeManager(py::wrapper::Microsoft::Windows::Management::Deployment::PackageRuntimeManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageRuntimeManager_AddPackageSet(py::wrapper::Microsoft::Windows::Management::Deployment::PackageRuntimeManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageRuntimeManager", L"AddPackageSet", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);

                return py::convert(self->obj.AddPackageSet(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageRuntimeManager_AddPackageSetWithOptions(py::wrapper::Microsoft::Windows::Management::Deployment::PackageRuntimeManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageRuntimeManager", L"AddPackageSet", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSet>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>(args, 2);

                return py::convert(self->obj.AddPackageSet(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageRuntimeManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageRuntimeManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageRuntimeManager_RemovePackageSet(py::wrapper::Microsoft::Windows::Management::Deployment::PackageRuntimeManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageRuntimeManager", L"RemovePackageSet", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>(args, 0);

                self->obj.RemovePackageSet(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageRuntimeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageRuntimeManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageRuntimeManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageRuntimeManager[] = {
        { "add_package_set", reinterpret_cast<PyCFunction>(PackageRuntimeManager_AddPackageSet), METH_VARARGS, nullptr },
        { "add_package_set_with_options", reinterpret_cast<PyCFunction>(PackageRuntimeManager_AddPackageSetWithOptions), METH_VARARGS, nullptr },
        { "remove_package_set", reinterpret_cast<PyCFunction>(PackageRuntimeManager_RemovePackageSet), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageRuntimeManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageRuntimeManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageRuntimeManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageRuntimeManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageRuntimeManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageRuntimeManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageRuntimeManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageRuntimeManager) },
        { }
    };

    static PyType_Spec type_spec_PackageRuntimeManager = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageRuntimeManager",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageRuntimeManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageRuntimeManager};

    static PyGetSetDef getset_PackageRuntimeManager_Static[] = {
        { }
    };

    static PyMethodDef methods_PackageRuntimeManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PackageRuntimeManager_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageRuntimeManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageRuntimeManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageRuntimeManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageRuntimeManager_Static =
    {
        "winrt._winrt_microsoft_windows_management_deployment.PackageRuntimeManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageRuntimeManager_Static
    };

    // ----- PackageSet class --------------------

    static PyObject* _new_PackageSet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::PackageSet instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageSet(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageSet_get_PackageUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSet", L"PackageUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSet_put_PackageUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSet", L"PackageUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.PackageUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSet_get_Id(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSet", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSet_put_Id(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSet", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSet_get_Items(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSet", L"Items");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageSet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageSet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageSet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageSet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageSet[] = {
        { "_assign_array_", _assign_array_PackageSet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageSet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageSet[] = {
        { "package_uri", reinterpret_cast<getter>(PackageSet_get_PackageUri), reinterpret_cast<setter>(PackageSet_put_PackageUri), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PackageSet_get_Id), reinterpret_cast<setter>(PackageSet_put_Id), nullptr, nullptr },
        { "items", reinterpret_cast<getter>(PackageSet_get_Items), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageSet[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageSet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageSet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageSet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageSet) },
        { }
    };

    static PyType_Spec type_spec_PackageSet = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageSet",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageSet};

    // ----- PackageSetItem class --------------------

    static PyObject* _new_PackageSetItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::PackageSetItem instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageSetItem(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageSetItem_get_ProcessorArchitectureFilter(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"ProcessorArchitectureFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProcessorArchitectureFilter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetItem_put_ProcessorArchitectureFilter(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"ProcessorArchitectureFilter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(arg);

            self->obj.ProcessorArchitectureFilter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSetItem_get_PackageUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"PackageUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetItem_put_PackageUri(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"PackageUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.PackageUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSetItem_get_PackageFamilyName(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"PackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetItem_put_PackageFamilyName(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"PackageFamilyName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSetItem_get_MinVersion(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"MinVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetItem_put_MinVersion(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"MinVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);

            self->obj.MinVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSetItem_get_Id(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetItem_put_Id(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItem", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PackageSetItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageSetItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageSetItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageSetItem[] = {
        { "_assign_array_", _assign_array_PackageSetItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageSetItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageSetItem[] = {
        { "processor_architecture_filter", reinterpret_cast<getter>(PackageSetItem_get_ProcessorArchitectureFilter), reinterpret_cast<setter>(PackageSetItem_put_ProcessorArchitectureFilter), nullptr, nullptr },
        { "package_uri", reinterpret_cast<getter>(PackageSetItem_get_PackageUri), reinterpret_cast<setter>(PackageSetItem_put_PackageUri), nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(PackageSetItem_get_PackageFamilyName), reinterpret_cast<setter>(PackageSetItem_put_PackageFamilyName), nullptr, nullptr },
        { "min_version", reinterpret_cast<getter>(PackageSetItem_get_MinVersion), reinterpret_cast<setter>(PackageSetItem_put_MinVersion), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PackageSetItem_get_Id), reinterpret_cast<setter>(PackageSetItem_put_Id), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageSetItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageSetItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageSetItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageSetItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageSetItem) },
        { }
    };

    static PyType_Spec type_spec_PackageSetItem = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageSetItem",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageSetItem};

    // ----- PackageSetItemRuntimeDisposition class --------------------

    static PyObject* _new_PackageSetItemRuntimeDisposition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageSetItemRuntimeDisposition(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageSetItemRuntimeDisposition_get_PackageDependencyContextId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItemRuntimeDisposition", L"PackageDependencyContextId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageDependencyContextId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageSetItemRuntimeDisposition_get_PackageDependencyId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItemRuntimeDisposition", L"PackageDependencyId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageDependencyId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageSetItemRuntimeDisposition_get_PackageFullName(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItemRuntimeDisposition", L"PackageFullName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageFullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageSetItemRuntimeDisposition_get_PackageSetItemId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetItemRuntimeDisposition", L"PackageSetItemId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageSetItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageSetItemRuntimeDisposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageSetItemRuntimeDisposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageSetItemRuntimeDisposition[] = {
        { "_assign_array_", _assign_array_PackageSetItemRuntimeDisposition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageSetItemRuntimeDisposition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageSetItemRuntimeDisposition[] = {
        { "package_dependency_context_id", reinterpret_cast<getter>(PackageSetItemRuntimeDisposition_get_PackageDependencyContextId), nullptr, nullptr, nullptr },
        { "package_dependency_id", reinterpret_cast<getter>(PackageSetItemRuntimeDisposition_get_PackageDependencyId), nullptr, nullptr, nullptr },
        { "package_full_name", reinterpret_cast<getter>(PackageSetItemRuntimeDisposition_get_PackageFullName), nullptr, nullptr, nullptr },
        { "package_set_item_id", reinterpret_cast<getter>(PackageSetItemRuntimeDisposition_get_PackageSetItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageSetItemRuntimeDisposition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageSetItemRuntimeDisposition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageSetItemRuntimeDisposition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageSetItemRuntimeDisposition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageSetItemRuntimeDisposition) },
        { }
    };

    static PyType_Spec type_spec_PackageSetItemRuntimeDisposition = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageSetItemRuntimeDisposition",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetItemRuntimeDisposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageSetItemRuntimeDisposition};

    // ----- PackageSetRuntimeDisposition class --------------------

    static PyObject* _new_PackageSetRuntimeDisposition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageSetRuntimeDisposition(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageSetRuntimeDisposition_get_PackageSetId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetRuntimeDisposition", L"PackageSetId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageSetId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageSetRuntimeDisposition_put_PackageSetId(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetRuntimeDisposition", L"PackageSetId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PackageSetId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageSetRuntimeDisposition_get_PackageSetItemRuntimeDispositions(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageSetRuntimeDisposition", L"PackageSetItemRuntimeDispositions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageSetItemRuntimeDispositions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageSetRuntimeDisposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageSetRuntimeDisposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageSetRuntimeDisposition[] = {
        { "_assign_array_", _assign_array_PackageSetRuntimeDisposition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageSetRuntimeDisposition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageSetRuntimeDisposition[] = {
        { "package_set_id", reinterpret_cast<getter>(PackageSetRuntimeDisposition_get_PackageSetId), reinterpret_cast<setter>(PackageSetRuntimeDisposition_put_PackageSetId), nullptr, nullptr },
        { "package_set_item_runtime_dispositions", reinterpret_cast<getter>(PackageSetRuntimeDisposition_get_PackageSetItemRuntimeDispositions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageSetRuntimeDisposition[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageSetRuntimeDisposition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageSetRuntimeDisposition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageSetRuntimeDisposition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageSetRuntimeDisposition) },
        { }
    };

    static PyType_Spec type_spec_PackageSetRuntimeDisposition = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageSetRuntimeDisposition",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageSetRuntimeDisposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageSetRuntimeDisposition};

    // ----- PackageVolume class --------------------

    static PyObject* _new_PackageVolume(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageVolume(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageVolume_FindPackageVolumeByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"FindPackageVolumeByName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageVolume::FindPackageVolumeByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackageVolumeByPath(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"FindPackageVolumeByPath", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageVolume::FindPackageVolumeByPath(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackageVolumes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"FindPackageVolumes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Microsoft::Windows::Management::Deployment::PackageVolume::FindPackageVolumes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_IsRepairNeeded(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"IsRepairNeeded", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsRepairNeeded());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_Repair(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"Repair", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Repair();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsAppxInstallSupported(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"IsAppxInstallSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAppxInstallSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsFullTrustPackageSupported(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"IsFullTrustPackageSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullTrustPackageSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsSystemVolume(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"IsSystemVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_MountPoint(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"MountPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MountPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_Name(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_PackageStorePath(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"PackageStorePath");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PackageStorePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_SupportsHardLinks(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.PackageVolume", L"SupportsHardLinks");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportsHardLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageVolume[] = {
        { "is_repair_needed", reinterpret_cast<PyCFunction>(PackageVolume_IsRepairNeeded), METH_VARARGS, nullptr },
        { "repair", reinterpret_cast<PyCFunction>(PackageVolume_Repair), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageVolume, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageVolume), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageVolume[] = {
        { "is_appx_install_supported", reinterpret_cast<getter>(PackageVolume_get_IsAppxInstallSupported), nullptr, nullptr, nullptr },
        { "is_full_trust_package_supported", reinterpret_cast<getter>(PackageVolume_get_IsFullTrustPackageSupported), nullptr, nullptr, nullptr },
        { "is_system_volume", reinterpret_cast<getter>(PackageVolume_get_IsSystemVolume), nullptr, nullptr, nullptr },
        { "mount_point", reinterpret_cast<getter>(PackageVolume_get_MountPoint), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageVolume_get_Name), nullptr, nullptr, nullptr },
        { "package_store_path", reinterpret_cast<getter>(PackageVolume_get_PackageStorePath), nullptr, nullptr, nullptr },
        { "supports_hard_links", reinterpret_cast<getter>(PackageVolume_get_SupportsHardLinks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVolume[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageVolume) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageVolume) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageVolume) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageVolume) },
        { }
    };

    static PyType_Spec type_spec_PackageVolume = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageVolume",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageVolume),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVolume};

    static PyGetSetDef getset_PackageVolume_Static[] = {
        { }
    };

    static PyMethodDef methods_PackageVolume_Static[] = {
        { "find_package_volume_by_name", reinterpret_cast<PyCFunction>(PackageVolume_FindPackageVolumeByName), METH_VARARGS, nullptr },
        { "find_package_volume_by_path", reinterpret_cast<PyCFunction>(PackageVolume_FindPackageVolumeByPath), METH_VARARGS, nullptr },
        { "find_package_volumes", reinterpret_cast<PyCFunction>(PackageVolume_FindPackageVolumes), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageVolume_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageVolume_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageVolume_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageVolume_Static =
    {
        "winrt._winrt_microsoft_windows_management_deployment.PackageVolume_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageVolume_Static
    };

    // ----- ProvisionPackageOptions class --------------------

    static PyObject* _new_ProvisionPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvisionPackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionPackageOptions_get_IsOptionalPackageFamilyNamesSupported(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.ProvisionPackageOptions", L"IsOptionalPackageFamilyNamesSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOptionalPackageFamilyNamesSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionPackageOptions_get_IsProjectionOrderPackageFamilyNamesSupported(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.ProvisionPackageOptions", L"IsProjectionOrderPackageFamilyNamesSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsProjectionOrderPackageFamilyNamesSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.ProvisionPackageOptions", L"OptionalPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionPackageOptions_get_ProjectionOrderPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.ProvisionPackageOptions", L"ProjectionOrderPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProjectionOrderPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProvisionPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProvisionPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionPackageOptions[] = {
        { "_assign_array_", _assign_array_ProvisionPackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionPackageOptions[] = {
        { "is_optional_package_family_names_supported", reinterpret_cast<getter>(ProvisionPackageOptions_get_IsOptionalPackageFamilyNamesSupported), nullptr, nullptr, nullptr },
        { "is_projection_order_package_family_names_supported", reinterpret_cast<getter>(ProvisionPackageOptions_get_IsProjectionOrderPackageFamilyNamesSupported), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(ProvisionPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "projection_order_package_family_names", reinterpret_cast<getter>(ProvisionPackageOptions_get_ProjectionOrderPackageFamilyNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProvisionPackageOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProvisionPackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProvisionPackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProvisionPackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProvisionPackageOptions) },
        { }
    };

    static PyType_Spec type_spec_ProvisionPackageOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.ProvisionPackageOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::ProvisionPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionPackageOptions};

    // ----- RegisterPackageOptions class --------------------

    static PyObject* _new_RegisterPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegisterPackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RegisterPackageOptions_get_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceTargetAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceTargetAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceAppShutdown(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ForceAppShutdown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DeferRegistrationWhenPackagesAreInUse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DeferRegistrationWhenPackagesAreInUse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AppDataVolume(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"AppDataVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppDataVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AppDataVolume(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"AppDataVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.AppDataVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DependencyPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DependencyPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_DependencyPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"DependencyPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExpectedDigests(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"ExpectedDigests");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_IsExpectedDigestsSupported(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"IsExpectedDigestsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExpectedDigestsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RegisterPackageOptions", L"OptionalPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::RegisterPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegisterPackageOptions[] = {
        { "_assign_array_", _assign_array_RegisterPackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RegisterPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegisterPackageOptions[] = {
        { "stage_in_place", reinterpret_cast<getter>(RegisterPackageOptions_get_StageInPlace), reinterpret_cast<setter>(RegisterPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(RegisterPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(RegisterPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(RegisterPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(RegisterPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(RegisterPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(RegisterPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "app_data_volume", reinterpret_cast<getter>(RegisterPackageOptions_get_AppDataVolume), reinterpret_cast<setter>(RegisterPackageOptions_put_AppDataVolume), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(RegisterPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(RegisterPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_family_names", reinterpret_cast<getter>(RegisterPackageOptions_get_DependencyPackageFamilyNames), nullptr, nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(RegisterPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(RegisterPackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { "is_expected_digests_supported", reinterpret_cast<getter>(RegisterPackageOptions_get_IsExpectedDigestsSupported), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(RegisterPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegisterPackageOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RegisterPackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RegisterPackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RegisterPackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RegisterPackageOptions) },
        { }
    };

    static PyType_Spec type_spec_RegisterPackageOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.RegisterPackageOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::RegisterPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegisterPackageOptions};

    // ----- RemovePackageOptions class --------------------

    static PyObject* _new_RemovePackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemovePackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemovePackageOptions_get_RemoveForAllUsers(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"RemoveForAllUsers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoveForAllUsers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemovePackageOptions_put_RemoveForAllUsers(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"RemoveForAllUsers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RemoveForAllUsers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemovePackageOptions_get_PreserveRoamableApplicationData(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"PreserveRoamableApplicationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreserveRoamableApplicationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemovePackageOptions_put_PreserveRoamableApplicationData(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"PreserveRoamableApplicationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.PreserveRoamableApplicationData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemovePackageOptions_get_PreserveApplicationData(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"PreserveApplicationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PreserveApplicationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemovePackageOptions_put_PreserveApplicationData(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"PreserveApplicationData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.PreserveApplicationData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RemovePackageOptions_get_FailIfNotFound(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"FailIfNotFound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FailIfNotFound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RemovePackageOptions_put_FailIfNotFound(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.RemovePackageOptions", L"FailIfNotFound");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.FailIfNotFound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_RemovePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemovePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::RemovePackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemovePackageOptions[] = {
        { "_assign_array_", _assign_array_RemovePackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemovePackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemovePackageOptions[] = {
        { "remove_for_all_users", reinterpret_cast<getter>(RemovePackageOptions_get_RemoveForAllUsers), reinterpret_cast<setter>(RemovePackageOptions_put_RemoveForAllUsers), nullptr, nullptr },
        { "preserve_roamable_application_data", reinterpret_cast<getter>(RemovePackageOptions_get_PreserveRoamableApplicationData), reinterpret_cast<setter>(RemovePackageOptions_put_PreserveRoamableApplicationData), nullptr, nullptr },
        { "preserve_application_data", reinterpret_cast<getter>(RemovePackageOptions_get_PreserveApplicationData), reinterpret_cast<setter>(RemovePackageOptions_put_PreserveApplicationData), nullptr, nullptr },
        { "fail_if_not_found", reinterpret_cast<getter>(RemovePackageOptions_get_FailIfNotFound), reinterpret_cast<setter>(RemovePackageOptions_put_FailIfNotFound), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemovePackageOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemovePackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemovePackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemovePackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemovePackageOptions) },
        { }
    };

    static PyType_Spec type_spec_RemovePackageOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.RemovePackageOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::RemovePackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemovePackageOptions};

    // ----- StagePackageOptions class --------------------

    static PyObject* _new_StagePackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StagePackageOptions(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StagePackageOptions_get_TargetVolume(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"TargetVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_TargetVolume(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"TargetVolume");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StubPackageOption(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"StubPackageOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StubPackageOption(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"StubPackageOption");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StageInPlace(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"StageInPlace");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_RequiredContentGroupOnly(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"RequiredContentGroupOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_RequiredContentGroupOnly(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"RequiredContentGroupOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_InstallAllResources(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"InstallAllResources");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"ForceUpdateFromAnyVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ExternalLocationUri(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"ExternalLocationUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_DeveloperMode(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"DeveloperMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_AllowUnsigned(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"AllowUnsigned");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DependencyPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"DependencyPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_ExpectedDigests(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"ExpectedDigests");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpectedDigests());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_IsExpectedDigestsSupported(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"IsExpectedDigestsSupported");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExpectedDigestsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"OptionalPackageFamilyNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"OptionalPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_RelatedPackageUris(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Management.Deployment.StagePackageOptions", L"RelatedPackageUris");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Management::Deployment::StagePackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StagePackageOptions[] = {
        { "_assign_array_", _assign_array_StagePackageOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StagePackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StagePackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(StagePackageOptions_get_TargetVolume), reinterpret_cast<setter>(StagePackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(StagePackageOptions_get_StubPackageOption), reinterpret_cast<setter>(StagePackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(StagePackageOptions_get_StageInPlace), reinterpret_cast<setter>(StagePackageOptions_put_StageInPlace), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(StagePackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(StagePackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(StagePackageOptions_get_InstallAllResources), reinterpret_cast<setter>(StagePackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(StagePackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(StagePackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(StagePackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(StagePackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(StagePackageOptions_get_DeveloperMode), reinterpret_cast<setter>(StagePackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(StagePackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(StagePackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "expected_digests", reinterpret_cast<getter>(StagePackageOptions_get_ExpectedDigests), nullptr, nullptr, nullptr },
        { "is_expected_digests_supported", reinterpret_cast<getter>(StagePackageOptions_get_IsExpectedDigestsSupported), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StagePackageOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_StagePackageOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_StagePackageOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_StagePackageOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_StagePackageOptions) },
        { }
    };

    static PyType_Spec type_spec_StagePackageOptions = {
        "winrt._winrt_microsoft_windows_management_deployment.StagePackageOptions",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::StagePackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StagePackageOptions};

    // ----- PackageDeploymentProgress struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>* _new_PackageDeploymentProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PackageDeploymentProgress(winrt_struct_wrapper<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Status{};
        double _Progress{};

        static const char* kwlist[] = {"status", "progress", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "id", const_cast<char**>(kwlist), &_Status, &_Progress))
        {
            return -1;
        }

        try
        {
            self->obj.Status = static_cast<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus>(_Status);
            self->obj.Progress = _Progress;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PackageDeploymentProgress(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PackageDeploymentProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PackageDeploymentProgress[] = {
        { "_assign_array_", _assign_array_PackageDeploymentProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PackageDeploymentProgress_get_Status(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageDeploymentProgress_set_Status(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Status = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgressStatus>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageDeploymentProgress_get_Progress(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageDeploymentProgress_set_Progress(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Progress = py::convert_to<double>(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageDeploymentProgress[] = {
        { "status", reinterpret_cast<getter>(PackageDeploymentProgress_get_Status), reinterpret_cast<setter>(PackageDeploymentProgress_set_Status), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageDeploymentProgress_get_Progress), reinterpret_cast<setter>(PackageDeploymentProgress_set_Progress), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_PackageDeploymentProgress(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PackageDeploymentProgress(PyObject* self) noexcept
    {
        py::pyobj_handle Status{PyObject_GetAttrString(self, "status")};
        if (!Status)
        {
            return nullptr;
        }

        py::pyobj_handle Progress{PyObject_GetAttrString(self, "progress")};
        if (!Progress)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PackageDeploymentProgress(status=%R, progress=%R)", Status.get(), Progress.get());
    }

    static PyType_Slot _type_slots_PackageDeploymentProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDeploymentProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PackageDeploymentProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDeploymentProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDeploymentProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDeploymentProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PackageDeploymentProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PackageDeploymentProgress) },
        { }
    };

    static PyType_Spec type_spec_PackageDeploymentProgress = {
        "winrt._winrt_microsoft_windows_management_deployment.PackageDeploymentProgress",
        sizeof(py::wrapper::Microsoft::Windows::Management::Deployment::PackageDeploymentProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDeploymentProgress};

    // ----- Microsoft.Windows.Management.Deployment Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.Windows.Management.Deployment");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_windows_management_deployment",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::Windows::Management::Deployment

PyMODINIT_FUNC PyInit__winrt_microsoft_windows_management_deployment(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::Management::Deployment;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AddPackageOptions_type{py::register_python_type(module.get(), &type_spec_AddPackageOptions, object_bases.get(), nullptr)};
    if (!AddPackageOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle EnsureReadyOptions_type{py::register_python_type(module.get(), &type_spec_EnsureReadyOptions, object_bases.get(), nullptr)};
    if (!EnsureReadyOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageDeploymentManager_Static{PyType_FromSpec(&type_spec_PackageDeploymentManager_Static)};
    if (!type_PackageDeploymentManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PackageDeploymentManager_type{py::register_python_type(module.get(), &type_spec_PackageDeploymentManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageDeploymentManager_Static.get()))};
    if (!PackageDeploymentManager_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageDeploymentResult_type{py::register_python_type(module.get(), &type_spec_PackageDeploymentResult, object_bases.get(), nullptr)};
    if (!PackageDeploymentResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageRuntimeManager_Static{PyType_FromSpec(&type_spec_PackageRuntimeManager_Static)};
    if (!type_PackageRuntimeManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PackageRuntimeManager_type{py::register_python_type(module.get(), &type_spec_PackageRuntimeManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageRuntimeManager_Static.get()))};
    if (!PackageRuntimeManager_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageSet_type{py::register_python_type(module.get(), &type_spec_PackageSet, object_bases.get(), nullptr)};
    if (!PackageSet_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageSetItem_type{py::register_python_type(module.get(), &type_spec_PackageSetItem, object_bases.get(), nullptr)};
    if (!PackageSetItem_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageSetItemRuntimeDisposition_type{py::register_python_type(module.get(), &type_spec_PackageSetItemRuntimeDisposition, object_bases.get(), nullptr)};
    if (!PackageSetItemRuntimeDisposition_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageSetRuntimeDisposition_type{py::register_python_type(module.get(), &type_spec_PackageSetRuntimeDisposition, object_bases.get(), nullptr)};
    if (!PackageSetRuntimeDisposition_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageVolume_Static{PyType_FromSpec(&type_spec_PackageVolume_Static)};
    if (!type_PackageVolume_Static)
    {
        return nullptr;
    }

    py::pytype_handle PackageVolume_type{py::register_python_type(module.get(), &type_spec_PackageVolume, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageVolume_Static.get()))};
    if (!PackageVolume_type)
    {
        return nullptr;
    }

    py::pytype_handle ProvisionPackageOptions_type{py::register_python_type(module.get(), &type_spec_ProvisionPackageOptions, object_bases.get(), nullptr)};
    if (!ProvisionPackageOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle RegisterPackageOptions_type{py::register_python_type(module.get(), &type_spec_RegisterPackageOptions, object_bases.get(), nullptr)};
    if (!RegisterPackageOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle RemovePackageOptions_type{py::register_python_type(module.get(), &type_spec_RemovePackageOptions, object_bases.get(), nullptr)};
    if (!RemovePackageOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle StagePackageOptions_type{py::register_python_type(module.get(), &type_spec_StagePackageOptions, object_bases.get(), nullptr)};
    if (!StagePackageOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageDeploymentProgress_type{py::register_python_type(module.get(), &type_spec_PackageDeploymentProgress, nullptr, nullptr)};
    if (!PackageDeploymentProgress_type)
    {
        return nullptr;
    }


    return module.detach();
}
