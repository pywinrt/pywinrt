// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Xaml.Automation.Peers.h"


namespace py::cpp::Windows::UI::Xaml::Automation::Peers
{
    // ----- AppBarAutomationPeer class --------------------
    static constexpr const char* const type_name_AppBarAutomationPeer = "AppBarAutomationPeer";

    static PyObject* _new_AppBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"SetVisualState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"WaitForInputIdle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"InteractionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsModal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsTopmost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Maximizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Minimizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"VisualState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AppBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarAutomationPeer
    };

    // ----- AppBarButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_AppBarButtonAutomationPeer = "AppBarButtonAutomationPeer";

    static PyObject* _new_AppBarButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AppBarButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonAutomationPeer
    };

    // ----- AppBarToggleButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_AppBarToggleButtonAutomationPeer = "AppBarToggleButtonAutomationPeer";

    static PyObject* _new_AppBarToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AppBarToggleButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonAutomationPeer[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AppBarToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonAutomationPeer
    };

    // ----- AutoSuggestBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_AutoSuggestBoxAutomationPeer = "AutoSuggestBoxAutomationPeer";

    static PyObject* _new_AutoSuggestBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoSuggestBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutoSuggestBoxAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(AutoSuggestBoxAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutoSuggestBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AutoSuggestBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AutoSuggestBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxAutomationPeer
    };

    // ----- AutomationPeer class --------------------
    static constexpr const char* const type_name_AutomationPeer = "AutomationPeer";

    static PyObject* _new_AutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AutomationPeer);
        return nullptr;
    }

    static void _dealloc_AutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeer_GenerateRawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GenerateRawElementProviderRuntimeId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::GenerateRawElementProviderRuntimeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAcceleratorKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAcceleratorKey", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAcceleratorKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAcceleratorKeyCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAcceleratorKeyCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAcceleratorKeyCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAccessKey(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAccessKey", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAccessKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAccessKeyCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAccessKeyCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAccessKeyCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAnnotations(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAnnotations", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAnnotations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAnnotationsCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAnnotationsCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAnnotationsCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationControlType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAutomationControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationControlTypeCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationControlTypeCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAutomationControlTypeCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationId(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAutomationId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationIdCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationIdCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAutomationIdCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetBoundingRectangle(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetBoundingRectangle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBoundingRectangle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetBoundingRectangleCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetBoundingRectangleCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetBoundingRectangleCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetChildren(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetChildren", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetChildrenCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetChildrenCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChildrenCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClassName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClassName", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetClassName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClassNameCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClassNameCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetClassNameCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClickablePoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClickablePoint", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetClickablePoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClickablePointCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClickablePointCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetClickablePointCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetControlledPeers(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetControlledPeers", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetControlledPeers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetControlledPeersCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetControlledPeersCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetControlledPeersCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetCulture(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetCulture", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCulture());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetCultureCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetCultureCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetCultureCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetDescribedByCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetDescribedByCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDescribedByCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetElementFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetElementFromPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetElementFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetElementFromPointCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetElementFromPointCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetElementFromPointCore(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFlowsFromCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFlowsFromCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFlowsFromCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFlowsToCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFlowsToCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFlowsToCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFocusedElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFocusedElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFocusedElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFocusedElementCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFocusedElementCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFocusedElementCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFullDescription(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFullDescription", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFullDescription());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFullDescriptionCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFullDescriptionCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFullDescriptionCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHeadingLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHeadingLevel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHeadingLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHeadingLevelCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHeadingLevelCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHeadingLevelCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHelpText(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHelpText", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHelpText());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHelpTextCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHelpTextCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHelpTextCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemStatus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemStatus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetItemStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemStatusCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemStatusCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetItemStatusCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetItemType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemTypeCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemTypeCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetItemTypeCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLabeledBy(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLabeledBy", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLabeledBy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLabeledByCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLabeledByCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLabeledByCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLandmarkType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLandmarkTypeCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLandmarkTypeCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLandmarkTypeCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLevel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLevelCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLevelCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLevelCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLiveSetting(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLiveSetting", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLiveSetting());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLiveSettingCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLiveSettingCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLiveSettingCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedControlType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedControlType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLocalizedControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedControlTypeCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedControlTypeCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLocalizedControlTypeCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedLandmarkType(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedLandmarkType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLocalizedLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedLandmarkTypeCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedLandmarkTypeCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetLocalizedLandmarkTypeCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetName(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetName", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetNameCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetNameCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNameCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetOrientation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetOrientation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetOrientationCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetOrientationCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetOrientationCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetParent", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetParent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPattern(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPattern", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PatternInterface>(args, 0);

                return py::convert(self->obj.GetPattern(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPatternCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPatternCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PatternInterface>(args, 0);

                return py::convert(self->obj.GetPatternCore(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPeerFromPoint(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPeerFromPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetPeerFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPeerFromPointCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPeerFromPointCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetPeerFromPointCore(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPositionInSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPositionInSet", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPositionInSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPositionInSetCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPositionInSetCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPositionInSetCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetSizeOfSet(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetSizeOfSet", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSizeOfSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetSizeOfSetCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"GetSizeOfSetCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSizeOfSetCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_HasKeyboardFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"HasKeyboardFocus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.HasKeyboardFocus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_HasKeyboardFocusCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"HasKeyboardFocusCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.HasKeyboardFocusCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_InvalidatePeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"InvalidatePeer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InvalidatePeer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsContentElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsContentElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsContentElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsContentElementCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsContentElementCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsContentElementCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsControlElement(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsControlElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsControlElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsControlElementCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsControlElementCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsControlElementCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDataValidForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDataValidForForm", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsDataValidForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDataValidForFormCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDataValidForFormCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsDataValidForFormCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDialog(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDialog", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsDialog());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDialogCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDialogCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsDialogCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsEnabled(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsEnabled", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsEnabledCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsEnabledCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsEnabledCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsKeyboardFocusable(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsKeyboardFocusable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsKeyboardFocusable());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsKeyboardFocusableCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsKeyboardFocusableCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsKeyboardFocusableCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsOffscreen(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsOffscreen", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsOffscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsOffscreenCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsOffscreenCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsOffscreenCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPassword(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPassword", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsPassword());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPasswordCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPasswordCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsPasswordCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPeripheral(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPeripheral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsPeripheral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPeripheralCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPeripheralCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsPeripheralCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsRequiredForForm(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsRequiredForForm", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsRequiredForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsRequiredForFormCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"IsRequiredForFormCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsRequiredForFormCore());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ListenerExists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ListenerExists", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer::ListenerExists(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_Navigate(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"Navigate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.Navigate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_NavigateCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"NavigateCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.NavigateCore(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_PeerFromProvider(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"PeerFromProvider", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert(self->obj.PeerFromProvider(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ProviderFromPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ProviderFromPeer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 0);

                return py::convert(self->obj.ProviderFromPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseAutomationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseAutomationEvent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                self->obj.RaiseAutomationEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseNotificationEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseNotificationEvent", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationNotificationProcessing>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                self->obj.RaiseNotificationEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaisePropertyChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaisePropertyChangedEvent", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.RaisePropertyChangedEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseStructureChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseStructureChangedEvent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationStructureChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                self->obj.RaiseStructureChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseTextEditTextChangedEvent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseTextEditTextChangedEvent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationTextEditChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                self->obj.RaiseTextEditTextChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetFocus(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetFocus", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetFocusCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetFocusCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.SetFocusCore();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetParent(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"SetParent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 0);

                self->obj.SetParent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ShowContextMenu(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ShowContextMenu", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowContextMenu();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ShowContextMenuCore(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"ShowContextMenuCore", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowContextMenuCore();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_get_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeer_put_EventsSource(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.EventsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeer[] = {
        { "generate_raw_element_provider_runtime_id", reinterpret_cast<PyCFunction>(AutomationPeer_GenerateRawElementProviderRuntimeId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_accelerator_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAcceleratorKey), METH_VARARGS, nullptr },
        { "get_accelerator_key_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetAcceleratorKeyCore), METH_VARARGS, nullptr },
        { "get_access_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAccessKey), METH_VARARGS, nullptr },
        { "get_access_key_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetAccessKeyCore), METH_VARARGS, nullptr },
        { "get_annotations", reinterpret_cast<PyCFunction>(AutomationPeer_GetAnnotations), METH_VARARGS, nullptr },
        { "get_annotations_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetAnnotationsCore), METH_VARARGS, nullptr },
        { "get_automation_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationControlType), METH_VARARGS, nullptr },
        { "get_automation_control_type_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationControlTypeCore), METH_VARARGS, nullptr },
        { "get_automation_id", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationId), METH_VARARGS, nullptr },
        { "get_automation_id_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationIdCore), METH_VARARGS, nullptr },
        { "get_bounding_rectangle", reinterpret_cast<PyCFunction>(AutomationPeer_GetBoundingRectangle), METH_VARARGS, nullptr },
        { "get_bounding_rectangle_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetBoundingRectangleCore), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(AutomationPeer_GetChildren), METH_VARARGS, nullptr },
        { "get_children_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetChildrenCore), METH_VARARGS, nullptr },
        { "get_class_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetClassName), METH_VARARGS, nullptr },
        { "get_class_name_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetClassNameCore), METH_VARARGS, nullptr },
        { "get_clickable_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetClickablePoint), METH_VARARGS, nullptr },
        { "get_clickable_point_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetClickablePointCore), METH_VARARGS, nullptr },
        { "get_controlled_peers", reinterpret_cast<PyCFunction>(AutomationPeer_GetControlledPeers), METH_VARARGS, nullptr },
        { "get_controlled_peers_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetControlledPeersCore), METH_VARARGS, nullptr },
        { "get_culture", reinterpret_cast<PyCFunction>(AutomationPeer_GetCulture), METH_VARARGS, nullptr },
        { "get_culture_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetCultureCore), METH_VARARGS, nullptr },
        { "get_described_by_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetDescribedByCore), METH_VARARGS, nullptr },
        { "get_element_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetElementFromPoint), METH_VARARGS, nullptr },
        { "get_element_from_point_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetElementFromPointCore), METH_VARARGS, nullptr },
        { "get_flows_from_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetFlowsFromCore), METH_VARARGS, nullptr },
        { "get_flows_to_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetFlowsToCore), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(AutomationPeer_GetFocusedElement), METH_VARARGS, nullptr },
        { "get_focused_element_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetFocusedElementCore), METH_VARARGS, nullptr },
        { "get_full_description", reinterpret_cast<PyCFunction>(AutomationPeer_GetFullDescription), METH_VARARGS, nullptr },
        { "get_full_description_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetFullDescriptionCore), METH_VARARGS, nullptr },
        { "get_heading_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetHeadingLevel), METH_VARARGS, nullptr },
        { "get_heading_level_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetHeadingLevelCore), METH_VARARGS, nullptr },
        { "get_help_text", reinterpret_cast<PyCFunction>(AutomationPeer_GetHelpText), METH_VARARGS, nullptr },
        { "get_help_text_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetHelpTextCore), METH_VARARGS, nullptr },
        { "get_item_status", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemStatus), METH_VARARGS, nullptr },
        { "get_item_status_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemStatusCore), METH_VARARGS, nullptr },
        { "get_item_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemType), METH_VARARGS, nullptr },
        { "get_item_type_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemTypeCore), METH_VARARGS, nullptr },
        { "get_labeled_by", reinterpret_cast<PyCFunction>(AutomationPeer_GetLabeledBy), METH_VARARGS, nullptr },
        { "get_labeled_by_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLabeledByCore), METH_VARARGS, nullptr },
        { "get_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLandmarkType), METH_VARARGS, nullptr },
        { "get_landmark_type_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLandmarkTypeCore), METH_VARARGS, nullptr },
        { "get_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetLevel), METH_VARARGS, nullptr },
        { "get_level_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLevelCore), METH_VARARGS, nullptr },
        { "get_live_setting", reinterpret_cast<PyCFunction>(AutomationPeer_GetLiveSetting), METH_VARARGS, nullptr },
        { "get_live_setting_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLiveSettingCore), METH_VARARGS, nullptr },
        { "get_localized_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedControlType), METH_VARARGS, nullptr },
        { "get_localized_control_type_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedControlTypeCore), METH_VARARGS, nullptr },
        { "get_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "get_localized_landmark_type_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedLandmarkTypeCore), METH_VARARGS, nullptr },
        { "get_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetName), METH_VARARGS, nullptr },
        { "get_name_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetNameCore), METH_VARARGS, nullptr },
        { "get_orientation", reinterpret_cast<PyCFunction>(AutomationPeer_GetOrientation), METH_VARARGS, nullptr },
        { "get_orientation_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetOrientationCore), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(AutomationPeer_GetParent), METH_VARARGS, nullptr },
        { "get_pattern", reinterpret_cast<PyCFunction>(AutomationPeer_GetPattern), METH_VARARGS, nullptr },
        { "get_pattern_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetPatternCore), METH_VARARGS, nullptr },
        { "get_peer_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetPeerFromPoint), METH_VARARGS, nullptr },
        { "get_peer_from_point_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetPeerFromPointCore), METH_VARARGS, nullptr },
        { "get_position_in_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetPositionInSet), METH_VARARGS, nullptr },
        { "get_position_in_set_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetPositionInSetCore), METH_VARARGS, nullptr },
        { "get_size_of_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetSizeOfSet), METH_VARARGS, nullptr },
        { "get_size_of_set_core", reinterpret_cast<PyCFunction>(AutomationPeer_GetSizeOfSetCore), METH_VARARGS, nullptr },
        { "has_keyboard_focus", reinterpret_cast<PyCFunction>(AutomationPeer_HasKeyboardFocus), METH_VARARGS, nullptr },
        { "has_keyboard_focus_core", reinterpret_cast<PyCFunction>(AutomationPeer_HasKeyboardFocusCore), METH_VARARGS, nullptr },
        { "invalidate_peer", reinterpret_cast<PyCFunction>(AutomationPeer_InvalidatePeer), METH_VARARGS, nullptr },
        { "is_content_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsContentElement), METH_VARARGS, nullptr },
        { "is_content_element_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsContentElementCore), METH_VARARGS, nullptr },
        { "is_control_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsControlElement), METH_VARARGS, nullptr },
        { "is_control_element_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsControlElementCore), METH_VARARGS, nullptr },
        { "is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsDataValidForForm), METH_VARARGS, nullptr },
        { "is_data_valid_for_form_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsDataValidForFormCore), METH_VARARGS, nullptr },
        { "is_dialog", reinterpret_cast<PyCFunction>(AutomationPeer_IsDialog), METH_VARARGS, nullptr },
        { "is_dialog_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsDialogCore), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(AutomationPeer_IsEnabled), METH_VARARGS, nullptr },
        { "is_enabled_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsEnabledCore), METH_VARARGS, nullptr },
        { "is_keyboard_focusable", reinterpret_cast<PyCFunction>(AutomationPeer_IsKeyboardFocusable), METH_VARARGS, nullptr },
        { "is_keyboard_focusable_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsKeyboardFocusableCore), METH_VARARGS, nullptr },
        { "is_offscreen", reinterpret_cast<PyCFunction>(AutomationPeer_IsOffscreen), METH_VARARGS, nullptr },
        { "is_offscreen_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsOffscreenCore), METH_VARARGS, nullptr },
        { "is_password", reinterpret_cast<PyCFunction>(AutomationPeer_IsPassword), METH_VARARGS, nullptr },
        { "is_password_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsPasswordCore), METH_VARARGS, nullptr },
        { "is_peripheral", reinterpret_cast<PyCFunction>(AutomationPeer_IsPeripheral), METH_VARARGS, nullptr },
        { "is_peripheral_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsPeripheralCore), METH_VARARGS, nullptr },
        { "is_required_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsRequiredForForm), METH_VARARGS, nullptr },
        { "is_required_for_form_core", reinterpret_cast<PyCFunction>(AutomationPeer_IsRequiredForFormCore), METH_VARARGS, nullptr },
        { "listener_exists", reinterpret_cast<PyCFunction>(AutomationPeer_ListenerExists), METH_VARARGS | METH_STATIC, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(AutomationPeer_Navigate), METH_VARARGS, nullptr },
        { "navigate_core", reinterpret_cast<PyCFunction>(AutomationPeer_NavigateCore), METH_VARARGS, nullptr },
        { "peer_from_provider", reinterpret_cast<PyCFunction>(AutomationPeer_PeerFromProvider), METH_VARARGS, nullptr },
        { "provider_from_peer", reinterpret_cast<PyCFunction>(AutomationPeer_ProviderFromPeer), METH_VARARGS, nullptr },
        { "raise_automation_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseAutomationEvent), METH_VARARGS, nullptr },
        { "raise_notification_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseNotificationEvent), METH_VARARGS, nullptr },
        { "raise_property_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaisePropertyChangedEvent), METH_VARARGS, nullptr },
        { "raise_structure_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseStructureChangedEvent), METH_VARARGS, nullptr },
        { "raise_text_edit_text_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseTextEditTextChangedEvent), METH_VARARGS, nullptr },
        { "set_focus", reinterpret_cast<PyCFunction>(AutomationPeer_SetFocus), METH_VARARGS, nullptr },
        { "set_focus_core", reinterpret_cast<PyCFunction>(AutomationPeer_SetFocusCore), METH_VARARGS, nullptr },
        { "set_parent", reinterpret_cast<PyCFunction>(AutomationPeer_SetParent), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(AutomationPeer_ShowContextMenu), METH_VARARGS, nullptr },
        { "show_context_menu_core", reinterpret_cast<PyCFunction>(AutomationPeer_ShowContextMenuCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeer[] = {
        { "events_source", reinterpret_cast<getter>(AutomationPeer_get_EventsSource), reinterpret_cast<setter>(AutomationPeer_put_EventsSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_AutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeer
    };

    // ----- AutomationPeerAnnotation class --------------------
    static constexpr const char* const type_name_AutomationPeerAnnotation = "AutomationPeerAnnotation";

    static PyObject* _new_AutomationPeerAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutomationPeerAnnotation(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeerAnnotation_get_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Type(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AnnotationType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Peer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Peer(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.Peer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_PeerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"PeerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::PeerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"TypeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeerAnnotation[] = {
        { "_assign_array_", _assign_array_AutomationPeerAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeerAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeerAnnotation[] = {
        { "type", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Type), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Type), nullptr, nullptr },
        { "peer", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Peer), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Peer), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeerAnnotation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeerAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeerAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeerAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeerAnnotation) },
        { },
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AutomationPeerAnnotation",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::AutomationPeerAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeerAnnotation
    };

    static PyGetSetDef getset_AutomationPeerAnnotation_Meta[] = {
        { "peer_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_PeerProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutomationPeerAnnotation_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeerAnnotation_Meta) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation_Meta =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.AutomationPeerAnnotation_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeerAnnotation_Meta
    };

    // ----- ButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_ButtonAutomationPeer = "ButtonAutomationPeer";

    static PyObject* _new_ButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Button>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ButtonAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(ButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonAutomationPeer
    };

    // ----- ButtonBaseAutomationPeer class --------------------
    static constexpr const char* const type_name_ButtonBaseAutomationPeer = "ButtonBaseAutomationPeer";

    static PyObject* _new_ButtonBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ButtonBaseAutomationPeer);
        return nullptr;
    }

    static void _dealloc_ButtonBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ButtonBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBaseAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ButtonBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonBaseAutomationPeer
    };

    // ----- CalendarDatePickerAutomationPeer class --------------------
    static constexpr const char* const type_name_CalendarDatePickerAutomationPeer = "CalendarDatePickerAutomationPeer";

    static PyObject* _new_CalendarDatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CalendarDatePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarDatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarDatePickerAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarDatePickerAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CalendarDatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarDatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarDatePickerAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarDatePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarDatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarDatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarDatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarDatePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.CalendarDatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarDatePickerAutomationPeer
    };

    // ----- CaptureElementAutomationPeer class --------------------
    static constexpr const char* const type_name_CaptureElementAutomationPeer = "CaptureElementAutomationPeer";

    static PyObject* _new_CaptureElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CaptureElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CaptureElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CaptureElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CaptureElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_CaptureElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CaptureElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CaptureElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CaptureElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CaptureElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CaptureElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CaptureElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CaptureElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CaptureElementAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.CaptureElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CaptureElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CaptureElementAutomationPeer
    };

    // ----- CheckBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_CheckBoxAutomationPeer = "CheckBoxAutomationPeer";

    static PyObject* _new_CheckBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::CheckBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_CheckBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.CheckBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBoxAutomationPeer
    };

    // ----- ColorPickerSliderAutomationPeer class --------------------
    static constexpr const char* const type_name_ColorPickerSliderAutomationPeer = "ColorPickerSliderAutomationPeer";

    static PyObject* _new_ColorPickerSliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorPickerSlider>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorPickerSliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPickerSliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorPickerSliderAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSliderAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ColorPickerSliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorPickerSliderAutomationPeer
    };

    // ----- ColorSpectrumAutomationPeer class --------------------
    static constexpr const char* const type_name_ColorSpectrumAutomationPeer = "ColorSpectrumAutomationPeer";

    static PyObject* _new_ColorSpectrumAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ColorSpectrum>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrumAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrumAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorSpectrumAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrumAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrumAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrumAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrumAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrumAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrumAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrumAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ColorSpectrumAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorSpectrumAutomationPeer
    };

    // ----- ComboBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_ComboBoxAutomationPeer = "ComboBoxAutomationPeer";

    static PyObject* _new_ComboBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxAutomationPeer_Close(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetVisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetVisualState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_WaitForInputIdle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"WaitForInputIdle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_InteractionState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"InteractionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsModal(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsModal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsTopmost(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsTopmost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Maximizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Maximizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Minimizable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Minimizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_VisualState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"VisualState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ComboBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxAutomationPeer
    };

    // ----- ComboBoxItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ComboBoxItemAutomationPeer = "ComboBoxItemAutomationPeer";

    static PyObject* _new_ComboBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ComboBoxItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ComboBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ComboBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemAutomationPeer
    };

    // ----- ComboBoxItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_ComboBoxItemDataAutomationPeer = "ComboBoxItemDataAutomationPeer";

    static PyObject* _new_ComboBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ComboBoxItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ComboBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ComboBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemDataAutomationPeer
    };

    // ----- DatePickerAutomationPeer class --------------------
    static constexpr const char* const type_name_DatePickerAutomationPeer = "DatePickerAutomationPeer";

    static PyObject* _new_DatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::DatePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.DatePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerAutomationPeer
    };

    // ----- DatePickerFlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_DatePickerFlyoutPresenterAutomationPeer = "DatePickerFlyoutPresenterAutomationPeer";

    static PyObject* _new_DatePickerFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DatePickerFlyoutPresenterAutomationPeer);
        return nullptr;
    }

    static void _dealloc_DatePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_DatePickerFlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.DatePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyoutPresenterAutomationPeer
    };

    // ----- FlipViewAutomationPeer class --------------------
    static constexpr const char* const type_name_FlipViewAutomationPeer = "FlipViewAutomationPeer";

    static PyObject* _new_FlipViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.FlipViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewAutomationPeer
    };

    // ----- FlipViewItemAutomationPeer class --------------------
    static constexpr const char* const type_name_FlipViewItemAutomationPeer = "FlipViewItemAutomationPeer";

    static PyObject* _new_FlipViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlipViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.FlipViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemAutomationPeer
    };

    // ----- FlipViewItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_FlipViewItemDataAutomationPeer = "FlipViewItemDataAutomationPeer";

    static PyObject* _new_FlipViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FlipViewItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(FlipViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FlipViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.FlipViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemDataAutomationPeer
    };

    // ----- FlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_FlyoutPresenterAutomationPeer = "FlyoutPresenterAutomationPeer";

    static PyObject* _new_FlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::FlyoutPresenter>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.FlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutPresenterAutomationPeer
    };

    // ----- FrameworkElementAutomationPeer class --------------------
    static constexpr const char* const type_name_FrameworkElementAutomationPeer = "FrameworkElementAutomationPeer";

    static PyObject* _new_FrameworkElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::FrameworkElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkElementAutomationPeer_CreatePeerForElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"CreatePeerForElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::CreatePeerForElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_FromElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"FromElement", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::FromElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_get_Owner(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"Owner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Owner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkElementAutomationPeer[] = {
        { "create_peer_for_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_CreatePeerForElement), METH_VARARGS | METH_STATIC, nullptr },
        { "from_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_FromElement), METH_VARARGS | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_FrameworkElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkElementAutomationPeer[] = {
        { "owner", reinterpret_cast<getter>(FrameworkElementAutomationPeer_get_Owner), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameworkElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.FrameworkElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkElementAutomationPeer
    };

    // ----- GridViewAutomationPeer class --------------------
    static constexpr const char* const type_name_GridViewAutomationPeer = "GridViewAutomationPeer";

    static PyObject* _new_GridViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.GridViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewAutomationPeer
    };

    // ----- GridViewHeaderItemAutomationPeer class --------------------
    static constexpr const char* const type_name_GridViewHeaderItemAutomationPeer = "GridViewHeaderItemAutomationPeer";

    static PyObject* _new_GridViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewHeaderItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.GridViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewHeaderItemAutomationPeer
    };

    // ----- GridViewItemAutomationPeer class --------------------
    static constexpr const char* const type_name_GridViewItemAutomationPeer = "GridViewItemAutomationPeer";

    static PyObject* _new_GridViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GridViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.GridViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemAutomationPeer
    };

    // ----- GridViewItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_GridViewItemDataAutomationPeer = "GridViewItemDataAutomationPeer";

    static PyObject* _new_GridViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::GridViewAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.GridViewItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(GridViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GridViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.GridViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemDataAutomationPeer
    };

    // ----- GroupItemAutomationPeer class --------------------
    static constexpr const char* const type_name_GroupItemAutomationPeer = "GroupItemAutomationPeer";

    static PyObject* _new_GroupItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::GroupItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GroupItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GroupItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GroupItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GroupItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GroupItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GroupItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GroupItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GroupItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GroupItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GroupItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.GroupItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::GroupItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GroupItemAutomationPeer
    };

    // ----- HubAutomationPeer class --------------------
    static constexpr const char* const type_name_HubAutomationPeer = "HubAutomationPeer";

    static PyObject* _new_HubAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Hub>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubAutomationPeer[] = {
        { "_assign_array_", _assign_array_HubAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HubAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.HubAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubAutomationPeer
    };

    // ----- HubSectionAutomationPeer class --------------------
    static constexpr const char* const type_name_HubSectionAutomationPeer = "HubSectionAutomationPeer";

    static PyObject* _new_HubSectionAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HubSection>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubSectionAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HubSectionAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HubSectionAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubSectionAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(HubSectionAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HubSectionAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubSectionAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubSectionAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubSectionAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubSectionAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubSectionAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubSectionAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubSectionAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.HubSectionAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HubSectionAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubSectionAutomationPeer
    };

    // ----- HyperlinkButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_HyperlinkButtonAutomationPeer = "HyperlinkButtonAutomationPeer";

    static PyObject* _new_HyperlinkButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::HyperlinkButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.HyperlinkButtonAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(HyperlinkButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HyperlinkButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.HyperlinkButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButtonAutomationPeer
    };

    // ----- ImageAutomationPeer class --------------------
    static constexpr const char* const type_name_ImageAutomationPeer = "ImageAutomationPeer";

    static PyObject* _new_ImageAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Image>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageAutomationPeer[] = {
        { "_assign_array_", _assign_array_ImageAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ImageAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ImageAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ImageAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageAutomationPeer
    };

    // ----- InkToolbarAutomationPeer class --------------------
    static constexpr const char* const type_name_InkToolbarAutomationPeer = "InkToolbarAutomationPeer";

    static PyObject* _new_InkToolbarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InkToolbarAutomationPeer);
        return nullptr;
    }

    static void _dealloc_InkToolbarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InkToolbarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkToolbarAutomationPeer[] = {
        { "_assign_array_", _assign_array_InkToolbarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkToolbarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkToolbarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkToolbarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InkToolbarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InkToolbarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InkToolbarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InkToolbarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_InkToolbarAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.InkToolbarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::InkToolbarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkToolbarAutomationPeer
    };

    // ----- ItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ItemAutomationPeer = "ItemAutomationPeer";

    static PyObject* _new_ItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Realize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_Item(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Item"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"ItemsControlAutomationPeer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemsControlAutomationPeer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(ItemAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemAutomationPeer[] = {
        { "item", reinterpret_cast<getter>(ItemAutomationPeer_get_Item), nullptr, nullptr, nullptr },
        { "items_control_automation_peer", reinterpret_cast<getter>(ItemAutomationPeer_get_ItemsControlAutomationPeer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemAutomationPeer
    };

    // ----- ItemsControlAutomationPeer class --------------------
    static constexpr const char* const type_name_ItemsControlAutomationPeer = "ItemsControlAutomationPeer";

    static PyObject* _new_ItemsControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ItemsControl>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsControlAutomationPeer_CreateItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"CreateItemAutomationPeer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CreateItemAutomationPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsControlAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"FindItemByProperty", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsControlAutomationPeer_OnCreateItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"OnCreateItemAutomationPeer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.OnCreateItemAutomationPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsControlAutomationPeer[] = {
        { "create_item_automation_peer", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_CreateItemAutomationPeer), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "on_create_item_automation_peer", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_OnCreateItemAutomationPeer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemsControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ItemsControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ItemsControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsControlAutomationPeer
    };

    // ----- ListBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_ListBoxAutomationPeer = "ListBoxAutomationPeer";

    static PyObject* _new_ListBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxAutomationPeer
    };

    // ----- ListBoxItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ListBoxItemAutomationPeer = "ListBoxItemAutomationPeer";

    static PyObject* _new_ListBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListBoxItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListBoxItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemAutomationPeer
    };

    // ----- ListBoxItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_ListBoxItemDataAutomationPeer = "ListBoxItemDataAutomationPeer";

    static PyObject* _new_ListBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListBoxItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemDataAutomationPeer
    };

    // ----- ListPickerFlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_ListPickerFlyoutPresenterAutomationPeer = "ListPickerFlyoutPresenterAutomationPeer";

    static PyObject* _new_ListPickerFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ListPickerFlyoutPresenterAutomationPeer);
        return nullptr;
    }

    static void _dealloc_ListPickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListPickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListPickerFlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListPickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyoutPresenterAutomationPeer
    };

    // ----- ListViewAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewAutomationPeer = "ListViewAutomationPeer";

    static PyObject* _new_ListViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListView>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewAutomationPeer
    };

    // ----- ListViewBaseAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewBaseAutomationPeer = "ListViewBaseAutomationPeer";

    static PyObject* _new_ListViewBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewBase>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffect(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffects(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffects"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseAutomationPeer[] = {
        { "drop_effect", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseAutomationPeer
    };

    // ----- ListViewBaseHeaderItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewBaseHeaderItemAutomationPeer = "ListViewBaseHeaderItemAutomationPeer";

    static PyObject* _new_ListViewBaseHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ListViewBaseHeaderItemAutomationPeer);
        return nullptr;
    }

    static void _dealloc_ListViewBaseHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewBaseHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseHeaderItemAutomationPeer
    };

    // ----- ListViewHeaderItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewHeaderItemAutomationPeer = "ListViewHeaderItemAutomationPeer";

    static PyObject* _new_ListViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewHeaderItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewHeaderItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewHeaderItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewHeaderItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewHeaderItemAutomationPeer
    };

    // ----- ListViewItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewItemAutomationPeer = "ListViewItemAutomationPeer";

    static PyObject* _new_ListViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ListViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemAutomationPeer
    };

    // ----- ListViewItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_ListViewItemDataAutomationPeer = "ListViewItemDataAutomationPeer";

    static PyObject* _new_ListViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ListViewItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ListViewItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemDataAutomationPeer
    };

    // ----- LoopingSelectorAutomationPeer class --------------------
    static constexpr const char* const type_name_LoopingSelectorAutomationPeer = "LoopingSelectorAutomationPeer";

    static PyObject* _new_LoopingSelectorAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LoopingSelectorAutomationPeer);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_FindItemByProperty(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"FindItemByProperty", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Scroll", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"SetScrollPercent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"CanSelectMultiple"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"IsSelectionRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "horizontal_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.LoopingSelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorAutomationPeer
    };

    // ----- LoopingSelectorItemAutomationPeer class --------------------
    static constexpr const char* const type_name_LoopingSelectorItemAutomationPeer = "LoopingSelectorItemAutomationPeer";

    static PyObject* _new_LoopingSelectorItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LoopingSelectorItemAutomationPeer);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"SelectionContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.LoopingSelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemAutomationPeer
    };

    // ----- LoopingSelectorItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_LoopingSelectorItemDataAutomationPeer = "LoopingSelectorItemDataAutomationPeer";

    static PyObject* _new_LoopingSelectorItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LoopingSelectorItemDataAutomationPeer);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.LoopingSelectorItemDataAutomationPeer", L"Realize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemDataAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(LoopingSelectorItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_LoopingSelectorItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.LoopingSelectorItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemDataAutomationPeer
    };

    // ----- MapControlAutomationPeer class --------------------
    static constexpr const char* const type_name_MapControlAutomationPeer = "MapControlAutomationPeer";

    static PyObject* _new_MapControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MapControlAutomationPeer);
        return nullptr;
    }

    static void _dealloc_MapControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MapControlAutomationPeer_Move(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Move", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Move(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Resize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Resize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Resize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Rotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Rotate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Rotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Scroll", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"SetScrollPercent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_Zoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"Zoom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Zoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_ZoomByUnit(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomByUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ZoomUnit>(args, 0);

                self->obj.ZoomByUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"HorizontallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"VerticallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanMove(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanMove"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMove());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanResize(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanResize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanResize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanRotate(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanRotate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRotate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_CanZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"CanZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MaxZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MaxZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_MinZoom(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"MinZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapControlAutomationPeer_get_ZoomLevel(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MapControlAutomationPeer", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MapControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapControlAutomationPeer[] = {
        { "move", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Rotate), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "zoom", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_Zoom), METH_VARARGS, nullptr },
        { "zoom_by_unit", reinterpret_cast<PyCFunction>(MapControlAutomationPeer_ZoomByUnit), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MapControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MapControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapControlAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(MapControlAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_move", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanRotate), nullptr, nullptr, nullptr },
        { "can_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_CanZoom), nullptr, nullptr, nullptr },
        { "max_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MaxZoom), nullptr, nullptr, nullptr },
        { "min_zoom", reinterpret_cast<getter>(MapControlAutomationPeer_get_MinZoom), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(MapControlAutomationPeer_get_ZoomLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MapControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MapControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MapControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MapControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MapControlAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MapControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MapControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapControlAutomationPeer
    };

    // ----- MediaElementAutomationPeer class --------------------
    static constexpr const char* const type_name_MediaElementAutomationPeer = "MediaElementAutomationPeer";

    static PyObject* _new_MediaElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaElementAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MediaElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaElementAutomationPeer
    };

    // ----- MediaPlayerElementAutomationPeer class --------------------
    static constexpr const char* const type_name_MediaPlayerElementAutomationPeer = "MediaPlayerElementAutomationPeer";

    static PyObject* _new_MediaPlayerElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaPlayerElement>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayerElementAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaPlayerElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerElementAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerElementAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MediaPlayerElementAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerElementAutomationPeer
    };

    // ----- MediaTransportControlsAutomationPeer class --------------------
    static constexpr const char* const type_name_MediaTransportControlsAutomationPeer = "MediaTransportControlsAutomationPeer";

    static PyObject* _new_MediaTransportControlsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MediaTransportControls>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTransportControlsAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaTransportControlsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MediaTransportControlsAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTransportControlsAutomationPeer
    };

    // ----- MenuBarAutomationPeer class --------------------
    static constexpr const char* const type_name_MenuBarAutomationPeer = "MenuBarAutomationPeer";

    static PyObject* _new_MenuBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MenuBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarAutomationPeer
    };

    // ----- MenuBarItemAutomationPeer class --------------------
    static constexpr const char* const type_name_MenuBarItemAutomationPeer = "MenuBarItemAutomationPeer";

    static PyObject* _new_MenuBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuBarItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(MenuBarItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MenuBarItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarItemAutomationPeer
    };

    // ----- MenuFlyoutItemAutomationPeer class --------------------
    static constexpr const char* const type_name_MenuFlyoutItemAutomationPeer = "MenuFlyoutItemAutomationPeer";

    static PyObject* _new_MenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.MenuFlyoutItemAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(MenuFlyoutItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemAutomationPeer
    };

    // ----- MenuFlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_MenuFlyoutPresenterAutomationPeer = "MenuFlyoutPresenterAutomationPeer";

    static PyObject* _new_MenuFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::MenuFlyoutPresenter>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.MenuFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterAutomationPeer
    };

    // ----- NavigationViewItemAutomationPeer class --------------------
    static constexpr const char* const type_name_NavigationViewItemAutomationPeer = "NavigationViewItemAutomationPeer";

    static PyObject* _new_NavigationViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_NavigationViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.NavigationViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemAutomationPeer
    };

    // ----- PasswordBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_PasswordBoxAutomationPeer = "PasswordBoxAutomationPeer";

    static PyObject* _new_PasswordBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PasswordBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_PasswordBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PasswordBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PasswordBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PasswordBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PasswordBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PasswordBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PasswordBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PasswordBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PasswordBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordBoxAutomationPeer
    };

    // ----- PersonPictureAutomationPeer class --------------------
    static constexpr const char* const type_name_PersonPictureAutomationPeer = "PersonPictureAutomationPeer";

    static PyObject* _new_PersonPictureAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PersonPicture>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPictureAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureAutomationPeer[] = {
        { "_assign_array_", _assign_array_PersonPictureAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersonPictureAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PersonPictureAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PersonPictureAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersonPictureAutomationPeer
    };

    // ----- PickerFlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_PickerFlyoutPresenterAutomationPeer = "PickerFlyoutPresenterAutomationPeer";

    static PyObject* _new_PickerFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PickerFlyoutPresenterAutomationPeer);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_PickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PickerFlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyoutPresenterAutomationPeer
    };

    // ----- PivotAutomationPeer class --------------------
    static constexpr const char* const type_name_PivotAutomationPeer = "PivotAutomationPeer";

    static PyObject* _new_PivotAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Pivot>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"Scroll", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"SetScrollPercent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"CanSelectMultiple"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"IsSelectionRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(PivotAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(PivotAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(PivotAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(PivotAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(PivotAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PivotAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotAutomationPeer
    };

    // ----- PivotItemAutomationPeer class --------------------
    static constexpr const char* const type_name_PivotItemAutomationPeer = "PivotItemAutomationPeer";

    static PyObject* _new_PivotItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::PivotItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_PivotItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PivotItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemAutomationPeer
    };

    // ----- PivotItemDataAutomationPeer class --------------------
    static constexpr const char* const type_name_PivotItemDataAutomationPeer = "PivotItemDataAutomationPeer";

    static PyObject* _new_PivotItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::PivotAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemDataAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotItemDataAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Realize(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Realize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_ScrollIntoView(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"SelectionContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemDataAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "realize", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemDataAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotItemDataAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemDataAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_PivotItemDataAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.PivotItemDataAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemDataAutomationPeer
    };

    // ----- ProgressBarAutomationPeer class --------------------
    static constexpr const char* const type_name_ProgressBarAutomationPeer = "ProgressBarAutomationPeer";

    static PyObject* _new_ProgressBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ProgressBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBarAutomationPeer
    };

    // ----- ProgressRingAutomationPeer class --------------------
    static constexpr const char* const type_name_ProgressRingAutomationPeer = "ProgressRingAutomationPeer";

    static PyObject* _new_ProgressRingAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ProgressRing>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRingAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressRingAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressRingAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressRingAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ProgressRingAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressRingAutomationPeer
    };

    // ----- RadioButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_RadioButtonAutomationPeer = "RadioButtonAutomationPeer";

    static PyObject* _new_RadioButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RadioButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButtonAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"SelectionContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadioButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButtonAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RadioButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButtonAutomationPeer
    };

    // ----- RangeBaseAutomationPeer class --------------------
    static constexpr const char* const type_name_RangeBaseAutomationPeer = "RangeBaseAutomationPeer";

    static PyObject* _new_RangeBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RangeBase>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RangeBaseAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseAutomationPeer_SetValue(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_IsReadOnly(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_LargeChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"LargeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Maximum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Maximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Minimum(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Minimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_SmallChange(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SmallChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Value(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(RangeBaseAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RangeBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RangeBaseAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseAutomationPeer
    };

    // ----- RatingControlAutomationPeer class --------------------
    static constexpr const char* const type_name_RatingControlAutomationPeer = "RatingControlAutomationPeer";

    static PyObject* _new_RatingControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RatingControl>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControlAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControlAutomationPeer[] = {
        { "_assign_array_", _assign_array_RatingControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RatingControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RatingControlAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControlAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RatingControlAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RatingControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RatingControlAutomationPeer
    };

    // ----- RepeatButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_RepeatButtonAutomationPeer = "RepeatButtonAutomationPeer";

    static PyObject* _new_RepeatButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::RepeatButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButtonAutomationPeer_Invoke(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.RepeatButtonAutomationPeer", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(RepeatButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RepeatButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeatButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RepeatButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButtonAutomationPeer
    };

    // ----- RichEditBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_RichEditBoxAutomationPeer = "RichEditBoxAutomationPeer";

    static PyObject* _new_RichEditBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichEditBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichEditBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichEditBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichEditBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RichEditBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditBoxAutomationPeer
    };

    // ----- RichTextBlockAutomationPeer class --------------------
    static constexpr const char* const type_name_RichTextBlockAutomationPeer = "RichTextBlockAutomationPeer";

    static PyObject* _new_RichTextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlock>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RichTextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockAutomationPeer
    };

    // ----- RichTextBlockOverflowAutomationPeer class --------------------
    static constexpr const char* const type_name_RichTextBlockOverflowAutomationPeer = "RichTextBlockOverflowAutomationPeer";

    static PyObject* _new_RichTextBlockOverflowAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::RichTextBlockOverflow>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockOverflowAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockOverflowAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockOverflowAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockOverflowAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockOverflowAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockOverflowAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockOverflowAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RichTextBlockOverflowAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockOverflowAutomationPeer
    };

    // ----- ScrollBarAutomationPeer class --------------------
    static constexpr const char* const type_name_ScrollBarAutomationPeer = "ScrollBarAutomationPeer";

    static PyObject* _new_ScrollBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ScrollBar>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBarAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ScrollBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollBarAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBarAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ScrollBarAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBarAutomationPeer
    };

    // ----- ScrollViewerAutomationPeer class --------------------
    static constexpr const char* const type_name_ScrollViewerAutomationPeer = "ScrollViewerAutomationPeer";

    static PyObject* _new_ScrollViewerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ScrollViewer>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollViewerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollViewerAutomationPeer_Scroll(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"Scroll", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_SetScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"SetScrollPercent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalScrollPercent(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalViewSize(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticallyScrollable(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollViewerAutomationPeer[] = {
        { "scroll", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScrollViewerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollViewerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollViewerAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollViewerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollViewerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollViewerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollViewerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollViewerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ScrollViewerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollViewerAutomationPeer
    };

    // ----- SearchBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_SearchBoxAutomationPeer = "SearchBoxAutomationPeer";

    static PyObject* _new_SearchBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SearchBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SearchBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SearchBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_SearchBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SearchBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SearchBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SearchBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SearchBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SearchBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SearchBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SearchBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SearchBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchBoxAutomationPeer
    };

    // ----- SelectorAutomationPeer class --------------------
    static constexpr const char* const type_name_SelectorAutomationPeer = "SelectorAutomationPeer";

    static PyObject* _new_SelectorAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Selector>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorAutomationPeer_GetSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"CanSelectMultiple"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"IsSelectionRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(SelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorAutomationPeer[] = {
        { "can_select_multiple", reinterpret_cast<getter>(SelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(SelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SelectorAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SelectorAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorAutomationPeer
    };

    // ----- SelectorItemAutomationPeer class --------------------
    static constexpr const char* const type_name_SelectorItemAutomationPeer = "SelectorItemAutomationPeer";

    static PyObject* _new_SelectorItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Automation::Peers::SelectorAutomationPeer>(args, 1);

                winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItemAutomationPeer_AddToSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_Select(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_IsSelected(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"SelectionContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SelectorItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorItemAutomationPeer
    };

    // ----- SemanticZoomAutomationPeer class --------------------
    static constexpr const char* const type_name_SemanticZoomAutomationPeer = "SemanticZoomAutomationPeer";

    static PyObject* _new_SemanticZoomAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SemanticZoom>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SemanticZoomAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SemanticZoomAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SemanticZoomAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SemanticZoomAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(SemanticZoomAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SemanticZoomAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SemanticZoomAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SemanticZoomAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(SemanticZoomAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SemanticZoomAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SemanticZoomAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SemanticZoomAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SemanticZoomAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SemanticZoomAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SemanticZoomAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SemanticZoomAutomationPeer
    };

    // ----- SettingsFlyoutAutomationPeer class --------------------
    static constexpr const char* const type_name_SettingsFlyoutAutomationPeer = "SettingsFlyoutAutomationPeer";

    static PyObject* _new_SettingsFlyoutAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::SettingsFlyout>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SettingsFlyoutAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SettingsFlyoutAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SettingsFlyoutAutomationPeer[] = {
        { "_assign_array_", _assign_array_SettingsFlyoutAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SettingsFlyoutAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SettingsFlyoutAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SettingsFlyoutAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SettingsFlyoutAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SettingsFlyoutAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SettingsFlyoutAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SettingsFlyoutAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SettingsFlyoutAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SettingsFlyoutAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SettingsFlyoutAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SettingsFlyoutAutomationPeer
    };

    // ----- SliderAutomationPeer class --------------------
    static constexpr const char* const type_name_SliderAutomationPeer = "SliderAutomationPeer";

    static PyObject* _new_SliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Slider>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SliderAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_SliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SliderAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SliderAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_SliderAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.SliderAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::SliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SliderAutomationPeer
    };

    // ----- TextBlockAutomationPeer class --------------------
    static constexpr const char* const type_name_TextBlockAutomationPeer = "TextBlockAutomationPeer";

    static PyObject* _new_TextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBlock>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBlockAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBlockAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBlockAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TextBlockAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBlockAutomationPeer
    };

    // ----- TextBoxAutomationPeer class --------------------
    static constexpr const char* const type_name_TextBoxAutomationPeer = "TextBoxAutomationPeer";

    static PyObject* _new_TextBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TextBox>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBoxAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBoxAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBoxAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TextBoxAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TextBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBoxAutomationPeer
    };

    // ----- ThumbAutomationPeer class --------------------
    static constexpr const char* const type_name_ThumbAutomationPeer = "ThumbAutomationPeer";

    static PyObject* _new_ThumbAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::Thumb>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThumbAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThumbAutomationPeer[] = {
        { "_assign_array_", _assign_array_ThumbAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThumbAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThumbAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ThumbAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThumbAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThumbAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThumbAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThumbAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ThumbAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ThumbAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ThumbAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ThumbAutomationPeer
    };

    // ----- TimePickerAutomationPeer class --------------------
    static constexpr const char* const type_name_TimePickerAutomationPeer = "TimePickerAutomationPeer";

    static PyObject* _new_TimePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TimePicker>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TimePickerAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerAutomationPeer
    };

    // ----- TimePickerFlyoutPresenterAutomationPeer class --------------------
    static constexpr const char* const type_name_TimePickerFlyoutPresenterAutomationPeer = "TimePickerFlyoutPresenterAutomationPeer";

    static PyObject* _new_TimePickerFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimePickerFlyoutPresenterAutomationPeer);
        return nullptr;
    }

    static void _dealloc_TimePickerFlyoutPresenterAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyoutPresenterAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyoutPresenterAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TimePickerFlyoutPresenterAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TimePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyoutPresenterAutomationPeer
    };

    // ----- ToggleButtonAutomationPeer class --------------------
    static constexpr const char* const type_name_ToggleButtonAutomationPeer = "ToggleButtonAutomationPeer";

    static PyObject* _new_ToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::Primitives::ToggleButton>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButtonAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButtonAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButtonAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButtonAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButtonAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButtonAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButtonAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ToggleButtonAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleButtonAutomationPeer
    };

    // ----- ToggleMenuFlyoutItemAutomationPeer class --------------------
    static constexpr const char* const type_name_ToggleMenuFlyoutItemAutomationPeer = "ToggleMenuFlyoutItemAutomationPeer";

    static PyObject* _new_ToggleMenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleMenuFlyoutItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleMenuFlyoutItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleMenuFlyoutItemAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleMenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleMenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleMenuFlyoutItemAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleMenuFlyoutItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleMenuFlyoutItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ToggleMenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleMenuFlyoutItemAutomationPeer
    };

    // ----- ToggleSwitchAutomationPeer class --------------------
    static constexpr const char* const type_name_ToggleSwitchAutomationPeer = "ToggleSwitchAutomationPeer";

    static PyObject* _new_ToggleSwitchAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::ToggleSwitch>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSwitchAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchAutomationPeer_Toggle(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchAutomationPeer_get_ToggleState(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSwitchAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSwitchAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleSwitchAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.ToggleSwitchAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchAutomationPeer
    };

    // ----- TreeViewItemAutomationPeer class --------------------
    static constexpr const char* const type_name_TreeViewItemAutomationPeer = "TreeViewItemAutomationPeer";

    static PyObject* _new_TreeViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewItem>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemAutomationPeer_Collapse(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_Expand(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItemAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TreeViewItemAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItemAutomationPeer
    };

    // ----- TreeViewListAutomationPeer class --------------------
    static constexpr const char* const type_name_TreeViewListAutomationPeer = "TreeViewListAutomationPeer";

    static PyObject* _new_TreeViewListAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Controls::TreeViewList>(args, 0);

                winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewListAutomationPeer(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewListAutomationPeer[] = {
        { "_assign_array_", _assign_array_TreeViewListAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewListAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewListAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewListAutomationPeer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewListAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewListAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewListAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewListAutomationPeer) },
        { },
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.TreeViewListAutomationPeer",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewListAutomationPeer
    };

    // ----- RawElementProviderRuntimeId struct --------------------
    static constexpr const char* const type_name_RawElementProviderRuntimeId = "RawElementProviderRuntimeId";

    PyObject* _new_RawElementProviderRuntimeId(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _Part1{};
        uint32_t _Part2{};

        static const char* kwlist[] = {"part1", "part2", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Part1, &_Part2))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId return_value{ _Part1, _Part2 };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RawElementProviderRuntimeId(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self) noexcept
    {
    }

    static PyObject* RawElementProviderRuntimeId_get_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part1);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part1(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part1 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RawElementProviderRuntimeId_get_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part2);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part2(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part2 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RawElementProviderRuntimeId[] = {
        { "part1", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part1), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part1), nullptr, nullptr },
        { "part2", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part2), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part2), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawElementProviderRuntimeId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawElementProviderRuntimeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawElementProviderRuntimeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawElementProviderRuntimeId) },
        { },
    };

    static PyType_Spec type_spec_RawElementProviderRuntimeId =
    {
        "_winrt_Windows_UI_Xaml_Automation_Peers.RawElementProviderRuntimeId",
        sizeof(py::wrapper::Windows::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawElementProviderRuntimeId
    };

    // ----- Windows.UI.Xaml.Automation.Peers Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Automation::Peers");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_UI_Xaml_Automation_Peers",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Automation::Peers

PyMODINIT_FUNC PyInit__winrt_Windows_UI_Xaml_Automation_Peers(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Automation::Peers;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AppBarAutomationPeer, &type_spec_AppBarAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AppBarAutomationPeer, &type_spec_AppBarAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AppBarButtonAutomationPeer, &type_spec_AppBarButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AppBarButtonAutomationPeer, &type_spec_AppBarButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AppBarToggleButtonAutomationPeer, &type_spec_AppBarToggleButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AppBarToggleButtonAutomationPeer, &type_spec_AppBarToggleButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AutoSuggestBoxAutomationPeer, &type_spec_AutoSuggestBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AutoSuggestBoxAutomationPeer, &type_spec_AutoSuggestBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AutomationPeer, &type_spec_AutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AutomationPeer, &type_spec_AutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeerAnnotation_Meta{PyType_FromSpec(&type_spec_AutomationPeerAnnotation_Meta)};
    if (!type_AutomationPeerAnnotation_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_AutomationPeerAnnotation, &type_spec_AutomationPeerAnnotation, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeerAnnotation_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_AutomationPeerAnnotation, &type_spec_AutomationPeerAnnotation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeerAnnotation_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ButtonAutomationPeer, &type_spec_ButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ButtonAutomationPeer, &type_spec_ButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ButtonBaseAutomationPeer, &type_spec_ButtonBaseAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ButtonBaseAutomationPeer, &type_spec_ButtonBaseAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CalendarDatePickerAutomationPeer, &type_spec_CalendarDatePickerAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CalendarDatePickerAutomationPeer, &type_spec_CalendarDatePickerAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CaptureElementAutomationPeer, &type_spec_CaptureElementAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CaptureElementAutomationPeer, &type_spec_CaptureElementAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_CheckBoxAutomationPeer, &type_spec_CheckBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_CheckBoxAutomationPeer, &type_spec_CheckBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorPickerSliderAutomationPeer, &type_spec_ColorPickerSliderAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorPickerSliderAutomationPeer, &type_spec_ColorPickerSliderAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ColorSpectrumAutomationPeer, &type_spec_ColorSpectrumAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ColorSpectrumAutomationPeer, &type_spec_ColorSpectrumAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ComboBoxAutomationPeer, &type_spec_ComboBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ComboBoxAutomationPeer, &type_spec_ComboBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ComboBoxItemAutomationPeer, &type_spec_ComboBoxItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ComboBoxItemAutomationPeer, &type_spec_ComboBoxItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ComboBoxItemDataAutomationPeer, &type_spec_ComboBoxItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ComboBoxItemDataAutomationPeer, &type_spec_ComboBoxItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DatePickerAutomationPeer, &type_spec_DatePickerAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DatePickerAutomationPeer, &type_spec_DatePickerAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_DatePickerFlyoutPresenterAutomationPeer, &type_spec_DatePickerFlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_DatePickerFlyoutPresenterAutomationPeer, &type_spec_DatePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FlipViewAutomationPeer, &type_spec_FlipViewAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FlipViewAutomationPeer, &type_spec_FlipViewAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FlipViewItemAutomationPeer, &type_spec_FlipViewItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FlipViewItemAutomationPeer, &type_spec_FlipViewItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FlipViewItemDataAutomationPeer, &type_spec_FlipViewItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FlipViewItemDataAutomationPeer, &type_spec_FlipViewItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FlyoutPresenterAutomationPeer, &type_spec_FlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FlyoutPresenterAutomationPeer, &type_spec_FlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_FrameworkElementAutomationPeer, &type_spec_FrameworkElementAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_FrameworkElementAutomationPeer, &type_spec_FrameworkElementAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GridViewAutomationPeer, &type_spec_GridViewAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GridViewAutomationPeer, &type_spec_GridViewAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GridViewHeaderItemAutomationPeer, &type_spec_GridViewHeaderItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GridViewHeaderItemAutomationPeer, &type_spec_GridViewHeaderItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GridViewItemAutomationPeer, &type_spec_GridViewItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GridViewItemAutomationPeer, &type_spec_GridViewItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GridViewItemDataAutomationPeer, &type_spec_GridViewItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GridViewItemDataAutomationPeer, &type_spec_GridViewItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_GroupItemAutomationPeer, &type_spec_GroupItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_GroupItemAutomationPeer, &type_spec_GroupItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_HubAutomationPeer, &type_spec_HubAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_HubAutomationPeer, &type_spec_HubAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_HubSectionAutomationPeer, &type_spec_HubSectionAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_HubSectionAutomationPeer, &type_spec_HubSectionAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_HyperlinkButtonAutomationPeer, &type_spec_HyperlinkButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_HyperlinkButtonAutomationPeer, &type_spec_HyperlinkButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ImageAutomationPeer, &type_spec_ImageAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ImageAutomationPeer, &type_spec_ImageAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_InkToolbarAutomationPeer, &type_spec_InkToolbarAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_InkToolbarAutomationPeer, &type_spec_InkToolbarAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ItemAutomationPeer, &type_spec_ItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ItemAutomationPeer, &type_spec_ItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ItemsControlAutomationPeer, &type_spec_ItemsControlAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ItemsControlAutomationPeer, &type_spec_ItemsControlAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListBoxAutomationPeer, &type_spec_ListBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListBoxAutomationPeer, &type_spec_ListBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListBoxItemAutomationPeer, &type_spec_ListBoxItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListBoxItemAutomationPeer, &type_spec_ListBoxItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListBoxItemDataAutomationPeer, &type_spec_ListBoxItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListBoxItemDataAutomationPeer, &type_spec_ListBoxItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListPickerFlyoutPresenterAutomationPeer, &type_spec_ListPickerFlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListPickerFlyoutPresenterAutomationPeer, &type_spec_ListPickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewAutomationPeer, &type_spec_ListViewAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewAutomationPeer, &type_spec_ListViewAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewBaseAutomationPeer, &type_spec_ListViewBaseAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewBaseAutomationPeer, &type_spec_ListViewBaseAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewBaseHeaderItemAutomationPeer, &type_spec_ListViewBaseHeaderItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewBaseHeaderItemAutomationPeer, &type_spec_ListViewBaseHeaderItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewHeaderItemAutomationPeer, &type_spec_ListViewHeaderItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewHeaderItemAutomationPeer, &type_spec_ListViewHeaderItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewItemAutomationPeer, &type_spec_ListViewItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewItemAutomationPeer, &type_spec_ListViewItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ListViewItemDataAutomationPeer, &type_spec_ListViewItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ListViewItemDataAutomationPeer, &type_spec_ListViewItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LoopingSelectorAutomationPeer, &type_spec_LoopingSelectorAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LoopingSelectorAutomationPeer, &type_spec_LoopingSelectorAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LoopingSelectorItemAutomationPeer, &type_spec_LoopingSelectorItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LoopingSelectorItemAutomationPeer, &type_spec_LoopingSelectorItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_LoopingSelectorItemDataAutomationPeer, &type_spec_LoopingSelectorItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_LoopingSelectorItemDataAutomationPeer, &type_spec_LoopingSelectorItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MapControlAutomationPeer, &type_spec_MapControlAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MapControlAutomationPeer, &type_spec_MapControlAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaElementAutomationPeer, &type_spec_MediaElementAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaElementAutomationPeer, &type_spec_MediaElementAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaPlayerElementAutomationPeer, &type_spec_MediaPlayerElementAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaPlayerElementAutomationPeer, &type_spec_MediaPlayerElementAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MediaTransportControlsAutomationPeer, &type_spec_MediaTransportControlsAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MediaTransportControlsAutomationPeer, &type_spec_MediaTransportControlsAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MenuBarAutomationPeer, &type_spec_MenuBarAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MenuBarAutomationPeer, &type_spec_MenuBarAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MenuBarItemAutomationPeer, &type_spec_MenuBarItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MenuBarItemAutomationPeer, &type_spec_MenuBarItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MenuFlyoutItemAutomationPeer, &type_spec_MenuFlyoutItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MenuFlyoutItemAutomationPeer, &type_spec_MenuFlyoutItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_MenuFlyoutPresenterAutomationPeer, &type_spec_MenuFlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_MenuFlyoutPresenterAutomationPeer, &type_spec_MenuFlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_NavigationViewItemAutomationPeer, &type_spec_NavigationViewItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_NavigationViewItemAutomationPeer, &type_spec_NavigationViewItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PasswordBoxAutomationPeer, &type_spec_PasswordBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PasswordBoxAutomationPeer, &type_spec_PasswordBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PersonPictureAutomationPeer, &type_spec_PersonPictureAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PersonPictureAutomationPeer, &type_spec_PersonPictureAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PickerFlyoutPresenterAutomationPeer, &type_spec_PickerFlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PickerFlyoutPresenterAutomationPeer, &type_spec_PickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PivotAutomationPeer, &type_spec_PivotAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PivotAutomationPeer, &type_spec_PivotAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PivotItemAutomationPeer, &type_spec_PivotItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PivotItemAutomationPeer, &type_spec_PivotItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_PivotItemDataAutomationPeer, &type_spec_PivotItemDataAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_PivotItemDataAutomationPeer, &type_spec_PivotItemDataAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ProgressBarAutomationPeer, &type_spec_ProgressBarAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ProgressBarAutomationPeer, &type_spec_ProgressBarAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ProgressRingAutomationPeer, &type_spec_ProgressRingAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ProgressRingAutomationPeer, &type_spec_ProgressRingAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RadioButtonAutomationPeer, &type_spec_RadioButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RadioButtonAutomationPeer, &type_spec_RadioButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RangeBaseAutomationPeer, &type_spec_RangeBaseAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RangeBaseAutomationPeer, &type_spec_RangeBaseAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RatingControlAutomationPeer, &type_spec_RatingControlAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RatingControlAutomationPeer, &type_spec_RatingControlAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RepeatButtonAutomationPeer, &type_spec_RepeatButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RepeatButtonAutomationPeer, &type_spec_RepeatButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RichEditBoxAutomationPeer, &type_spec_RichEditBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RichEditBoxAutomationPeer, &type_spec_RichEditBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RichTextBlockAutomationPeer, &type_spec_RichTextBlockAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RichTextBlockAutomationPeer, &type_spec_RichTextBlockAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RichTextBlockOverflowAutomationPeer, &type_spec_RichTextBlockOverflowAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RichTextBlockOverflowAutomationPeer, &type_spec_RichTextBlockOverflowAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ScrollBarAutomationPeer, &type_spec_ScrollBarAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ScrollBarAutomationPeer, &type_spec_ScrollBarAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ScrollViewerAutomationPeer, &type_spec_ScrollViewerAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ScrollViewerAutomationPeer, &type_spec_ScrollViewerAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SearchBoxAutomationPeer, &type_spec_SearchBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SearchBoxAutomationPeer, &type_spec_SearchBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SelectorAutomationPeer, &type_spec_SelectorAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SelectorAutomationPeer, &type_spec_SelectorAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SelectorItemAutomationPeer, &type_spec_SelectorItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SelectorItemAutomationPeer, &type_spec_SelectorItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SemanticZoomAutomationPeer, &type_spec_SemanticZoomAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SemanticZoomAutomationPeer, &type_spec_SemanticZoomAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SettingsFlyoutAutomationPeer, &type_spec_SettingsFlyoutAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SettingsFlyoutAutomationPeer, &type_spec_SettingsFlyoutAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_SliderAutomationPeer, &type_spec_SliderAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_SliderAutomationPeer, &type_spec_SliderAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TextBlockAutomationPeer, &type_spec_TextBlockAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TextBlockAutomationPeer, &type_spec_TextBlockAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TextBoxAutomationPeer, &type_spec_TextBoxAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TextBoxAutomationPeer, &type_spec_TextBoxAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ThumbAutomationPeer, &type_spec_ThumbAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ThumbAutomationPeer, &type_spec_ThumbAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimePickerAutomationPeer, &type_spec_TimePickerAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimePickerAutomationPeer, &type_spec_TimePickerAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TimePickerFlyoutPresenterAutomationPeer, &type_spec_TimePickerFlyoutPresenterAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TimePickerFlyoutPresenterAutomationPeer, &type_spec_TimePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ToggleButtonAutomationPeer, &type_spec_ToggleButtonAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ToggleButtonAutomationPeer, &type_spec_ToggleButtonAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ToggleMenuFlyoutItemAutomationPeer, &type_spec_ToggleMenuFlyoutItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ToggleMenuFlyoutItemAutomationPeer, &type_spec_ToggleMenuFlyoutItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_ToggleSwitchAutomationPeer, &type_spec_ToggleSwitchAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_ToggleSwitchAutomationPeer, &type_spec_ToggleSwitchAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TreeViewItemAutomationPeer, &type_spec_TreeViewItemAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TreeViewItemAutomationPeer, &type_spec_TreeViewItemAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_TreeViewListAutomationPeer, &type_spec_TreeViewListAutomationPeer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_TreeViewListAutomationPeer, &type_spec_TreeViewListAutomationPeer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), type_name_RawElementProviderRuntimeId, &type_spec_RawElementProviderRuntimeId, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), type_name_RawElementProviderRuntimeId, &type_spec_RawElementProviderRuntimeId, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
